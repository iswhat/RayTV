import { useState, useEffect, onWindowFocus, onWindowBlur } from '@ohos/base';
import { Router, RouteConfig } from '@ohos/router';
import { getContext } from '@ohos.ability.featureAbility';
import { LoadingProgress, Button, Text } from '@ohos/components';
import { mediaService } from './service/media/MediaService';
import { historyService } from './service/media/HistoryService';
import { favoriteService } from './service/media/FavoriteService';
import { configService } from './service/config/ConfigService';
import { subscriptionManager } from './service/config/SubscriptionManager';
import { lineManager } from './service/config/LineManager';
import Logger from './common/util/Logger';

/**
 * RayTVåº”ç”¨ä¸»å…¥å£
 * è´Ÿè´£åº”ç”¨åˆå§‹åŒ–ã€è·¯ç”±é…ç½®ã€å…¨å±€çŠ¶æ€ç®¡ç†ç­‰
 */
@Entry
@Component
struct App {
  private readonly TAG: string = 'App';
  
  // å…¨å±€çŠ¶æ€
  @State isInitialized: boolean = false;
  @State initializationError: string = '';
  @State appName: string = 'RayTV';
  @State appVersion: string = '1.0.0';
  
  // è·¯ç”±é…ç½®
  private routeConfigs: RouteConfig[] = [
    {
      path: 'pages/HomePage',
      name: 'HomePage',
      meta: {
        title: 'é¦–é¡µ',
        showTabBar: true,
        icon: 'ğŸ '
      }
    },
    {
      path: 'pages/CategoryPage',
      name: 'CategoryPage',
      meta: {
        title: 'åˆ†ç±»',
        showTabBar: true,
        icon: 'ğŸ“‹'
      }
    },
    {
      path: 'pages/FavoritesPage',
      name: 'FavoritesPage',
      meta: {
        title: 'æ”¶è—',
        showTabBar: true,
        icon: 'â­'
      }
    },
    {
      path: 'pages/HistoryPage',
      name: 'HistoryPage',
      meta: {
        title: 'å†å²',
        showTabBar: true,
        icon: 'â°'
      }
    },
    {
      path: 'pages/SettingsPage',
      name: 'SettingsPage',
      meta: {
        title: 'è®¾ç½®',
        showTabBar: true,
        icon: 'âš™ï¸'
      }
    },
    {      
      path: 'pages/subscription/SubscriptionManagerPage',
      name: 'SubscriptionManagerPage',
      meta: {
        title: 'é…ç½®æºç®¡ç†',
        showTabBar: false
      }
    },
    {      
      path: 'pages/LineManagerPage',
      name: 'LineManagerPage',
      meta: {
        title: 'çº¿è·¯ç®¡ç†',
        showTabBar: false
      }
    },
    {
      path: 'pages/SearchPage',
      name: 'SearchPage',
      meta: {
        title: 'æœç´¢',
        showTabBar: false
      }
    },
    {
      path: 'pages/MediaDetailPage',
      name: 'MediaDetailPage',
      meta: {
        title: 'åª’ä½“è¯¦æƒ…',
        showTabBar: false
      }
    },
    {
      path: 'pages/PlaybackPage',
      name: 'PlaybackPage',
      meta: {
        title: 'æ’­æ”¾',
        showTabBar: false,
        immersive: true
      }
    }
  ];
  
  // åº”ç”¨åˆå§‹åŒ–
  useEffect(() => {
    this.initializeApp();
  }, []);
  
  /**
   * åˆå§‹åŒ–åº”ç”¨
   */
  private async initializeApp(): Promise<void> {
    Logger.info(this.TAG, `Initializing ${this.appName} v${this.appVersion}...`);
    
    try {
      // 1. åˆå§‹åŒ–é…ç½®æœåŠ¡
      await this.initConfigService();
      
      // 2. åˆå§‹åŒ–æ•°æ®åº“æœåŠ¡
      await this.initDatabaseServices();
      
      // 3. åˆå§‹åŒ–åª’ä½“æœåŠ¡
      await this.initMediaService();
      
      // 4. åˆå§‹åŒ–è®¢é˜…ç®¡ç†å™¨
      await this.initSubscriptionManager();
      
      // 5. åˆå§‹åŒ–çº¿è·¯ç®¡ç†å™¨
      await this.initLineManager();
      
      // 6. è®¾ç½®å…¨å±€è·¯ç”±é…ç½®
      this.setupRouter();
      
      // 6. æ‰§è¡Œå¯åŠ¨ä»»åŠ¡
      await this.executeStartupTasks();
      
      this.isInitialized = true;
      Logger.info(this.TAG, 'Application initialized successfully');
    } catch (error) {
      Logger.error(this.TAG, `Failed to initialize application: ${error}`);
      this.initializationError = 'åº”ç”¨åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·é‡å¯åº”ç”¨';
    }
  }
  
  /**
   * åˆå§‹åŒ–é…ç½®æœåŠ¡
   */
  private async initConfigService(): Promise<void> {
    try {
      Logger.info(this.TAG, 'Initializing configuration service...');
      
      // è·å–åº”ç”¨ä¸Šä¸‹æ–‡å¹¶ä¼ é€’ç»™é…ç½®æœåŠ¡
      const context = getContext(this);
      await configService.initialize(context);
      
      // åŠ è½½åº”ç”¨é…ç½®
      try {
        const appVersion = await configService.getConfig('appVersion', this.appVersion);
        if (appVersion) {
          this.appVersion = appVersion.toString();
        }
      } catch (e) {
        Logger.warn(this.TAG, 'Failed to get app version from config, using default');
      }
      
      Logger.info(this.TAG, 'Configuration service initialized');
    } catch (error) {
      Logger.error(this.TAG, `Failed to initialize configuration service: ${error}`);
      throw error;
    }
  }
  
  /**
   * åˆå§‹åŒ–è®¢é˜…ç®¡ç†å™¨
   */
  private async initSubscriptionManager(): Promise<void> {
    try {
      Logger.info(this.TAG, 'Initializing subscription manager...');
      
      // è·å–åº”ç”¨ä¸Šä¸‹æ–‡å¹¶ä¼ é€’ç»™è®¢é˜…ç®¡ç†å™¨
      const context = getContext(this);
      await subscriptionManager.initialize(context);
      
      Logger.info(this.TAG, 'Subscription manager initialized');
    } catch (error) {
      Logger.error(this.TAG, `Failed to initialize subscription manager: ${error}`);
      // è®¢é˜…ç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥ä¸åº”é˜»æ­¢åº”ç”¨å¯åŠ¨
      throw error;
    }
  }
  
  /**
   * åˆå§‹åŒ–çº¿è·¯ç®¡ç†å™¨
   */
  private async initLineManager(): Promise<void> {
    try {
      Logger.info(this.TAG, 'Initializing line manager...');
      
      // è·å–åº”ç”¨ä¸Šä¸‹æ–‡å¹¶ä¼ é€’ç»™çº¿è·¯ç®¡ç†å™¨
      const context = getContext(this);
      await lineManager.initialize(context);
      
      Logger.info(this.TAG, 'Line manager initialized');
    } catch (error) {
      Logger.error(this.TAG, `Failed to initialize line manager: ${error}`);
      // çº¿è·¯ç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥ä¸åº”é˜»æ­¢åº”ç”¨å¯åŠ¨
    }
  }
  
  /**
   * åˆå§‹åŒ–æ•°æ®åº“æœåŠ¡
   */
  private async initDatabaseServices(): Promise<void> {
    try {
      Logger.info(this.TAG, 'Initializing database services...');
      
      // åˆå§‹åŒ–å†å²è®°å½•æœåŠ¡
      await historyService.initialize();
      
      // åˆå§‹åŒ–æ”¶è—æœåŠ¡
      await favoriteService.initialize();
      
      Logger.info(this.TAG, 'Database services initialized');
    } catch (error) {
      Logger.error(this.TAG, `Failed to initialize database services: ${error}`);
      throw error;
    }
  }
  
  /**
   * åˆå§‹åŒ–åª’ä½“æœåŠ¡
   */
  private async initMediaService(): Promise<void> {
    try {
      Logger.info(this.TAG, 'Initializing media service...');
      await mediaService.initialize();
      Logger.info(this.TAG, 'Media service initialized');
    } catch (error) {
      Logger.error(this.TAG, `Failed to initialize media service: ${error}`);
      throw error;
    }
  }
  
  /**
   * è®¾ç½®è·¯ç”±é…ç½®
   */
  private setupRouter(): void {
    try {
      Logger.info(this.TAG, 'Setting up router configuration...');
      
      // æ³¨å†Œè·¯ç”±
      this.routeConfigs.forEach(config => {
        Router.registerRoute(config);
      });
      
      // æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çº¿è·¯ï¼Œå¦‚æœæ²¡æœ‰åˆ™è·³è½¬åˆ°çº¿è·¯ç®¡ç†é¡µé¢
      const hasAvailableLines = lineManager.hasAvailableLines();
      const defaultPath = hasAvailableLines ? 'pages/HomePage' : 'pages/LineManagerPage';
      
      // è®¾ç½®é»˜è®¤è·¯ç”±
      Router.replace({
        url: defaultPath
      });
      
      Logger.info(this.TAG, `Default route set to: ${defaultPath}`);
      
      Logger.info(this.TAG, 'Router configured successfully');
    } catch (error) {
      Logger.error(this.TAG, `Failed to setup router: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ‰§è¡Œå¯åŠ¨ä»»åŠ¡
   */
  private async executeStartupTasks(): Promise<void> {
    try {
      Logger.info(this.TAG, 'Executing startup tasks...');
      
      // å¹¶è¡Œæ‰§è¡Œå¯åŠ¨ä»»åŠ¡
      await Promise.all([
        this.cleanupOldData(),
        this.preloadCommonData(),
        this.checkAppUpdate()
      ]);
      
      Logger.info(this.TAG, 'Startup tasks completed');
    } catch (error) {
      Logger.warn(this.TAG, `Some startup tasks failed: ${error}`);
      // å¯åŠ¨ä»»åŠ¡å¤±è´¥ä¸å½±å“åº”ç”¨å¯åŠ¨
    }
  }
  
  /**
   * æ¸…ç†æ—§æ•°æ®
   */
  private async cleanupOldData(): Promise<void> {
    try {
      // æ¸…ç†è¿‡æœŸçš„å†å²è®°å½•
      await historyService.cleanupExpiredHistories();
      
      Logger.info(this.TAG, 'Old data cleaned up');
    } catch (error) {
      Logger.error(this.TAG, `Failed to cleanup old data: ${error}`);
      throw error;
    }
  }
  
  /**
   * é¢„åŠ è½½å¸¸ç”¨æ•°æ®
   */
  private async preloadCommonData(): Promise<void> {
    try {
      // é¢„åŠ è½½ä¸€äº›å¸¸ç”¨çš„æ•°æ®ï¼Œå¦‚åˆ†ç±»åˆ—è¡¨ã€çƒ­é—¨æœç´¢è¯ç­‰
      await Promise.all([
        mediaService.getCategories(),
        mediaService.getHotSearchKeywords(10)
      ]);
      
      Logger.info(this.TAG, 'Common data preloaded');
    } catch (error) {
      Logger.warn(this.TAG, `Failed to preload common data: ${error}`);
    }
  }
  
  /**
   * æ£€æŸ¥åº”ç”¨æ›´æ–°
   */
  private async checkAppUpdate(): Promise<void> {
    try {
      // æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†è‡ªåŠ¨æ›´æ–°
      const enableUpdateCheck = await configService.getConfig('enableUpdateCheck', true);
      
      if (enableUpdateCheck) {
        Logger.info(this.TAG, 'Checking for app updates...');
        // è¿™é‡Œåº”è¯¥è°ƒç”¨æ›´æ–°æ£€æŸ¥æœåŠ¡
        // æš‚æ—¶è·³è¿‡å®é™…çš„æ›´æ–°æ£€æŸ¥
      }
    } catch (error) {
      Logger.warn(this.TAG, `Failed to check for updates: ${error}`);
    }
  }
  
  /**
   * åº”ç”¨è·å¾—ç„¦ç‚¹
   */
  onWindowFocus() {
    Logger.info(this.TAG, 'App window focused');
    
    // å¤„ç†åº”ç”¨å›åˆ°å‰å°çš„é€»è¾‘
    this.handleAppResume();
  }
  
  /**
   * åº”ç”¨å¤±å»ç„¦ç‚¹
   */
  onWindowBlur() {
    Logger.info(this.TAG, 'App window blurred');
    
    // å¤„ç†åº”ç”¨è¿›å…¥åå°çš„é€»è¾‘
    this.handleAppPause();
  }
  
  /**
   * å¤„ç†åº”ç”¨æ¢å¤
   */
  private async handleAppResume(): Promise<void> {
    try {
      // åˆ·æ–°ç¼“å­˜çš„æ•°æ®
      await mediaService.refreshCache();
      
      Logger.info(this.TAG, 'App resumed successfully');
    } catch (error) {
      Logger.warn(this.TAG, `Failed to handle app resume: ${error}`);
    }
  }
  
  /**
   * å¤„ç†åº”ç”¨æš‚åœ
   */
  private async handleAppPause(): Promise<void> {
    try {
      // ä¿å­˜åº”ç”¨çŠ¶æ€
      await this.saveAppState();
      
      // æ¸…ç†ä¸´æ—¶èµ„æº
      await mediaService.cleanupTempResources();
      
      Logger.info(this.TAG, 'App paused successfully');
    } catch (error) {
      Logger.warn(this.TAG, `Failed to handle app pause: ${error}`);
    }
  }
  
  /**
   * ä¿å­˜åº”ç”¨çŠ¶æ€
   */
  private async saveAppState(): Promise<void> {
    try {
      // ä¿å­˜å½“å‰åº”ç”¨çŠ¶æ€ä¿¡æ¯
      const appState = {
        lastActiveTime: new Date().toISOString(),
        version: this.appVersion
      };
      
      await configService.setConfig('appState', appState);
      
      Logger.info(this.TAG, 'App state saved');
    } catch (error) {
      Logger.error(this.TAG, `Failed to save app state: ${error}`);
    }
  }
  
  /**
   * æ¸²æŸ“åŠ è½½çŠ¶æ€
   */
  @Builder
  private renderLoading(): void {
    <Stack className="loading-container">
      <LoadingProgress className="loading-spinner" color="#FF4500" />
      <Text className="loading-text">æ­£åœ¨å¯åŠ¨ {this.appName}...</Text>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“é”™è¯¯çŠ¶æ€
   */
  @Builder
  private renderError(): void {
    <Stack className="error-container">
      <Text className="error-icon">âš ï¸</Text>
      <Text className="error-title">å¯åŠ¨å¤±è´¥</Text>
      <Text className="error-message">{this.initializationError}</Text>
      <Button className="retry-button" onClick={() => this.initializeApp()}>
        é‡è¯•
      </Button>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“åº”ç”¨å®¹å™¨
   */
  @Builder
  private renderAppContainer(): void {
    <Stack className="app-container">
      {/* è·¯ç”±è§†å›¾å®¹å™¨ */}
      <Router.RouterView className="router-view" />
    </Stack>
  }
  
  /**
   * ç»„ä»¶æ¸²æŸ“
   */
  build() {
    <Stack className="app">
      {!this.isInitialized && !this.initializationError ? (
        this.renderLoading()
      ) : this.initializationError ? (
        this.renderError()
      ) : (
        this.renderAppContainer()
      )}
    </Stack>
  }
}

export default App;