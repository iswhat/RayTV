// PlayVodUseCase - æ’­æ”¾ç‚¹æ’­ç”¨ä¾‹
import Logger from '../../common/util/Logger';
import { Vod } from '../../data/bean/Vod';
import { History } from '../../data/bean/History';
import { VideoSource } from '../../data/bean/Vod';
import { VodRepository } from '../../data/repository/VodRepository';
import { HistoryRepository } from '../../data/repository/HistoryRepository';
import { PlaybackRepository } from '../../data/repository/PlaybackRepository';
import { CollectionRepository } from '../../data/repository/CollectionRepository';

const TAG = 'PlayVodUseCase';

/**
 * æ’­æ”¾ç‚¹æ’­å†…å®¹çš„ä¸šåŠ¡ç”¨ä¾?
 */
export class PlayVodUseCase {
  private vodRepository: VodRepository;
  private historyRepository: HistoryRepository;
  private playbackRepository: PlaybackRepository;
  private collectionRepository: CollectionRepository;
  
  constructor(
    vodRepository: VodRepository,
    historyRepository: HistoryRepository,
    playbackRepository: PlaybackRepository,
    collectionRepository: CollectionRepository
  ) {
    this.vodRepository = vodRepository;
    this.historyRepository = historyRepository;
    this.playbackRepository = playbackRepository;
    this.collectionRepository = collectionRepository;
  }
  
  /**
   * åŠ è½½ç‚¹æ’­å†…å®¹è¯¦æƒ…
   * @param contentId å†…å®¹ID
   * @param sourceKey æ•°æ®æºæ ‡è¯?
   * @returns å®Œæ•´çš„Vodå¯¹è±¡
   */
  public async loadVodDetail(contentId: string, sourceKey: string): Promise<Vod> {
    try {
      Logger.info(TAG, `Loading vod detail for: ${contentId} from ${sourceKey}`);
      
      // å…ˆå°è¯•ä»ç¼“å­˜è·å–
      let vod = await this.vodRepository.getVodById(contentId, sourceKey);
      
      // å¦‚æœç¼“å­˜ä¸­æ²¡æœ‰æˆ–éœ€è¦æ›´æ–°ï¼Œä»ç½‘ç»œè·å?
      if (!vod || !vod.episodeList || vod.episodeList.length === 0) {
        vod = await this.vodRepository.fetchVodDetail(contentId, sourceKey);
        // æ›´æ–°ç¼“å­˜
        await this.vodRepository.cacheVods([vod]);
      }
      
      // æ£€æŸ¥æ˜¯å¦å·²æ”¶è—
      vod.isCollected = await this.collectionRepository.isCollected(contentId, sourceKey);
      
      return vod;
    } catch (error) {
      Logger.error(TAG, `Failed to load vod detail: ${error}`);
      throw error;
    }
  }
  
  /**
   * å‡†å¤‡æ’­æ”¾
   * @param vod ç‚¹æ’­å†…å®¹
   * @param episodeIndex å‰§é›†ç´¢å¼•
   * @param sourceIndex è§†é¢‘æºç´¢å¼?
   * @returns åŒ…å«æ’­æ”¾ä¿¡æ¯çš„å¯¹è±?
   */
  public async preparePlayback(
    vod: Vod, episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
   instanceof Error ? episodeIndex: number,
    sourceIndex: number = 0
   : new Error(String(episodeIndex: number,
    sourceIndex: number = 0
  ))))))): Promise<{
    videoSource: VideoSource;
    startPosition: number;
    isNewView: boolean;
  }> {
    try {
      Logger.info(TAG, `Preparing playback for ${vod.name}, episode ${episodeIndex}`);
      
      // éªŒè¯å‚æ•°
      if (!vod.episodeList || !vod.episodeList[episodeIndex]) {
        throw new Error('æ— æ•ˆçš„å‰§é›†ç´¢å¼?);
      }
      
      const episode = vod.episodeList[episodeIndex];
      if (!episode.sourceList || !episode.sourceList[sourceIndex]) {
        throw new Error('æ— æ•ˆçš„è§†é¢‘æºç´¢å¼•');
      }
      
      // è·å–è§†é¢‘æº?
      const videoSource = episode.sourceList[sourceIndex];
      
      // æ£€æŸ¥æ˜¯å¦æœ‰è§‚çœ‹å†å²
      const historyKey = `${vod.id}_${episodeIndex}`;
      const history = await this.historyRepository.getHistory(historyKey, vod.sourceKey);
      
      // å¦‚æœæ˜¯å‰§é›†ï¼Œåˆ›å»ºæˆ–æ›´æ–°è§‚çœ‹è®°å½?
      const isNewView = !history || history.position === 0;
      const startPosition = history?.position || 0;
      
      // æ›´æ–°è§†é¢‘æºä¿¡æ¯ï¼ˆå¦‚æœéœ€è¦ï¼‰
      if (!videoSource.url || videoSource.url.startsWith('http://placeholder')) {
        const realUrl = await this.playbackRepository.resolveVideoUrl(videoSource.url);
        videoSource.url = realUrl;
      }
      
      Logger.info(TAG, `Playback prepared, start at ${startPosition}ms, isNewView: ${isNewView}`);
      
      return {
        videoSource,
        startPosition,
        isNewView
      };
    } catch (error) {
      Logger.error(TAG, `Failed to prepare playback: ${error}`);
      throw error;
    }
  }
  
  /**
   * ä¿å­˜æ’­æ”¾è¿›åº¦
   * @param vod ç‚¹æ’­å†…å®¹
   * @param episodeIndex å‰§é›†ç´¢å¼•
   * @param position å½“å‰æ’­æ”¾ä½ç½®ï¼ˆæ¯«ç§’ï¼‰
   * @param duration æ€»æ—¶é•¿ï¼ˆæ¯«ç§’ï¼?
   */
  public async savePlaybackProgress(
    vod: Vod, episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
   instanceof Error ? episodeIndex: number,
    position: number,
    duration: number
   : new Error(String(episodeIndex: number,
    position: number,
    duration: number
  ))))))): Promise<void> {
    try {
      // æ„å»ºå†å²è®°å½•å¯¹è±¡
      const history: History = {
        id: `${vod.id}_${episodeIndex}`,
        contentId: vod.id,
        contentName: vod.name,
        type: 'vod',
        cover: vod.cover,
        episodeName: vod.episodeList?.[episodeIndex]?.name,
        sourceKey: vod.sourceKey,
        position,
        duration,
        lastPlayedAt: Date.now(),
        createdAt: Date.now()
      };
      
      // ä¿å­˜å†å²è®°å½•
      await this.historyRepository.saveHistory(history);
      
      Logger.info(TAG, `Saved playback progress for ${vod.name}, position: ${position}ms`);
    } catch (error) {
      Logger.error(TAG, `Failed to save playback progress: ${error}`);
    }
  }
  
  /**
   * åˆ‡æ¢è§†é¢‘æº?
   * @param vod ç‚¹æ’­å†…å®¹
   * @param episodeIndex å‰§é›†ç´¢å¼•
   * @param newSourceIndex æ–°çš„è§†é¢‘æºç´¢å¼?
   * @returns æ–°çš„è§†é¢‘æº?
   */
  public async switchVideoSource(
    vod: Vod, episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
   instanceof Error ? episodeIndex: number,
    newSourceIndex: number
   : new Error(String(episodeIndex: number,
    newSourceIndex: number
  ))))))): Promise<VideoSource> {
    try {
      Logger.info(TAG, `Switching video source to index ${newSourceIndex}`);
      
      if (!vod.episodeList || !vod.episodeList[episodeIndex]) {
        throw new Error('æ— æ•ˆçš„å‰§é›?);
      }
      
      const episode = vod.episodeList[episodeIndex];
      if (!episode.sourceList || !episode.sourceList[newSourceIndex]) {
        throw new Error('æ— æ•ˆçš„è§†é¢‘æºç´¢å¼•');
      }
      
      const videoSource = episode.sourceList[newSourceIndex];
      
      // è§£æè§†é¢‘æºURLï¼ˆå¦‚æœéœ€è¦ï¼‰
      if (!videoSource.url || videoSource.url.startsWith('http://placeholder')) {
        const realUrl = await this.playbackRepository.resolveVideoUrl(videoSource.url);
        videoSource.url = realUrl;
      }
      
      return videoSource;
    } catch (error) {
      Logger.error(TAG, `Failed to switch video source: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ”¶è—/å–æ¶ˆæ”¶è—
   * @param vod ç‚¹æ’­å†…å®¹
   * @returns æ”¶è—çŠ¶æ€?
   */
  public async toggleCollection(vod: Vod): Promise<boolean> {
    try {
      const isCurrentlyCollected = await this.collectionRepository.isCollected(vod.id, vod.sourceKey instanceof Error ? vod.sourceKey : new Error(String(vod.sourceKey instanceof Error ? vod.sourceKey instanceof Error ? vod.sourceKey : new Error(String(vod.sourceKey : new Error(String(vod.sourceKey instanceof Error ? vod.sourceKey : new Error(String(vod.sourceKey instanceof Error ? vod.sourceKey instanceof Error ? vod.sourceKey : new Error(String(vod.sourceKey instanceof Error ? vod.sourceKey instanceof Error ? vod.sourceKey : new Error(String(vod.sourceKey : new Error(String(vod.sourceKey instanceof Error ? vod.sourceKey : new Error(String(vod.sourceKey : new Error(String(vod.sourceKey instanceof Error ? vod.sourceKey : new Error(String(vod.sourceKey instanceof Error ? vod.sourceKey instanceof Error ? vod.sourceKey : new Error(String(vod.sourceKey : new Error(String(vod.sourceKey instanceof Error ? vod.sourceKey : new Error(String(vod.sourceKey)))))));
      
      if (isCurrentlyCollected) {
        await this.collectionRepository.removeCollection(vod.id, vod.sourceKey);
        Logger.info(TAG, `Uncollected ${vod.name}`);
        return false;
      } else {
        await this.collectionRepository.addCollection({
          id: vod.id,
          name: vod.name,
          type: 'vod',
          cover: vod.cover,
          sourceKey: vod.sourceKey,
          addedAt: Date.now()
        });
        Logger.info(TAG, `Collected ${vod.name}`);
        return true;
      }
    } catch (error) {
      Logger.error(TAG, `Failed to toggle collection: ${error}`);
      throw error;
    }
  }
}


