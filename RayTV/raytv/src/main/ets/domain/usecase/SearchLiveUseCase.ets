// SearchLiveUseCase - æœç´¢ç›´æ’­ç”¨ä¾‹
import Logger from '../../common/util/Logger';
import { Live } from '../../data/bean/Live';
import { LiveRepository } from '../../data/repository/LiveRepository';
import { SearchHistoryRepository } from '../../data/repository/SearchHistoryRepository';
import { CacheRepository } from '../../data/repository/CacheRepository';

const TAG = 'SearchLiveUseCase';
const SEARCH_CACHE_EXPIRY = 5 * 60 * 1000; // 5åˆ†é’Ÿç¼“å­˜è¿‡æœŸæ—¶é—´

/**
 * æœç´¢ç›´æ’­å†…å®¹çš„ä¸šåŠ¡ç”¨ä¾?
 */
export class SearchLiveUseCase {
  private liveRepository: LiveRepository;
  private searchHistoryRepository: SearchHistoryRepository;
  private cacheRepository: CacheRepository;
  
  constructor(
    liveRepository: LiveRepository,
    searchHistoryRepository: SearchHistoryRepository,
    cacheRepository: CacheRepository
  ) {
    this.liveRepository = liveRepository;
    this.searchHistoryRepository = searchHistoryRepository;
    this.cacheRepository = cacheRepository;
  }
  
  /**
   * æœç´¢ç›´æ’­é¢‘é“
   * @param keyword æœç´¢å…³é”®è¯?
   * @param includeHistory æ˜¯å¦åŒ…å«å†å²è®°å½•æœç´¢
   * @returns æœç´¢ç»“æœ
   */
  public async searchLive(keyword: string, includeHistory: boolean = true): Promise<{
    channels: Live[];
    historyMatches: Live[];
  }> {
    try {
      Logger.info(TAG, `Searching live with keyword: ${keyword}`);
      
      if (!keyword || keyword.trim().length === 0) {
        return { channels: [], historyMatches: [] };
      }
      
      // ç”Ÿæˆç¼“å­˜é”?
      const cacheKey = `live_search_${keyword.toLowerCase()}`;
      
      // å°è¯•ä»ç¼“å­˜è·å?
      const cachedResult = await this.getSearchCache(cacheKey);
      if (cachedResult) {
        Logger.info(TAG, `Using cached search results for: ${keyword}`);
        return cachedResult;
      }
      
      // å¹¶è¡Œæ‰§è¡Œæœç´¢
      const [channels, historyMatches] = await Promise.all([
        this.liveRepository.searchLiveChannels(keyword),
        includeHistory ? this.searchInHistory(keyword) : Promise.resolve([])
      ]);
      
      const result: Record<string, string | number | boolean | null> = { ... };
      
      // ç¼“å­˜ç»“æœ
      await this.cacheSearchResult(cacheKey, result);
      
      // ä¿å­˜æœç´¢å†å²
      await this.saveSearchHistory(keyword);
      
      return result;
    } catch (error) {
      Logger.error(TAG, `Failed to search live: ${error}`);
      return { channels: [], historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 instanceof Error ? historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10 : new Error(String(historyMatches: [] };
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit é™åˆ¶æ•°é‡
   * @returns çƒ­é—¨å…³é”®è¯åˆ—è¡?
   */
  public async getHotKeywords(limit: number = 10))))))): Promise<string[]> {
    try {
      Logger.info(TAG, 'Loading hot keywords');
      
      // å…ˆå°è¯•ä»ç¼“å­˜è·å–
      const cachedKeywords = await this.cacheRepository.getObject<string[]>(
        'live_hot_keywords'
      );
      
      if (cachedKeywords) {
        return cachedKeywords.slice(0, limit);
      }
      
      // ä»æ•°æ®åº“è·å–çƒ­é—¨æœç´¢è¯ï¼ˆåŸºäºæœç´¢é¢‘ç‡ï¼?
      const hotKeywords = await this.searchHistoryRepository.getHotKeywords(
        'live',
        limit
      );
      
      // å¦‚æœæ²¡æœ‰è¶³å¤Ÿçš„å†å²æœç´¢ï¼Œä½¿ç”¨é»˜è®¤çƒ­é—¨è¯?
      const defaultKeywords = [
        'ä¸­å¤®ç”µè§†å?, 'å«è§†', 'ä½“è‚²', 'ç”µå½±', 'æ–°é—»', 'ç”µè§†å‰?, 'ç»¼è‰º', 'åŠ¨ç”»', 'éŸ³ä¹', 'å°‘å„¿'
      ];
      
      const result = hotKeywords.length > 0 ? hotKeywords : defaultKeywords;
      
      // ç¼“å­˜ç»“æœ
      await this.cacheRepository.saveObject(
        'live_hot_keywords',
        result,
        SEARCH_CACHE_EXPIRY
      );
      
      return result.slice(0, limit);
    } catch (error) {
      Logger.error(TAG, `Failed to load hot keywords: ${error}`);
      return [];
    }
  }
  
  /**
   * è·å–æœç´¢å†å²
   * @param limit é™åˆ¶æ•°é‡
   * @returns æœç´¢å†å²åˆ—è¡¨
   */
  public async getSearchHistory(limit: number = 20): Promise<string[]> {
    try {
      Logger.info(TAG, 'Loading search history' instanceof Error ? 'Loading search history' : new Error(String('Loading search history' instanceof Error ? 'Loading search history' instanceof Error ? 'Loading search history' : new Error(String('Loading search history' : new Error(String('Loading search history' instanceof Error ? 'Loading search history' : new Error(String('Loading search history' instanceof Error ? 'Loading search history' instanceof Error ? 'Loading search history' : new Error(String('Loading search history' instanceof Error ? 'Loading search history' instanceof Error ? 'Loading search history' : new Error(String('Loading search history' : new Error(String('Loading search history' instanceof Error ? 'Loading search history' : new Error(String('Loading search history' : new Error(String('Loading search history' instanceof Error ? 'Loading search history' : new Error(String('Loading search history' instanceof Error ? 'Loading search history' instanceof Error ? 'Loading search history' : new Error(String('Loading search history' : new Error(String('Loading search history' instanceof Error ? 'Loading search history' : new Error(String('Loading search history')))))));
      return await this.searchHistoryRepository.getSearchHistory('live', limit);
    } catch (error) {
      Logger.error(TAG, `Failed to load search history: ${error}`);
      return [];
    }
  }
  
  /**
   * æ¸…é™¤æœç´¢å†å²
   */
  public async clearSearchHistory(): Promise<void> {
    try {
      Logger.info(TAG, 'Clearing search history' instanceof Error ? 'Clearing search history' : new Error(String('Clearing search history' instanceof Error ? 'Clearing search history' instanceof Error ? 'Clearing search history' : new Error(String('Clearing search history' : new Error(String('Clearing search history' instanceof Error ? 'Clearing search history' : new Error(String('Clearing search history' instanceof Error ? 'Clearing search history' instanceof Error ? 'Clearing search history' : new Error(String('Clearing search history' instanceof Error ? 'Clearing search history' instanceof Error ? 'Clearing search history' : new Error(String('Clearing search history' : new Error(String('Clearing search history' instanceof Error ? 'Clearing search history' : new Error(String('Clearing search history' : new Error(String('Clearing search history' instanceof Error ? 'Clearing search history' : new Error(String('Clearing search history' instanceof Error ? 'Clearing search history' instanceof Error ? 'Clearing search history' : new Error(String('Clearing search history' : new Error(String('Clearing search history' instanceof Error ? 'Clearing search history' : new Error(String('Clearing search history')))))));
      await this.searchHistoryRepository.clearSearchHistory('live');
      
      // æ¸…é™¤ç›¸å…³ç¼“å­˜
      await this.clearSearchCache();
    } catch (error) {
      Logger.error(TAG, `Failed to clear search history: ${error}`);
      throw error;
    }
  }
  
  /**
   * åˆ é™¤å•æ¡æœç´¢å†å²
   * @param keyword è¦åˆ é™¤çš„å…³é”®è¯?
   */
  public async removeFromHistory(keyword: string): Promise<void> {
    try {
      Logger.info(TAG, `Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}` instanceof Error ? `Removing keyword from history: ${keyword}` : new Error(String(`Removing keyword from history: ${keyword}`)))))));
      await this.searchHistoryRepository.removeFromHistory('live', keyword);
    } catch (error) {
      Logger.error(TAG, `Failed to remove from history: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ™ºèƒ½æœç´¢å»ºè®®
   * @param prefix æœç´¢å‰ç¼€
   * @param limit å»ºè®®æ•°é‡
   * @returns æœç´¢å»ºè®®åˆ—è¡¨
   */
  public async getSearchSuggestions(prefix: string, limit: number = 5 instanceof Error ? limit: number = 5 : new Error(String(limit: number = 5 instanceof Error ? limit: number = 5 instanceof Error ? limit: number = 5 : new Error(String(limit: number = 5 : new Error(String(limit: number = 5 instanceof Error ? limit: number = 5 : new Error(String(limit: number = 5 instanceof Error ? limit: number = 5 instanceof Error ? limit: number = 5 : new Error(String(limit: number = 5 instanceof Error ? limit: number = 5 instanceof Error ? limit: number = 5 : new Error(String(limit: number = 5 : new Error(String(limit: number = 5 instanceof Error ? limit: number = 5 : new Error(String(limit: number = 5 : new Error(String(limit: number = 5 instanceof Error ? limit: number = 5 : new Error(String(limit: number = 5 instanceof Error ? limit: number = 5 instanceof Error ? limit: number = 5 : new Error(String(limit: number = 5 : new Error(String(limit: number = 5 instanceof Error ? limit: number = 5 : new Error(String(limit: number = 5))))))): Promise<string[]> {
    try {
      if (!prefix || prefix.length < 2) {
        return [];
      }
      
      Logger.info(TAG, `Getting search suggestions for: ${prefix}`);
      
      // ä»å†å²å’Œé¢‘é“åç§°ä¸­è·å–å»ºè®?
      const [historySuggestions, channelSuggestions] = await Promise.all([
        this.searchHistoryRepository.getSuggestions('live', prefix, limit),
        this.liveRepository.getChannelNameSuggestions(prefix, limit)
      ]);
      
      // åˆå¹¶å»é‡
      const suggestions = [...new Set([...historySuggestions, ...channelSuggestions])];
      
      return suggestions.slice(0, limit);
    } catch (error) {
      Logger.error(TAG, `Failed to get search suggestions: ${error}`);
      return [];
    }
  }
  
  /**
   * ä¿å­˜æœç´¢å†å²
   * @param keyword æœç´¢å…³é”®è¯?
   */
  private async saveSearchHistory(keyword: string): Promise<void> {
    try {
      await this.searchHistoryRepository.addSearchHistory('live', keyword instanceof Error ? keyword : new Error(String(keyword instanceof Error ? keyword instanceof Error ? keyword : new Error(String(keyword : new Error(String(keyword instanceof Error ? keyword : new Error(String(keyword instanceof Error ? keyword instanceof Error ? keyword : new Error(String(keyword instanceof Error ? keyword instanceof Error ? keyword : new Error(String(keyword : new Error(String(keyword instanceof Error ? keyword : new Error(String(keyword : new Error(String(keyword instanceof Error ? keyword : new Error(String(keyword instanceof Error ? keyword instanceof Error ? keyword : new Error(String(keyword : new Error(String(keyword instanceof Error ? keyword : new Error(String(keyword)))))));
      
      // æ¸…é™¤çƒ­é—¨å…³é”®è¯ç¼“å­˜ï¼Œä»¥ä¾¿ä¸‹æ¬¡è·å–æœ€æ–°çš„
      await this.cacheRepository.removeObject('live_hot_keywords');
    } catch (error) {
      // ä¿å­˜å†å²å¤±è´¥ä¸åº”è¯¥å½±å“æœç´¢ç»“æ?
      Logger.warn(TAG, `Failed to save search history: ${error}`);
    }
  }
  
  /**
   * åœ¨å†å²è®°å½•ä¸­æœç´¢
   * @param keyword æœç´¢å…³é”®è¯?
   * @returns åŒ¹é…çš„é¢‘é?
   */
  private async searchInHistory(keyword: string): Promise<Live[]> {
    try {
      // è·å–æœ€è¿‘è§‚çœ‹çš„ç›´æ’­é¢‘é“
      const recentWatched = await this.liveRepository.getRecentWatchedLiveChannels(10);
      
      // è¿‡æ»¤åŒ¹é…å…³é”®è¯çš„é¢‘é“
      return recentWatched.filter(channel => 
        channel.name.toLowerCase().includes(keyword.toLowerCase()) ||
        (channel.groupName && channel.groupName.toLowerCase().includes(keyword.toLowerCase()))
      );
    } catch (error) {
      Logger.warn(TAG, `Failed to search in history: ${error}`);
      return [];
    }
  }
  
  /**
   * ç¼“å­˜æœç´¢ç»“æœ
   */
  private async cacheSearchResult<T>(key: string, result: T): Promise<void> {
    try {
      await this.cacheRepository.saveObject(key, result, SEARCH_CACHE_EXPIRY);
    } catch (error) {
      Logger.warn(TAG, `Failed to cache search result: ${error}`);
    }
  }
  
  /**
   * è·å–ç¼“å­˜çš„æœç´¢ç»“æ?
   */
  private async getSearchCache(key: string): Promise<LiveChannel[] | null> {
    try {
      return await this.cacheRepository.getObject(key);
    } catch (error) {
      Logger.warn(TAG, `Failed to get search cache: ${error}`);
      return null;
    }
  }
  
  /**
   * æ¸…é™¤æœç´¢ç¼“å­˜
   */
  private async clearSearchCache(): Promise<void> {
    try {
      // æ¸…é™¤æ‰€æœ‰ç›´æ’­æœç´¢ç›¸å…³çš„ç¼“å­˜
      const keys = await this.cacheRepository.getAllKeys();
      const searchKeys = keys.filter(key => key.startsWith('live_search_'));
      
      for (const key of searchKeys) {
        await this.cacheRepository.removeObject(key);
      }
      
      // æ¸…é™¤çƒ­é—¨å…³é”®è¯ç¼“å­?
      await this.cacheRepository.removeObject('live_hot_keywords');
    } catch (error) {
      Logger.warn(TAG, `Failed to clear search cache: ${error}`);
    }
  }
}


