// SearchVodUseCase - æœç´¢ç‚¹æ’­ç”¨ä¾‹
import Logger from '../../common/util/Logger';
import { Vod } from '../../data/bean/Vod';
import { SearchResult } from '../../data/model/SearchResult';
import { VodRepository } from '../../data/repository/VodRepository';
import { SearchRepository } from '../../data/repository/SearchRepository';
import { SearchHistoryRepository } from '../../data/repository/SearchHistoryRepository';

const TAG = 'SearchVodUseCase';

/**
 * æœç´¢ç‚¹æ’­å†…å®¹çš„ä¸šåŠ¡ç”¨ä¾?
 */
export class SearchVodUseCase {
  private vodRepository: VodRepository;
  private searchRepository: SearchRepository;
  private searchHistoryRepository: SearchHistoryRepository;
  
  constructor(
    vodRepository: VodRepository,
    searchRepository: SearchRepository,
    searchHistoryRepository: SearchHistoryRepository
  ) {
    this.vodRepository = vodRepository;
    this.searchRepository = searchRepository;
    this.searchHistoryRepository = searchHistoryRepository;
  }
  
  /**
   * æœç´¢ç‚¹æ’­å†…å®¹
   * @param keyword æœç´¢å…³é”®è¯?
   * @param page é¡µç 
   * @param pageSize æ¯é¡µæ•°é‡
   * @param siteKey å¯é€‰çš„ç«™ç‚¹è¿‡æ»¤
   * @returns æœç´¢ç»“æœ
   */
  public async search(
    keyword: string,
    page: number = 1,
    pageSize: number = 20,
    siteKey?: string
  ): Promise<SearchResult<Vod>> {
    try {
      Logger.info(TAG, `Searching vod with keyword: ${keyword}, page: ${page}`);
      
      // å‚æ•°éªŒè¯
      if (!keyword || keyword.trim().length === 0) {
        throw new Error('æœç´¢å…³é”®è¯ä¸èƒ½ä¸ºç©?);
      }
      
      // ä¿å­˜æœç´¢å†å²
      await this.searchHistoryRepository.saveSearchHistory(keyword);
      
      // æ‰§è¡Œæœç´¢
      const result = await this.searchRepository.searchVod(
        keyword,
        page,
        pageSize,
        siteKey
      );
      
      // ç¼“å­˜æœç´¢ç»“æœ
      if (result.items && result.items.length > 0) {
        await this.vodRepository.cacheVods(result.items);
      }
      
      Logger.info(TAG, `Search completed, found ${result.items?.length} items`);
      return result;
    } catch (error) {
      Logger.error(TAG, `Search failed: ${error}`);
      throw error;
    }
  }
  
  /**
   * æŒ‰åˆ†ç±»æœç´¢ç‚¹æ’­å†…å®?
   * @param category åˆ†ç±»
   * @param page é¡µç 
   * @param pageSize æ¯é¡µæ•°é‡
   * @param filters ç­›é€‰æ¡ä»?
   * @returns æœç´¢ç»“æœ
   */
  public async searchByCategory(
    category: string, page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   instanceof Error ? page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
   : new Error(String(page: number = 1,
    pageSize: number = 20,
    filters?: Record<string, string>
  ))))))): Promise<SearchResult<Vod>> {
    try {
      Logger.info(TAG, `Searching vod by category: ${category}, page: ${page}`);
      
      const result = await this.searchRepository.searchVodByCategory(
        category,
        page,
        pageSize,
        filters
      );
      
      // ç¼“å­˜æœç´¢ç»“æœ
      if (result.items && result.items.length > 0) {
        await this.vodRepository.cacheVods(result.items);
      }
      
      return result;
    } catch (error) {
      Logger.error(TAG, `Category search failed: ${error}`);
      throw error;
    }
  }
  
  /**
   * è·å–çƒ­é—¨æœç´¢å…³é”®è¯?
   * @param limit æ•°é‡é™åˆ¶
   * @returns çƒ­é—¨æœç´¢å…³é”®è¯åˆ—è¡?
   */
  public async getHotSearchKeywords(limit: number = 10): Promise<string[]> {
    try {
      return await this.searchRepository.getHotSearchKeywords(limit);
    } catch (error) {
      Logger.error(TAG, `Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}` instanceof Error ? `Failed to get hot search keywords: ${error}` : new Error(String(`Failed to get hot search keywords: ${error}`)))))));
      return [];
    }
  }
  
  /**
   * æ¸…é™¤æœç´¢å†å²
   */
  public async clearSearchHistory(): Promise<void> {
    try {
      await this.searchHistoryRepository.clearSearchHistory();
      Logger.info(TAG, 'Search history cleared');
    } catch (error) {
      Logger.error(TAG, `Failed to clear search history: ${error}`);
    }
  }
}


