import { ImageCacheManager } from '../utils/ImageCacheManager';
import { LazyLoadStrategy } from '../types/LazyLoadTypes';

/**
 * å›¾ç‰‡æ‡’åŠ è½½ç»„ä»¶
 * æ”¯æŒå¤šç§åŠ è½½ç­–ç•¥å’Œç¼“å­˜æœºåˆ¶
 */
@Entry
@Component
struct ImageLazyLoader {
  @State private isLoading: boolean = false;
  @State private isError: boolean = false;
  @State private isLoaded: boolean = false;
  @State private currentSrc: string = '';
  
  private cacheManager: ImageCacheManager = ImageCacheManager.getInstance();
  private observer: IntersectionObserver | null = null;
  private retryCount: number = 0;
  private maxRetries: number = 3;

  // ç»„ä»¶å±æ€§
  @Prop src: string = '';
  @Prop placeholder: string = '';
  @Prop errorPlaceholder: string = '';
  @Prop lazyStrategy: LazyLoadStrategy = LazyLoadStrategy.INTERSECTION;
  @Prop threshold: number = 0.1;
  @Prop rootMargin: string = '50px';
  @Prop enableCache: boolean = true;
  @Prop cacheKey: string = '';
  @Prop width: number | string = '100%';
  @Prop height: number | string = 'auto';
  @Prop borderRadius: number | string = 0;
  @Prop onLoad?: (src: string) => void;
  @Prop onError?: (error: Error) => void;

  aboutToAppear(): void {
    this.initializeLazyLoading();
  }

  aboutToDisappear(): void {
    this.cleanup();
  }

  private initializeLazyLoading(): void {
    if (!this.src) return;

    const cacheKey = this.cacheKey || this.src;
    
    // æ£€æŸ¥ç¼“å­˜
    if (this.enableCache && this.cacheManager.has(cacheKey)) {
      const cachedData = this.cacheManager.get(cacheKey);
      if (cachedData && !cachedData.error) {
        this.currentSrc = cachedData.data;
        this.isLoaded = true;
        this.onLoad?.(this.currentSrc);
        return;
      }
    }

    switch (this.lazyStrategy) {
      case LazyLoadStrategy.INTERSECTION:
        this.setupIntersectionObserver();
        break;
      case LazyLoadStrategy.SCROLL:
        this.setupScrollListener();
        break;
      case LazyLoadStrategy.VISIBLE:
        this.loadImmediately();
        break;
      case LazyLoadStrategy.DELAYED:
        this.loadWithDelay();
        break;
    }
  }

  private setupIntersectionObserver(): void {
    // æ¨¡æ‹Ÿäº¤å‰è§‚å¯Ÿå™¨å®ç°
    // åœ¨å®é™…HarmonyOSç¯å¢ƒä¸­éœ€è¦ä½¿ç”¨åŸç”ŸAPI
    setTimeout(() => {
      if (Math.random() > 0.3) { // æ¨¡æ‹Ÿå…ƒç´ è¿›å…¥è§†å£
        this.loadImage();
      }
    }, 1000 + Math.random() * 2000);
  }

  private setupScrollListener(): void {
    // ç›‘å¬æ»šåŠ¨äº‹ä»¶
    // è¿™é‡Œç®€åŒ–å®ç°ï¼Œåœ¨å®é™…åº”ç”¨ä¸­éœ€è¦ç›‘å¬å…·ä½“çš„æ»šåŠ¨å®¹å™¨
    setTimeout(() => {
      this.loadImage();
    }, 500);
  }

  private loadImmediately(): void {
    this.loadImage();
  }

  private loadWithDelay(): void {
    setTimeout(() => {
      this.loadImage();
    }, 1000);
  }

  private async loadImage(): Promise<void> {
    if (this.isLoading || this.isLoaded) return;

    this.isLoading = true;
    this.isError = false;

    try {
      const cacheKey = this.cacheKey || this.src;
      
      // å…ˆæ£€æŸ¥ç¼“å­˜
      if (this.enableCache && this.cacheManager.has(cacheKey)) {
        const cachedData = this.cacheManager.get(cacheKey);
        if (cachedData && !cachedData.error) {
          this.currentSrc = cachedData.data;
          this.isLoaded = true;
          this.isLoading = false;
          this.onLoad?.(this.currentSrc);
          return;
        }
      }

      // ç½‘ç»œåŠ è½½
      const imageData = await this.fetchImage(this.src);
      
      // ç¼“å­˜å›¾ç‰‡æ•°æ®
      if (this.enableCache) {
        this.cacheManager.set(cacheKey, imageData);
      }

      this.currentSrc = imageData;
      this.isLoaded = true;
      this.onLoad?.(imageData);

    } catch (error) {
      console.error('Image loading failed:', error);
      this.handleError(error);
    } finally {
      this.isLoading = false;
    }
  }

  private async fetchImage(url: string): Promise<string> {
    return new Promise((resolve, reject) => {
      // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
      setTimeout(() => {
        if (Math.random() > 0.1) { // 90%æˆåŠŸç‡
          // æ¨¡æ‹Ÿè¿”å›å›¾ç‰‡æ•°æ®
          resolve(`data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/${btoa(url)}`);
        } else {
          reject(new Error('Network error'));
        }
      }, 200 + Math.random() * 800);
    });
  }

  private handleError(error: Error): void {
    this.isError = true;
    this.onError?.(error);

    // è‡ªåŠ¨é‡è¯•æœºåˆ¶
    if (this.retryCount < this.maxRetries) {
      this.retryCount++;
      setTimeout(() => {
        this.loadImage();
      }, 1000 * this.retryCount);
    }
  }

  private cleanup(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
  }

  build() {
    Column() {
      if (this.isError && this.errorPlaceholder) {
        Image(this.errorPlaceholder)
          .width(this.width)
          .height(this.height)
          .borderRadius(this.borderRadius)
          .onTouch(() => {
            this.retryCount = 0;
            this.loadImage();
          })
      } else if (this.isLoading && this.placeholder) {
        Image(this.placeholder)
          .width(this.width)
          .height(this.height)
          .borderRadius(this.borderRadius)
      } else if (this.isLoaded && this.currentSrc) {
        Image(this.currentSrc)
          .width(this.width)
          .height(this.height)
          .borderRadius(this.borderRadius)
          .onComplete(() => {
            console.log('Image loaded successfully');
          })
          .onError(() => {
            this.isError = true;
          })
      } else {
        // é»˜è®¤å ä½ç¬¦
        Row()
          .width(this.width)
          .height(this.height)
          .borderRadius(this.borderRadius)
          .backgroundColor('#f0f0f0')
          .justifyContent(FlexAlign.Center)
          .alignItems(VerticalAlign.Center)
          .children([
            Text('ğŸ–¼ï¸')
              .fontSize(24)
          ])
      }
    }
  }
}