// LiveStreamRepository - Áõ¥Êí≠Êï∞ÊçÆ‰ªìÂ∫ìÁ±?// Ë¥üË¥£ÁÆ°ÁêÜÁõ¥Êí≠ÊµÅÁõ∏ÂÖ≥Êï∞ÊçÆÔºåÂåÖÊã¨Áõ¥Êí≠ÂàóË°®„ÄÅÁõ¥Êí≠ËØ¶ÊÉÖ„ÄÅÂÖ≥Ê≥®„ÄÅËßÇÁúãÁªüËÆ°Á≠â

import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import NetworkUtil from '../../common/util/NetworkUtil';
import EventBusUtil from '../../common/util/EventBusUtil';
import CacheService from '../../service/cache/CacheService';
import {
  VideoType,
  VideoQuality,
  VideoSource,
  VideoInfo
} from '../dto/VideoDto';
import { LocalStorageType } from '../model/LocalModel';
import { CacheType } from '../model/CacheModel';
import { UserRepository } from './UserRepository';

/**
 * Áõ¥Êí≠Áä∂ÊÄÅÊûö‰∏? */
export enum LiveStatus {
  OFFLINE = 'offline',
  LIVE = 'live',
  SCHEDULED = 'scheduled',
  ENDING = 'ending',
  ENDED = 'ended',
  ERROR = 'error'
}

/**
 * Áõ¥Êí≠Á±ªÂûãÊûö‰∏æ
 */
export enum LiveStreamType {
  GAME = 'game',
  ENTERTAINMENT = 'entertainment',
  EDUCATIONAL = 'educational',
  SPORTS = 'sports',
  NEWS = 'news',
  TALK = 'talk',
  OTHER = 'other'
}

/**
 * Áõ¥Êí≠ÊµÅ‰ø°ÊÅØÊé•Âè? */
export interface LiveStreamInfo extends VideoInfo {
  liveStatus: LiveStatus;
  streamType: LiveStreamType;
  streamUrl: string;
  hlsUrl: string;
  rtmpUrl?: string;
  viewerCount: number;
  peakViewers: number;
  startTime?: number;
  endTime?: number;
  scheduledStartTime?: number;
  streamKey?: string; // ‰ªÖÂØπ‰∏ªÊí≠ÂèØËßÅ
  chatEnabled: boolean;
  isFollowing?: boolean;
  broadcasterInfo: {
    id: string;
    name: string;
    avatarUrl?: string;
    followerCount: number;
    isVerified: boolean;
  };
  donationEnabled: boolean;
  latestChats?: LiveChat[];
  liveTags: string[];
  isRestricted?: boolean;
  restrictionReason?: string;
}

/**
 * Áõ¥Êí≠ËÅäÂ§©Ê∂àÊÅØ
 */
export interface LiveChat {
  id: string;
  userId: string;
  userName: string;
  userAvatar?: string;
  content: string;
  timestamp: number;
  isPinned?: boolean;
  isModerator?: boolean;
  isBroadcaster?: boolean;
  messageType: 'text' | 'emoji' | 'system' | 'donation' | 'subscription';
  metadata?: Record<string, unknown>;
}

/**
 * Áõ¥Êí≠ÂàóË°®ËØ∑Ê±ÇÂèÇÊï∞
 */
export interface LiveStreamListRequest {
  status?: LiveStatus;
  type?: LiveStreamType;
  category?: string;
  tag?: string;
  page?: number;
  pageSize?: number;
  sortBy?: 'viewers' | 'newest' | 'trending' | 'following';
  featured?: boolean;
  searchQuery?: string;
}

/**
 * Áõ¥Êí≠ÂàóË°®ÂìçÂ∫î
 */
export interface LiveStreamListResponse {
  streams: LiveStreamInfo[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}

/**
 * Áõ¥Êí≠ÁªüËÆ°‰ø°ÊÅØ
 */
export interface LiveStreamStatistics {
  currentViewerCount: number;
  totalViewCount: number;
  followerCount: number;
  subscriptionCount: number;
  chatMessageCount: number;
  donationTotal: number;
  peakViewerCount: number;
  averageWatchTime: number;
  retentionRate: number;
}

/**
 * Áõ¥Êí≠ÂÖ¨Âëä
 */
export interface LiveAnnouncement {
  id: string;
  title: string;
  content: string;
  startTime: number;
  endTime?: number;
  isActive: boolean;
  priority: number;
}

/**
 * Áõ¥Êí≠‰∫ã‰ª∂Á±ªÂûã
 */
export const LiveStreamEventType = {
  LIVE_STREAM_LOADED: 'livestream:loaded',
  LIVE_STREAM_LIST_LOADED: 'livestream:listLoaded',
  LIVE_STREAM_STATUS_CHANGED: 'livestream:statusChanged',
  LIVE_STREAM_FOLLOWED: 'livestream:followed',
  LIVE_STREAM_UNFOLLOWED: 'livestream:unfollowed',
  LIVE_CHAT_RECEIVED: 'livestream:chatReceived',
  LIVE_VIEWER_COUNT_UPDATED: 'livestream:viewerCountUpdated',
  LIVE_ERROR: 'livestream:error',
  LIVE_SCHEDULE_UPDATED: 'livestream:scheduleUpdated',
  FEATURED_LIVE_STREAMS_UPDATED: 'livestream:featuredUpdated'
} as const;

/**
 * Áõ¥Êí≠‰∫ã‰ª∂Êï∞ÊçÆ
 */
export interface LiveStreamEvent {
  streamId: string;
  type: string;
  timestamp: number;
  data?: Record<string, unknown>;
  error?: Error;
}

/**
 * ÂÖ≥Ê≥®Áä∂ÊÄÅÂèòÊõ¥‰∫ã‰ª∂Êï∞Êç? */
export interface FollowChangeEvent extends LiveStreamEvent {
  followed: boolean;
  userId: string;
  broadcasterId: string;
}

/**
 * Áõ¥Êí≠ËÅäÂ§©‰∫ã‰ª∂Êï∞ÊçÆ
 */
export interface ChatEvent extends LiveStreamEvent {
  chat: LiveChat;
}

/**
 * Áõ¥Êí≠Êï∞ÊçÆ‰ªìÂ∫ìÁ±? */
export class LiveStreamRepository {
  private static instance: LiveStreamRepository;
  private logger = Logger.getInstance();
  private storageUtil = StorageUtil.getInstance();
  private networkUtil = NetworkUtil.getInstance();
  private eventBus = EventBusUtil.getInstance();
  private cacheService = CacheService.getInstance();
  private userRepository = UserRepository.getInstance();
  
  // APIÁ´ØÁÇπÈÖçÁΩÆ
  private apiEndpoints = {
    baseUrl: 'https://api.raytv.example.com',
    liveStreams: '/live/streams',
    liveStreamDetail: '/live/streams/:id',
    liveStreamChat: '/live/streams/:id/chat',
    liveStreamStatistics: '/live/streams/:id/statistics',
    featuredStreams: '/live/featured',
    followedStreams: '/live/following',
    trendingStreams: '/live/trending',
    liveStreamFollow: '/live/streams/:id/follow',
    liveStreamCategories: '/live/categories',
    liveStreamAnnouncements: '/live/announcements'
  };
  
  // Â≠òÂÇ®ÂíåÁºìÂ≠òÈîÆÈÖçÁΩÆ
  private storageKeys = {
    liveStreamCache: 'livestream:cache:',
    liveStreamListCache: 'livestream:list:',
    followedBroadcasters: 'livestream:followed',
    liveStreamChatCache: 'livestream:chat:',
    featuredStreams: 'livestream:featured',
    trendingStreams: 'livestream:trending',
    watchedStreams: 'livestream:watched'
  };
  
  // Áõ¥Êí≠ÈÖçÁΩÆ
  private liveConfig = {
    liveStreamDetailCacheDuration: 60, // Áõ¥Êí≠ËØ¶ÊÉÖÁºìÂ≠òÊó∂Èó¥ÔºàÁßíÔº? ËæÉÁü≠‰ª•‰øùÊåÅÂÆûÊó∂ÊÄ?    liveStreamListCacheDuration: 30, // Áõ¥Êí≠ÂàóË°®ÁºìÂ≠òÊó∂Èó¥ÔºàÁßíÔº?    liveChatCacheDuration: 3600, // Áõ¥Êí≠ËÅäÂ§©ÁºìÂ≠òÊó∂Èó¥ÔºàÁßíÔº?    maxFollowedBroadcasters: 500, // ÊúÄÂ§ßÂÖ≥Ê≥®‰∏ªÊí≠Êï∞
    viewerCountUpdateInterval: 5000, // ËßÇÁúã‰∫∫Êï∞Êõ¥Êñ∞Èó¥ÈöîÔºàÊØ´ÁßíÔºâ
    chatMessageBatchSize: 50, // ËÅäÂ§©Ê∂àÊÅØÊâπÈáèËé∑ÂèñÊï∞Èáè
    featuredStreamsCacheDuration: 300 // Á≤æÈÄâÁõ¥Êí≠ÁºìÂ≠òÊó∂Èó¥ÔºàÁßíÔºâ
  };
  
  // ÂΩìÂâçÊ¥ªË∑ÉÁöÑÁõ¥Êí≠ËßÇÁúã‰ºöËØ?  private activeWatchSessions: Map<string, {
    startTime: number;
    lastHeartbeat: number;
  }> = new Map();

  /**
   * ÁßÅÊúâÊûÑÈÄ†ÂáΩÊï?   */
  private constructor() {
    this.logger.info('LiveStreamRepository initialized');
    this.setupEventListeners();
    this.initialize();
  }

  /**
   * Ëé∑ÂèñLiveStreamRepositoryÂçï‰æãÂÆû‰æã
   */
  public static getInstance(): LiveStreamRepository {
    if (!LiveStreamRepository.instance) {
      LiveStreamRepository.instance = new LiveStreamRepository();
    }
    return LiveStreamRepository.instance;
  }

  /**
   * ÂàùÂßãÂåñÁõ¥Êí≠‰ªìÂ∫?   */
  public async initialize(): Promise<void> {
    try {
      // È¢ÑÂä†ËΩΩÁ≤æÈÄâÁõ¥Êí≠ÔºàÂºÇÊ≠•Ôº?      this.loadFeaturedStreams().catch(err => {
        this.logger.warn('Failed to preload featured streams', err);
      });
      
      // È¢ÑÂä†ËΩΩÁÉ≠Èó®Áõ¥Êí≠ÔºàÂºÇÊ≠•Ôº?      this.loadTrendingStreams().catch(err => {
        this.logger.warn('Failed to preload trending streams', err);
      });
      
      // ÂêØÂä®ÂøÉË∑≥Ê£ÄÊµ?      this.startHeartbeatCheck();
      
      this.logger.info('LiveStreamRepository initialization completed');
    } catch (error) {
      this.Logger.error('Failed to initialize LiveStreamRepository', error as Error);
    }
  }

  /**
   * ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨Âô?   */
  private setupEventListeners(): void {
    // ÁõëÂê¨Â∫îÁî®ÈÄÄÂá∫‰∫ã‰ª∂ÔºåÊ∏ÖÁêÜËßÇÁúã‰ºöËØù
    this.eventBus.on('app:exit', async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ())))))) => {
      await this.cleanupWatchSessions();
    });
    
    // ÁõëÂê¨ÁΩëÁªúÁä∂ÊÄÅÂèòÂå?    this.eventBus.on('network:statusChanged', async (status?: { isOnline: boolean }) => {
      if (status?.isOnline) {
        // Âú®Á∫øÊó∂Âà∑Êñ∞Á≤æÈÄâÂíåÁÉ≠Èó®Áõ¥Êí≠
        this.loadFeaturedStreams().catch(err => {
          this.logger.warn('Failed to refresh featured streams after network recovery', err);
        });
        this.loadTrendingStreams().catch(err => {
          this.logger.warn('Failed to refresh trending streams after network recovery', err);
        });
      }
    });
    
    // ÁõëÂê¨Áî®Êà∑ÁôªÂΩïÁä∂ÊÄÅÂèòÂå?    this.eventBus.on('user:login', async () => {
      // Áî®Êà∑ÁôªÂΩïÂêéÂä†ËΩΩÂÖ≥Ê≥®ÁöÑÁõ¥Êí≠
      this.loadFollowedStreams().catch(err => {
        this.logger.warn('Failed to load followed streams after login', err);
      });
    });
    
    // ÁõëÂê¨Áî®Êà∑ÁôªÂá∫‰∫ã‰ª∂
    this.eventBus.on('user:logout', async () => {
      // Áî®Êà∑ÁôªÂá∫ÂêéÊ∏ÖÁêÜÂÖ≥Ê≥®ÁöÑÁõ¥Êí≠Êï∞ÊçÆ
      await this.clearFollowedStreams();
    });
  }

  /**
   * ÂêØÂä®ÂøÉË∑≥Ê£ÄÊµ?   */
  private startHeartbeatCheck(): void {
    // ÊØ?0ÁßíÊ£ÄÊü•‰∏ÄÊ¨°ËßÇÁúã‰ºöËØùÁöÑÂøÉË∑≥
    setInterval(() => {
      this.checkHeartbeats();
    }, 30000);
  }

  /**
   * Ê£ÄÊü•ËßÇÁúã‰ºöËØùÂøÉË∑?   */
  private checkHeartbeats(): void {
    const now = Date.now();
    const timeoutThreshold = 60000; // 60ÁßíË∂ÖÊó?    
    for (const [streamId, session] of this.activeWatchSessions) {
      if (now - session.lastHeartbeat > timeoutThreshold) {
        // ÂøÉË∑≥Ë∂ÖÊó∂ÔºåÊ∏ÖÁêÜ‰ºöËØ?        this.activeWatchSessions.delete(streamId);
        this.logger.debug(`Watch session timeout for stream: ${streamId}`);
      }
    }
  }

  /**
   * Ê∏ÖÁêÜËßÇÁúã‰ºöËØù
   */
  private async cleanupWatchSessions(): Promise<void> {
    try {
      // ‰øùÂ≠òËßÇÁúãÂéÜÂè≤
      for (const [streamId, session] of this.activeWatchSessions) {
        await this.saveWatchHistory(streamId, session.startTime, Date.now());
      }
      
      // Ê∏ÖÁ©∫Ê¥ªË∑É‰ºöËØù
      this.activeWatchSessions.clear();
      
      this.logger.info('Watch sessions cleaned up');
    } catch (error) {
      this.Logger.error('Failed to cleanup watch sessions', error as Error);
    }
  }

  /**
   * ‰øùÂ≠òËßÇÁúãÂéÜÂè≤
   */
  private async saveWatchHistory(streamId: string, startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number : new Error(String(startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number : new Error(String(startTime: number, endTime: number : new Error(String(startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number : new Error(String(startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number : new Error(String(startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number : new Error(String(startTime: number, endTime: number : new Error(String(startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number : new Error(String(startTime: number, endTime: number : new Error(String(startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number : new Error(String(startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number : new Error(String(startTime: number, endTime: number : new Error(String(startTime: number, endTime: number instanceof Error ? startTime: number, endTime: number : new Error(String(startTime: number, endTime: number))))))): Promise<void> {
    try {
      const watchDuration = endTime - startTime;
      
      // Âè™‰øùÂ≠òËßÇÁúãÊó∂Èó¥Ë∂ÖËø?0ÁßíÁöÑËÆ∞ÂΩï
      if (watchDuration < 30000) {
        return;
      }
      
      const watchHistory: Record<string, string | number | boolean | null> = { ... };
      
      // ‰øùÂ≠òÂà∞Êú¨Âú∞Â≠òÂÇ?      await this.storageUtil.setItem(
        LocalStorageType.WATCH_HISTORY,
        this.storageKeys.watchedStreams,
        watchHistory
      );
      
      this.logger.debug(`Watch history saved for stream: ${streamId}, duration: ${watchDuration}ms`);
    } catch (error) {
      this.Logger.error('Failed to save watch history', error as Error);
    }
  }

  /**
   * Ëé∑ÂèñÁõ¥Êí≠ÂàóË°®
   */
  public async getLiveStreams(request: LiveStreamListRequest): Promise<LiveStreamListResponse> {
    try {
      // ÁîüÊàêÁºìÂ≠òÈî?      const cacheKey = this.generateListCacheKey(request);
      
      // Â∞ùËØï‰ªéÁºìÂ≠òËé∑Âè?      const cachedData = await this.cacheService.get<LiveStreamListResponse>(
        CacheType.LIVE_STREAM_LIST, cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
      )))))));
      
      if (cachedData && !this.isCacheExpired(cachedData.timestamp, this.liveConfig.liveStreamListCacheDuration)) {
        this.logger.debug('Live streams loaded from cache');
        return cachedData.data;
      }
      
      // ‰ªéAPIËé∑Âèñ
      const response = await this.fetchLiveStreamsFromAPI(request);
      
      // ÁºìÂ≠òÁªìÊûú
      await this.cacheService.set(
        CacheType.LIVE_STREAM_LIST,
        cacheKey,
        response,
        this.liveConfig.liveStreamListCacheDuration
      );
      
      // ÂèëÂ∏É‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_STREAM_LIST_LOADED, {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now(),
        data: { request, response }
      });
      
      this.logger.info(`Live streams loaded: ${response.streams.length} streams`);
      
      return response;
    } catch (error) {
      this.Logger.error('Failed to get live streams', error as Error);
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * ‰ªéAPIËé∑ÂèñÁõ¥Êí≠ÂàóË°®
   */
  private async fetchLiveStreamsFromAPI(request: LiveStreamListRequest): Promise<LiveStreamListResponse> {
    const params = new URLSearchParams();
    
    if (request.status) params.append('status', request.status);
    if (request.type) params.append('type', request.type);
    if (request.category) params.append('category', request.category);
    if (request.tag) params.append('tag', request.tag);
    if (request.page) params.append('page', request.page.toString());
    if (request.pageSize) params.append('pageSize', request.pageSize.toString());
    if (request.sortBy) params.append('sortBy', request.sortBy);
    if (request.featured !== undefined) params.append('featured', request.featured.toString());
    if (request.searchQuery) params.append('searchQuery', request.searchQuery);
    
    const url = `${this.apiEndpoints.baseUrl}${this.apiEndpoints.liveStreams}?${params.toString()}`;
    
    const response = await this.networkUtil.get(url);
    
    if (!response.success) {
      throw new Error(`Failed to fetch live streams: ${response.error}`);
    }
    
    return response.data as LiveStreamListResponse;
  }

  /**
   * ÁîüÊàêÂàóË°®ÁºìÂ≠òÈî?   */
  private generateListCacheKey(request: LiveStreamListRequest): string {
    const keyParts = [
      request.status || 'all',
      request.type || 'all',
      request.category || 'all',
      request.tag || 'all',
      request.page || 1,
      request.pageSize || 20,
      request.sortBy || 'viewers',
      request.featured || false,
      request.searchQuery || ''
    ];
    
    return `${this.storageKeys.liveStreamListCache}${keyParts.join(':')}`;
  }

  /**
   * Ê£ÄÊü•ÁºìÂ≠òÊòØÂê¶ËøáÊú?   */
  private isCacheExpired(timestamp: number, duration: number): boolean {
    return Date.now() - timestamp > duration * 1000;
  }

  /**
   * Ëé∑ÂèñÁõ¥Êí≠ËØ¶ÊÉÖ
   */
  public async getLiveStreamDetail(streamId: string): Promise<LiveStreamInfo> {
    try {
      // ÁîüÊàêÁºìÂ≠òÈî?      const cacheKey = `${this.storageKeys.liveStreamCache}${streamId}`;
      
      // Â∞ùËØï‰ªéÁºìÂ≠òËé∑Âè?      const cachedData = await this.cacheService.get<LiveStreamInfo>(
        CacheType.LIVE_STREAM_DETAIL,
        cacheKey
      );
      
      if (cachedData && !this.isCacheExpired(cachedData.timestamp, this.liveConfig.liveStreamDetailCacheDuration)) {
        this.logger.debug(`Live stream detail loaded from cache: ${streamId}`);
        return cachedData.data;
      }
      
      // ‰ªéAPIËé∑Âèñ
      const stream = await this.fetchLiveStreamDetailFromAPI(streamId);
      
      // ÁºìÂ≠òÁªìÊûú
      await this.cacheService.set(
        CacheType.LIVE_STREAM_DETAIL,
        cacheKey,
        stream,
        this.liveConfig.liveStreamDetailCacheDuration
      );
      
      // ÂèëÂ∏É‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_STREAM_LOADED, {
        type: LiveStreamEventType.LIVE_STREAM_LOADED,
        timestamp: Date.now(),
        data: { streamId, stream }
      });
      
      this.logger.info(`Live stream detail loaded: ${streamId}`);
      
      return stream;
    } catch (error) {
      this.Logger.error(`Failed to get live stream detail: ${streamId}`, error as Error);
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * ‰ªéAPIËé∑ÂèñÁõ¥Êí≠ËØ¶ÊÉÖ
   */
  private async fetchLiveStreamDetailFromAPI(streamId: string): Promise<LiveStreamInfo> {
    const url = `${this.apiEndpoints.baseUrl}${this.apiEndpoints.liveStreamDetail.replace(':id', streamId)}`;
    
    const response = await this.networkUtil.get(url);
    
    if (!response.success) {
      throw new Error(`Failed to fetch live stream detail: ${response.error}`);
    }
    
    return response.data as LiveStreamInfo;
  }

  /**
   * ÂÖ≥Ê≥®/ÂèñÊ∂àÂÖ≥Ê≥®Áõ¥Êí≠
   */
  public async followLiveStream(streamId: string, follow: boolean): Promise<void> {
    try {
      const user = this.userRepository.getCurrentUser();
      if (!user) {
        throw new Error('User not logged in');
      }
      
      const url = `${this.apiEndpoints.baseUrl}${this.apiEndpoints.liveStreamFollow.replace(':id', streamId)}`;
      
      const response = await this.networkUtil.post(url, { follow });
      
      if (!response.success) {
        throw new Error(`Failed to ${follow ? 'follow' : 'unfollow'} live stream: ${response.error}`);
      }
      
      // Êõ¥Êñ∞Êú¨Âú∞ÂÖ≥Ê≥®Áä∂ÊÄ?      await this.updateLocalFollowStatus(streamId, follow, user.id);
      
      // ÂèëÂ∏É‰∫ã‰ª∂
      this.eventBus.emit(follow ? LiveStreamEventType.LIVE_STREAM_FOLLOWED : LiveStreamEventType.LIVE_STREAM_UNFOLLOWED, {
        type: follow ? LiveStreamEventType.LIVE_STREAM_FOLLOWED : LiveStreamEventType.LIVE_STREAM_UNFOLLOWED,
        timestamp: Date.now(),
        data: {
          streamId,
          userId: user.id,
          followed: follow
        }
      });
      
      this.logger.info(`Live stream ${follow ? 'followed' : 'unfollowed'}: ${streamId}`);
    } catch (error) {
      this.Logger.error(`Failed to ${follow ? 'follow' : 'unfollow'} live stream: ${streamId}`, error as Error);
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * Êõ¥Êñ∞Êú¨Âú∞ÂÖ≥Ê≥®Áä∂ÊÄ?   */
  private async updateLocalFollowStatus(streamId: string, follow: boolean, userId: string): Promise<void> {
    try {
      // Ëé∑ÂèñÂΩìÂâçÂÖ≥Ê≥®ÁöÑÁõ¥Êí≠ÂàóË°?      const followedStreams = await this.getFollowedStreams();
      
      if (follow) {
        // Ê∑ªÂä†ÂÖ≥Ê≥®
        if (!followedStreams.includes(streamId)) {
          followedStreams.push(streamId);
        }
      } else {
        // ÂèñÊ∂àÂÖ≥Ê≥®
        const index = followedStreams.indexOf(streamId);
        if (index > -1) {
          followedStreams.splice(index, 1);
        }
      }
      
      // ‰øùÂ≠òÂà∞Êú¨Âú∞Â≠òÂÇ?      await this.storageUtil.setItem(
        LocalStorageType.FOLLOWED_STREAMS,
        this.storageKeys.followedBroadcasters,
        followedStreams
      );
      
      this.logger.debug(`Local follow status updated: ${streamId} -> ${follow}`);
    } catch (error) {
      this.Logger.error('Failed to update local follow status', error as Error);
      throw error;
    }
  }

  /**
   * Ëé∑ÂèñÂÖ≥Ê≥®ÁöÑÁõ¥Êí≠ÂàóË°?   */
  public async getFollowedStreams(): Promise<string[]> {
    try {
      const followedStreams = await this.storageUtil.getItem<string[]>(
        LocalStorageType.FOLLOWED_STREAMS, this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
      )))))));
      
      return followedStreams || [];
    } catch (error) {
      this.Logger.error('Failed to get followed streams', error as Error);
      return [];
    }
  }

  /**
   * Âä†ËΩΩÂÖ≥Ê≥®ÁöÑÁõ¥Êí?   */
  private async loadFollowedStreams(): Promise<void> {
    try {
      const followedStreams = await this.getFollowedStreams();
      
      // ÂèëÂ∏É‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_STREAM_LIST_LOADED, {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_STREAM_LIST_LOADED,
        timestamp: Date.now())))))),
        data: { followedStreams }
      });
      
      this.logger.info(`Followed streams loaded: ${followedStreams.length} streams`);
    } catch (error) {
      this.Logger.error('Failed to load followed streams', error as Error);
    }
  }

  /**
   * Ê∏ÖÁêÜÂÖ≥Ê≥®ÁöÑÁõ¥Êí≠Êï∞Êç?   */
  private async clearFollowedStreams(): Promise<void> {
    try {
      await this.storageUtil.removeItem(
        LocalStorageType.FOLLOWED_STREAMS, this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
       instanceof Error ? this.storageKeys.followedBroadcasters
       : new Error(String(this.storageKeys.followedBroadcasters
      )))))));
      
      this.logger.info('Followed streams cleared');
    } catch (error) {
      this.Logger.error('Failed to clear followed streams', error as Error);
    }
  }

  /**
   * Âä†ËΩΩÁ≤æÈÄâÁõ¥Êí?   */
  private async loadFeaturedStreams(): Promise<void> {
    try {
      const cacheKey = this.storageKeys.featuredStreams;
      
      // Â∞ùËØï‰ªéÁºìÂ≠òËé∑Âè?      const cachedData = await this.cacheService.get<LiveStreamInfo[]>(
        CacheType.FEATURED_STREAMS, cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
       : new Error(String(cacheKey
       instanceof Error ? cacheKey
       : new Error(String(cacheKey
      )))))));
      
      if (cachedData && !this.isCacheExpired(cachedData.timestamp, this.liveConfig.featuredStreamsCacheDuration)) {
        this.logger.debug('Featured streams loaded from cache');
        return;
      }
      
      // ‰ªéAPIËé∑Âèñ
      const url = `${this.apiEndpoints.baseUrl}${this.apiEndpoints.featuredStreams}`;
      const response = await this.networkUtil.get(url);
      
      if (response.success) {
        const featuredStreams = response.data as LiveStreamInfo[];
        
        // ÁºìÂ≠òÁªìÊûú
        await this.cacheService.set(
          CacheType.FEATURED_STREAMS,
          cacheKey,
          featuredStreams,
          this.liveConfig.featuredStreamsCacheDuration
        );
        
        // ÂèëÂ∏É‰∫ã‰ª∂
        this.eventBus.emit(LiveStreamEventType.FEATURED_LIVE_STREAMS_UPDATED, {
          type: LiveStreamEventType.FEATURED_LIVE_STREAMS_UPDATED,
          timestamp: Date.now(),
          data: { featuredStreams }
        });
        
        this.logger.info(`Featured streams loaded: ${featuredStreams.length} streams`);
      }
    } catch (error) {
      this.logger.warn('Failed to load featured streams', error as Error);
    }
  }

  /**
   * Âä†ËΩΩÁÉ≠Èó®Áõ¥Êí≠
   */
  private async loadTrendingStreams(): Promise<void> {
    try {
      const cacheKey = this.storageKeys.trendingStreams;
      
      // Â∞ùËØï‰ªéÁºìÂ≠òËé∑Âè?      const cachedData = await this.cacheService.get<LiveStreamInfo[]>(
        CacheType.TRENDING_STREAMS,
        cacheKey
      );
      
      if (cachedData && !this.isCacheExpired(cachedData.timestamp, this.liveConfig.featuredStreamsCacheDuration)) {
        this.logger.debug('Trending streams loaded from cache');
        return;
      }
      
      // ‰ªéAPIËé∑Âèñ
      const url = `${this.apiEndpoints.baseUrl}${this.apiEndpoints.trendingStreams}`;
      const response = await this.networkUtil.get(url);
      
      if (response.success) {
        const trendingStreams = response.data as LiveStreamInfo[];
        
        // ÁºìÂ≠òÁªìÊûú
        await this.cacheService.set(
          CacheType.TRENDING_STREAMS,
          cacheKey,
          trendingStreams,
          this.liveConfig.featuredStreamsCacheDuration
        );
        
        // ÂèëÂ∏É‰∫ã‰ª∂
        this.eventBus.emit(LiveStreamEventType.FEATURED_LIVE_STREAMS_UPDATED, {
          type: LiveStreamEventType.FEATURED_LIVE_STREAMS_UPDATED,
          timestamp: Date.now(),
          data: { trendingStreams }
        });
        
        this.logger.info(`Trending streams loaded: ${trendingStreams.length} streams`);
      }
    } catch (error) {
      this.logger.warn('Failed to load trending streams', error as Error);
    }
  }

  /**
   * Ëé∑ÂèñÁõ¥Êí≠ËÅäÂ§©Ê∂àÊÅØ
   */
  public async getLiveChat(streamId: string, limit?: number): Promise<LiveChat[]> {
    try {
      const actualLimit = limit || this.liveConfig.chatMessageBatchSize;
      
      // ÁîüÊàêÁºìÂ≠òÈî?      const cacheKey = `${this.storageKeys.liveStreamChatCache}${streamId}:${actualLimit}`;
      
      // Â∞ùËØï‰ªéÁºìÂ≠òËé∑Âè?      const cachedData = await this.cacheService.get<LiveChat[]>(
        CacheType.LIVE_CHAT,
        cacheKey
      );
      
      if (cachedData && !this.isCacheExpired(cachedData.timestamp, this.liveConfig.liveChatCacheDuration)) {
        this.logger.debug(`Live chat loaded from cache: ${streamId}`);
        return cachedData.data;
      }
      
      // ‰ªéAPIËé∑Âèñ
      const url = `${this.apiEndpoints.baseUrl}${this.apiEndpoints.liveStreamChat.replace(':id', streamId)}?limit=${actualLimit}`;
      const response = await this.networkUtil.get(url);
      
      if (!response.success) {
        throw new Error(`Failed to fetch live chat: ${response.error}`);
      }
      
      const chatMessages = response.data as LiveChat[];
      
      // ÁºìÂ≠òÁªìÊûú
      await this.cacheService.set(
        CacheType.LIVE_CHAT,
        cacheKey,
        chatMessages,
        this.liveConfig.liveChatCacheDuration
      );
      
      // ÂèëÂ∏É‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_CHAT_RECEIVED, {
        type: LiveStreamEventType.LIVE_CHAT_RECEIVED,
        timestamp: Date.now(),
        data: { streamId, chatMessages }
      });
      
      this.logger.info(`Live chat loaded: ${streamId}, ${chatMessages.length} messages`);
      
      return chatMessages;
    } catch (error) {
      this.Logger.error(`Failed to get live chat: ${streamId}`, error as Error);
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * ÂèëÈÄÅËÅäÂ§©Ê∂àÊÅ?   */
  public async sendChatMessage(streamId: string, message: string): Promise<void> {
    try {
      const user = this.userRepository.getCurrentUser();
      if (!user) {
        throw new Error('User not logged in');
      }
      
      const url = `${this.apiEndpoints.baseUrl}${this.apiEndpoints.liveStreamChat.replace(':id', streamId)}`;
      
      const response = await this.networkUtil.post(url, {
        message,
        userId: user.id,
        userName: user.name
      });
      
      if (!response.success) {
        throw new Error(`Failed to send chat message: ${response.error}`);
      }
      
      this.logger.info(`Chat message sent to stream: ${streamId}`);
    } catch (error) {
      this.Logger.error(`Failed to send chat message: ${streamId}`, error as Error);
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * ÂºÄÂßãËßÇÁúãÁõ¥Êí?   */
  public startWatching(streamId: string): void {
    const now = Date.now();
    this.activeWatchSessions.set(streamId, {
      startTime: now,
      lastHeartbeat: now
    });
    
    this.logger.debug(`Started watching stream: ${streamId}`);
  }

  /**
   * Êõ¥Êñ∞ËßÇÁúãÂøÉË∑≥
   */
  public updateHeartbeat(streamId: string): void {
    const session = this.activeWatchSessions.get(streamId);
    if (session) {
      session.lastHeartbeat = Date.now();
      this.logger.debug(`Heartbeat updated for stream: ${streamId}`);
    }
  }

  /**
   * ÂÅúÊ≠¢ËßÇÁúãÁõ¥Êí≠
   */
  public async stopWatching(streamId: string): Promise<void> {
    const session = this.activeWatchSessions.get(streamId);
    if (session) {
      await this.saveWatchHistory(streamId, session.startTime, Date.now());
      this.activeWatchSessions.delete(streamId);
      this.logger.debug(`Stopped watching stream: ${streamId}`);
    }
  }

  /**
   * Ëé∑ÂèñÁõ¥Êí≠ÁªüËÆ°‰ø°ÊÅØ
   */
  public async getLiveStreamStatistics(streamId: string): Promise<LiveStreamStatistics> {
    try {
      const url = `${this.apiEndpoints.baseUrl}${this.apiEndpoints.liveStreamStatistics.replace(':id', streamId)}`;
      
      const response = await this.networkUtil.get(url);
      
      if (!response.success) {
        throw new Error(`Failed to fetch live stream statistics: ${response.error}`);
      }
      
      return response.data as LiveStreamStatistics;
    } catch (error) {
      this.Logger.error(`Failed to get live stream statistics: ${streamId}`, error as Error);
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * Ëé∑ÂèñÁõ¥Êí≠ÂÖ¨Âëä
   */
  public async getLiveAnnouncements(streamId: string): Promise<LiveAnnouncement[]> {
    try {
      const url = `${this.apiEndpoints.baseUrl}${this.apiEndpoints.liveStreamAnnouncements.replace(':id', streamId)}`;
      
      const response = await this.networkUtil.get(url);
      
      if (!response.success) {
        throw new Error(`Failed to fetch live announcements: ${response.error}`);
      }
      
      return response.data as LiveAnnouncement[];
    } catch (error) {
      this.Logger.error(`Failed to get live announcements: ${streamId}`, error as Error);
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * ÊêúÁ¥¢Áõ¥Êí≠
   */
  public async searchLiveStreams(query: string, filters?: {
    type?: LiveStreamType;
    category?: string;
    status?: LiveStatus;
    featured?: boolean;
  }): Promise<LiveStreamInfo[]> {
    try {
      const params = new URLSearchParams();
      params.append('searchQuery', query);
      
      if (filters?.type) params.append('type', filters.type);
      if (filters?.category) params.append('category', filters.category);
      if (filters?.status) params.append('status', filters.status);
      if (filters?.featured !== undefined) params.append('featured', filters.featured.toString());
      
      const url = `${this.apiEndpoints.baseUrl}${this.apiEndpoints.liveStreams}?${params.toString()}`;
      
      const response = await this.networkUtil.get(url);
      
      if (!response.success) {
        throw new Error(`Failed to search live streams: ${response.error}`);
      }
      
      const searchResult = response.data as LiveStreamListResponse;
      
      this.logger.info(`Live streams search completed: "${query}", ${searchResult.streams.length} results`);
      
      return searchResult.streams;
    } catch (error) {
      this.Logger.error(`Failed to search live streams: "${query}"`, error as Error);
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * Ê£ÄÊü•Áõ¥Êí≠Áä∂ÊÄ?   */
  public async checkLiveStreamStatus(streamId: string): Promise<LiveStatus> {
    try {
      const stream = await this.getLiveStreamDetail(streamId);
      
      // ÂèëÂ∏ÉÁä∂ÊÄÅÊõ¥Êñ∞‰∫ã‰ª?      this.eventBus.emit(LiveStreamEventType.LIVE_STREAM_STATUS_CHANGED, {
        type: LiveStreamEventType.LIVE_STREAM_STATUS_CHANGED,
        timestamp: Date.now(),
        data: { streamId, status: stream.liveStatus }
      });
      
      return stream.liveStatus;
    } catch (error) {
      this.Logger.error(`Failed to check live stream status: ${streamId}`, error as Error);
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * Ëé∑ÂèñÁõ¥Êí≠ÂàÜÁ±ª
   */
  public async getLiveStreamCategories(): Promise<{ id: string; name: string; count: number }[]> {
    try {
      const url = `${this.apiEndpoints.baseUrl}${this.apiEndpoints.liveStreamCategories}`;
      
      const response = await this.networkUtil.get(url);
      
      if (!response.success) {
        throw new Error(`Failed to fetch live stream categories: ${response.error}`);
      }
      
      return response.data as { id: string; name: string; count: number }[];
    } catch (error) {
      this.Logger.error('Failed to get live stream categories', error as Error);
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * Ëé∑ÂèñÊé®ËçêÁöÑÁõ¥Êí?   */
  public async getRecommendedLiveStreams(limit: number = 10): Promise<LiveStreamInfo[]> {
    try {
      // Âü∫‰∫éÁî®Êà∑ËßÇÁúãÂéÜÂè≤ÂíåÂÖ≥Ê≥®ÁöÑ‰∏ªÊí≠Êé®Ëçê
      const user = this.userRepository.getCurrentUser();
      if (!user) {
        return [];
      }
      
      // Ëé∑ÂèñÁî®Êà∑ÂÖ≥Ê≥®ÁöÑÁõ¥Êí?      const followedStreams = await this.getFollowedStreams();
      
      // Ëé∑ÂèñÁÉ≠Èó®Áõ¥Êí≠‰Ωú‰∏∫Â§áÈÄ?      const trendingRequest: LiveStreamListRequest = {
        page: 1,
        pageSize: limit * 2,
        sortBy: 'trending'
      };
      
      const trendingResponse = await this.getLiveStreams(trendingRequest);
      
      // ‰ºòÂÖàÊé®ËçêÂÖ≥Ê≥®ÁöÑÁõ¥Êí?      const recommended: LiveStreamInfo[] = [];
      
      for (const streamId of followedStreams) {
        if (recommended.length >= limit) break;
        
        try {
          const stream = await this.getLiveStreamDetail(streamId);
          if (stream.liveStatus === LiveStatus.LIVE) {
            recommended.push(stream);
          }
        } catch (error) {
          // ÂøΩÁï•Ëé∑ÂèñÂ§±Ë¥•ÁöÑÁõ¥Êí?          this.logger.warn(`Failed to get recommended stream detail: ${streamId}`, error as Error);
        }
      }
      
      // Â¶ÇÊûúÂÖ≥Ê≥®ÁöÑ‰∏çÂ§üÔºåË°•ÂÖÖÁÉ≠Èó®Áõ¥Êí≠
      if (recommended.length < limit) {
        const remaining = limit - recommended.length;
        const trendingStreams = trendingResponse.streams.slice(0, remaining);
        recommended.push(...trendingStreams);
      }
      
      this.logger.info(`Recommended live streams loaded: ${recommended.length} streams`);
      
      return recommended;
    } catch (error) {
      this.Logger.error('Failed to get recommended live streams', error as Error);
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now( : new Error(String({
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * Ê∏ÖÁêÜËøáÊúüÁºìÂ≠ò
   */
  public async cleanupExpiredCache(): Promise<void> {
    try {
      await this.cacheService.cleanupExpired();
      this.logger.info('Live stream cache cleanup completed');
    } catch (error) {
      this.Logger.error('Failed to cleanup live stream cache', error as Error);
    }
  }

  /**
   * ÂÖ≥Èó≠Áõ¥Êí≠‰ªìÂ∫ì
   */
  public async shutdown(): Promise<void> {
    try {
      // Ê∏ÖÁêÜËßÇÁúã‰ºöËØù
      await this.cleanupWatchSessions();
      
      // Ê∏ÖÁêÜÁºìÂ≠ò
      await this.cleanupExpiredCache();
      
      // ÂÅúÊ≠¢ÂøÉË∑≥Ê£ÄÊµ?      // Ê≥®ÊÑèÔºöÂú®ArkTS‰∏≠ÔºåsetIntervalËøîÂõûÁöÑtimerÈúÄË¶ÅÊâãÂä®Ê∏ÖÁê?      // ËøôÈáåÈúÄË¶ÅÊ†πÊçÆÂÆûÈôÖÂÆûÁé∞Êù•Ê∏ÖÁêÜÂÆöÊó∂Âô?      
      this.logger.info('LiveStreamRepository shutdown');
    } catch (error) {
      this.logger.error('Failed to shutdown LiveStreamRepository', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
      
      // ÂèëÂ∏ÉÈîôËØØ‰∫ã‰ª∂
      this.eventBus.emit(LiveStreamEventType.LIVE_ERROR, {
        type: LiveStreamEventType.LIVE_ERROR,
        timestamp: Date.now(),
        error: error as Error
      });
      
      throw error;
    }
  }
}



