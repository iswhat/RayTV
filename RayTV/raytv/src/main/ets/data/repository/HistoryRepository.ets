// HistoryRepository.ets - å†å²è®°å½•æ•°æ®ä»“åº“
// è´Ÿè´£å†å²è®°å½•ç›¸å…³æ•°æ®çš„å­˜å‚¨ã€è¯»å–å’Œç®¡ç†

import { SQLiteHelper, QueryCondition } from '../db/SQLiteHelper';
import { History, HistoryGroup, HistoryType, ContentType } from '../bean/History';
import { HISTORY_TABLE } from '../db/TableSchema';
import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';

const TAG = 'HistoryRepository';
const HISTORY_CACHE_PREFIX = 'history_item_';
const HISTORY_LIST_CACHE = 'history_list_cache';
const MAX_HISTORY_ITEMS = 1000; // æœ€å¤§å†å²è®°å½•æ•°é‡?
export class HistoryRepository {
  private static instance: HistoryRepository;
  private sqliteHelper: SQLiteHelper;
  private storageUtil: StorageUtil;
  
  private constructor() {
    this.sqliteHelper = SQLiteHelper.getInstance();
    this.storageUtil = StorageUtil.getInstance();
  }
  
  /**
   * è·å–å†å²è®°å½•ä»“åº“å•ä¾‹å®ä¾‹
   */
  public static getInstance(): HistoryRepository {
    if (!HistoryRepository.instance) {
      HistoryRepository.instance = new HistoryRepository();
    }
    return HistoryRepository.instance;
  }
  
  /**
   * ä¿å­˜æˆ–æ›´æ–°å†å²è®°å½?   * @param history å†å²è®°å½•ä¿¡æ¯
   * @returns æ˜¯å¦ä¿å­˜æˆåŠŸ
   */
  public async saveHistory(history: History): Promise<boolean> {
    try {
      Logger.debug(TAG, `Saving history for: ${history.title}`);
      
      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒå†…å®¹çš„å†å²è®°å½?      const existingHistory = await this.findExistingHistory(history);
      
      const historyData = {
        [HISTORY_TABLE.COLUMNS.ID]: existingHistory?.id || null,
        [HISTORY_TABLE.COLUMNS.TITLE]: history.title,
        [HISTORY_TABLE.COLUMNS.SUBTITLE]: history.subtitle || '',
        [HISTORY_TABLE.COLUMNS.COVER_URL]: history.coverUrl || '',
        [HISTORY_TABLE.COLUMNS.CONTENT_TYPE]: history.contentType,
        [HISTORY_TABLE.COLUMNS.HISTORY_TYPE]: history.historyType,
        [HISTORY_TABLE.COLUMNS.SITE_ID]: history.siteId || '',
        [HISTORY_TABLE.COLUMNS.CONTENT_ID]: history.contentId,
        [HISTORY_TABLE.COLUMNS.EPISODE_ID]: history.episodeId || '',
        [HISTORY_TABLE.COLUMNS.PLAY_URL]: history.playUrl || '',
        [HISTORY_TABLE.COLUMNS.PLAY_POSITION]: history.playPosition || 0,
        [HISTORY_TABLE.COLUMNS.TOTAL_DURATION]: history.totalDuration || 0,
        [HISTORY_TABLE.COLUMNS.PROGRESS]: history.progress || 0,
        [HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME]: Date.now(),
        [HISTORY_TABLE.COLUMNS.CREATE_TIME]: existingHistory?.createTime || Date.now(),
        [HISTORY_TABLE.COLUMNS.EXTRA_DATA]: JSON.stringify(history.extraData || {})
      };
      
      let result: number | undefined;
      if (existingHistory?.id) {
        // æ›´æ–°ç°æœ‰å†å²è®°å½•
        const conditions: QueryCondition[] = [{
          column: HISTORY_TABLE.COLUMNS.ID,
          value: existingHistory.id
        }];
        result = await this.sqliteHelper.update(HISTORY_TABLE.TABLE_NAME, historyData, conditions);
        if (result.success) {
          history.id = existingHistory.id.toString();
        }
      } else {
        // æ’å…¥æ–°å†å²è®°å½?        result = await this.sqliteHelper.insert(HISTORY_TABLE.TABLE_NAME, historyData);
        if (result.success && result.lastInsertRowId) {
          history.id = result.lastInsertRowId.toString();
        }
      }
      
      if (result.success) {
        // æ›´æ–°ç¼“å­˜
        await this.cacheHistoryItem(history);
        await this.invalidateHistoryListCache();
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ¸…ç†æ—§è®°å½•
        await this.cleanupOldHistory();
        
        Logger.info(TAG, `History saved successfully: ${history.title}`);
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to save history: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨ç›¸åŒå†…å®¹çš„å†å²è®°å½?   */
  private async findExistingHistory(history: History): Promise<unknown | null> {
    const conditions: QueryCondition[] = [{
      column: HISTORY_TABLE.COLUMNS.CONTENT_TYPE, value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE instanceof Error ? value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE : new Error(String(value: history.contentType
    }, {
      column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
      value: history.contentId
    }];
    
    // å¯¹äºå‰§é›†å†…å®¹ï¼Œè¿˜éœ€è¦åŒ¹é…é›†æ•°ID
    if (history.episodeId && history.contentType === ContentType.EPISODE))))))) {
      conditions.push({
        column: HISTORY_TABLE.COLUMNS.EPISODE_ID,
        value: history.episodeId
      });
    }
    
    return await this.sqliteHelper.getFirst(HISTORY_TABLE.TABLE_NAME, ['*'], conditions);
  }
  
  /**
   * è·å–å†å²è®°å½•åˆ—è¡¨
   * @param limit é™åˆ¶æ•°é‡
   * @param offset åç§»é‡?   * @returns å†å²è®°å½•åˆ—è¡¨
   */
  public async getHistoryList(limit: number = 50, offset: number = 0): Promise<History[]> {
    try {
      // æ„å»ºæ’åºé€‰é¡¹ - æŒ‰æœ€åæ’­æ”¾æ—¶é—´é™åº?      const sortOptions = [{
        column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      // æŸ¥è¯¢æ•°æ®åº?      const historyRecords = await this.sqliteHelper.query(
        HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit,
        offset
      );
      
      // è½¬æ¢ä¸ºHistoryå¯¹è±¡
      const histories = this.convertToHistoryObjects(historyRecords);
      
      Logger.info(TAG, `Retrieved ${histories.length} history items`);
      return histories;
    } catch (error) {
      Logger.error(TAG, `Failed to get history list: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * æŒ‰å†…å®¹ç±»å‹è·å–å†å²è®°å½?   * @param contentType å†…å®¹ç±»å‹
   * @param limit é™åˆ¶æ•°é‡
   * @returns å†å²è®°å½•åˆ—è¡¨
   */
  public async getHistoryByContentType(contentType: ContentType, limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50))))))): Promise<History[]> {
    try {
      const conditions: QueryCondition[] = [{
        column: HISTORY_TABLE.COLUMNS.CONTENT_TYPE,
        value: contentType
      }];
      
      const sortOptions = [{
        column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const historyRecords = await this.sqliteHelper.query(
        HISTORY_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions,
        limit
      );
      
      const histories = this.convertToHistoryObjects(historyRecords);
      Logger.info(TAG, `Retrieved ${histories.length} history items for type ${contentType}`);
      return histories;
    } catch (error) {
      Logger.error(TAG, `Failed to get history by content type: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * æŒ‰ç«™ç‚¹è·å–å†å²è®°å½?   * @param siteId ç«™ç‚¹ID
   * @param limit é™åˆ¶æ•°é‡
   * @returns å†å²è®°å½•åˆ—è¡¨
   */
  public async getHistoryBySite(siteId: string, limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50 : new Error(String(limit: number = 50 instanceof Error ? limit: number = 50 : new Error(String(limit: number = 50))))))): Promise<History[]> {
    try {
      const conditions: QueryCondition[] = [{
        column: HISTORY_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }];
      
      const sortOptions = [{
        column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const historyRecords = await this.sqliteHelper.query(
        HISTORY_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions,
        limit
      );
      
      const histories = this.convertToHistoryObjects(historyRecords);
      Logger.info(TAG, `Retrieved ${histories.length} history items for site ${siteId}`);
      return histories;
    } catch (error) {
      Logger.error(TAG, `Failed to get history by site: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * è·å–å•æ¡å†å²è®°å½•
   * @param historyId å†å²è®°å½•ID
   * @returns å†å²è®°å½•æˆ–null
   */
  public async getHistoryById(historyId: string): Promise<History | null> {
    try {
      // å°è¯•ä»ç¼“å­˜è·å?      const cachedHistory = await this.getCachedHistoryItem(historyId);
      if (cachedHistory) {
        Logger.debug(TAG, `Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache` instanceof Error ? `Returning history ${historyId} from cache` : new Error(String(`Returning history ${historyId} from cache`)))))));
        return cachedHistory;
      }
      
      // æŸ¥è¯¢æ•°æ®åº?      const conditions: QueryCondition[] = [{
        column: HISTORY_TABLE.COLUMNS.ID,
        value: historyId
      }];
      
      const historyRecord = await this.sqliteHelper.getFirst(
        HISTORY_TABLE.TABLE_NAME,
        ['*'],
        conditions
      );
      
      if (!historyRecord) {
        return null;
      }
      
      // è½¬æ¢ä¸ºHistoryå¯¹è±¡
      const history = this.convertToHistoryObject(historyRecord);
      
      // æ›´æ–°ç¼“å­˜
      await this.cacheHistoryItem(history);
      
      return history;
    } catch (error) {
      Logger.error(TAG, `Failed to get history by ID: ${JSON.stringify(error)}`);
      return null;
    }
  }
  
  /**
   * æ ¹æ®å†…å®¹IDè·å–å†å²è®°å½•
   * @param contentType å†…å®¹ç±»å‹
   * @param contentId å†…å®¹ID
   * @param episodeId é›†æ•°IDï¼ˆå¯é€‰ï¼‰
   * @returns å†å²è®°å½•æˆ–null
   */
  public async getHistoryByContent(contentType: ContentType, contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string instanceof Error ? contentId: string, episodeId?: string : new Error(String(contentId: string, episodeId?: string))))))): Promise<History | null> {
    try {
      const conditions: QueryCondition[] = [{
        column: HISTORY_TABLE.COLUMNS.CONTENT_TYPE,
        value: contentType
      }, {
        column: HISTORY_TABLE.COLUMNS.CONTENT_ID,
        value: contentId
      }];
      
      if (episodeId && contentType === ContentType.EPISODE) {
        conditions.push({
          column: HISTORY_TABLE.COLUMNS.EPISODE_ID,
          value: episodeId
        });
      }
      
      const historyRecord = await this.sqliteHelper.getFirst(
        HISTORY_TABLE.TABLE_NAME,
        ['*'],
        conditions
      );
      
      if (!historyRecord) {
        return null;
      }
      
      return this.convertToHistoryObject(historyRecord);
    } catch (error) {
      Logger.error(TAG, `Failed to get history by content: ${JSON.stringify(error)}`);
      return null;
    }
  }
  
  /**
   * åˆ é™¤å†å²è®°å½•
   * @param historyId å†å²è®°å½•ID
   * @returns æ˜¯å¦åˆ é™¤æˆåŠŸ
   */
  public async deleteHistory(historyId: string): Promise<boolean> {
    try {
      Logger.debug(TAG, `Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}` instanceof Error ? `Deleting history with ID: ${historyId}` : new Error(String(`Deleting history with ID: ${historyId}`)))))));
      
      const conditions: QueryCondition[] = [{
        column: HISTORY_TABLE.COLUMNS.ID,
        value: historyId
      }];
      
      const result = await this.sqliteHelper.delete(HISTORY_TABLE.TABLE_NAME, conditions);
      
      if (result.success) {
        // æ¸…é™¤ç¼“å­˜
        await this.removeCachedHistoryItem(historyId);
        await this.invalidateHistoryListCache();
        Logger.info(TAG, `History ${historyId} deleted successfully`);
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to delete history: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * æ‰¹é‡åˆ é™¤å†å²è®°å½•
   * @param historyIds å†å²è®°å½•IDåˆ—è¡¨
   * @returns åˆ é™¤æˆåŠŸçš„æ•°é‡?   */
  public async deleteHistories(historyIds: string[]): Promise<number> {
    if (!historyIds || historyIds.length === 0) {
      return 0;
    }
    
    try {
      Logger.debug(TAG, `Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items` instanceof Error ? `Deleting ${historyIds.length} history items` : new Error(String(`Deleting ${historyIds.length} history items`)))))));
      
      const conditions: QueryCondition[] = [{
        column: HISTORY_TABLE.COLUMNS.ID,
        operator: 'IN',
        value: historyIds
      }];
      
      const result = await this.sqliteHelper.delete(HISTORY_TABLE.TABLE_NAME, conditions);
      
      if (result.success) {
        // æ¸…é™¤ç¼“å­˜
        for (const id of historyIds) {
          await this.removeCachedHistoryItem(id);
        }
        await this.invalidateHistoryListCache();
        Logger.info(TAG, `Deleted ${result.affectedRows} history items`);
      }
      
      return result.affectedRows || 0;
    } catch (error) {
      Logger.error(TAG, `Failed to batch delete histories: ${JSON.stringify(error)}`);
      return 0;
    }
  }
  
  /**
   * æ¸…ç©ºæ‰€æœ‰å†å²è®°å½?   * @returns æ˜¯å¦æ¸…ç©ºæˆåŠŸ
   */
  public async clearAllHistory(): Promise<boolean> {
    try {
      Logger.warning(TAG, 'Clearing all history records' instanceof Error ? 'Clearing all history records' : new Error(String('Clearing all history records' instanceof Error ? 'Clearing all history records' instanceof Error ? 'Clearing all history records' : new Error(String('Clearing all history records' : new Error(String('Clearing all history records' instanceof Error ? 'Clearing all history records' : new Error(String('Clearing all history records' instanceof Error ? 'Clearing all history records' instanceof Error ? 'Clearing all history records' : new Error(String('Clearing all history records' instanceof Error ? 'Clearing all history records' instanceof Error ? 'Clearing all history records' : new Error(String('Clearing all history records' : new Error(String('Clearing all history records' instanceof Error ? 'Clearing all history records' : new Error(String('Clearing all history records' : new Error(String('Clearing all history records' instanceof Error ? 'Clearing all history records' : new Error(String('Clearing all history records' instanceof Error ? 'Clearing all history records' instanceof Error ? 'Clearing all history records' : new Error(String('Clearing all history records' : new Error(String('Clearing all history records' instanceof Error ? 'Clearing all history records' : new Error(String('Clearing all history records')))))));
      
      const result = await this.sqliteHelper.delete(HISTORY_TABLE.TABLE_NAME);
      
      if (result.success) {
        // æ¸…é™¤æ‰€æœ‰ç¼“å­?        await this.clearHistoryCache();
        Logger.info(TAG, `All history cleared, deleted ${result.affectedRows} records`);
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to clear all history: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * æ¸…ç©ºæŒ‡å®šç±»å‹çš„å†å²è®°å½?   * @param contentType å†…å®¹ç±»å‹
   * @returns åˆ é™¤æˆåŠŸçš„æ•°é‡?   */
  public async clearHistoryByType(contentType: ContentType): Promise<number> {
    try {
      Logger.debug(TAG, `Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}` instanceof Error ? `Clearing history for type: ${contentType}` : new Error(String(`Clearing history for type: ${contentType}`)))))));
      
      const conditions: QueryCondition[] = [{
        column: HISTORY_TABLE.COLUMNS.CONTENT_TYPE,
        value: contentType
      }];
      
      const result = await this.sqliteHelper.delete(HISTORY_TABLE.TABLE_NAME, conditions);
      
      if (result.success) {
        await this.invalidateHistoryListCache();
        Logger.info(TAG, `Cleared ${result.affectedRows} history items for type ${contentType}`);
      }
      
      return result.affectedRows || 0;
    } catch (error) {
      Logger.error(TAG, `Failed to clear history by type: ${JSON.stringify(error)}`);
      return 0;
    }
  }
  
  /**
   * è·å–å†å²è®°å½•æ€»æ•°
   * @returns å†å²è®°å½•æ€»æ•°
   */
  public async getHistoryCount(): Promise<number> {
    try {
      return await this.sqliteHelper.count(HISTORY_TABLE.TABLE_NAME);
    } catch (error) {
      Logger.error(TAG, `Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error instanceof Error ? `Failed to get history count: ${JSON.stringify(error : new Error(String(`Failed to get history count: ${JSON.stringify(error)))))))}`);
      return 0;
    }
  }
  
  /**
   * æŒ‰å†…å®¹ç±»å‹è·å–å†å²è®°å½•æ€»æ•°
   * @param contentType å†…å®¹ç±»å‹
   * @returns å†å²è®°å½•æ€»æ•°
   */
  public async getHistoryCountByType(contentType: ContentType): Promise<number> {
    try {
      const conditions: QueryCondition[] = [{
        column: HISTORY_TABLE.COLUMNS.CONTENT_TYPE,
        value: contentType
      }];
      
      return await this.sqliteHelper.count(HISTORY_TABLE.TABLE_NAME, conditions);
    } catch (error) {
      Logger.error(TAG, `Failed to get history count by type: ${JSON.stringify(error)}`);
      return 0;
    }
  }
  
  /**
   * æ›´æ–°æ’­æ”¾è¿›åº¦
   * @param historyId å†å²è®°å½•ID
   * @param playPosition æ’­æ”¾ä½ç½®ï¼ˆæ¯«ç§’ï¼‰
   * @param totalDuration æ€»æ—¶é•¿ï¼ˆæ¯«ç§’ï¼?   * @returns æ˜¯å¦æ›´æ–°æˆåŠŸ
   */
  public async updatePlayProgress(historyId: string, playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number instanceof Error ? playPosition: number, totalDuration: number : new Error(String(playPosition: number, totalDuration: number))))))): Promise<boolean> {
    try {
      const progress = totalDuration > 0 ? (playPosition / totalDuration) * 100 : 0;
      
      const data: Record<string, string | number | boolean | null> = { ... };
      
      const conditions: QueryCondition[] = [{
        column: HISTORY_TABLE.COLUMNS.ID,
        value: historyId
      }];
      
      const result = await this.sqliteHelper.update(HISTORY_TABLE.TABLE_NAME, data, conditions);
      
      if (result.success) {
        // æ¸…é™¤ç¼“å­˜
        await this.removeCachedHistoryItem(historyId);
        await this.invalidateHistoryListCache();
        Logger.info(TAG, `Updated play progress for history ${historyId}`);
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to update play progress: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * è·å–æœ€è¿‘è§‚çœ‹çš„å†å²è®°å½•åˆ†ç»„
   * @param limit æ¯ä¸ªç±»å‹çš„é™åˆ¶æ•°é‡?   * @returns åˆ†ç»„åçš„å†å²è®°å½•
   */
  public async getRecentHistoryGroups(limit: number = 10): Promise<HistoryGroup[]> {
    try {
      const groups: HistoryGroup[] = [];
      
      // æŒ‰å†…å®¹ç±»å‹åˆ†ç»„è·å?      const contentTypes = [ContentType.MOVIE, ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes instanceof Error ? ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes : new Error(String(ContentType.SERIES, ContentType.LIVE, ContentType.EPISODE];
      
      for (const type of contentTypes))))))) {
        const histories = await this.getHistoryByContentType(type, limit);
        if (histories.length > 0) {
          groups.push({
            type,
            title: this.getContentTypeTitle(type),
            items: histories
          });
        }
      }
      
      Logger.info(TAG, `Retrieved ${groups.length} history groups`);
      return groups;
    } catch (error) {
      Logger.error(TAG, `Failed to get recent history groups: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * æ¸…ç†è¶…å‡ºé™åˆ¶çš„æ—§å†å²è®°å½•
   */
  private async cleanupOldHistory(): Promise<void> {
    try {
      const totalCount = await this.getHistoryCount();
      
      if (totalCount > MAX_HISTORY_ITEMS) {
        const excessCount = totalCount - MAX_HISTORY_ITEMS;
        
        // è·å–éœ€è¦åˆ é™¤çš„æ—§è®°å½•ID
        const oldestRecords = await this.sqliteHelper.query(
          HISTORY_TABLE.TABLE_NAME, [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         instanceof Error ? [HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
         : new Error(String([HISTORY_TABLE.COLUMNS.ID],
          undefined,
          [{
            column: HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
            order: 'ASC'
          }],
          excessCount
        )))))));
        
        const oldestIds = oldestRecords.map(record => record[HISTORY_TABLE.COLUMNS.ID].toString());
        
        if (oldestIds.length > 0) {
          await this.deleteHistories(oldestIds);
          Logger.info(TAG, `Cleaned up ${oldestIds.length} old history records`);
        }
      }
    } catch (error) {
      Logger.error(TAG, `Failed to cleanup old history: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * ç¼“å­˜å†å²è®°å½•é¡?   */
  private async cacheHistoryItem(history: History): Promise<void> {
    try {
      await this.storageUtil.setObject(`${HISTORY_CACHE_PREFIX}${history.id}`, history instanceof Error ? history : new Error(String(history instanceof Error ? history instanceof Error ? history : new Error(String(history : new Error(String(history instanceof Error ? history : new Error(String(history instanceof Error ? history instanceof Error ? history : new Error(String(history instanceof Error ? history instanceof Error ? history : new Error(String(history : new Error(String(history instanceof Error ? history : new Error(String(history : new Error(String(history instanceof Error ? history : new Error(String(history instanceof Error ? history instanceof Error ? history : new Error(String(history : new Error(String(history instanceof Error ? history : new Error(String(history)))))));
    } catch (error) {
      Logger.warn(TAG, `Failed to cache history item: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * è·å–ç¼“å­˜çš„å†å²è®°å½•é¡¹
   */
  private async getCachedHistoryItem(historyId: string): Promise<History | null> {
    try {
      return await this.storageUtil.getObject<History>(`${HISTORY_CACHE_PREFIX}${historyId}`);
    } catch (error) {
      return null;
    }
  }
  
  /**
   * ç§»é™¤ç¼“å­˜çš„å†å²è®°å½•é¡¹
   */
  private async removeCachedHistoryItem(historyId: string): Promise<void> {
    try {
      await this.storageUtil.remove(`${HISTORY_CACHE_PREFIX}${historyId}`);
    } catch (error) {
      Logger.warn(TAG, `Failed to remove cached history item: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * ä½¿å†å²è®°å½•åˆ—è¡¨ç¼“å­˜å¤±æ•?   */
  private async invalidateHistoryListCache(): Promise<void> {
    try {
      await this.storageUtil.remove(HISTORY_LIST_CACHE);
    } catch (error) {
      Logger.warn(TAG, `Failed to invalidate history list cache: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * æ¸…é™¤æ‰€æœ‰å†å²è®°å½•ç¼“å­?   */
  private async clearHistoryCache(): Promise<void> {
    try {
      // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦æ›´å¤æ‚çš„ç¼“å­˜æ¸…ç†é€»è¾‘
      await this.storageUtil.remove(HISTORY_LIST_CACHE);
    } catch (error) {
      Logger.warn(TAG, `Failed to clear history cache: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * è·å–å†…å®¹ç±»å‹çš„æ ‡é¢?   */
  private getContentTypeTitle(contentType: ContentType): string {
    const titles: Record<string, string | number | boolean | null> = { ... };
    return titles[contentType] || 'å…¶ä»–';
  }
  
  /**
   * å°†æ•°æ®åº“è®°å½•è½¬æ¢ä¸ºHistoryå¯¹è±¡
   */
  private convertToHistoryObject(record: Record<string, string | number | boolean | null>): History {
    return {
      id: record[HISTORY_TABLE.COLUMNS.ID]?.toString(),
      title: record[HISTORY_TABLE.COLUMNS.TITLE],
      subtitle: record[HISTORY_TABLE.COLUMNS.SUBTITLE],
      coverUrl: record[HISTORY_TABLE.COLUMNS.COVER_URL],
      contentType: record[HISTORY_TABLE.COLUMNS.CONTENT_TYPE],
      historyType: record[HISTORY_TABLE.COLUMNS.HISTORY_TYPE],
      siteId: record[HISTORY_TABLE.COLUMNS.SITE_ID],
      contentId: record[HISTORY_TABLE.COLUMNS.CONTENT_ID],
      episodeId: record[HISTORY_TABLE.COLUMNS.EPISODE_ID],
      playUrl: record[HISTORY_TABLE.COLUMNS.PLAY_URL],
      playPosition: record[HISTORY_TABLE.COLUMNS.PLAY_POSITION],
      totalDuration: record[HISTORY_TABLE.COLUMNS.TOTAL_DURATION],
      progress: record[HISTORY_TABLE.COLUMNS.PROGRESS],
      lastPlayTime: record[HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME],
      createTime: record[HISTORY_TABLE.COLUMNS.CREATE_TIME],
      extraData: record[HISTORY_TABLE.COLUMNS.EXTRA_DATA] ? JSON.parse(record[HISTORY_TABLE.COLUMNS.EXTRA_DATA]) : {}
    };
  }
  
  /**
   * å°†æ•°æ®åº“è®°å½•åˆ—è¡¨è½¬æ¢ä¸ºHistoryå¯¹è±¡åˆ—è¡¨
   */
  private convertToHistoryObjects(records: Record<string, string | number | boolean | null>[]): History[] {
    return records.map(record => this.convertToHistoryObject(record));
  }
}


