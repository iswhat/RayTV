// SearchHistoryRepository - æœç´¢å†å²ä»“åº“ç±?// è´Ÿè´£ç®¡ç†ç”¨æˆ·çš„æœç´¢å†å²æ•°æ®ï¼ŒåŒ…æ‹¬ä¿å­˜ã€è·å–ã€åˆ é™¤æœç´¢è®°å½•ç­‰

import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import EventBusUtil from '../../common/util/EventBusUtil';
import { LocalStorageType } from '../model/LocalModel';

/**
 * æœç´¢è®°å½•ç±»å‹æšä¸¾
 */
export enum SearchType {
  VIDEO = 'video',
  LIVE = 'live',
  USER = 'user',
  CATEGORY = 'category',
  TAG = 'tag',
  ALL = 'all'
}

/**
 * æœç´¢å†å²è®°å½•æ¥å£
 */
export interface SearchHistoryItem {
  id: string; // å”¯ä¸€æ ‡è¯†ç¬?  query: string; // æœç´¢å…³é”®è¯?  type: SearchType; // æœç´¢ç±»å‹
  timestamp: number; // æœç´¢æ—¶é—´æˆ?  resultCount?: number; // æœç´¢ç»“æœæ•°é‡
  selected?: boolean; // æ˜¯å¦è¢«é€‰ä¸­
  isFavorite?: boolean; // æ˜¯å¦ä¸ºæ”¶è—çš„æœç´¢è¯?  category?: string; // æœç´¢åˆ†ç±»ï¼ˆå¯é€‰ï¼‰
}

/**
 * æœç´¢å†å²é…ç½®æ¥å£
 */
export interface SearchHistoryConfig {
  maxHistoryItems: number; // æœ€å¤§å†å²è®°å½•æ•°é‡?  maxFavoriteItems: number; // æœ€å¤§æ”¶è—æœç´¢è¯æ•°é‡
  autoClearDays?: number; // è‡ªåŠ¨æ¸…é™¤å¤©æ•°ï¼ˆå¯é€‰ï¼‰
  enableAutoComplete: boolean; // æ˜¯å¦å¯ç”¨è‡ªåŠ¨å®Œæˆ
  enableRecentSearches: boolean; // æ˜¯å¦å¯ç”¨æœ€è¿‘æœç´?  enableFavorites: boolean; // æ˜¯å¦å¯ç”¨æ”¶è—åŠŸèƒ½
}

/**
 * æœç´¢å†å²äº‹ä»¶ç±»å‹
 */
export const SearchHistoryEventType = {
  SEARCH_HISTORY_ADDED: 'searchHistory:added',
  SEARCH_HISTORY_DELETED: 'searchHistory:deleted',
  SEARCH_HISTORY_CLEARED: 'searchHistory:cleared',
  SEARCH_HISTORY_UPDATED: 'searchHistory:updated',
  SEARCH_FAVORITE_TOGGLED: 'searchHistory:favoriteToggled',
  SEARCH_HISTORY_CONFIG_CHANGED: 'searchHistory:configChanged'
} as const;

/**
 * æœç´¢å†å²äº‹ä»¶æ•°æ®
 */
export interface SearchHistoryEvent {
  type: string;
  timestamp: number;
  data?: Record<string, string | number | boolean | null>;
  error?: Error;
}

/**
 * æœç´¢å†å²ä»“åº“ç±? */
export class SearchHistoryRepository {
  private static instance: SearchHistoryRepository;
  private logger = Logger.getInstance();
  private storageUtil = StorageUtil.getInstance();
  private eventBus = EventBusUtil.getInstance();
  
  // å­˜å‚¨é”®é…ç½?  private storageKeys = {
    searchHistory: 'search:history',
    favoriteSearches: 'search:favorites',
    searchHistoryConfig: 'search:history:config',
    recentSearches: 'search:recent'
  };
  
  // é»˜è®¤é…ç½®
  private defaultConfig: SearchHistoryConfig = {
    maxHistoryItems: 100,
    maxFavoriteItems: 20,
    autoClearDays: 30,
    enableAutoComplete: true,
    enableRecentSearches: true,
    enableFavorites: true
  };
  
  // ç¼“å­˜çš„é…ç½?  private cachedConfig: SearchHistoryConfig | null = null;
  
  // ç¼“å­˜çš„å†å²è®°å½?  private cachedHistory: SearchHistoryItem[] | null = null;
  
  // ç¼“å­˜çš„æ”¶è—æœç´?  private cachedFavorites: SearchHistoryItem[] | null = null;

  /**
   * ç§æœ‰æ„é€ å‡½æ•?   */
  private constructor() {
    this.logger.info('SearchHistoryRepository initialized');
    this.setupEventListeners();
    this.initialize();
  }

  /**
   * è·å–SearchHistoryRepositoryå•ä¾‹å®ä¾‹
   */
  public static getInstance(): SearchHistoryRepository {
    if (!SearchHistoryRepository.instance) {
      SearchHistoryRepository.instance = new SearchHistoryRepository();
    }
    return SearchHistoryRepository.instance;
  }

  /**
   * åˆå§‹åŒ–æœç´¢å†å²ä»“åº?   */
  public async initialize(): Promise<void> {
    try {
      // åŠ è½½é…ç½®
      await this.loadConfig();
      
      // åˆå§‹åŒ–ç¼“å­?      await this.loadHistory();
      await this.loadFavorites();
      
      // æ£€æŸ¥å¹¶æ¸…ç†è¿‡æœŸå†å²è®°å½•
      await this.cleanupExpiredHistory();
      
      this.logger.info('SearchHistoryRepository initialization completed');
    } catch (error) {
      this.Logger.error('Failed to initialize SearchHistoryRepository', error as Error);
    }
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬å™?   */
  private setupEventListeners(): void {
    // ç›‘å¬ç”¨æˆ·ç™»å½•/ç™»å‡ºäº‹ä»¶
    this.eventBus.on('user:logout', async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ())))))) => {
      // ç™»å‡ºæ—¶æ¸…é™¤ç”¨æˆ·ç›¸å…³çš„æœç´¢å†å²ï¼ˆå¦‚æœé…ç½®å…è®¸ï¼‰
      if (this.cachedConfig?.enableRecentSearches) {
        await this.clearRecentSearches();
      }
    });
    
    // ç›‘å¬åº”ç”¨é€€å‡ºäº‹ä»?    this.eventBus.on('app:exit', async () => {
      // åº”ç”¨é€€å‡ºæ—¶ä¿å­˜æ•°æ®
      await this.saveData();
    });
  }

  /**
   * ä¿å­˜æœç´¢è®°å½•
   * @param query æœç´¢å…³é”®è¯?   * @param type æœç´¢ç±»å‹
   * @param resultCount æœç´¢ç»“æœæ•°é‡
   * @param category æœç´¢åˆ†ç±»
   */
  public async saveSearch(
    query: string, 
    type: SearchType = SearchType.ALL, 
    resultCount?: number,
    category?: string
  ): Promise<SearchHistoryItem> {
    try {
      // éªŒè¯è¾“å…¥
      if (!query || query.trim().length === 0) {
        throw new Error('Search query cannot be empty');
      }
      
      // å»é™¤å¤šä½™ç©ºæ ¼å¹¶è½¬å°å†™
      const trimmedQuery = query.trim().toLowerCase();
      
      // æ£€æŸ¥å…³é”®è¯é•¿åº¦
      if (trimmedQuery.length > 100) {
        throw new Error('Search query too long (maximum 100 characters)');
      }
      
      // åŠ è½½é…ç½®
      const config = await this.getConfig();
      
      // æ£€æŸ¥æ˜¯å¦å¯ç”¨æœç´¢å†å?      if (!config.enableRecentSearches) {
        return {
          id: this.generateId(),
          query: trimmedQuery,
          type,
          timestamp: Date.now(),
          resultCount,
          category
        };
      }
      
      // åŠ è½½ç°æœ‰å†å²è®°å½•
      let history = await this.getHistory();
      
      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçš„æœç´¢è®°å½?      const existingIndex = history.findIndex(
        item => item.query === trimmedQuery && item.type === type
      );
      
      const newItem: SearchHistoryItem = {
        id: this.generateId(),
        query: trimmedQuery,
        type,
        timestamp: Date.now(),
        resultCount,
        category,
        isFavorite: false
      };
      
      if (existingIndex >= 0) {
        // æ›´æ–°ç°æœ‰è®°å½•
        const existingItem = history[existingIndex];
        newItem.isFavorite = existingItem.isFavorite;
        history.splice(existingIndex, 1);
      }
      
      // æ·»åŠ åˆ°å†å²è®°å½•å¼€å¤?      history.unshift(newItem);
      
      // é™åˆ¶å†å²è®°å½•æ•°é‡
      if (history.length > config.maxHistoryItems) {
        history = history.slice(0, config.maxHistoryItems);
      }
      
      // ä¿å­˜æ›´æ–°åçš„å†å²è®°å½•
      this.cachedHistory = history;
      await this.storageUtil.setObject(
        this.storageKeys.searchHistory,
        history,
        LocalStorageType.DEFAULT
      );
      
      // å‘å¸ƒæœç´¢å†å²æ·»åŠ äº‹ä»¶
      this.eventBus.emit(SearchHistoryEventType.SEARCH_HISTORY_ADDED, {
        type: SearchHistoryEventType.SEARCH_HISTORY_ADDED,
        timestamp: Date.now(),
        data: newItem
      } as SearchHistoryEvent);
      
      this.logger.debug(`Search history saved: "${trimmedQuery}" (type: ${type})`);
      
      return newItem;
    } catch (error) {
      this.Logger.error('Failed to save search history', error as Error);
      throw error;
    }
  }

  /**
   * è·å–æœç´¢å†å²è®°å½•
   * @param type å¯é€‰çš„æœç´¢ç±»å‹è¿‡æ»¤
   * @param limit å¯é€‰çš„è¿”å›æ•°é‡é™åˆ¶
   */
  public async getHistory(type?: SearchType, limit?: number instanceof Error ? limit?: number : new Error(String(limit?: number instanceof Error ? limit?: number instanceof Error ? limit?: number : new Error(String(limit?: number : new Error(String(limit?: number instanceof Error ? limit?: number : new Error(String(limit?: number instanceof Error ? limit?: number instanceof Error ? limit?: number : new Error(String(limit?: number instanceof Error ? limit?: number instanceof Error ? limit?: number : new Error(String(limit?: number : new Error(String(limit?: number instanceof Error ? limit?: number : new Error(String(limit?: number : new Error(String(limit?: number instanceof Error ? limit?: number : new Error(String(limit?: number instanceof Error ? limit?: number instanceof Error ? limit?: number : new Error(String(limit?: number : new Error(String(limit?: number instanceof Error ? limit?: number : new Error(String(limit?: number))))))): Promise<SearchHistoryItem[]> {
    try {
      // å¦‚æœç¼“å­˜ä¸ºç©ºï¼ŒåŠ è½½æ•°æ?      if (!this.cachedHistory) {
        await this.loadHistory();
      }
      
      let history = [...this.cachedHistory!];
      
      // æŒ‰ç±»å‹è¿‡æ»?      if (type && type !== SearchType.ALL) {
        history = history.filter(item => item.type === type);
      }
      
      // é™åˆ¶è¿”å›æ•°é‡
      if (limit && limit > 0) {
        history = history.slice(0, limit);
      }
      
      return history;
    } catch (error) {
      this.Logger.error('Failed to get search history', error as Error);
      return [];
    }
  }

  /**
   * è·å–æœ€è¿‘çš„æœç´¢è®°å½•
   * @param count è¿”å›æ•°é‡
   */
  public async getRecentSearches(count: number = 10): Promise<SearchHistoryItem[]> {
    try {
      return await this.getHistory(SearchType.ALL, Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50 instanceof Error ? Math.max(1, Math.min(count, 50 : new Error(String(Math.max(1, Math.min(count, 50)))))))));
    } catch (error) {
      this.logger.warn('Failed to get recent searches', error as Error);
      return [];
    }
  }

  /**
   * åˆ é™¤æœç´¢å†å²è®°å½•
   * @param id æœç´¢è®°å½•ID
   */
  public async deleteSearchHistory(id: string): Promise<boolean> {
    try {
      // åŠ è½½å†å²è®°å½•
      let history = await this.getHistory();
      
      // æŸ¥æ‰¾å¹¶åˆ é™¤è®°å½?      const initialLength = history.length;
      history = history.filter(item => item.id !== id);
      
      // æ£€æŸ¥æ˜¯å¦åˆ é™¤äº†è®°å½•
      if (history.length === initialLength) {
        this.logger.debug(`Search history item with ID ${id} not found`);
        return false;
      }
      
      // ä¿å­˜æ›´æ–°åçš„å†å²è®°å½•
      this.cachedHistory = history;
      await this.storageUtil.setObject(
        this.storageKeys.searchHistory,
        history,
        LocalStorageType.DEFAULT
      );
      
      // å‘å¸ƒæœç´¢å†å²åˆ é™¤äº‹ä»¶
      this.eventBus.emit(SearchHistoryEventType.SEARCH_HISTORY_DELETED, {
        type: SearchHistoryEventType.SEARCH_HISTORY_DELETED,
        timestamp: Date.now(),
        data: { id }
      } as SearchHistoryEvent);
      
      this.logger.debug(`Search history item deleted: ${id}`);
      
      return true;
    } catch (error) {
      this.Logger.error(`Failed to delete search history item ${id}`, error as Error);
      return false;
    }
  }

  /**
   * æ¸…é™¤æ‰€æœ‰æœç´¢å†å?   * @param type å¯é€‰çš„æœç´¢ç±»å‹è¿‡æ»¤
   */
  public async clearSearchHistory(type?: SearchType): Promise<boolean> {
    try {
      let history: SearchHistoryItem[] = [];
      
      // å¦‚æœæŒ‡å®šäº†ç±»å‹ï¼Œåªæ¸…é™¤è¯¥ç±»å‹çš„è®°å½?      if (type && type !== SearchType.ALL) {
        const allHistory = await this.getHistory();
        history = allHistory.filter(item => item.type !== type && item.isFavorite);
      }
      
      // ä¿å­˜æ›´æ–°åçš„å†å²è®°å½•
      this.cachedHistory = history;
      await this.storageUtil.setObject(
        this.storageKeys.searchHistory, history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
       instanceof Error ? history,
        LocalStorageType.DEFAULT
       : new Error(String(history,
        LocalStorageType.DEFAULT
      )))))));
      
      // æ¸…é™¤æœ€è¿‘æœç´¢ç¼“å­?      await this.clearRecentSearches();
      
      // å‘å¸ƒæœç´¢å†å²æ¸…é™¤äº‹ä»¶
      this.eventBus.emit(SearchHistoryEventType.SEARCH_HISTORY_CLEARED, {
        type: SearchHistoryEventType.SEARCH_HISTORY_CLEARED,
        timestamp: Date.now(),
        data: { type }
      } as SearchHistoryEvent);
      
      this.logger.info(`Search history cleared${type ? ` for type: ${type}` : ''}`);
      
      return true;
    } catch (error) {
      this.Logger.error('Failed to clear search history', error as Error);
      return false;
    }
  }

  /**
   * æ¸…é™¤æœ€è¿‘æœç´¢è®°å½?   */
  private async clearRecentSearches(): Promise<void> {
    try {
      await this.storageUtil.remove(this.storageKeys.recentSearches, LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT)))))));
    } catch (error) {
      this.logger.warn('Failed to clear recent searches', error as Error);
    }
  }

  /**
   * åˆ‡æ¢æœç´¢æ”¶è—çŠ¶æ€?   * @param id æœç´¢è®°å½•ID
   */
  public async toggleFavorite(id: string): Promise<SearchHistoryItem | null> {
    try {
      // åŠ è½½é…ç½®
      const config = await this.getConfig();
      
      // æ£€æŸ¥æ˜¯å¦å¯ç”¨æ”¶è—åŠŸèƒ?      if (!config.enableFavorites) {
        throw new Error('Favorites feature is disabled');
      }
      
      // åŠ è½½å†å²è®°å½•å’Œæ”¶è—?      let history = await this.getHistory();
      let favorites = await this.getFavorites();
      
      // æŸ¥æ‰¾æœç´¢è®°å½•
      const itemIndex = history.findIndex(item => item.id === id);
      if (itemIndex === -1) {
        throw new Error('Search history item not found');
      }
      
      const item: Record<string, string | number | boolean | null> = { ... };
      const isCurrentlyFavorite = item.isFavorite || false;
      
      if (isCurrentlyFavorite) {
        // å–æ¶ˆæ”¶è—
        item.isFavorite = false;
        favorites = favorites.filter(fav => fav.id !== id);
      } else {
        // æ·»åŠ æ”¶è—
        // æ£€æŸ¥æ”¶è—æ•°é‡é™åˆ?        if (favorites.length >= config.maxFavoriteItems) {
          throw new Error(`Maximum number of favorite searches (${config.maxFavoriteItems}) reached`);
        }
        
        item.isFavorite = true;
        favorites.push(item);
      }
      
      // æ›´æ–°å†å²è®°å½•
      history[itemIndex] = item;
      
      // ä¿å­˜æ›´æ–°åçš„æ•°æ®
      this.cachedHistory = history;
      this.cachedFavorites = favorites;
      
      await this.storageUtil.setObject(
        this.storageKeys.searchHistory,
        history,
        LocalStorageType.DEFAULT
      );
      
      await this.storageUtil.setObject(
        this.storageKeys.favoriteSearches,
        favorites,
        LocalStorageType.DEFAULT
      );
      
      // å‘å¸ƒæ”¶è—çŠ¶æ€å˜æ›´äº‹ä»?      this.eventBus.emit(SearchHistoryEventType.SEARCH_FAVORITE_TOGGLED, {
        type: SearchHistoryEventType.SEARCH_FAVORITE_TOGGLED,
        timestamp: Date.now(),
        data: {
          item,
          isFavorite: item.isFavorite
        }
      } as SearchHistoryEvent);
      
      this.logger.debug(`Search favorite toggled: ${id}, favorite: ${item.isFavorite}`);
      
      return item;
    } catch (error) {
      this.Logger.error(`Failed to toggle favorite for search history item ${id}`, error as Error);
      throw error;
    }
  }

  /**
   * è·å–æ”¶è—çš„æœç´¢è®°å½?   */
  public async getFavorites(): Promise<SearchHistoryItem[]> {
    try {
      // å¦‚æœç¼“å­˜ä¸ºç©ºï¼ŒåŠ è½½æ•°æ?      if (!this.cachedFavorites) {
        await this.loadFavorites();
      }
      
      return [...this.cachedFavorites!];
    } catch (error) {
      this.logger.error('Failed to get favorite searches', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
      return [];
    }
  }

  /**
   * æ¸…é™¤æ‰€æœ‰æ”¶è—?   */
  public async clearFavorites(): Promise<boolean> {
    try {
      // åŠ è½½å†å²è®°å½•
      const history = await this.getHistory();
      
      // ç§»é™¤æ‰€æœ‰æ”¶è—æ ‡è®?      const updatedHistory = history.map(item => ({
        ...item,
        isFavorite: false
      }));
      
      // ä¿å­˜æ›´æ–°åçš„å†å²è®°å½•
      this.cachedHistory = updatedHistory;
      this.cachedFavorites = [];
      
      await this.storageUtil.setObject(
        this.storageKeys.searchHistory,
        updatedHistory,
        LocalStorageType.DEFAULT
      );
      
      await this.storageUtil.setObject(
        this.storageKeys.favoriteSearches,
        [],
        LocalStorageType.DEFAULT
      );
      
      this.logger.info('All favorite searches cleared');
      
      return true;
    } catch (error) {
      this.Logger.error('Failed to clear favorite searches', error as Error);
      return false;
    }
  }

  /**
   * è·å–æœç´¢å»ºè®®ï¼ˆåŸºäºå†å²è®°å½•ï¼‰
   * @param query æœç´¢å…³é”®è¯å‰ç¼€
   * @param type å¯é€‰çš„æœç´¢ç±»å‹è¿‡æ»¤
   * @param limit è¿”å›æ•°é‡é™åˆ¶
   */
  public async getSuggestions(
    query: string, type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
   instanceof Error ? type?: SearchType,
    limit: number = 10
   : new Error(String(type?: SearchType,
    limit: number = 10
  ))))))): Promise<string[]> {
    try {
      // éªŒè¯è¾“å…¥
      if (!query || query.trim().length === 0) {
        return [];
      }
      
      const trimmedQuery = query.trim().toLowerCase();
      
      // åŠ è½½é…ç½®
      const config = await this.getConfig();
      
      // æ£€æŸ¥æ˜¯å¦å¯ç”¨è‡ªåŠ¨å®Œæˆ?      if (!config.enableAutoComplete) {
        return [];
      }
      
      // è·å–å†å²è®°å½•
      const history = await this.getHistory(type);
      
      // è¿‡æ»¤åŒ¹é…çš„æœç´¢è¯
      const suggestions = history
        .filter(item => item.query.includes(trimmedQuery))
        .map(item => item.query)
        .filter((suggestion, index, self) => self.indexOf(suggestion) === index) // å»é‡
        .slice(0, Math.max(1, Math.min(limit, 50))); // é™åˆ¶æ•°é‡
      
      return suggestions;
    } catch (error) {
      this.logger.warn('Failed to get search suggestions', error as Error);
      return [];
    }
  }

  /**
   * è®¾ç½®æœç´¢å†å²é…ç½®
   * @param config é…ç½®å¯¹è±¡
   */
  public async setConfig(config: Partial<SearchHistoryConfig>): Promise<SearchHistoryConfig> {
    try {
      // è·å–å½“å‰é…ç½®
      const currentConfig = await this.getConfig();
      
      // åˆå¹¶æ–°é…ç½?      const updatedConfig: SearchHistoryConfig = {
        ...currentConfig,
        ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig);
      
      // ä¿å­˜é…ç½®
      this.cachedConfig = updatedConfig;
      await this.storageUtil.setObject(
        this.storageKeys.searchHistoryConfig,
        updatedConfig,
        LocalStorageType.DEFAULT
      );
      
      // æ ¹æ®æ–°é…ç½®æ¸…ç†æ•°æ?      await this.applyConfigChanges(currentConfig, updatedConfig);
      
      // å‘å¸ƒé…ç½®å˜æ›´äº‹ä»¶
      this.eventBus.emit(SearchHistoryEventType.SEARCH_HISTORY_CONFIG_CHANGED, {
        type: SearchHistoryEventType.SEARCH_HISTORY_CONFIG_CHANGED,
        timestamp: Date.now(),
        data: updatedConfig
      } as SearchHistoryEvent);
      
      this.logger.info('Search history configuration updated');
      
      return updatedConfig;
    } catch (error) {
      this.Logger.error('Failed to set search history config', error as Error);
      throw error;
    }
  }

  /**
   * è·å–æœç´¢å†å²é…ç½®
   */
  public async getConfig(): Promise<SearchHistoryConfig> {
    try {
      // å¦‚æœç¼“å­˜ä¸ºç©ºï¼ŒåŠ è½½é…ç½?      if (!this.cachedConfig) {
        await this.loadConfig();
      }
      
      return { ...this.cachedConfig! };
    } catch (error) {
      this.logger.error('Failed to get search history config', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
      return { ...this.defaultConfig };
    }
  }

  /**
   * é‡ç½®æœç´¢å†å²é…ç½®åˆ°é»˜è®¤å€?   */
  public async resetConfig(): Promise<SearchHistoryConfig> {
    try {
      // ä¿å­˜é»˜è®¤é…ç½®
      this.cachedConfig = { ...this.defaultConfig };
      await this.storageUtil.setObject(
        this.storageKeys.searchHistoryConfig,
        this.defaultConfig,
        LocalStorageType.DEFAULT
      );
      
      this.logger.info('Search history configuration reset to default');
      
      return { ...this.defaultConfig };
    } catch (error) {
      this.Logger.error('Failed to reset search history config', error as Error);
      throw error;
    }
  }

  /**
   * åŠ è½½å†å²è®°å½•
   */
  private async loadHistory(): Promise<void> {
    try {
      const history = await this.storageUtil.getObject<SearchHistoryItem[]>(
        this.storageKeys.searchHistory, LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
      )))))));
      
      this.cachedHistory = history || [];
      this.logger.debug(`Loaded ${this.cachedHistory.length} search history items`);
    } catch (error) {
      this.Logger.error('Failed to load search history', error as Error);
      this.cachedHistory = [];
    }
  }

  /**
   * åŠ è½½æ”¶è—æœç´¢
   */
  private async loadFavorites(): Promise<void> {
    try {
      const favorites = await this.storageUtil.getObject<SearchHistoryItem[]>(
        this.storageKeys.favoriteSearches, LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
      )))))));
      
      this.cachedFavorites = favorites || [];
      this.logger.debug(`Loaded ${this.cachedFavorites.length} favorite searches`);
    } catch (error) {
      this.Logger.error('Failed to load favorite searches', error as Error);
      this.cachedFavorites = [];
    }
  }

  /**
   * åŠ è½½é…ç½®
   */
  private async loadConfig(): Promise<void> {
    try {
      const config = await this.storageUtil.getObject<SearchHistoryConfig>(
        this.storageKeys.searchHistoryConfig, LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
      )))))));
      
      this.cachedConfig = config ? { ...this.defaultConfig, ...config } : { ...this.defaultConfig };
      
      // éªŒè¯é…ç½®
      this.validateConfig(this.cachedConfig);
      
      this.logger.debug('Search history configuration loaded');
    } catch (error) {
      this.Logger.error('Failed to load search history config', error as Error);
      this.cachedConfig = { ...this.defaultConfig };
    }
  }

  /**
   * ä¿å­˜æ‰€æœ‰æ•°æ?   */
  private async saveData(): Promise<void> {
    try {
      await Promise.all([
        this.storageUtil.setObject(
          this.storageKeys.searchHistory, this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
         instanceof Error ? this.cachedHistory || [],
          LocalStorageType.DEFAULT
         : new Error(String(this.cachedHistory || [],
          LocalStorageType.DEFAULT
        ))))))),
        this.storageUtil.setObject(
          this.storageKeys.favoriteSearches,
          this.cachedFavorites || [],
          LocalStorageType.DEFAULT
        ),
        this.storageUtil.setObject(
          this.storageKeys.searchHistoryConfig,
          this.cachedConfig || this.defaultConfig,
          LocalStorageType.DEFAULT
        )
      ]);
      
      this.logger.debug('Search history data saved');
    } catch (error) {
      this.Logger.error('Failed to save search history data', error as Error);
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸçš„å†å²è®°å½?   */
  private async cleanupExpiredHistory(): Promise<void> {
    try {
      const config = await this.getConfig();
      
      // æ£€æŸ¥æ˜¯å¦å¯ç”¨è‡ªåŠ¨æ¸…ç?      if (!config.autoClearDays || config.autoClearDays <= 0) {
        return;
      }
      
      const expirationTime = Date.now() - (config.autoClearDays * 24 * 60 * 60 * 1000);
      const history = await this.getHistory();
      
      // è¿‡æ»¤å‡ºæœªè¿‡æœŸä¸”ä¸æ˜¯æ”¶è—çš„è®°å½•
      const filteredHistory = history.filter(
        item => item.timestamp > expirationTime || item.isFavorite
      );
      
      // å¦‚æœæœ‰å˜åŒ–ï¼Œä¿å­˜æ›´æ–°åçš„å†å²è®°å½•
      if (filteredHistory.length !== history.length) {
        this.cachedHistory = filteredHistory;
        await this.storageUtil.setObject(
          this.storageKeys.searchHistory, filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
        )))))));
        
        this.logger.info(`Cleaned up ${history.length - filteredHistory.length} expired search history items`);
      }
    } catch (error) {
      this.logger.warn('Failed to cleanup expired search history', error as Error);
    }
  }

  /**
   * åº”ç”¨é…ç½®å˜æ›´
   */
  private async applyConfigChanges(
    oldConfig: SearchHistoryConfig,
    newConfig: SearchHistoryConfig
  ): Promise<void> {
    try {
      // æ£€æŸ¥å†å²è®°å½•æ•°é‡é™åˆ¶æ˜¯å¦æ”¹å?      if (oldConfig.maxHistoryItems !== newConfig.maxHistoryItems) {
        const history = await this.getHistory();
        if (history.length > newConfig.maxHistoryItems) {
          const filteredHistory = history.slice(0, newConfig.maxHistoryItems);
          this.cachedHistory = filteredHistory;
          await this.storageUtil.setObject(
            this.storageKeys.searchHistory,
            filteredHistory,
            LocalStorageType.DEFAULT
          );
        }
      }
      
      // æ£€æŸ¥æ”¶è—æ•°é‡é™åˆ¶æ˜¯å¦æ”¹å?      if (oldConfig.maxFavoriteItems !== newConfig.maxFavoriteItems) {
        const favorites = await this.getFavorites();
        if (favorites.length > newConfig.maxFavoriteItems) {
          const filteredFavorites = favorites.slice(0, newConfig.maxFavoriteItems);
          this.cachedFavorites = filteredFavorites;
          
          // æ›´æ–°å†å²è®°å½•ä¸­çš„æ”¶è—çŠ¶æ€?          const history = await this.getHistory();
          const updatedHistory = history.map(item => ({
            ...item,
            isFavorite: filteredFavorites.some(fav => fav.id === item.id)
          }));
          
          this.cachedHistory = updatedHistory;
          await this.storageUtil.setObject(
            this.storageKeys.favoriteSearches,
            filteredFavorites,
            LocalStorageType.DEFAULT
          );
          await this.storageUtil.setObject(
            this.storageKeys.searchHistory,
            updatedHistory,
            LocalStorageType.DEFAULT
          );
        }
      }
    } catch (error) {
      this.logger.warn('Failed to apply config changes', error as Error);
    }
  }

  /**
   * éªŒè¯é…ç½®
   */
  private validateConfig(config: SearchHistoryConfig): void {
    const errors: string[] = [];
    
    if (config.maxHistoryItems < 1 || config.maxHistoryItems > 1000) {
      errors.push('maxHistoryItems must be between 1 and 1000');
    }
    
    if (config.maxFavoriteItems < 1 || config.maxFavoriteItems > 100) {
      errors.push('maxFavoriteItems must be between 1 and 100');
    }
    
    if (config.autoClearDays !== undefined && (config.autoClearDays < 1 || config.autoClearDays > 365)) {
      errors.push('autoClearDays must be between 1 and 365');
    }
    
    if (errors.length > 0) {
      throw new Error(errors.join(', '));
    }
  }

  /**
   * ç”Ÿæˆå”¯ä¸€ID
   */
  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * å¯¼å‡ºæœç´¢å†å²æ•°æ®
   */
  public async exportData(): Promise<{
    history: SearchHistoryItem[];
    favorites: SearchHistoryItem[];
    config: SearchHistoryConfig;
    exportTime: number;
  }> {
    try {
      const data: Record<string, string | number | boolean | null> = { ... };
      
      this.logger.info('Search history data exported');
      
      return data;
    } catch (error) {
      this.Logger.error('Failed to export search history data', error as Error);
      throw error;
    }
  }

  /**
   * å¯¼å…¥æœç´¢å†å²æ•°æ®
   * @param data å¯¼å…¥çš„æ•°æ?   * @param merge æ˜¯å¦åˆå¹¶ï¼ˆtrueï¼‰æˆ–è¦†ç›–ï¼ˆfalseï¼?   */
  public async importData(
    data: {
      history?: SearchHistoryItem[];
      favorites?: SearchHistoryItem[];
      config?: Partial<SearchHistoryConfig>;
    }, merge: boolean = true
   instanceof Error ? merge: boolean = true
   : new Error(String(merge: boolean = true
   instanceof Error ? merge: boolean = true
   instanceof Error ? merge: boolean = true
   : new Error(String(merge: boolean = true
   : new Error(String(merge: boolean = true
   instanceof Error ? merge: boolean = true
   : new Error(String(merge: boolean = true
   instanceof Error ? merge: boolean = true
   instanceof Error ? merge: boolean = true
   : new Error(String(merge: boolean = true
   instanceof Error ? merge: boolean = true
   instanceof Error ? merge: boolean = true
   : new Error(String(merge: boolean = true
   : new Error(String(merge: boolean = true
   instanceof Error ? merge: boolean = true
   : new Error(String(merge: boolean = true
   : new Error(String(merge: boolean = true
   instanceof Error ? merge: boolean = true
   : new Error(String(merge: boolean = true
   instanceof Error ? merge: boolean = true
   instanceof Error ? merge: boolean = true
   : new Error(String(merge: boolean = true
   : new Error(String(merge: boolean = true
   instanceof Error ? merge: boolean = true
   : new Error(String(merge: boolean = true
  ))))))): Promise<void> {
    try {
      // éªŒè¯å¯¼å…¥æ•°æ®
      if (!data || (!data.history && !data.favorites && !data.config)) {
        throw new Error('No valid data to import');
      }
      
      // è·å–å½“å‰é…ç½®
      const currentConfig = await this.getConfig();
      
      // å¤„ç†é…ç½®å¯¼å…¥
      if (data.config) {
        const mergedConfig = merge ? 
          { ...currentConfig, ...data.config } : 
          { ...this.defaultConfig, ...data.config };
        
        this.validateConfig(mergedConfig);
        this.cachedConfig = mergedConfig;
        
        await this.storageUtil.setObject(
          this.storageKeys.searchHistoryConfig,
          mergedConfig,
          LocalStorageType.DEFAULT
        );
      }
      
      // å¤„ç†å†å²è®°å½•å¯¼å…¥
      if (data.history && Array.isArray(data.history)) {
        const processedHistory = data.history
          .filter(item => this.isValidHistoryItem(item))
          .map(item => this.normalizeHistoryItem(item));
        
        let finalHistory: SearchHistoryItem[];
        
        if (merge) {
          // åˆå¹¶å†å²è®°å½•
          const currentHistory = await this.getHistory();
          const historyMap = new Map<string, SearchHistoryItem>();
          
          // æ·»åŠ ç°æœ‰è®°å½•
          currentHistory.forEach(item => {
            historyMap.set(`${item.query}-${item.type}`, item);
          });
          
          // åˆå¹¶æ–°è®°å½•ï¼ˆæ–°è®°å½•ä¼˜å…ˆçº§æ›´é«˜ï¼?          processedHistory.forEach(item => {
            const key = `${item.query}-${item.type}`;
            const existingItem = historyMap.get(key);
            
            if (existingItem) {
              // ä¿ç•™æ”¶è—çŠ¶æ€?              item.isFavorite = existingItem.isFavorite;
            }
            
            historyMap.set(key, item);
          });
          
          finalHistory = Array.from(historyMap.values())
            .sort((a, b) => b.timestamp - a.timestamp);
        } else {
          // è¦†ç›–å†å²è®°å½•
          finalHistory = processedHistory
            .sort((a, b) => b.timestamp - a.timestamp);
        }
        
        // åº”ç”¨æ•°é‡é™åˆ¶
        if (finalHistory.length > currentConfig.maxHistoryItems) {
          finalHistory = finalHistory.slice(0, currentConfig.maxHistoryItems);
        }
        
        this.cachedHistory = finalHistory;
        await this.storageUtil.setObject(
          this.storageKeys.searchHistory,
          finalHistory,
          LocalStorageType.DEFAULT
        );
      }
      
      // å¤„ç†æ”¶è—å¯¼å…¥
      if (data.favorites && Array.isArray(data.favorites)) {
        const processedFavorites = data.favorites
          .filter(item => this.isValidHistoryItem(item))
          .map(item => this.normalizeHistoryItem(item))
          .map(item => ({ ...item, isFavorite: true }));
        
        let finalFavorites: SearchHistoryItem[];
        
        if (merge) {
          // åˆå¹¶æ”¶è—
          const currentFavorites = await this.getFavorites();
          const favoriteMap = new Map<string, SearchHistoryItem>();
          
          // æ·»åŠ ç°æœ‰æ”¶è—
          currentFavorites.forEach(item => {
            favoriteMap.set(`${item.query}-${item.type}`, item);
          });
          
          // åˆå¹¶æ–°æ”¶è—?          processedFavorites.forEach(item => {
            favoriteMap.set(`${item.query}-${item.type}`, item);
          });
          
          finalFavorites = Array.from(favoriteMap.values());
        } else {
          // è¦†ç›–æ”¶è—
          finalFavorites = processedFavorites;
        }
        
        // åº”ç”¨æ•°é‡é™åˆ¶
        if (finalFavorites.length > currentConfig.maxFavoriteItems) {
          finalFavorites = finalFavorites.slice(0, currentConfig.maxFavoriteItems);
        }
        
        this.cachedFavorites = finalFavorites;
        await this.storageUtil.setObject(
          this.storageKeys.favoriteSearches,
          finalFavorites,
          LocalStorageType.DEFAULT
        );
      }
      
      // æ›´æ–°å†å²è®°å½•ä¸­çš„æ”¶è—çŠ¶æ€?      if (data.favorites) {
        const history = await this.getHistory();
        const updatedHistory = history.map(item => ({
          ...item,
          isFavorite: finalFavorites?.some(fav => fav.id === item.id) || false
        }));
        
        this.cachedHistory = updatedHistory;
        await this.storageUtil.setObject(
          this.storageKeys.searchHistory,
          updatedHistory,
          LocalStorageType.DEFAULT
        );
      }
      
      this.logger.info('Search history data imported successfully');
    } catch (error) {
      this.Logger.error('Failed to import search history data', error as Error);
      throw error;
    }
  }

  /**
   * éªŒè¯å†å²è®°å½•é¡?   */
  private isValidHistoryItem(item: SearchHistoryItem): boolean {
    return !!item && 
           typeof item.id === 'string' && 
           typeof item.query === 'string' && 
           typeof item.timestamp === 'number' &&
           item.timestamp > 0 &&
           typeof item.type === 'string' &&
           (item.type === SearchType.ALL || item.type === SearchType.VIDEO || item.type === SearchType.LIVE || item.type === SearchType.USER || item.type === SearchType.CATEGORY || item.type === SearchType.TAG);
  }

  /**
   * è§„èŒƒåŒ–å†å²è®°å½•é¡¹
   */
  private normalizeHistoryItem(item: SearchHistoryItem): SearchHistoryItem {
    const normalizedType: SearchType = 
      (item.type === SearchType.ALL || item.type === SearchType.VIDEO || item.type === SearchType.LIVE || item.type === SearchType.USER || item.type === SearchType.CATEGORY || item.type === SearchType.TAG) ? 
      item.type : 
      SearchType.ALL;
    
    return {
      id: item.id || this.generateId(), query: item.query.trim( instanceof Error ? query: item.query.trim( : new Error(String(query: item.query.trim( instanceof Error ? query: item.query.trim( instanceof Error ? query: item.query.trim( : new Error(String(query: item.query.trim( : new Error(String(query: item.query.trim( instanceof Error ? query: item.query.trim( : new Error(String(query: item.query.trim( instanceof Error ? query: item.query.trim( instanceof Error ? query: item.query.trim( : new Error(String(query: item.query.trim( instanceof Error ? query: item.query.trim( instanceof Error ? query: item.query.trim( : new Error(String(query: item.query.trim( : new Error(String(query: item.query.trim( instanceof Error ? query: item.query.trim( : new Error(String(query: item.query.trim( : new Error(String(query: item.query.trim( instanceof Error ? query: item.query.trim( : new Error(String(query: item.query.trim( instanceof Error ? query: item.query.trim( instanceof Error ? query: item.query.trim( : new Error(String(query: item.query.trim( : new Error(String(query: item.query.trim( instanceof Error ? query: item.query.trim( : new Error(String(query: item.query.trim())))))),
      timestamp: item.timestamp || Date.now(),
      type: normalizedType,
      resultCount: item.resultCount || 0,
      selected: !!item.selected,
      isFavorite: !!item.isFavorite,
      category: item.category || undefined
    };
  }

  /**
   * è·å–æœç´¢ç»Ÿè®¡ä¿¡æ¯
   */
  public async getSearchStatistics(): Promise<{
    totalSearches: number;
    favoriteSearches: number;
    todaySearches: number;
    weekSearches: number;
    monthSearches: number;
    mostFrequent: Array<{query: string, count: number}>;
  }> {
    try {
      const history = await this.getHistory();
      const now = Date.now();
      const today = new Date().setHours(0, 0, 0, 0);
      const weekAgo = now - 7 * 24 * 60 * 60 * 1000;
      const monthAgo = now - 30 * 24 * 60 * 60 * 1000;

      // è®¡ç®—æœ€é¢‘ç¹çš„æœç´?      const frequencyMap = new Map<string, number>();
      history.forEach(item => {
        frequencyMap.set(item.query, (frequencyMap.get(item.query) || 0) + 1);
      });

      const mostFrequent = Array.from(frequencyMap.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([query, count]) => ({ query, count }));

      return {
        totalSearches: history.length,
        favoriteSearches: (await this.getFavorites()).length,
        todaySearches: history.filter(item => item.timestamp >= today).length,
        weekSearches: history.filter(item => item.timestamp >= weekAgo).length,
        monthSearches: history.filter(item => item.timestamp >= monthAgo).length,
        mostFrequent
      };
    } catch (error) {
      this.Logger.error('Failed to get search statistics', error as Error);
      return {
        totalSearches: 0, favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( instanceof Error ? favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance( : new Error(String(favoriteSearches: 0,
        todaySearches: 0,
        weekSearches: 0,
        monthSearches: 0,
        mostFrequent: []
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchHistoryRepository.getInstance()))))));
        



