/*
 * Copyright (c) 2024 RayTV. All rights reserved.
 * è§†é¢‘ä»“åº“ç±?- è´Ÿè´£è§†é¢‘ç›¸å…³æ•°æ®çš„è·å–å’Œç®¡ç†
 */

import Logger from '@ohos:common@ohos/common/src/main/ets/utils/Logger';
import StorageUtil from '@ohos:common@ohos/common/src/main/ets/utils/StorageUtil';
import NetworkUtil from '@ohos:common@ohos/common/src/main/ets/utils/NetworkUtil';
import CacheService from '@ohos:common@ohos/common/src/main/ets/services/CacheService';
import UserRepository from './UserRepository';
import { LocalStorageType } from '@ohos:common@ohos/common/src/main/ets/utils/StorageUtil';
import { CacheType } from '@ohos:common@ohos/common/src/main/ets/services/CacheService';

// è§†é¢‘ç±»å‹æšä¸¾
export enum VideoType {
  MOVIE = 'movie',
  TV_SERIES = 'tv_series',
  SHORT_VIDEO = 'short_video',
  LIVE = 'live',
  ANIMATION = 'animation',
  DOCUMENTARY = 'documentary'
}

// è§†é¢‘è´¨é‡æšä¸¾
export enum VideoQuality {
  SD = 'sd',
  HD = 'hd',
  FHD = 'fhd',
  UHD = 'uhd'
}

// è§†é¢‘äº‹ä»¶ç±»å‹å¸¸é‡
export class VideoEventType {
  static readonly VIDEO_LOADED = 'video:loaded';
  static readonly VIDEO_LIST_LOADED = 'video:list:loaded';
  static readonly VIDEO_ERROR = 'video:error';
  static readonly VIDEO_FAVORITED = 'video:favorited';
  static readonly VIDEO_UNFAVORITED = 'video:unfavorited';
  static readonly VIDEO_RATED = 'video:rated';
  static readonly VIDEO_COMMENT_ADDED = 'video:comment:added';
  static readonly VIDEO_PROGRESS_UPDATED = 'video:progress:updated';
  static readonly VIDEO_WATCHED = 'video:watched';
  static readonly VIDEO_CACHE_UPDATED = 'video:cache:updated';
}

// è§†é¢‘äº‹ä»¶æ¥å£
export interface VideoEvent {
  type: string;
  timestamp: number;
  videoId?: string;
  data?: Record<string, string | number | boolean | null>;
  error?: Error;
}

// æ”¶è—çŠ¶æ€å˜æ›´äº‹ä»¶æ¥å?export interface FavoriteChangeEvent extends VideoEvent {
  favorited: boolean;
  userId: string;
}

// è¿›åº¦æ›´æ–°äº‹ä»¶æ¥å£
export interface ProgressUpdateEvent extends VideoEvent {
  progress: PlaybackProgress;
}

// è§†é¢‘ä¿¡æ¯æ¥å£
export interface VideoInfo {
  id: string;
  title: string;
  description: string;
  coverUrl: string;
  duration: number;
  type: VideoType;
  quality: VideoQuality;
  releaseDate: string;
  director: string;
  actors: string[];
  genres: string[];
  rating: number;
  viewCount: number;
  isFavorite?: boolean;
  playUrl: string;
  subtitles?: Array<{
    language: string;
    url: string;
  }>;
}

// è§†é¢‘åˆ—è¡¨è¯·æ±‚æ¥å£
export interface VideoListRequest {
  type?: VideoType;
  category?: string;
  tag?: string;
  page?: number;
  pageSize?: number;
  sortBy?: string;
  filters?: {
    quality?: VideoQuality;
    duration?: {
      min?: number;
      max?: number;
    };
    dateRange?: {
      start?: string;
      end?: string;
    };
  };
}

// è§†é¢‘åˆ—è¡¨å“åº”æ¥å£
export interface VideoListResponse {
  videos: VideoInfo[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}

// è§†é¢‘åˆ†ç±»æ¥å£
export interface VideoCategory {
  id: string;
  name: string;
  description: string;
  iconUrl: string;
  videoCount: number;
}

// è§†é¢‘æ ‡ç­¾æ¥å£
export interface VideoTag {
  id: string;
  name: string;
  count: number;
}

// è§†é¢‘ç»Ÿè®¡ä¿¡æ¯æ¥å£
export interface VideoStatistics {
  viewCount: number;
  likeCount: number;
  dislikeCount: number;
  favoriteCount: number;
  commentCount: number;
  averageRating: number;
}

// ç›¸å…³è§†é¢‘æ¥å£
export interface RelatedVideo {
  id: string;
  title: string;
  coverUrl: string;
  duration: number;
  similarity: number;
}

// è§†é¢‘è¯„è®ºæ¥å£
export interface VideoComment {
  id: string;
  userId: string;
  userName: string;
  userAvatar: string;
  content: string;
  rating?: number;
  createdAt: string;
  likes: number;
  replies: VideoComment[];
}

// è§†é¢‘è¯„åˆ†æ¥å£
export interface VideoRating {
  videoId: string;
  userId: string;
  rating: number;
  ratedAt: string;
}

// æ’­æ”¾è¿›åº¦æ¥å£
export interface PlaybackProgress {
  videoId: string;
  currentTime: number;
  duration: number;
  lastUpdated: number;
  isCompleted: boolean;
}

/**
 * è§†é¢‘ä»“åº“ç±? */
export class VideoRepository {
  private static instance: VideoRepository;
  private logger: Logger;
  private storageUtil: StorageUtil;
  private networkUtil: NetworkUtil;
  private cacheService: CacheService;
  private userRepository: UserRepository;
  private eventBus: Record<string, string | number | boolean | null>; // EventBuså®ä¾‹
  
  // APIç«¯ç‚¹é…ç½®
  private apiEndpoints = {
    baseUrl: 'https://api.raytv.com/v1',
    videos: '/videos',
    videoDetail: '/videos/:id',
    videoCategories: '/categories',
    videoTags: '/tags',
    videoStatistics: '/videos/:id/statistics',
    relatedVideos: '/videos/:id/related',
    videoComments: '/videos/:id/comments',
    videoFavorites: '/videos/:id/favorite',
    videoRating: '/videos/:id/rating',
    watchHistory: '/user/watch-history'
  };
  
  // å­˜å‚¨é”®é…ç½?  private storageKeys = {
    videoCache: 'video:detail:',
    videoListCache: 'video:list:',
    categories: 'video:categories',
    tags: 'video:tags:',
    favorites: 'user:favorites',
    playbackProgress: 'video:progress:',
    watchHistory: 'video:watch:history',
    lastWatched: 'video:last:watched'
  };
  
  // è§†é¢‘é…ç½®
  private videoConfig = {
    maxFavorites: 1000,
    maxWatchHistoryItems: 100,
    videoDetailCacheDuration: 3600, // 1å°æ—¶
    videoListCacheDuration: 1800,   // 30åˆ†é’Ÿ
    progressSyncInterval: 300000    // 5åˆ†é’Ÿ
  };
  
  // æ’­æ”¾è¿›åº¦å†…å­˜ç¼“å­˜
  private progressCache: Map<string, PlaybackProgress> = new Map();
  
  /**
   * ç§æœ‰æ„é€ å‡½æ•?   */
  private constructor() {
    this.logger = Logger.getInstance();
    this.storageUtil = StorageUtil.getInstance();
    this.networkUtil = NetworkUtil.getInstance();
    this.cacheService = CacheService.getInstance();
    this.userRepository = UserRepository.getInstance();
    // this.eventBus = EventBus.getInstance(); // éœ€è¦å¯¼å…¥EventBus
  }
  
  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): VideoRepository {
    if (!VideoRepository.instance) {
      VideoRepository.instance = new VideoRepository();
    }
    return VideoRepository.instance;
  }
  
  /**
   * åˆå§‹åŒ–è§†é¢‘ä»“åº?   */
  public async initialize(): Promise<void> {
    try {
      // åŠ è½½æ’­æ”¾è¿›åº¦ç¼“å­˜
      await this.loadProgressCache();
      
      // é¢„åŠ è½½åˆ†ç±?      await this.loadCategories();
      
      // è®¾ç½®äº‹ä»¶ç›‘å¬
      this.setupEventListeners();
      
      this.logger.info('VideoRepository initialized successfully');
    } catch (error) {
      this.Logger.error('Failed to initialize VideoRepository', error as Error);
      throw error;
    }
  }
  
  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬
   */
  private setupEventListeners(): void {
    // ç›‘å¬åº”ç”¨é€€å‡ºäº‹ä»?    // this.eventBus.on('app:exit', async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ())))))) => {
    //   await this.saveAllProgress();
    // });
    
    // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ?    // this.eventBus.on('network:statusChanged', async (status: { isOnline: boolean }) => {
    //   if (status.isOnline) {
    //     // åœ¨çº¿æ—¶åŒæ­¥æ’­æ”¾è¿›åº?    //     await this.syncPlaybackProgress();
    //   }
    // });
    
    // ç›‘å¬ç”¨æˆ·ç™»å½•/ç™»å‡ºäº‹ä»¶
    // this.eventBus.on('user:login', async () => {
    //   // ç™»å½•ååŒæ­¥æ’­æ”¾è¿›åº¦å’Œæ”¶è—
    //   await this.syncPlaybackProgress();
    //   await this.syncFavorites();
    // });
    
    // this.eventBus.on('user:logout', async () => {
    //   // ç™»å‡ºå‰ä¿å­˜æ‰€æœ‰è¿›åº?    //   await this.saveAllProgress();
    // });
  }
  
  /**
   * è·å–è§†é¢‘è¯¦æƒ…
   * @param videoId è§†é¢‘ID
   * @param forceRefresh æ˜¯å¦å¼ºåˆ¶åˆ·æ–°
   */
  public async getVideoDetail(videoId: string, forceRefresh: boolean = false): Promise<VideoInfo> {
    try {
      const cacheKey = `${this.storageKeys.videoCache}${videoId}`;
      
      // å°è¯•ä»ç¼“å­˜è·å?      if (!forceRefresh) {
        const cachedVideo = await this.cacheService.getCache<VideoInfo>(cacheKey);
        if (cachedVideo) {
          this.logger.debug(`Video detail loaded from cache: ${videoId}`);
          
          // å‘å¸ƒè§†é¢‘åŠ è½½äº‹ä»¶
          // this.eventBus.emit(VideoEventType.VIDEO_LOADED, {
          //   videoId,
          //   type: VideoEventType.VIDEO_LOADED,
          //   timestamp: Date.now(),
          //   data: cachedVideo
          // } as VideoEvent);
          
          return cachedVideo;
        }
      }
      
      // æ„å»ºè¯·æ±‚URL
      const url = this.apiEndpoints.videoDetail.replace(':id', videoId);
      
      // æ„å»ºè¯·æ±‚é…ç½®
      const config: Record<string, unknown> = {};
      
      // å¦‚æœç”¨æˆ·å·²ç™»å½•ï¼Œæ·»åŠ è®¤è¯å¤?      const authToken = this.userRepository.getAuthToken();
      if (authToken) {
        config.headers = {
          'Authorization': `Bearer ${authToken}`
        };
      }
      
      // è°ƒç”¨APIè·å–è§†é¢‘è¯¦æƒ…
      const response = await this.networkUtil.get<VideoInfo>(
        `${this.apiEndpoints.baseUrl}${url}`,
        config
      );
      
      const videoInfo = response.data;
      
      // ç¼“å­˜è§†é¢‘è¯¦æƒ…
      await this.cacheService.setCache(
        cacheKey,
        videoInfo,
        {
          type: CacheType.MEMORY_DISK,
          expiry: this.videoConfig.videoDetailCacheDuration * 1000
        }
      );
      
      // å‘å¸ƒè§†é¢‘åŠ è½½äº‹ä»¶
      // this.eventBus.emit(VideoEventType.VIDEO_LOADED, {
      //   videoId,
      //   type: VideoEventType.VIDEO_LOADED,
      //   timestamp: Date.now(),
      //   data: videoInfo
      // } as VideoEvent);
      
      this.logger.info(`Video detail loaded: ${videoInfo.title} (${videoId})`);
      
      return videoInfo;
    } catch (error) {
      this.Logger.error(`Failed to get video detail for ${videoId}`, error as Error);
      
      // å‘å¸ƒè§†é¢‘é”™è¯¯äº‹ä»¶
      // this.eventBus.emit(VideoEventType.VIDEO_ERROR, {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now())))))),
      //   error: error as Error
      // } as VideoEvent);
      
      throw error;
    }
  }
  
  /**
   * è·å–è§†é¢‘åˆ—è¡¨
   * @param request è§†é¢‘åˆ—è¡¨è¯·æ±‚å‚æ•°
   */
  public async getVideoList(request: VideoListRequest): Promise<VideoListResponse> {
    try {
      // éªŒè¯è¯·æ±‚å‚æ•°
      this.validateVideoListRequest(request);
      
      // ç”Ÿæˆç¼“å­˜é”?      const cacheKey = this.generateVideoListCacheKey(request);
      
      // å°è¯•ä»ç¼“å­˜è·å?      const cachedList = await this.cacheService.getCache<VideoListResponse>(cacheKey);
      if (cachedList) {
        this.logger.debug(`Video list loaded from cache`);
        
        // å‘å¸ƒè§†é¢‘åˆ—è¡¨åŠ è½½äº‹ä»¶
        // this.eventBus.emit(VideoEventType.VIDEO_LIST_LOADED, {
        //   type: VideoEventType.VIDEO_LIST_LOADED,
        //   timestamp: Date.now(),
        //   data: cachedList
        // } as VideoEvent);
        
        return cachedList;
      }
      
      // æ„å»ºè¯·æ±‚å‚æ•°
      const params = this.buildVideoListParams(request);
      
      // æ„å»ºè¯·æ±‚é…ç½®
      const config: Record<string, unknown> = {
        params
      };
      
      // å¦‚æœç”¨æˆ·å·²ç™»å½•ï¼Œæ·»åŠ è®¤è¯å¤?      const authToken = this.userRepository.getAuthToken();
      if (authToken) {
        config.headers = {
          'Authorization': `Bearer ${authToken}`
        };
      }
      
      // è°ƒç”¨APIè·å–è§†é¢‘åˆ—è¡¨
      const response = await this.networkUtil.get<VideoListResponse>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.videos}`,
        config
      );
      
      const videoList = response.data;
      
      // ç¼“å­˜è§†é¢‘åˆ—è¡¨
      await this.cacheService.setCache(
        cacheKey,
        videoList,
        {
          type: CacheType.MEMORY_DISK,
          expiry: this.videoConfig.videoListCacheDuration * 1000
        }
      );
      
      // å‘å¸ƒè§†é¢‘åˆ—è¡¨åŠ è½½äº‹ä»¶
      // this.eventBus.emit(VideoEventType.VIDEO_LIST_LOADED, {
      //   type: VideoEventType.VIDEO_LIST_LOADED,
      //   timestamp: Date.now(),
      //   data: videoList
      // } as VideoEvent);
      
      this.logger.info(`Video list loaded: ${videoList.videos.length} videos, page ${videoList.page}`);
      
      return videoList;
    } catch (error) {
      this.Logger.error('Failed to get video list', error as Error);
      
      // å‘å¸ƒè§†é¢‘é”™è¯¯äº‹ä»¶
      // this.eventBus.emit(VideoEventType.VIDEO_ERROR, {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( instanceof Error ? {
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now( : new Error(String({
      //   type: VideoEventType.VIDEO_ERROR,
      //   timestamp: Date.now())))))),
      //   error: error as Error
      // } as VideoEvent);
      
      throw error;
    }
  }
  
  /**
   * è·å–è§†é¢‘åˆ†ç±»
   */
  public async getCategories(): Promise<VideoCategory[]> {
    try {
      // å°è¯•ä»ç¼“å­˜è·å?      const cachedCategories = await this.cacheService.getCache<VideoCategory[]>(this.storageKeys.categories);
      if (cachedCategories) {
        return cachedCategories;
      }
      
      // è°ƒç”¨APIè·å–åˆ†ç±»
      const response = await this.networkUtil.get<VideoCategory[]>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.videoCategories}`
      );
      
      const categories = response.data;
      
      // ç¼“å­˜åˆ†ç±»
      await this.cacheService.setCache(
        this.storageKeys.categories,
        categories,
        {
          type: CacheType.MEMORY_DISK,
          expiry: 86400 * 1000 // 24å°æ—¶
        }
      );
      
      return categories;
    } catch (error) {
      this.Logger.error('Failed to get video categories', error as Error);
      return [];
    }
  }
  
  /**
   * è·å–çƒ­é—¨æ ‡ç­¾
   */
  public async getPopularTags(limit: number = 50): Promise<VideoTag[]> {
    try {
      // ç”Ÿæˆç¼“å­˜é”?      const cacheKey = `${this.storageKeys.tags}:${limit}`;
      
      // å°è¯•ä»ç¼“å­˜è·å?      const cachedTags = await this.cacheService.getCache<VideoTag[]>(cacheKey);
      if (cachedTags) {
        return cachedTags;
      }
      
      // è°ƒç”¨APIè·å–æ ‡ç­¾
      const response = await this.networkUtil.get<VideoTag[]>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.videoTags}`, {
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
       instanceof Error ? {
          params: { limit }
        }
       : new Error(String({
          params: { limit }
        }
      )))))));
      
      const tags = response.data;
      
      // ç¼“å­˜æ ‡ç­¾
      await this.cacheService.setCache(
        cacheKey,
        tags,
        {
          type: CacheType.MEMORY_DISK,
          expiry: 3600 * 1000 // 1å°æ—¶
        }
      );
      
      return tags;
    } catch (error) {
      this.Logger.error('Failed to get popular tags', error as Error);
      return [];
    }
  }
  
  /**
   * è·å–è§†é¢‘ç»Ÿè®¡ä¿¡æ¯
   * @param videoId è§†é¢‘ID
   */
  public async getVideoStatistics(videoId: string): Promise<VideoStatistics> {
    try {
      // æ„å»ºè¯·æ±‚URL
      const url = this.apiEndpoints.videoStatistics.replace(':id', videoId instanceof Error ? videoId : new Error(String(videoId instanceof Error ? videoId instanceof Error ? videoId : new Error(String(videoId : new Error(String(videoId instanceof Error ? videoId : new Error(String(videoId instanceof Error ? videoId instanceof Error ? videoId : new Error(String(videoId instanceof Error ? videoId instanceof Error ? videoId : new Error(String(videoId : new Error(String(videoId instanceof Error ? videoId : new Error(String(videoId : new Error(String(videoId instanceof Error ? videoId : new Error(String(videoId instanceof Error ? videoId instanceof Error ? videoId : new Error(String(videoId : new Error(String(videoId instanceof Error ? videoId : new Error(String(videoId)))))));
      
      // è°ƒç”¨APIè·å–ç»Ÿè®¡ä¿¡æ¯
      const response = await this.networkUtil.get<VideoStatistics>(
        `${this.apiEndpoints.baseUrl}${url}`
      );
      
      return response.data;
    } catch (error) {
      this.Logger.error(`Failed to get statistics for video ${videoId}`, error as Error);
      
      // è¿”å›é»˜è®¤ç»Ÿè®¡ä¿¡æ¯
      return {
        viewCount: 0, likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 instanceof Error ? likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10 : new Error(String(likeCount: 0,
        dislikeCount: 0,
        favoriteCount: 0,
        commentCount: 0,
        averageRating: 0
      };
    }
  }
  
  /**
   * è·å–ç›¸å…³è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getRelatedVideos(videoId: string, limit: number = 10))))))): Promise<RelatedVideo[]> {
    try {
      // ç”Ÿæˆç¼“å­˜é”?      const cacheKey = `video:related:${videoId}:${limit}`;
      
      // å°è¯•ä»ç¼“å­˜è·å?      const cachedRelated = await this.cacheService.getCache<RelatedVideo[]>(cacheKey);
      if (cachedRelated) {
        return cachedRelated;
      }
      
      // æ„å»ºè¯·æ±‚URL
      const url = this.apiEndpoints.relatedVideos.replace(':id', videoId);
      
      // è°ƒç”¨APIè·å–ç›¸å…³è§†é¢‘
      const response = await this.networkUtil.get<RelatedVideo[]>(
        `${this.apiEndpoints.baseUrl}${url}`,
        {
          params: { limit }
        }
      );
      
      const relatedVideos = response.data;
      
      // ç¼“å­˜ç›¸å…³è§†é¢‘
      await this.cacheService.setCache(
        cacheKey,
        relatedVideos,
        {
          type: CacheType.MEMORY,
          expiry: 3600 * 1000 // 1å°æ—¶
        }
      );
      
      return relatedVideos;
    } catch (error) {
      this.Logger.error(`Failed to get related videos for ${videoId}`, error as Error);
      return [];
    }
  }
  
  /**
   * è·å–è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param page é¡µç 
   * @param pageSize æ¯é¡µæ•°é‡
   */
  public async getVideoComments(videoId: string, page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20 instanceof Error ? page: number = 1, pageSize: number = 20 : new Error(String(page: number = 1, pageSize: number = 20))))))): Promise<{
    comments: VideoComment[];
    total: number;
    page: number;
    pageSize: number;
  }> {
    try {
      // æ„å»ºè¯·æ±‚URL
      const url = this.apiEndpoints.videoComments.replace(':id', videoId);
      
      // è°ƒç”¨APIè·å–è¯„è®º
      const response = await this.networkUtil.get<{
        comments: VideoComment[];
        total: number;
        page: number;
        pageSize: number;
      }>(
        `${this.apiEndpoints.baseUrl}${url}`,
        {
          params: { page, pageSize }
        }
      );
      
      return response.data;
    } catch (error) {
      this.Logger.error(`Failed to get comments for video ${videoId}`, error as Error);
      
      // è¿”å›ç©ºè¯„è®ºåˆ—è¡?      return {
        comments: [], total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string instanceof Error ? total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string : new Error(String(total: 0,
        page,
        pageSize
      };
    }
  }
  
  /**
   * æ·»åŠ è§†é¢‘è¯„è®º
   * @param videoId è§†é¢‘ID
   * @param content è¯„è®ºå†…å®¹
   */
  public async addVideoComment(videoId: string, content: string))))))): Promise<VideoComment> {
    try {
      // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç™»å½•
      if (!this.userRepository.isLoggedIn()) {
        throw new Error('User not logged in');
      }
      
      // éªŒè¯è¯„è®ºå†…å®¹
      if (!content || content.trim().length < 1) {
        throw new Error('Comment content cannot be empty');
      }
      
      // æ„å»ºè¯·æ±‚URL
      const url = this.apiEndpoints.videoComments.replace(':id', videoId);
      
      // è°ƒç”¨APIæ·»åŠ è¯„è®º
      const response = await this.networkUtil.post<VideoComment>(
        `${this.apiEndpoints.baseUrl}${url}`,
        { content },
        {
          headers: {
            'Authorization': `Bearer ${this.userRepository.getAuthToken()}`
          }
        }
      );
      
      const comment = response.data;
      
      // å‘å¸ƒè¯„è®ºæ·»åŠ äº‹ä»¶
      // this.eventBus.emit(VideoEventType.VIDEO_COMMENT_ADDED, {
      //   videoId,
      //   type: VideoEventType.VIDEO_COMMENT_ADDED,
      //   timestamp: Date.now(),
      //   data: comment
      // } as VideoEvent);
      
      return comment;
    } catch (error) {
      this.Logger.error(`Failed to add comment to video ${videoId}`, error as Error);
      throw error;
    }
  }
  
  /**
   * æ”¶è—/å–æ¶ˆæ”¶è—è§†é¢‘
   * @param videoId è§†é¢‘ID
   * @param favorited æ˜¯å¦æ”¶è—
   */
  public async setFavoriteStatus(videoId: string, favorited: boolean instanceof Error ? favorited: boolean : new Error(String(favorited: boolean instanceof Error ? favorited: boolean instanceof Error ? favorited: boolean : new Error(String(favorited: boolean : new Error(String(favorited: boolean instanceof Error ? favorited: boolean : new Error(String(favorited: boolean instanceof Error ? favorited: boolean instanceof Error ? favorited: boolean : new Error(String(favorited: boolean instanceof Error ? favorited: boolean instanceof Error ? favorited: boolean : new Error(String(favorited: boolean : new Error(String(favorited: boolean instanceof Error ? favorited: boolean : new Error(String(favorited: boolean : new Error(String(favorited: boolean instanceof Error ? favorited: boolean : new Error(String(favorited: boolean instanceof Error ? favorited: boolean instanceof Error ? favorited: boolean : new Error(String(favorited: boolean : new Error(String(favorited: boolean instanceof Error ? favorited: boolean : new Error(String(favorited: boolean))))))): Promise<boolean> {
    try {
      // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç™»å½•
      if (!this.userRepository.isLoggedIn()) {
        throw new Error('User not logged in');
      }
      
      const userId = this.userRepository.getCurrentUser()?.id;
      if (!userId) {
        throw new Error('User ID not available');
      }
      
      // æ„å»ºè¯·æ±‚URL
      const url = this.apiEndpoints.videoFavorites.replace(':id', videoId);
      
      try {
        // è°ƒç”¨APIæ›´æ–°æ”¶è—çŠ¶æ€?        await this.networkUtil.post(
          `${this.apiEndpoints.baseUrl}${url}`,
          { favorited },
          {
            headers: {
              'Authorization': `Bearer ${this.userRepository.getAuthToken()}`
            }
          }
        );
      } catch (error) {
        // APIè°ƒç”¨å¤±è´¥æ—¶ï¼Œä»ç„¶æ›´æ–°æœ¬åœ°çŠ¶æ€?        this.logger.warn(`Failed to update favorite status on server for video ${videoId}`, error as Error);
      }
      
      // æ›´æ–°æœ¬åœ°æ”¶è—çŠ¶æ€?      const favorites = await this.getFavorites();
      
      if (favorited) {
        // æ·»åŠ æ”¶è—
        if (!favorites.includes(videoId)) {
          // æ£€æŸ¥æ”¶è—æ•°é‡é™åˆ?          if (favorites.length >= this.videoConfig.maxFavorites) {
            throw new Error(`Maximum number of favorites (${this.videoConfig.maxFavorites}) reached`);
          }
          favorites.push(videoId);
        }
      } else {
        // å–æ¶ˆæ”¶è—
        const index = favorites.indexOf(videoId);
        if (index > -1) {
          favorites.splice(index, 1);
        }
      }
      
      // ä¿å­˜æ›´æ–°åçš„æ”¶è—åˆ—è¡¨
      await this.storageUtil.setObject(this.storageKeys.favorites, favorites, LocalStorageType.DEFAULT);
      
      // å‘å¸ƒæ”¶è—çŠ¶æ€å˜æ›´äº‹ä»?      // this.eventBus.emit(favorited ? VideoEventType.VIDEO_FAVORITED : VideoEventType.VIDEO_UNFAVORITED, {
      //   videoId,
      //   type: favorited ? VideoEventType.VIDEO_FAVORITED : VideoEventType.VIDEO_UNFAVORITED,
      //   timestamp: Date.now(),
      //   favorited,
      //   userId
      // } as FavoriteChangeEvent);
      
      // æ›´æ–°è§†é¢‘ç¼“å­˜ä¸­çš„æ”¶è—çŠ¶æ€?      await this.updateVideoFavoriteStatus(videoId, favorited);
      
      return true;
    } catch (error) {
      this.Logger.error(`Failed to ${favorited ? 'favorite' : 'unfavorite'} video ${videoId}`, error as Error);
      throw error;
    }
  }
  
  /**
   * è·å–æ”¶è—è§†é¢‘åˆ—è¡¨
   */
  public async getFavorites(): Promise<string[]> {
    try {
      return await this.storageUtil.getObject<string[]>(this.storageKeys.favorites, LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT))))))) || [];
    } catch (error) {
      this.Logger.error('Failed to get favorites', error as Error);
      return [];
    }
  }
  
  /**
   * æ£€æŸ¥è§†é¢‘æ˜¯å¦å·²æ”¶è—
   * @param videoId è§†é¢‘ID
   */
  public async isFavorite(videoId: string): Promise<boolean> {
    try {
      const favorites = await this.getFavorites();
      return favorites.includes(videoId);
    } catch (error) {
      this.logger.warn(`Failed to check favorite status for video ${videoId}`, error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
      return false;
    }
  }
  
  /**
   * å¯¹è§†é¢‘è¿›è¡Œè¯„åˆ?   * @param videoId è§†é¢‘ID
   * @param rating è¯„åˆ†ï¼?-5ï¼?   */
  public async rateVideo(videoId: string, rating: number): Promise<VideoRating> {
    try {
      // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç™»å½•
      if (!this.userRepository.isLoggedIn()) {
        throw new Error('User not logged in');
      }
      
      // éªŒè¯è¯„åˆ†
      if (rating < 1 || rating > 5) {
        throw new Error('Rating must be between 1 and 5');
      }
      
      // æ„å»ºè¯·æ±‚URL
      const url = this.apiEndpoints.videoRating.replace(':id', videoId);
      
      // è°ƒç”¨APIæäº¤è¯„åˆ†
      const response = await this.networkUtil.post<VideoRating>(
        `${this.apiEndpoints.baseUrl}${url}`,
        { rating },
        {
          headers: {
            'Authorization': `Bearer ${this.userRepository.getAuthToken()}`
          }
        }
      );
      
      const videoRating = response.data;
      
      // å‘å¸ƒè¯„åˆ†äº‹ä»¶
      // this.eventBus.emit(VideoEventType.VIDEO_RATED, {
      //   videoId,
      //   type: VideoEventType.VIDEO_RATED,
      //   timestamp: Date.now(),
      //   data: videoRating
      // } as VideoEvent);
      
      return videoRating;
    } catch (error) {
      this.Logger.error(`Failed to rate video ${videoId}`, error as Error);
      throw error;
    }
  }
  
  /**
   * æ›´æ–°æ’­æ”¾è¿›åº¦
   * @param videoId è§†é¢‘ID
   * @param progress æ’­æ”¾è¿›åº¦
   * @param saveToStorage æ˜¯å¦ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨
   */
  public async updatePlaybackProgress(
    videoId: string, progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
   instanceof Error ? progress: PlaybackProgress, 
    saveToStorage: boolean = true
   : new Error(String(progress: PlaybackProgress, 
    saveToStorage: boolean = true
  ))))))): Promise<void> {
    try {
      // æ›´æ–°å†…å­˜ç¼“å­˜
      this.progressCache.set(videoId, progress);
      
      // å¦‚æœéœ€è¦ï¼Œä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨
      if (saveToStorage) {
        const key = `${this.storageKeys.playbackProgress}${videoId}`;
        await this.storageUtil.setObject(key, progress, LocalStorageType.DEFAULT);
      }
      
      // æ›´æ–°æœ€åè§‚çœ‹è®°å½?      await this.updateLastWatched(videoId, progress.currentTime);
      
      // å‘å¸ƒè¿›åº¦æ›´æ–°äº‹ä»¶
      // this.eventBus.emit(VideoEventType.VIDEO_PROGRESS_UPDATED, {
      //   videoId,
      //   type: VideoEventType.VIDEO_PROGRESS_UPDATED,
      //   timestamp: Date.now(),
      //   progress
      // } as ProgressUpdateEvent);
      
      // å¦‚æœè§†é¢‘æ¥è¿‘å®Œæˆï¼Œè®°å½•ä¸ºå·²è§‚çœ?      if (progress.duration > 0 && progress.currentTime / progress.duration > 0.9) {
        await this.markAsWatched(videoId);
      }
    } catch (error) {
      this.logger.warn(`Failed to update playback progress for video ${videoId}`, error as Error);
    }
  }
  
  /**
   * è·å–æ’­æ”¾è¿›åº¦
   * @param videoId è§†é¢‘ID
   */
  public async getPlaybackProgress(videoId: string): Promise<PlaybackProgress | null> {
    try {
      // é¦–å…ˆæ£€æŸ¥å†…å­˜ç¼“å­?      const cachedProgress = this.progressCache.get(videoId);
      if (cachedProgress) {
        return cachedProgress;
      }
      
      // ä»æŒä¹…åŒ–å­˜å‚¨è·å–
      const key = `${this.storageKeys.playbackProgress}${videoId}`;
      return await this.storageUtil.getObject<PlaybackProgress>(key, LocalStorageType.DEFAULT);
    } catch (error) {
      this.logger.warn(`Failed to get playback progress for video ${videoId}`, error as Error);
      return null;
    }
  }
  
  /**
   * æ·»åŠ åˆ°è§‚çœ‹å†å?   * @param videoId è§†é¢‘ID
   * @param videoInfo è§†é¢‘ä¿¡æ¯
   */
  public async addToWatchHistory(videoId: string, videoInfo?: VideoInfo): Promise<void> {
    try {
      // è·å–ç°æœ‰è§‚çœ‹å†å²
      const history = await this.getWatchHistory();
      
      // ç§»é™¤é‡å¤é¡?      const filteredHistory = history.filter(item => item.videoId !== videoId);
      
      // è·å–è§†é¢‘ä¿¡æ¯ï¼ˆå¦‚æœæœªæä¾›ï¼?      let video = videoInfo;
      if (!video) {
        try {
          video = await this.getVideoDetail(videoId, false);
        } catch (error) {
          this.logger.warn(`Failed to get video info for watch history: ${videoId}`, error as Error);
          return;
        }
      }
      
      // åˆ›å»ºå†å²è®°å½•é¡?      const historyItem: Record<string, string | number | boolean | null> = { ... };
      
      // æ·»åŠ åˆ°å†å²è®°å½•å¼€å¤?      filteredHistory.unshift(historyItem);
      
      // é™åˆ¶å†å²è®°å½•æ•°é‡
      const limitedHistory = filteredHistory.slice(0, this.videoConfig.maxWatchHistoryItems);
      
      // ä¿å­˜å†å²è®°å½•
      await this.storageUtil.setObject(
        this.storageKeys.watchHistory,
        limitedHistory,
        LocalStorageType.DEFAULT
      );
    } catch (error) {
      this.logger.warn(`Failed to add video ${videoId} to watch history`, error as Error);
    }
  }
  
  /**
   * è·å–è§‚çœ‹å†å²
   * @param limit é™åˆ¶æ•°é‡
   */
  public async getWatchHistory(limit?: number): Promise<Array<{
    videoId: string;
    title: string;
    thumbnailUrl: string;
    duration: number;
    watchedAt: number;
  }>> {
    try {
      const history = await this.storageUtil.getObject<Array<{
        videoId: string;
        title: string;
        thumbnailUrl: string;
        duration: number;
        watchedAt: number;
      }>>(this.storageKeys.watchHistory, LocalStorageType.DEFAULT) || [];
      
      // é™åˆ¶æ•°é‡
      if (limit && limit > 0) {
        return history.slice(0, limit);
      }
      
      return history;
    } catch (error) {
      this.Logger.error('Failed to get watch history', error as Error);
      return [];
    }
  }

  /**
   * æ¸…é™¤è§‚çœ‹å†å²
   */
  public async clearWatchHistory(): Promise<void> {
    try {
      await this.storageUtil.remove(this.storageKeys.watchHistory, LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT instanceof Error ? LocalStorageType.DEFAULT : new Error(String(LocalStorageType.DEFAULT)))))));
      this.logger.info('Watch history cleared');
    } catch (error) {
      this.Logger.error('Failed to clear watch history', error as Error);
      throw error;
    }
  }

  /**
   * æ ‡è®°è§†é¢‘ä¸ºå·²è§‚çœ‹
   * @param videoId è§†é¢‘ID
   */
  private async markAsWatched(videoId: string): Promise<void> {
    try {
      // å‘å¸ƒè§†é¢‘å·²è§‚çœ‹äº‹ä»?      // this.eventBus.emit(VideoEventType.VIDEO_WATCHED, {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( instanceof Error ? {
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now( : new Error(String({
      //   videoId,
      //   type: VideoEventType.VIDEO_WATCHED,
      //   timestamp: Date.now()))))))
      // } as VideoEvent);
      
      // å¼‚æ­¥å‘é€è§‚çœ‹è®°å½•åˆ°æœåŠ¡å™?      if (this.userRepository.isLoggedIn()) {
        this.networkUtil.post(
          `${this.apiEndpoints.baseUrl}${this.apiEndpoints.watchHistory}`,
          {
            videoId,
            watchedAt: Date.now()
          },
          {
            headers: {
              'Authorization': `Bearer ${this.userRepository.getAuthToken()}`
            }
          }
        ).catch(error => {
          this.logger.warn(`Failed to sync watch status to server for video ${videoId}`, error as Error);
        });
      }
    } catch (error) {
      this.logger.warn(`Failed to mark video ${videoId} as watched`, error as Error);
    }
  }

  /**
   * æ›´æ–°æœ€åè§‚çœ‹è®°å½?   * @param videoId è§†é¢‘ID
   * @param currentTime å½“å‰æ’­æ”¾æ—¶é—´
   */
  private async updateLastWatched(videoId: string, currentTime: number): Promise<void> {
    try {
      await this.storageUtil.setObject(
        this.storageKeys.lastWatched,
        {
          videoId,
          currentTime,
          timestamp: Date.now()
        },
        LocalStorageType.DEFAULT
      );
    } catch (error) {
      this.logger.warn('Failed to update last watched', error as Error);
    }
  }

  /**
   * åŠ è½½æœ¬åœ°æ’­æ”¾è¿›åº¦ç¼“å­˜
   */
  private async loadProgressCache(): Promise<void> {
    try {
      // è·å–æ‰€æœ‰å­˜å‚¨çš„è¿›åº¦è®°å½•é”?      const keys = await this.storageUtil.getAllKeys(LocalStorageType.DEFAULT);
      const progressKeys = keys.filter(key => key.startsWith(this.storageKeys.playbackProgress));
      
      // åŠ è½½æ‰€æœ‰è¿›åº¦è®°å½•åˆ°å†…å­˜ç¼“å­˜
      for (const key of progressKeys) {
        const videoId = key.replace(this.storageKeys.playbackProgress, '');
        const progress = await this.storageUtil.getObject<PlaybackProgress>(key, LocalStorageType.DEFAULT);
        if (progress) {
          this.progressCache.set(videoId, progress);
        }
      }
      
      this.logger.debug(`Loaded ${this.progressCache.size} playback progress records into cache`);
    } catch (error) {
      this.logger.warn('Failed to load progress cache', error as Error);
    }
  }

  /**
   * ä¿å­˜æ‰€æœ‰æ’­æ”¾è¿›åº?   */
  private async saveAllProgress(): Promise<void> {
    try {
      // å°†å†…å­˜ç¼“å­˜ä¸­çš„æ‰€æœ‰è¿›åº¦ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚?      for (const [videoId, progress] of this.progressCache.entries()) {
        const key = `${this.storageKeys.playbackProgress}${videoId}`;
        await this.storageUtil.setObject(key, progress, LocalStorageType.DEFAULT);
      }
      
      this.logger.debug(`Saved ${this.progressCache.size} playback progress records`);
    } catch (error) {
      this.logger.warn('Failed to save all progress records', error as Error);
    }
  }

  /**
   * åŒæ­¥æ’­æ”¾è¿›åº¦åˆ°æœåŠ¡å™¨
   */
  private async syncPlaybackProgress(): Promise<void> {
    try {
      if (!this.userRepository.isLoggedIn()) {
        return;
      }
      
      // è·å–éœ€è¦åŒæ­¥çš„è¿›åº¦è®°å½•ï¼ˆä¾‹å¦‚æœ€è¿‘æ›´æ–°çš„ï¼?      const recentProgress = Array.from(this.progressCache.entries())
        .filter(([_, progress]) => progress.lastUpdated > Date.now() - 3600000) // æœ€è¿?å°æ—¶æ›´æ–°çš?        .slice(0, 50); // é™åˆ¶åŒæ­¥æ•°é‡
      
      if (recentProgress.length === 0) {
        return;
      }
      
      // æ„å»ºåŒæ­¥æ•°æ®
      const syncData = recentProgress.map(([videoId, progress]) => ({
        videoId,
        progress
      }));
      
      // è°ƒç”¨APIåŒæ­¥è¿›åº¦
      await this.networkUtil.post(
        `${this.apiEndpoints.baseUrl}/user/progress/sync`,
        { progresses: syncData },
        {
          headers: {
            'Authorization': `Bearer ${this.userRepository.getAuthToken()}`
          }
        }
      );
      
      this.logger.debug(`Synced ${syncData.length} playback progress records to server`);
    } catch (error) {
      this.logger.warn('Failed to sync playback progress to server', error as Error);
    }
  }

  /**
   * åŒæ­¥æ”¶è—åˆ—è¡¨
   */
  private async syncFavorites(): Promise<void> {
    try {
      if (!this.userRepository.isLoggedIn()) {
        return;
      }
      
      // è°ƒç”¨APIè·å–æœåŠ¡å™¨ç«¯æ”¶è—åˆ—è¡¨
      const response = await this.networkUtil.get<string[]>(
        `${this.apiEndpoints.baseUrl}/user/favorites`,
        {
          headers: {
            'Authorization': `Bearer ${this.userRepository.getAuthToken()}`
          }
        }
      );
      
      const serverFavorites = response.data;
      
      // è·å–æœ¬åœ°æ”¶è—åˆ—è¡¨
      const localFavorites = await this.getFavorites();
      
      // åˆå¹¶æ”¶è—åˆ—è¡¨ï¼ˆä¿ç•™å¹¶é›†ï¼‰
      const mergedFavorites = [...new Set([...serverFavorites, ...localFavorites])];
      
      // ä¿å­˜åˆå¹¶åçš„æ”¶è—åˆ—è¡¨
      if (mergedFavorites.length > 0) {
        await this.storageUtil.setObject(
          this.storageKeys.favorites,
          mergedFavorites,
          LocalStorageType.DEFAULT
        );
      }
      
      this.logger.debug(`Synced favorites with server, total: ${mergedFavorites.length}`);
    } catch (error) {
      this.logger.warn('Failed to sync favorites with server', error as Error);
    }
  }

  /**
   * æ›´æ–°è§†é¢‘ç¼“å­˜ä¸­çš„æ”¶è—çŠ¶æ€?   * @param videoId è§†é¢‘ID
   * @param favorited æ˜¯å¦æ”¶è—
   */
  private async updateVideoFavoriteStatus(videoId: string, favorited: boolean): Promise<void> {
    try {
      const cacheKey = `${this.storageKeys.videoCache}${videoId}`;
      const videoInfo = await this.cacheService.getCache<VideoInfo>(cacheKey);
      
      if (videoInfo) {
        videoInfo.isFavorite = favorited;
        
        // æ›´æ–°ç¼“å­˜
        await this.cacheService.setCache(
          cacheKey,
          videoInfo,
          {
            type: CacheType.MEMORY_DISK,
            expiry: this.videoConfig.videoDetailCacheDuration * 1000
          }
        );
      }
    } catch (error) {
      this.logger.warn(`Failed to update favorite status in video cache for ${videoId}`, error as Error);
    }
  }

  /**
   * éªŒè¯è§†é¢‘åˆ—è¡¨è¯·æ±‚å‚æ•°
   */
  private validateVideoListRequest(request: VideoListRequest): void {
    const errors: string[] = [];
    
    if (request.page && request.page < 1) {
      errors.push('Page number must be at least 1');
    }
    
    if (request.pageSize && (request.pageSize < 1 || request.pageSize > 100)) {
      errors.push('Page size must be between 1 and 100');
    }
    
    if (errors.length > 0) {
      throw new Error(errors.join(', '));
    }
  }

  /**
   * æ„å»ºè§†é¢‘åˆ—è¡¨è¯·æ±‚å‚æ•°
   */
  private buildVideoListParams(request: VideoListRequest): Record<string, string | number> {
    const params: Record<string, string | number> = {
      page: request.page || 1,
      pageSize: request.pageSize || 20,
      sortBy: request.sortBy || 'latest'
    };
    
    if (request.type) {
      params.type = request.type;
    }
    
    if (request.category) {
      params.category = request.category;
    }
    
    if (request.tag) {
      params.tag = request.tag;
    }
    
    // æ·»åŠ è¿‡æ»¤æ¡ä»¶
    if (request.filters) {
      if (request.filters.quality) {
        params['filter[quality]'] = request.filters.quality;
      }
      
      if (request.filters.duration) {
        if (request.filters.duration.min !== undefined) {
          params['filter[duration][min]'] = request.filters.duration.min;
        }
        if (request.filters.duration.max !== undefined) {
          params['filter[duration][max]'] = request.filters.duration.max;
        }
      }
      
      if (request.filters.dateRange) {
        if (request.filters.dateRange.start !== undefined) {
          params['filter[dateRange][start]'] = request.filters.dateRange.start;
        }
        if (request.filters.dateRange.end !== undefined) {
          params['filter[dateRange][end]'] = request.filters.dateRange.end;
        }
      }
    }
    
    return params;
  }

  /**
   * ç”Ÿæˆè§†é¢‘åˆ—è¡¨ç¼“å­˜é”?   */
  private generateVideoListCacheKey(request: VideoListRequest): string {
    const filtersString = request.filters ? 
      JSON.stringify(request.filters) : '';
    
    return `video:list:${request.type || 'all'}:${request.category || ''}:${request.tag || ''}:${request.page || 1}:${request.pageSize || 20}:${request.sortBy || 'latest'}:${filtersString}`;
  }

  /**
   * åŠ è½½è§†é¢‘åˆ†ç±»
   */
  private async loadCategories(): Promise<VideoCategory[]> {
    return this.getCategories();
  }

  /**
   * æ¸…é™¤è§†é¢‘ç¼“å­˜
   * @param videoId å¯é€‰çš„è§†é¢‘IDï¼Œå¦‚æœä¸æä¾›åˆ™æ¸…é™¤æ‰€æœ‰ç¼“å­?   */
  public async clearVideoCache(videoId?: string): Promise<void> {
    try {
      if (videoId) {
        // æ¸…é™¤ç‰¹å®šè§†é¢‘çš„ç¼“å­?        const cacheKey = `${this.storageKeys.videoCache}${videoId}`;
        await this.cacheService.removeCache(cacheKey);
        
        // æ¸…é™¤ç›¸å…³ç¼“å­˜
        await this.cacheService.removeCache(`video:related:${videoId}:*`);
        await this.cacheService.removeCache(`search:item:*:${videoId}`);
      } else {
        // æ¸…é™¤æ‰€æœ‰è§†é¢‘åˆ—è¡¨ç¼“å­?        const pattern = `${this.storageKeys.videoListCache}*`;
        await this.cacheService.removeCacheByPattern(pattern);
        
        // æ¸…é™¤æ‰€æœ‰è§†é¢‘è¯¦æƒ…ç¼“å­?        const detailPattern = `${this.storageKeys.videoCache}*`;
        await this.cacheService.removeCacheByPattern(detailPattern);
      }
      
      // å‘å¸ƒç¼“å­˜æ›´æ–°äº‹ä»¶
      // this.eventBus.emit(VideoEventType.VIDEO_CACHE_UPDATED, {
      //   type: VideoEventType.VIDEO_CACHE_UPDATED,
      //   timestamp: Date.now(),
      //   data: { videoId }
      // } as VideoEvent);
      
      this.logger.info(`${videoId ? `Cache cleared for video ${videoId}` : 'All video caches cleared'}`);
    } catch (error) {
      this.logger.error(`Failed to clear video cache${videoId ? ` for ${videoId}` : ''}`, error as Error);
      throw error;
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default VideoRepository.getInstance();


