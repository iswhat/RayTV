// CategoryRepository - åˆ†ç±»ä»“åº“ç±?// è´Ÿè´£ç®¡ç†è§†é¢‘å’Œç›´æ’­çš„åˆ†ç±»æ•°æ®

import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import NetworkUtil from '../../common/util/NetworkUtil';
import EventBusUtil from '../../common/util/EventBusUtil';
import CacheService from '../../service/cache/CacheService';
import { LocalStorageType } from '../model/LocalModel';
import { CacheType, CachePolicy } from '../model/CacheModel';

/**
 * åˆ†ç±»ç±»å‹æšä¸¾
 */
export enum CategoryType {
  VIDEO = 'video',
  LIVE = 'live',
  BOTH = 'both',
  GENRE = 'genre',
  TOPIC = 'topic',
  TAG = 'tag',
  COLLECTION = 'collection',
  CHANNEL = 'channel',
  FORMAT = 'format',
  LANGUAGE = 'language',
  REGION = 'region',
  UNKNOWN = 'unknown'
}

/**
 * åˆ†ç±»å¯è§æ€§æšä¸? */
export enum CategoryVisibility {
  PUBLIC = 'public',
  PRIVATE = 'private',
  RESTRICTED = 'restricted',
  FEATURED = 'featured',
  HIDDEN = 'hidden'
}

/**
 * åˆ†ç±»æ’åºç±»å‹æšä¸¾
 */
export enum CategorySortType {
  NAME_ASC = 'name_asc',
  NAME_DESC = 'name_desc',
  POPULARITY = 'popularity',
  TRENDING = 'trending',
  RECENTLY_ADDED = 'recently_added',
  CONTENT_COUNT = 'content_count',
  CUSTOM = 'custom'
}

/**
 * åˆ†ç±»å›¾æ ‡ç±»å‹æšä¸¾
 */
export enum CategoryIconType {
  ICON_FONT = 'icon_font',
  IMAGE = 'image',
  SVG = 'svg',
  EMOJI = 'emoji',
  GRADIENT = 'gradient',
  NONE = 'none'
}

/**
 * åˆ†ç±»å›¾æ ‡æ¥å£
 */
export interface CategoryIcon {
  type: CategoryIconType;
  value: string; // å›¾æ ‡åç§°ã€å›¾ç‰‡URLæˆ–emoji
  color?: string;
  backgroundColor?: string;
  size?: number;
}

/**
 * åˆ†ç±»å…ƒæ•°æ®æ¥å? */
export interface CategoryMetadata {
  viewCount: number; // æµè§ˆæ¬¡æ•°
  contentCount: number; // å†…å®¹æ•°é‡
  followerCount: number; // å…³æ³¨è€…æ•°é‡?  isFollowing?: boolean; // å½“å‰ç”¨æˆ·æ˜¯å¦å…³æ³¨
  isFeatured?: boolean; // æ˜¯å¦ç²¾é€?  lastUpdated: number; // æœ€åæ›´æ–°æ—¶é—?  createdAt: number; // åˆ›å»ºæ—¶é—´
  updatedBy?: string; // æ›´æ–°è€…ID
  createdBy?: string; // åˆ›å»ºè€…ID
  parentCategoryId?: string; // çˆ¶åˆ†ç±»ID
  childCategoryIds?: string[]; // å­åˆ†ç±»IDåˆ—è¡¨
  relatedCategoryIds?: string[]; // ç›¸å…³åˆ†ç±»IDåˆ—è¡¨
  allowedUserIds?: string[]; // å…è®¸è®¿é—®çš„ç”¨æˆ·IDåˆ—è¡¨ï¼ˆç§æœ‰åˆ†ç±»ï¼‰
  restrictedCountries?: string[]; // é™åˆ¶è®¿é—®çš„å›½å®¶åˆ—è¡?  tags?: string[]; // åˆ†ç±»æ ‡ç­¾
  description?: string; // è¯¦ç»†æè¿°
  coverImageUrl?: string; // å°é¢å›¾ç‰‡URL
  bannerImageUrl?: string; // æ¨ªå¹…å›¾ç‰‡URL
  icon?: CategoryIcon; // åˆ†ç±»å›¾æ ‡
}

/**
 * åˆ†ç±»æ¥å£
 */
export interface Category {
  id: string; // åˆ†ç±»ID
  name: string; // åˆ†ç±»åç§°
  type: CategoryType; // åˆ†ç±»ç±»å‹
  visibility: CategoryVisibility; // å¯è§æ€?  slug: string; // URLå‹å¥½çš„æ ‡è¯?  metadata: CategoryMetadata; // å…ƒæ•°æ?  orderIndex?: number; // æ’åºç´¢å¼•
  status: 'active' | 'inactive' | 'pending' | 'deprecated'; // çŠ¶æ€?  localization?: Record<string, { // æœ¬åœ°åŒ–æ•°æ?    name: string;
    description?: string;
    slug?: string;
  }>;
}

/**
 * åˆ†ç±»ç»„æ¥å? */
export interface CategoryGroup {
  id: string; // ç»„ID
  name: string; // ç»„åç§?  description?: string; // ç»„æè¿?  categoryIds: string[]; // åˆ†ç±»IDåˆ—è¡¨
  orderIndex?: number; // æ’åºç´¢å¼•
  isExpanded?: boolean; // æ˜¯å¦å±•å¼€
  icon?: CategoryIcon; // ç»„å›¾æ ?  createdAt: number; // åˆ›å»ºæ—¶é—´
  updatedAt: number; // æ›´æ–°æ—¶é—´
}

/**
 * åˆ†ç±»äº‹ä»¶ç±»å‹
 */
export const CategoryEventType = {
  // åˆ†ç±»ç”Ÿå‘½å‘¨æœŸäº‹ä»¶
  CREATED: 'category:created',
  UPDATED: 'category:updated',
  DELETED: 'category:deleted',
  ACTIVATED: 'category:activated',
  DEACTIVATED: 'category:deactivated',
  
  // çŠ¶æ€å˜æ›´äº‹ä»?  VISIBILITY_CHANGED: 'category:visibilityChanged',
  FOLLOWED: 'category:followed',
  UNFOLLOWED: 'category:unfollowed',
  
  // å†…å®¹äº‹ä»¶
  CONTENT_ADDED: 'category:contentAdded',
  CONTENT_REMOVED: 'category:contentRemoved',
  CONTENT_COUNT_CHANGED: 'category:contentCountChanged',
  
  // ç»„äº‹ä»?  GROUP_CREATED: 'category:groupCreated',
  GROUP_UPDATED: 'category:groupUpdated',
  GROUP_DELETED: 'category:groupDeleted',
  
  // æ‰¹é‡äº‹ä»¶
  BATCH_UPDATED: 'category:batchUpdated',
  REORDERED: 'category:reordered',
  
  // åŠ è½½äº‹ä»¶
  LOADED: 'category:loaded',
  SYNCED: 'category:synced',
  
  // é”™è¯¯äº‹ä»¶
  ERROR: 'category:error'
} as const;

/**
 * åˆ†ç±»äº‹ä»¶æ•°æ®
 */
export interface CategoryEvent {
  type: string;
  timestamp: number;
  category?: Category;
  categories?: Category[];
  categoryIds?: string[];
  group?: CategoryGroup;
  groups?: CategoryGroup[];
  visibility?: CategoryVisibility;
  previousVisibility?: CategoryVisibility;
  contentId?: string;
  contentCount?: number;
  error?: Error;
}

/**
 * åˆ†ç±»è¿‡æ»¤æ¡ä»¶æ¥å£
 */
export interface CategoryFilter {
  types?: CategoryType[]; // åˆ†ç±»ç±»å‹
  visibility?: CategoryVisibility[]; // å¯è§æ€?  searchTerm?: string; // æœç´¢è¯?  parentId?: string; // çˆ¶åˆ†ç±»ID
  childOf?: string; // å­åˆ†ç±»ç­›é€?  status?: string[]; // çŠ¶æ€?  featured?: boolean; // æ˜¯å¦ç²¾é€?  followed?: boolean; // æ˜¯å¦å·²å…³æ³?  contentCountMin?: number; // å†…å®¹æ•°é‡ä¸‹é™
  contentCountMax?: number; // å†…å®¹æ•°é‡ä¸Šé™
  tags?: string[]; // æ ‡ç­¾ç­›é€?  sortBy?: CategorySortType; // æ’åºæ–¹å¼
  limit?: number; // æ•°é‡é™åˆ¶
  offset?: number; // åç§»é‡?  lang?: string; // è¯­è¨€ç­›é€?  region?: string; // åœ°åŒºç­›é€?}

/**
 * åˆ†ç±»è¯·æ±‚æ¥å£
 */
export interface CategoryRequest {
  filter?: CategoryFilter;
  includeMetadata?: boolean; // æ˜¯å¦åŒ…å«å…ƒæ•°æ?  includeGroups?: boolean; // æ˜¯å¦åŒ…å«åˆ†ç»„
  includeLocalization?: boolean; // æ˜¯å¦åŒ…å«æœ¬åœ°åŒ?  includeChildCategories?: boolean; // æ˜¯å¦åŒ…å«å­åˆ†ç±?  includeContentCount?: boolean; // æ˜¯å¦åŒ…å«å†…å®¹è®¡æ•°
  cachePolicy?: CachePolicy; // ç¼“å­˜ç­–ç•¥
}

/**
 * åˆ†ç±»å“åº”æ¥å£
 */
export interface CategoryResponse {
  categories: Category[];
  totalCount: number;
  hasMore: boolean;
  groups?: CategoryGroup[];
  timestamp: number;
  cacheHit?: boolean;
}

/**
 * åˆ†ç±»ç»Ÿè®¡æ¥å£
 */
export interface CategoryStats {
  totalCategories: number;
  activeCategories: number;
  featuredCategories: number;
  followedCategories: number;
  byType: Map<CategoryType, number>;
  byVisibility: Map<CategoryVisibility, number>;
  totalContentCount: number;
  lastUpdated: number;
}

/**
 * åˆ†ç±»å­˜å‚¨é…ç½®æ¥å£
 */
export interface CategoryStorageConfig {
  cacheTTL: number; // ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  maxCacheItems: number; // æœ€å¤§ç¼“å­˜é¡¹æ•?  persistCategories: boolean; // æ˜¯å¦æŒä¹…åŒ–åˆ†ç±?  autoSync: boolean; // æ˜¯å¦è‡ªåŠ¨åŒæ­¥
  syncInterval: number; // åŒæ­¥é—´éš”ï¼ˆæ¯«ç§’ï¼‰
  offlineMode: boolean; // ç¦»çº¿æ¨¡å¼
}

/**
 * åˆ†ç±»ä»“åº“ç±? */
export class CategoryRepository {
  private static instance: CategoryRepository;
  private logger = Logger.getInstance();
  private storageUtil = StorageUtil.getInstance();
  private networkUtil = NetworkUtil.getInstance();
  private eventBus = EventBusUtil.getInstance();
  private cacheService = CacheService.getInstance();
  
  // å­˜å‚¨é”®é…ç½?  private storageKeys = {
    categories: 'category:categories',
    groups: 'category:groups',
    stats: 'category:stats',
    followed: 'category:followed',
    config: 'category:config',
    lastSyncTime: 'category:lastSyncTime',
    customOrder: 'category:customOrder'
  };
  
  // é»˜è®¤å­˜å‚¨é…ç½®
  private defaultStorageConfig: CategoryStorageConfig = {
    cacheTTL: 3600000, // 1å°æ—¶
    maxCacheItems: 1000,
    persistCategories: true,
    autoSync: true,
    syncInterval: 1800000, // 30åˆ†é’Ÿ
    offlineMode: false
  };
  
  // å­˜å‚¨é…ç½®
  private storageConfig: CategoryStorageConfig = { ...this.defaultStorageConfig };
  
  // åˆ†ç±»æ•°æ®å­˜å‚¨
  private categories: Map<string, Category> = new Map();
  private groups: Map<string, CategoryGroup> = new Map();
  private followedCategories: Set<string> = new Set();
  private customOrder: Map<string, number> = new Map();
  
  // ç»Ÿè®¡ä¿¡æ¯
  private stats: CategoryStats = {
    totalCategories: 0,
    activeCategories: 0,
    featuredCategories: 0,
    followedCategories: 0,
    byType: new Map(),
    byVisibility: new Map(),
    totalContentCount: 0,
    lastUpdated: 0
  };
  
  // åŒæ­¥çŠ¶æ€?  private lastSyncTime: number = 0;
  private isSyncing: boolean = false;
  private syncTimer: number | null = null;
  
  // åˆå§‹åŒ–çŠ¶æ€?  private initialized: boolean = false;
  
  /**
   * ç§æœ‰æ„é€ å‡½æ•?   */
  private constructor() {
    this.logger.info('CategoryRepository initialized');
    this.setupEventListeners();
  }

  /**
   * è·å–CategoryRepositoryå•ä¾‹å®ä¾‹
   */
  public static getInstance(): CategoryRepository {
    if (!CategoryRepository.instance) {
      CategoryRepository.instance = new CategoryRepository();
    }
    return CategoryRepository.instance;
  }

  /**
   * åˆå§‹åŒ–åˆ†ç±»ä»“åº?   * @param config å­˜å‚¨é…ç½®
   */
  public async initialize(config?: Partial<CategoryStorageConfig>): Promise<void> {
    try {
      if (this.initialized) {
        this.logger.warn('CategoryRepository already initialized');
        return;
      }
      
      // æ›´æ–°é…ç½®
      if (config) {
        this.storageConfig = { ...this.storageConfig, ...config };
      }
      
      // åŠ è½½æœ¬åœ°æ•°æ®
      await this.loadLocalData();
      
      // å¯åŠ¨è‡ªåŠ¨åŒæ­¥
      if (this.storageConfig.autoSync) {
        this.startAutoSync();
      }
      
      this.initialized = true;
      this.logger.info('CategoryRepository initialized successfully', {
        persistCategories: this.storageConfig.persistCategories,
        autoSync: this.storageConfig.autoSync,
        offlineMode: this.storageConfig.offlineMode
      });
      
      // å‘å¸ƒåŠ è½½å®Œæˆäº‹ä»¶
      this.eventBus.emit(CategoryEventType.LOADED, {
        type: CategoryEventType.LOADED,
        timestamp: Date.now(),
        categories: Array.from(this.categories.values())
      });
    } catch (error) {
      this.Logger.error('Failed to initialize CategoryRepository', error as Error);
      
      // å‘å¸ƒé”™è¯¯äº‹ä»¶
      this.eventBus.emit(CategoryEventType.ERROR, {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
    }
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬å™?   */
  private setupEventListeners(): void {
    // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ?    this.eventBus.on('network:online', () => {
      this.onNetworkOnline();
    });
    
    this.eventBus.on('network:offline', () => {
      this.onNetworkOffline();
    });
    
    // ç›‘å¬åº”ç”¨é€€å‡ºäº‹ä»?    this.eventBus.on('app:exit', async () => {
      await this.shutdown();
    });
  }

  /**
   * åŠ è½½æœ¬åœ°æ•°æ®
   */
  private async loadLocalData(): Promise<void> {
    try {
      // åŠ è½½åˆ†ç±»æ•°æ®
      const categoriesData = await this.storageUtil.get(LocalStorageType.CATEGORIES);
      if (categoriesData) {
        const categories = JSON.parse(categoriesData) as Category[];
        this.categories.clear();
        categories.forEach(category => {
          this.categories.set(category.id, category);
        });
      }
      
      // åŠ è½½åˆ†ç»„æ•°æ®
      const groupsData = await this.storageUtil.get(LocalStorageType.CATEGORY_GROUPS);
      if (groupsData) {
        const groups = JSON.parse(groupsData) as CategoryGroup[];
        this.groups.clear();
        groups.forEach(group => {
          this.groups.set(group.id, group);
        });
      }
      
      // åŠ è½½å…³æ³¨åˆ†ç±»
      const followedData = await this.storageUtil.get(LocalStorageType.FOLLOWED_CATEGORIES);
      if (followedData) {
        const followed = JSON.parse(followedData) as string[];
        this.followedCategories = new Set(followed);
      }
      
      // åŠ è½½è‡ªå®šä¹‰æ’åº?      const orderData = await this.storageUtil.get(LocalStorageType.CATEGORY_CUSTOM_ORDER);
      if (orderData) {
        const order = JSON.parse(orderData) as Record<string, number>;
        this.customOrder.clear();
        Object.entries(order).forEach(([id, index]) => {
          this.customOrder.set(id, index);
        });
      }
      
      // åŠ è½½ç»Ÿè®¡ä¿¡æ¯
      const statsData = await this.storageUtil.get(LocalStorageType.CATEGORY_STATS);
      if (statsData) {
        this.stats = JSON.parse(statsData) as CategoryStats;
      }
      
      // åŠ è½½æœ€ååŒæ­¥æ—¶é—?      const syncTimeData = await this.storageUtil.get(LocalStorageType.LAST_SYNC_TIME);
      if (syncTimeData) {
        this.lastSyncTime = parseInt(syncTimeData);
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.updateStats();
      
      this.logger.info('Local category data loaded', {
        categories: this.categories.size,
        groups: this.groups.size,
        followed: this.followedCategories.size
      });
    } catch (error) {
      this.logger.warn('Failed to load local category data', error as Error);
    }
  }

  /**
   * ä¿å­˜æœ¬åœ°æ•°æ®
   */
  private async saveLocalData(): Promise<void> {
    if (!this.storageConfig.persistCategories) {
      return;
    }
    
    try {
      // ä¿å­˜åˆ†ç±»æ•°æ®
      const categories = Array.from(this.categories.values());
      await this.storageUtil.set(
        LocalStorageType.CATEGORIES,
        JSON.stringify(categories)
      );
      
      // ä¿å­˜åˆ†ç»„æ•°æ®
      const groups = Array.from(this.groups.values());
      await this.storageUtil.set(
        LocalStorageType.CATEGORY_GROUPS,
        JSON.stringify(groups)
      );
      
      // ä¿å­˜å…³æ³¨åˆ†ç±»
      const followed = Array.from(this.followedCategories);
      await this.storageUtil.set(
        LocalStorageType.FOLLOWED_CATEGORIES,
        JSON.stringify(followed)
      );
      
      // ä¿å­˜è‡ªå®šä¹‰æ’åº?      const order = Object.fromEntries(this.customOrder);
      await this.storageUtil.set(
        LocalStorageType.CATEGORY_CUSTOM_ORDER,
        JSON.stringify(order)
      );
      
      // ä¿å­˜ç»Ÿè®¡ä¿¡æ¯
      await this.storageUtil.set(
        LocalStorageType.CATEGORY_STATS,
        JSON.stringify(this.stats)
      );
      
      // ä¿å­˜æœ€ååŒæ­¥æ—¶é—?      await this.storageUtil.set(
        LocalStorageType.LAST_SYNC_TIME,
        this.lastSyncTime.toString()
      );
      
      this.logger.debug('Local category data saved');
    } catch (error) {
      this.logger.warn('Failed to save local category data', error as Error);
    }
  }

  /**
   * å¯åŠ¨è‡ªåŠ¨åŒæ­¥
   */
  private startAutoSync(): void {
    if (this.syncTimer) {
      clearInterval(this.syncTimer);
    }
    
    this.syncTimer = setInterval(async () => {
      if (!this.isSyncing && this.shouldSync()) {
        await this.syncCategories();
      }
    }, this.storageConfig.syncInterval) as unknown as number;
  }

  /**
   * åœæ­¢è‡ªåŠ¨åŒæ­¥
   */
  private stopAutoSync(): void {
    if (this.syncTimer) {
      clearInterval(this.syncTimer);
      this.syncTimer = null;
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦éœ€è¦åŒæ­?   */
  private shouldSync(): boolean {
    const now = Date.now();
    const timeSinceLastSync = now - this.lastSyncTime;
    return timeSinceLastSync >= this.storageConfig.cacheTTL;
  }

  /**
   * ç½‘ç»œåœ¨çº¿å¤„ç†
   */
  private onNetworkOnline(): void {
    this.logger.info('Network online, checking for category sync');
    
    if (this.shouldSync()) {
      this.syncCategories();
    }
  }

  /**
   * ç½‘ç»œç¦»çº¿å¤„ç†
   */
  private onNetworkOffline(): void {
    this.logger.info('Network offline, category sync paused');
    this.storageConfig.offlineMode = true;
  }

  /**
   * åŒæ­¥åˆ†ç±»æ•°æ®
   */
  public async syncCategories(): Promise<void> {
    if (this.isSyncing) {
      this.logger.warn('Category sync already in progress');
      return;
    }
    
    if (this.storageConfig.offlineMode) {
      this.logger.info('Category sync skipped (offline mode)');
      return;
    }
    
    this.isSyncing = true;
    
    try {
      this.logger.info('Starting category sync');
      
      // ä»APIè·å–åˆ†ç±»æ•°æ®
      const response = await this.fetchCategoriesFromAPI();
      
      if (response) {
        // æ›´æ–°åˆ†ç±»æ•°æ®
        await this.updateCategories(response.categories);
        
        // æ›´æ–°åˆ†ç»„æ•°æ®
        if (response.groups) {
          await this.updateGroups(response.groups);
        }
        
        // æ›´æ–°æœ€ååŒæ­¥æ—¶é—?        this.lastSyncTime = Date.now();
        
        // ä¿å­˜æœ¬åœ°æ•°æ®
        await this.saveLocalData();
        
        // å‘å¸ƒåŒæ­¥å®Œæˆäº‹ä»¶
        this.eventBus.emit(CategoryEventType.SYNCED, {
          type: CategoryEventType.SYNCED,
          timestamp: this.lastSyncTime,
          categories: response.categories,
          cacheHit: response.cacheHit
        });
        
        this.logger.info('Category sync completed', {
          categories: response.categories.length,
          groups: response.groups?.length || 0,
          cacheHit: response.cacheHit
        });
      }
    } catch (error) {
      this.Logger.error('Category sync failed', error as Error);
      
      // å‘å¸ƒé”™è¯¯äº‹ä»¶
      this.eventBus.emit(CategoryEventType.ERROR, {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
    } finally {
      this.isSyncing = false;
    }
  }

  /**
   * ä»APIè·å–åˆ†ç±»æ•°æ®
   */
  private async fetchCategoriesFromAPI(): Promise<CategoryResponse | null> {
    try {
      // æ„å»ºè¯·æ±‚URL
      const url = '/api/categories';
      const cacheKey = `categories:${Date.now()}`;
      
      // å°è¯•ä»ç¼“å­˜è·å?      const cachedResponse = await this.cacheService.getCache<CategoryResponse>(cacheKey);
      if (cachedResponse) {
        this.logger.debug('Category data loaded from cache');
        return { ...cachedResponse, cacheHit: true };
      }
      
      // ä»ç½‘ç»œè·å?      const response = await this.networkUtil.get(url);
      
      if (response.success && response.data) {
        const categoryResponse = response.data as CategoryResponse;
        
        // ç¼“å­˜å“åº”æ•°æ®
        await this.cacheService.setCache(cacheKey, categoryResponse, {
          expiry: this.storageConfig.cacheTTL,
          type: CacheType.MEMORY_DISK,
          policy: CachePolicy.STANDARD
        });
        
        return categoryResponse;
      }
      
      return null;
    } catch (error) {
      this.Logger.error('Failed to fetch categories from API', error as Error);
      throw error;
    }
  }

  /**
   * æ›´æ–°åˆ†ç±»æ•°æ®
   */
  private async updateCategories(newCategories: Category[]): Promise<void> {
    const updatedCategories: Category[] = [];
    const createdCategories: Category[] = [];
    
    for (const newCategory of newCategories) {
      const existingCategory = this.categories.get(newCategory.id);
      
      if (existingCategory) {
        // æ›´æ–°ç°æœ‰åˆ†ç±»
        const updatedCategory: Record<string, string | number | boolean | null> = { ... };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? string | number | boolean | null> = { ... };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(string | number | boolean | null> = { ... };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory instanceof Error ? ...newCategory };
        this.categories.set(newCategory.id, updatedCategory : new Error(String(...newCategory };
        this.categories.set(newCategory.id, updatedCategory)))))));
        updatedCategories.push(updatedCategory);
      } else {
        // æ·»åŠ æ–°åˆ†ç±?        this.categories.set(newCategory.id, newCategory);
        createdCategories.push(newCategory);
      }
    }
    
    // å‘å¸ƒäº‹ä»¶
    if (createdCategories.length > 0) {
      this.eventBus.emit(CategoryEventType.CREATED, {
        type: CategoryEventType.CREATED,
        timestamp: Date.now(),
        categories: createdCategories
      });
    }
    
    if (updatedCategories.length > 0) {
      this.eventBus.emit(CategoryEventType.UPDATED, {
        type: CategoryEventType.UPDATED,
        timestamp: Date.now(),
        categories: updatedCategories
      });
    }
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    this.updateStats();
  }

  /**
   * æ›´æ–°åˆ†ç»„æ•°æ®
   */
  private async updateGroups(newGroups: CategoryGroup[]): Promise<void> {
    const updatedGroups: CategoryGroup[] = [];
    const createdGroups: CategoryGroup[] = [];
    
    for (const newGroup of newGroups) {
      const existingGroup = this.groups.get(newGroup.id);
      
      if (existingGroup) {
        // æ›´æ–°ç°æœ‰åˆ†ç»„
        const updatedGroup: Record<string, string | number | boolean | null> = { ... };
        this.groups.set(newGroup.id, updatedGroup);
        updatedGroups.push(updatedGroup);
      } else {
        // æ·»åŠ æ–°åˆ†ç»?        this.groups.set(newGroup.id, newGroup);
        createdGroups.push(newGroup);
      }
    }
    
    // å‘å¸ƒäº‹ä»¶
    if (createdGroups.length > 0) {
      this.eventBus.emit(CategoryEventType.GROUP_CREATED, {
        type: CategoryEventType.GROUP_CREATED,
        timestamp: Date.now(),
        groups: createdGroups
      });
    }
    
    if (updatedGroups.length > 0) {
      this.eventBus.emit(CategoryEventType.GROUP_UPDATED, {
        type: CategoryEventType.GROUP_UPDATED,
        timestamp: Date.now(),
        groups: updatedGroups
      });
    }
  }

  /**
   * æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
   */
  private updateStats(): void {
    const now = Date.now();
    
    // é‡ç½®ç»Ÿè®¡ä¿¡æ¯
    this.stats = {
      totalCategories: this.categories.size,
      activeCategories: 0,
      featuredCategories: 0,
      followedCategories: this.followedCategories.size,
      byType: new Map(),
      byVisibility: new Map(),
      totalContentCount: 0,
      lastUpdated: now
    };
    
    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    for (const category of this.categories.values()) {
      // æŒ‰ç±»å‹ç»Ÿè®?      const typeCount = this.stats.byType.get(category.type) || 0;
      this.stats.byType.set(category.type, typeCount + 1);
      
      // æŒ‰å¯è§æ€§ç»Ÿè®?      const visibilityCount = this.stats.byVisibility.get(category.visibility) || 0;
      this.stats.byVisibility.set(category.visibility, visibilityCount + 1);
      
      // ç»Ÿè®¡æ´»è·ƒåˆ†ç±»
      if (category.status === 'active') {
        this.stats.activeCategories++;
      }
      
      // ç»Ÿè®¡ç²¾é€‰åˆ†ç±?      if (category.metadata.isFeatured) {
        this.stats.featuredCategories++;
      }
      
      // ç»Ÿè®¡å†…å®¹æ€»æ•°
      this.stats.totalContentCount += category.metadata.contentCount;
    }
    
    // å‘å¸ƒç»Ÿè®¡æ›´æ–°äº‹ä»¶
    this.eventBus.emit(CategoryEventType.CONTENT_COUNT_CHANGED, {
      type: CategoryEventType.CONTENT_COUNT_CHANGED,
      timestamp: now,
      contentCount: this.stats.totalContentCount
    });
  }

  /**
   * è·å–åˆ†ç±»åˆ—è¡¨
   * @param request åˆ†ç±»è¯·æ±‚
   */
  public async getCategories(request?: CategoryRequest): Promise<CategoryResponse> {
    if (!this.initialized) {
      throw new Error('CategoryRepository not initialized');
    }
    
    try {
      // æ£€æŸ¥æ˜¯å¦éœ€è¦åŒæ­?      if (this.shouldSync() && !this.isSyncing) {
        this.syncCategories();
      }
      
      // è·å–æ‰€æœ‰åˆ†ç±?      let categories = Array.from(this.categories.values());
      
      // åº”ç”¨è¿‡æ»¤å™?      if (request?.filter) {
        categories = this.filterCategories(categories, request.filter);
      }
      
      // åº”ç”¨æ’åº
      categories = this.sortCategories(categories, request?.filter?.sortBy);
      
      // åº”ç”¨åˆ†é¡µ
      const limit = request?.filter?.limit || 50;
      const offset = request?.filter?.offset || 0;
      const paginatedCategories = categories.slice(offset, offset + limit);
      
      // æ„å»ºå“åº”
      const response: CategoryResponse = {
        categories: paginatedCategories,
        totalCount: categories.length,
        hasMore: offset + limit < categories.length,
        timestamp: Date.now()
      };
      
      // åŒ…å«åˆ†ç»„ä¿¡æ¯
      if (request?.includeGroups) {
        response.groups = Array.from(this.groups.values());
      }
      
      this.logger.debug('Categories retrieved', {
        total: categories.length,
        returned: paginatedCategories.length,
        hasMore: response.hasMore
      });
      
      return response;
    } catch (error) {
      this.Logger.error('Failed to get categories', error as Error);
      
      // å‘å¸ƒé”™è¯¯äº‹ä»¶
      this.eventBus.emit(CategoryEventType.ERROR, {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * æ ¹æ®IDè·å–åˆ†ç±»
   * @param id åˆ†ç±»ID
   */
  public getCategoryById(id: string): Category | null {
    if (!this.initialized) {
      throw new Error('CategoryRepository not initialized');
    }
    
    return this.categories.get(id) || null;
  }

  /**
   * æ ¹æ®slugè·å–åˆ†ç±»
   * @param slug åˆ†ç±»slug
   */
  public getCategoryBySlug(slug: string): Category | null {
    if (!this.initialized) {
      throw new Error('CategoryRepository not initialized');
    }
    
    for (const category of this.categories.values()) {
      if (category.slug === slug) {
        return category;
      }
    }
    
    return null;
  }

  /**
   * è·å–åˆ†ç±»ç»„åˆ—è¡?   */
  public getCategoryGroups(): CategoryGroup[] {
    if (!this.initialized) {
      throw new Error('CategoryRepository not initialized');
    }
    
    return Array.from(this.groups.values());
  }

  /**
   * è·å–åˆ†ç±»ç»Ÿè®¡ä¿¡æ¯
   */
  public getCategoryStats(): CategoryStats {
    return { ...this.stats };
  }

  /**
   * å…³æ³¨åˆ†ç±»
   * @param categoryId åˆ†ç±»ID
   */
  public async followCategory(categoryId: string): Promise<void> {
    if (!this.initialized) {
      throw new Error('CategoryRepository not initialized');
    }
    
    try {
      const category = this.categories.get(categoryId);
      if (!category) {
        throw new Error(`Category not found: ${categoryId}`);
      }
      
      // æ·»åŠ å…³æ³¨
      this.followedCategories.add(categoryId);
      
      // æ›´æ–°åˆ†ç±»å…ƒæ•°æ?      category.metadata.isFollowing = true;
      category.metadata.followerCount++;
      
      // ä¿å­˜æœ¬åœ°æ•°æ®
      await this.saveLocalData();
      
      // å‘å¸ƒå…³æ³¨äº‹ä»¶
      this.eventBus.emit(CategoryEventType.FOLLOWED, {
        type: CategoryEventType.FOLLOWED,
        timestamp: Date.now(),
        category,
        contentCount: category.metadata.contentCount
      });
      
      this.logger.info(`Category followed: ${category.name}`);
    } catch (error) {
      this.Logger.error(`Failed to follow category: ${categoryId}`, error as Error);
      
      // å‘å¸ƒé”™è¯¯äº‹ä»¶
      this.eventBus.emit(CategoryEventType.ERROR, {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * å–æ¶ˆå…³æ³¨åˆ†ç±»
   * @param categoryId åˆ†ç±»ID
   */
  public async unfollowCategory(categoryId: string): Promise<void> {
    if (!this.initialized) {
      throw new Error('CategoryRepository not initialized');
    }
    
    try {
      const category = this.categories.get(categoryId);
      if (!category) {
        throw new Error(`Category not found: ${categoryId}`);
      }
      
      // ç§»é™¤å…³æ³¨
      this.followedCategories.delete(categoryId);
      
      // æ›´æ–°åˆ†ç±»å…ƒæ•°æ?      category.metadata.isFollowing = false;
      category.metadata.followerCount = Math.max(0, category.metadata.followerCount - 1);
      
      // ä¿å­˜æœ¬åœ°æ•°æ®
      await this.saveLocalData();
      
      // å‘å¸ƒå–æ¶ˆå…³æ³¨äº‹ä»¶
      this.eventBus.emit(CategoryEventType.UNFOLLOWED, {
        type: CategoryEventType.UNFOLLOWED,
        timestamp: Date.now(),
        category,
        contentCount: category.metadata.contentCount
      });
      
      this.logger.info(`Category unfollowed: ${category.name}`);
    } catch (error) {
      this.Logger.error(`Failed to unfollow category: ${categoryId}`, error as Error);
      
      // å‘å¸ƒé”™è¯¯äº‹ä»¶
      this.eventBus.emit(CategoryEventType.ERROR, {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²å…³æ³¨åˆ†ç±»
   * @param categoryId åˆ†ç±»ID
   */
  public isCategoryFollowed(categoryId: string): boolean {
    if (!this.initialized) {
      return false;
    }
    
    return this.followedCategories.has(categoryId);
  }

  /**
   * è·å–å·²å…³æ³¨çš„åˆ†ç±»åˆ—è¡¨
   */
  public getFollowedCategories(): Category[] {
    if (!this.initialized) {
      return [];
    }
    
    const followed: Category[] = [];
    
    for (const categoryId of this.followedCategories) {
      const category = this.categories.get(categoryId);
      if (category) {
        followed.push(category);
      }
    }
    
    return followed;
  }

  /**
   * è®¾ç½®åˆ†ç±»è‡ªå®šä¹‰æ’åº?   * @param categoryId åˆ†ç±»ID
   * @param orderIndex æ’åºç´¢å¼•
   */
  public async setCategoryOrder(categoryId: string, orderIndex: number): Promise<void> {
    if (!this.initialized) {
      throw new Error('CategoryRepository not initialized');
    }
    
    try {
      const category = this.categories.get(categoryId);
      if (!category) {
        throw new Error(`Category not found: ${categoryId}`);
      }
      
      // æ›´æ–°æ’åºç´¢å¼•
      this.customOrder.set(categoryId, orderIndex);
      category.orderIndex = orderIndex;
      
      // ä¿å­˜æœ¬åœ°æ•°æ®
      await this.saveLocalData();
      
      // å‘å¸ƒé‡æ–°æ’åºäº‹ä»¶
      this.eventBus.emit(CategoryEventType.REORDERED, {
        type: CategoryEventType.REORDERED,
        timestamp: Date.now(),
        category,
        previousOrderIndex: category.orderIndex
      });
      
      this.logger.debug(`Category order updated: ${category.name} -> ${orderIndex}`);
    } catch (error) {
      this.Logger.error(`Failed to set category order: ${categoryId}`, error as Error);
      
      // å‘å¸ƒé”™è¯¯äº‹ä»¶
      this.eventBus.emit(CategoryEventType.ERROR, {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * æ‰¹é‡æ›´æ–°åˆ†ç±»
   * @param categories åˆ†ç±»åˆ—è¡¨
   */
  public async updateCategoriesBatch(categories: Category[]): Promise<void> {
    if (!this.initialized) {
      throw new Error('CategoryRepository not initialized');
    }
    
    try {
      const updatedCategories: Category[] = [];
      
      for (const category of categories) {
        const existingCategory = this.categories.get(category.id);
        
        if (existingCategory) {
          // æ›´æ–°ç°æœ‰åˆ†ç±»
          const updatedCategory: Record<string, string | number | boolean | null> = { ... };
          this.categories.set(category.id, updatedCategory);
          updatedCategories.push(updatedCategory);
        } else {
          // æ·»åŠ æ–°åˆ†ç±?          this.categories.set(category.id, category);
          updatedCategories.push(category);
        }
      }
      
      // ä¿å­˜æœ¬åœ°æ•°æ®
      await this.saveLocalData();
      
      // å‘å¸ƒæ‰¹é‡æ›´æ–°äº‹ä»¶
      this.eventBus.emit(CategoryEventType.BATCH_UPDATED, {
        type: CategoryEventType.BATCH_UPDATED,
        timestamp: Date.now(),
        categories: updatedCategories
      });
      
      this.logger.info(`Categories batch updated: ${updatedCategories.length} categories`);
    } catch (error) {
      this.Logger.error('Failed to update categories batch', error as Error);
      
      // å‘å¸ƒé”™è¯¯äº‹ä»¶
      this.eventBus.emit(CategoryEventType.ERROR, {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }

  /**
   * è¿‡æ»¤åˆ†ç±»
   */
  private filterCategories(categories: Category[], filter: CategoryFilter): Category[] {
    return categories.filter(category => {
      // æ£€æŸ¥ç±»å?      if (filter.types && filter.types.length > 0 && !filter.types.includes(category.type)) {
        return false;
      }
      
      // æ£€æŸ¥å¯è§æ€?      if (filter.visibility && filter.visibility.length > 0 && !filter.visibility.includes(category.visibility)) {
        return false;
      }
      
      // æ£€æŸ¥æœç´¢è¯
      if (filter.searchTerm) {
        const searchTerm = filter.searchTerm.toLowerCase();
        const nameMatch = category.name.toLowerCase().includes(searchTerm);
        const slugMatch = category.slug.toLowerCase().includes(searchTerm);
        const descMatch = category.metadata.description?.toLowerCase().includes(searchTerm);
        
        if (!nameMatch && !slugMatch && !descMatch) {
          return false;
        }
      }
      
      // æ£€æŸ¥çˆ¶åˆ†ç±»ID
      if (filter.parentId && category.metadata.parentCategoryId !== filter.parentId) {
        return false;
      }
      
      // æ£€æŸ¥å­åˆ†ç±»
      if (filter.childOf && (!category.metadata.childCategoryIds || !category.metadata.childCategoryIds.includes(filter.childOf))) {
        return false;
      }
      
      // æ£€æŸ¥çŠ¶æ€?      if (filter.status && filter.status.length > 0 && !filter.status.includes(category.status)) {
        return false;
      }
      
      // æ£€æŸ¥ç²¾é€‰çŠ¶æ€?      if (filter.featured !== undefined && category.metadata.isFeatured !== filter.featured) {
        return false;
      }
      
      // æ£€æŸ¥å…³æ³¨çŠ¶æ€?      if (filter.followed !== undefined && this.followedCategories.has(category.id) !== filter.followed) {
        return false;
      }
      
      // æ£€æŸ¥å†…å®¹æ•°é‡èŒƒå›?      if (filter.contentCountMin && category.metadata.contentCount < filter.contentCountMin) {
        return false;
      }
      
      if (filter.contentCountMax && category.metadata.contentCount > filter.contentCountMax) {
        return false;
      }
      
      // æ£€æŸ¥æ ‡ç­?      if (filter.tags && filter.tags.length > 0) {
        const hasMatchingTag = filter.tags.some(tag => category.metadata.tags?.includes(tag));
        if (!hasMatchingTag) {
          return false;
        }
      }
      
      // æ£€æŸ¥è¯­è¨€
      if (filter.lang && category.localization && !category.localization[filter.lang]) {
        return false;
      }
      
      // æ£€æŸ¥åœ°åŒ?      if (filter.region && category.metadata.restrictedCountries?.includes(filter.region)) {
        return false;
      }
      
      return true;
    });
  }

  /**
   * æ’åºåˆ†ç±»
   */
  private sortCategories(categories: Category[], sortBy?: CategorySortType): Category[] {
    if (!sortBy) {
      return categories;
    }
    
    return [...categories].sort((a, b) => {
      switch (sortBy) {
        case CategorySortType.NAME_ASC:
          return a.name.localeCompare(b.name);
        
        case CategorySortType.NAME_DESC:
          return b.name.localeCompare(a.name);
        
        case CategorySortType.POPULARITY:
          return (b.metadata.viewCount || 0) - (a.metadata.viewCount || 0);
        
        case CategorySortType.TRENDING:
          // ç®€åŒ–å®ç°ï¼šåŸºäºæœ€åæ›´æ–°æ—¶é—?          return (b.metadata.lastUpdated || 0) - (a.metadata.lastUpdated || 0);
        
        case CategorySortType.RECENTLY_ADDED:
          return (b.metadata.createdAt || 0) - (a.metadata.createdAt || 0);
        
        case CategorySortType.CONTENT_COUNT:
          return (b.metadata.contentCount || 0) - (a.metadata.contentCount || 0);
        
        case CategorySortType.CUSTOM:
          const aOrder = this.customOrder.get(a.id) || a.orderIndex || 0;
          const bOrder = this.customOrder.get(b.id) || b.orderIndex || 0;
          return aOrder - bOrder;
        
        default:
          return 0;
      }
    });
  }

  /**
   * å…³é—­åˆ†ç±»ä»“åº“
   */
  public async shutdown(): Promise<void> {
    if (!this.initialized) {
      return;
    }
    
    try {
      // åœæ­¢è‡ªåŠ¨åŒæ­¥
      this.stopAutoSync();
      
      // ä¿å­˜æœ¬åœ°æ•°æ®
      await this.saveLocalData();
      
      // æ¸…ç©ºæ•°æ®
      this.categories.clear();
      this.groups.clear();
      this.followedCategories.clear();
      this.customOrder.clear();
      
      this.initialized = false;
      this.logger.info('CategoryRepository shutdown');
    } catch (error) {
      this.Logger.error('Failed to shutdown CategoryRepository', error as Error);
      
      // å‘å¸ƒé”™è¯¯äº‹ä»¶
      this.eventBus.emit(CategoryEventType.ERROR, {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now( instanceof Error ? {
        type: CategoryEventType.ERROR,
        timestamp: Date.now( : new Error(String({
        type: CategoryEventType.ERROR,
        timestamp: Date.now())))))),
        error: error as Error
      });
      
      throw error;
    }
  }
}


