// NotificationRepository - é€šçŸ¥ä»“åº“ç±?// è´Ÿè´£ç®¡ç†åº”ç”¨å†…é€šçŸ¥ã€ç³»ç»Ÿé€šçŸ¥å’Œç”¨æˆ·åå¥½è®¾ç½?
import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import EventBusUtil from '../../common/util/EventBusUtil';
import CacheService from '../../service/cache/CacheService';
import { LocalStorageType } from '../model/LocalModel';
import { CacheType } from '../model/CacheModel';

/**
 * é€šçŸ¥ç±»å‹æšä¸¾
 */
export enum NotificationType {
  // å†…å®¹é€šçŸ¥
  LIVE_START = 'live_start',
  LIVE_END = 'live_end',
  VIDEO_UPDATED = 'video_updated',
  SERIES_NEW_EPISODE = 'series_new_episode',
  RECOMMENDATION = 'recommendation',
  
  // ç¤¾äº¤é€šçŸ¥
  FOLLOWED_CHANNEL_LIVE = 'followed_channel_live',
  COMMENT_REPLY = 'comment_reply',
  MENTIONED = 'mentioned',
  LIKE = 'like',
  SHARE = 'share',
  
  // ç³»ç»Ÿé€šçŸ¥
  SYSTEM_ANNOUNCEMENT = 'system_announcement',
  MAINTENANCE_ALERT = 'maintenance_alert',
  FEATURE_UPDATE = 'feature_update',
  
  // ç”¨æˆ·ç›¸å…³é€šçŸ¥
  ACCOUNT_VERIFICATION = 'account_verification',
  PASSWORD_CHANGE = 'password_change',
  LOGIN_ACTIVITY = 'login_activity',
  SUBSCRIPTION_REMINDER = 'subscription_reminder',
  SUBSCRIPTION_EXPIRY = 'subscription_expiry',
  PAYMENT_SUCCESS = 'payment_success',
  PAYMENT_FAILED = 'payment_failed',
  
  // äº’åŠ¨é€šçŸ¥
  DOWNLOAD_COMPLETE = 'download_complete',
  DOWNLOAD_FAILED = 'download_failed',
  PLAYBACK_ERROR = 'playback_error',
  WATCHLIST_ADD = 'watchlist_add',
  WATCHLIST_REMOVE = 'watchlist_remove',
  
  // å®šåˆ¶é€šçŸ¥
  CUSTOM = 'custom',
  UNKNOWN = 'unknown'
}

/**
 * é€šçŸ¥ä¼˜å…ˆçº§æšä¸? */
export enum NotificationPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent'
}

/**
 * é€šçŸ¥çŠ¶æ€æšä¸? */
export enum NotificationStatus {
  NEW = 'new',
  READ = 'read',
  DISMISSED = 'dismissed',
  ARCHIVED = 'archived'
}

/**
 * é€šçŸ¥å†…å®¹æ¥å£
 */
export interface NotificationContent {
  title: string;
  body: string;
  imageUrl?: string;
  videoUrl?: string;
  thumbnailUrl?: string;
  deepLink?: string;
  actionText?: string;
  actionUrl?: string;
  actionData?: Record<string, unknown>;
}

/**
 * é€šçŸ¥å…ƒæ•°æ®æ¥å? */
export interface NotificationMetadata {
  relatedEntityId?: string;
  relatedEntityType?: 'video' | 'live' | 'user' | 'channel' | 'comment';
  senderId?: string;
  senderName?: string;
  senderAvatar?: string;
  timestamp: number;
  expiresAt?: number;
  isSilent: boolean;
  requiresInteraction: boolean;
  notificationGroup?: string;
  badgeCount?: number;
  customSound?: string;
  vibrationPattern?: number[];
}

/**
 * é€šçŸ¥æ¥å£
 */
export interface Notification {
  id: string;
  type: NotificationType;
  status: NotificationStatus;
  priority: NotificationPriority;
  content: NotificationContent;
  metadata: NotificationMetadata;
  readAt?: number;
  dismissedAt?: number;
  archivedAt?: number;
}

/**
 * é€šçŸ¥é…ç½®æ¥å£
 */
export interface NotificationConfig {
  // é€šç”¨è®¾ç½®
  enableNotifications: boolean;
  enableSound: boolean;
  enableVibration: boolean;
  enableLight: boolean;
  
  // ç±»å‹è®¾ç½®
  enabledTypes: NotificationType[];
  mutedTypes: NotificationType[];
  
  // æ—¶é—´æ®µè®¾ç½?  enableDoNotDisturb: boolean;
  doNotDisturbStart: string; // HH:MM
  doNotDisturbEnd: string; // HH:MM
  
  // ä¼˜å…ˆçº§è®¾ç½?  minPriority: NotificationPriority;
  
  // é«˜çº§è®¾ç½®
  enableBadgeCount: boolean;
  maxStoredNotifications: number;
  notificationHistoryDays: number;
  
  // é¢‘é“/ç”¨æˆ·ç‰¹å®šè®¾ç½®
  subscribedChannels: string[];
  mutedChannels: string[];
  
  // ç³»ç»Ÿé€šçŸ¥è®¾ç½®
  enableSystemNotifications: boolean;
  enableMaintenanceAlerts: boolean;
  enableFeatureUpdates: boolean;
  
  // ç¤¾äº¤é€šçŸ¥è®¾ç½®
  enableSocialNotifications: boolean;
  enableCommentReplies: boolean;
  enableMentions: boolean;
  enableLikes: boolean;
  enableShares: boolean;
  
  // å†…å®¹é€šçŸ¥è®¾ç½®
  enableLiveNotifications: boolean;
  enableVideoUpdateNotifications: boolean;
  enableRecommendationNotifications: boolean;
  
  // ç”¨æˆ·é€šçŸ¥è®¾ç½®
  enableAccountNotifications: boolean;
  enablePaymentNotifications: boolean;
  enableSubscriptionNotifications: boolean;
  
  // äº’åŠ¨é€šçŸ¥è®¾ç½®
  enableDownloadNotifications: boolean;
  enableErrorNotifications: boolean;
}

/**
 * é€šçŸ¥äº‹ä»¶ç±»å‹
 */
export const NotificationEventType = {
  // é€šçŸ¥ç”Ÿå‘½å‘¨æœŸäº‹ä»¶
  RECEIVED: 'notification:received',
  READ: 'notification:read',
  DISMISSED: 'notification:dismissed',
  ARCHIVED: 'notification:archived',
  RESTORED: 'notification:restored',
  
  // çŠ¶æ€å˜æ›´äº‹ä»?  STATUS_CHANGED: 'notification:statusChanged',
  BADGE_COUNT_CHANGED: 'notification:badgeCountChanged',
  
  // é…ç½®äº‹ä»¶
  CONFIG_CHANGED: 'notification:configChanged',
  DO_NOT_DISTURB_TOGGLED: 'notification:doNotDisturbToggled',
  
  // ç»„äº‹ä»?  GROUP_CREATED: 'notification:groupCreated',
  GROUP_UPDATED: 'notification:groupUpdated',
  
  // æ‰¹é‡äº‹ä»¶
  BATCH_MARKED_READ: 'notification:batchMarkedRead',
  BATCH_DISMISSED: 'notification:batchDismissed',
  BATCH_ARCHIVED: 'notification:batchArchived',
  CLEARED_ALL: 'notification:clearedAll',
  
  // è¿‡æ»¤äº‹ä»¶
  FILTER_APPLIED: 'notification:filterApplied',
  
  // ç»Ÿè®¡äº‹ä»¶
  STATS_UPDATED: 'notification:statsUpdated'
} as const;

/**
 * é€šçŸ¥äº‹ä»¶æ•°æ®
 */
export interface NotificationEvent {
  type: string;
  timestamp: number;
  notification?: Notification;
  notifications?: Notification[];
  notificationIds?: string[];
  status?: NotificationStatus;
  config?: NotificationConfig;
  badgeCount?: number;
  filter?: NotificationFilter;
  stats?: NotificationStats;
  error?: Error;
}

/**
 * é€šçŸ¥è¿‡æ»¤å™¨æ¥å? */
export interface NotificationFilter {
  types?: NotificationType[];
  status?: NotificationStatus[];
  priorities?: NotificationPriority[];
  startDate?: number;
  endDate?: number;
  searchTerm?: string;
  relatedEntityId?: string;
  relatedEntityType?: string;
  senderId?: string;
  limit?: number;
  offset?: number;
}

/**
 * é€šçŸ¥ç»Ÿè®¡æ¥å£
 */
export interface NotificationStats {
  totalCount: number;
  newCount: number;
  readCount: number;
  dismissedCount: number;
  archivedCount: number;
  byType: Map<NotificationType, number>;
  byPriority: Map<NotificationPriority, number>;
  bySender: Map<string, number>;
  lastReceivedTime: number;
  lastReadTime: number;
}

/**
 * é€šçŸ¥ç»„æ¥å? */
export interface NotificationGroup {
  id: string;
  title: string;
  summary: string;
  notificationIds: string[];
  count: number;
  newCount: number;
  timestamp: number;
  type: NotificationType;
  priority: NotificationPriority;
  senderId?: string;
  relatedEntityId?: string;
}

/**
 * é€šçŸ¥ä»“åº“ç±? */
export class NotificationRepository {
  private static instance: NotificationRepository;
  private logger = Logger.getInstance();
  private storageUtil = StorageUtil.getInstance();
  private eventBus = EventBusUtil.getInstance();
  private cacheService = CacheService.getInstance();
  
  // å­˜å‚¨é”®é…ç½?  private storageKeys = {
    notifications: 'notification:notifications',
    config: 'notification:config',
    stats: 'notification:stats',
    groups: 'notification:groups',
    badgeCount: 'notification:badgeCount'
  };
  
  // ç¼“å­˜é”®é…ç½?  private cacheKeys = {
    notifications: 'notification:notifications',
    config: 'notification:config',
    stats: 'notification:stats',
    groups: 'notification:groups'
  };
  
  // é»˜è®¤é…ç½®
  private defaultConfig: NotificationConfig = {
    enableNotifications: true,
    enableSound: true,
    enableVibration: true,
    enableLight: true,
    enabledTypes: Object.values(NotificationType),
    mutedTypes: [],
    enableDoNotDisturb: false,
    doNotDisturbStart: '22:00',
    doNotDisturbEnd: '08:00',
    minPriority: NotificationPriority.LOW,
    enableBadgeCount: true,
    maxStoredNotifications: 1000,
    notificationHistoryDays: 30,
    subscribedChannels: [],
    mutedChannels: [],
    enableSystemNotifications: true,
    enableMaintenanceAlerts: true,
    enableFeatureUpdates: true,
    enableSocialNotifications: true,
    enableCommentReplies: true,
    enableMentions: true,
    enableLikes: true,
    enableShares: true,
    enableLiveNotifications: true,
    enableVideoUpdateNotifications: true,
    enableRecommendationNotifications: true,
    enableAccountNotifications: true,
    enablePaymentNotifications: true,
    enableSubscriptionNotifications: true,
    enableDownloadNotifications: true,
    enableErrorNotifications: true
  };
  
  // å†…éƒ¨çŠ¶æ€?  private notifications: Map<string, Notification> = new Map();
  private groups: Map<string, NotificationGroup> = new Map();
  private config: NotificationConfig = this.defaultConfig;
  private stats: NotificationStats = this.createDefaultStats();
  private badgeCount: number = 0;
  private isInitialized: boolean = false;
  
  /**
   * ç§æœ‰æ„é€ å‡½æ•?   */
  private constructor() {
    // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
    this.setupEventListeners();
  }
  
  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): NotificationRepository {
    if (!NotificationRepository.instance) {
      NotificationRepository.instance = new NotificationRepository();
    }
    return NotificationRepository.instance;
  }
  
  /**
   * åˆå§‹åŒ–ä»“åº?   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }
    
    try {
      // åŠ è½½é…ç½®
      await this.loadConfig();
      
      // åŠ è½½é€šçŸ¥æ•°æ®
      await this.loadNotifications();
      
      // åŠ è½½ç»Ÿè®¡ä¿¡æ¯
      await this.loadStats();
      
      // åŠ è½½åˆ†ç»„ä¿¡æ¯
      await this.loadGroups();
      
      // åŠ è½½å¾½ç« è®¡æ•°
      await this.loadBadgeCount();
      
      this.isInitialized = true;
      this.logger.info('NotificationRepository initialized successfully');
    } catch (error) {
      this.Logger.error('Failed to initialize NotificationRepository:', error);
      throw error;
    }
  }
  
  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬å™?   */
  private setupEventListeners(): void {
    // ç›‘å¬åº”ç”¨ç”Ÿå‘½å‘¨æœŸäº‹ä»¶
    this.eventBus.on('app:foreground', ( instanceof Error ? ( : new Error(String(( instanceof Error ? ( instanceof Error ? ( : new Error(String(( : new Error(String(( instanceof Error ? ( : new Error(String(( instanceof Error ? ( instanceof Error ? ( : new Error(String(( instanceof Error ? ( instanceof Error ? ( : new Error(String(( : new Error(String(( instanceof Error ? ( : new Error(String(( : new Error(String(( instanceof Error ? ( : new Error(String(( instanceof Error ? ( instanceof Error ? ( : new Error(String(( : new Error(String(( instanceof Error ? ( : new Error(String(())))))) => {
      this.handleAppForeground();
    });
    
    this.eventBus.on('app:background', () => {
      this.handleAppBackground();
    });
    
    // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ?    this.eventBus.on('network:online', () => {
      this.handleNetworkOnline();
    });
    
    this.eventBus.on('network:offline', () => {
      this.handleNetworkOffline();
    });
    
    // ç›‘å¬å­˜å‚¨å˜åŒ–
    this.eventBus.on('storage:changed', (event) => {
      this.handleStorageChanged(event);
    });
  }
  
  /**
   * åˆ›å»ºé»˜è®¤ç»Ÿè®¡ä¿¡æ¯
   */
  private createDefaultStats(): NotificationStats {
    return {
      totalCount: 0,
      newCount: 0,
      readCount: 0,
      dismissedCount: 0,
      archivedCount: 0,
      byType: new Map(),
      byPriority: new Map(),
      bySender: new Map(),
      lastReceivedTime: 0,
      lastReadTime: 0
    };
  }
  
  /**
   * åŠ è½½é…ç½®
   */
  private async loadConfig(): Promise<void> {
    try {
      const config = await this.storageUtil.get<NotificationConfig>(
        this.storageKeys.config,
        LocalStorageType.PERSISTENT
      );
      
      if (config) {
        this.config = { ...this.defaultConfig, ...config };
      } else {
        this.config = this.defaultConfig;
        await this.saveConfig();
      }
      
      // ç¼“å­˜é…ç½®
      await this.cacheService.set(
        this.cacheKeys.config,
        this.config,
        CacheType.PERSISTENT,
        3600 // 1å°æ—¶
      );
    } catch (error) {
      this.Logger.error('Failed to load notification config:', error);
      this.config = this.defaultConfig;
    }
  }
  
  /**
   * ä¿å­˜é…ç½®
   */
  private async saveConfig(): Promise<void> {
    try {
      await this.storageUtil.set(
        this.storageKeys.config, this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.config,
        LocalStorageType.PERSISTENT
       : new Error(String(this.config,
        LocalStorageType.PERSISTENT
      )))))));
      
      // æ›´æ–°ç¼“å­˜
      await this.cacheService.set(
        this.cacheKeys.config,
        this.config,
        CacheType.PERSISTENT,
        3600
      );
      
      // å‘å¸ƒé…ç½®å˜æ›´äº‹ä»¶
      this.eventBus.emit(NotificationEventType.CONFIG_CHANGED, {
        type: NotificationEventType.CONFIG_CHANGED,
        timestamp: Date.now(),
        config: this.config
      });
    } catch (error) {
      this.Logger.error('Failed to save notification config:', error);
    }
  }
  
  /**
   * åŠ è½½é€šçŸ¥æ•°æ®
   */
  private async loadNotifications(): Promise<void> {
    try {
      const notifications = await this.storageUtil.get<Notification[]>(
        this.storageKeys.notifications, LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
      )))))));
      
      if (notifications) {
        this.notifications.clear();
        notifications.forEach(notification => {
          this.notifications.set(notification.id, notification);
        });
      }
      
      // ç¼“å­˜é€šçŸ¥æ•°æ®
      await this.cacheService.set(
        this.cacheKeys.notifications,
        Array.from(this.notifications.values()),
        CacheType.PERSISTENT,
        300 // 5åˆ†é’Ÿ
      );
    } catch (error) {
      this.Logger.error('Failed to load notifications:', error);
      this.notifications.clear();
    }
  }
  
  /**
   * ä¿å­˜é€šçŸ¥æ•°æ®
   */
  private async saveNotifications(): Promise<void> {
    try {
      const notifications = Array.from(this.notifications.values());
      
      await this.storageUtil.set(
        this.storageKeys.notifications, notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
       instanceof Error ? notifications,
        LocalStorageType.PERSISTENT
       : new Error(String(notifications,
        LocalStorageType.PERSISTENT
      )))))));
      
      // æ›´æ–°ç¼“å­˜
      await this.cacheService.set(
        this.cacheKeys.notifications,
        notifications,
        CacheType.PERSISTENT,
        300
      );
    } catch (error) {
      this.Logger.error('Failed to save notifications:', error);
    }
  }
  
  /**
   * åŠ è½½ç»Ÿè®¡ä¿¡æ¯
   */
  private async loadStats(): Promise<void> {
    try {
      const stats = await this.storageUtil.get<NotificationStats>(
        this.storageKeys.stats, LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
      )))))));
      
      if (stats) {
        this.stats = stats;
      } else {
        this.stats = this.createDefaultStats();
        await this.saveStats();
      }
      
      // ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
      await this.cacheService.set(
        this.cacheKeys.stats,
        this.stats,
        CacheType.PERSISTENT,
        600 // 10åˆ†é’Ÿ
      );
    } catch (error) {
      this.Logger.error('Failed to load notification stats:', error);
      this.stats = this.createDefaultStats();
    }
  }
  
  /**
   * ä¿å­˜ç»Ÿè®¡ä¿¡æ¯
   */
  private async saveStats(): Promise<void> {
    try {
      await this.storageUtil.set(
        this.storageKeys.stats, this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.stats,
        LocalStorageType.PERSISTENT
       : new Error(String(this.stats,
        LocalStorageType.PERSISTENT
      )))))));
      
      // æ›´æ–°ç¼“å­˜
      await this.cacheService.set(
        this.cacheKeys.stats,
        this.stats,
        CacheType.PERSISTENT,
        600
      );
      
      // å‘å¸ƒç»Ÿè®¡æ›´æ–°äº‹ä»¶
      this.eventBus.emit(NotificationEventType.STATS_UPDATED, {
        type: NotificationEventType.STATS_UPDATED,
        timestamp: Date.now(),
        stats: this.stats
      });
    } catch (error) {
      this.Logger.error('Failed to save notification stats:', error);
    }
  }
  
  /**
   * åŠ è½½åˆ†ç»„ä¿¡æ¯
   */
  private async loadGroups(): Promise<void> {
    try {
      const groups = await this.storageUtil.get<NotificationGroup[]>(
        this.storageKeys.groups, LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
      )))))));
      
      if (groups) {
        this.groups.clear();
        groups.forEach(group => {
          this.groups.set(group.id, group);
        });
      }
      
      // ç¼“å­˜åˆ†ç»„ä¿¡æ¯
      await this.cacheService.set(
        this.cacheKeys.groups,
        Array.from(this.groups.values()),
        CacheType.PERSISTENT,
        300
      );
    } catch (error) {
      this.Logger.error('Failed to load notification groups:', error);
      this.groups.clear();
    }
  }
  
  /**
   * ä¿å­˜åˆ†ç»„ä¿¡æ¯
   */
  private async saveGroups(): Promise<void> {
    try {
      const groups = Array.from(this.groups.values());
      
      await this.storageUtil.set(
        this.storageKeys.groups, groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
       instanceof Error ? groups,
        LocalStorageType.PERSISTENT
       : new Error(String(groups,
        LocalStorageType.PERSISTENT
      )))))));
      
      // æ›´æ–°ç¼“å­˜
      await this.cacheService.set(
        this.cacheKeys.groups,
        groups,
        CacheType.PERSISTENT,
        300
      );
    } catch (error) {
      this.Logger.error('Failed to save notification groups:', error);
    }
  }
  
  /**
   * åŠ è½½å¾½ç« è®¡æ•°
   */
  private async loadBadgeCount(): Promise<void> {
    try {
      const badgeCount = await this.storageUtil.get<number>(
        this.storageKeys.badgeCount, LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
       instanceof Error ? LocalStorageType.PERSISTENT
       : new Error(String(LocalStorageType.PERSISTENT
      )))))));
      
      if (badgeCount !== undefined) {
        this.badgeCount = badgeCount;
      }
    } catch (error) {
      this.Logger.error('Failed to load badge count:', error);
      this.badgeCount = 0;
    }
  }
  
  /**
   * ä¿å­˜å¾½ç« è®¡æ•°
   */
  private async saveBadgeCount(): Promise<void> {
    try {
      await this.storageUtil.set(
        this.storageKeys.badgeCount, this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
       instanceof Error ? this.badgeCount,
        LocalStorageType.PERSISTENT
       : new Error(String(this.badgeCount,
        LocalStorageType.PERSISTENT
      )))))));
      
      // å‘å¸ƒå¾½ç« è®¡æ•°å˜æ›´äº‹ä»¶
      this.eventBus.emit(NotificationEventType.BADGE_COUNT_CHANGED, {
        type: NotificationEventType.BADGE_COUNT_CHANGED,
        timestamp: Date.now(),
        badgeCount: this.badgeCount
      });
    } catch (error) {
      this.Logger.error('Failed to save badge count:', error);
    }
  }
  
  /**
   * å¤„ç†åº”ç”¨è¿›å…¥å‰å°
   */
  private handleAppForeground(): void {
    this.logger.debug('NotificationRepository: App entered foreground');
    // å¯ä»¥åœ¨è¿™é‡Œæ‰§è¡Œä¸€äº›å‰å°æ“ä½œï¼Œå¦‚åˆ·æ–°é€šçŸ¥ç­?  }
  
  /**
   * å¤„ç†åº”ç”¨è¿›å…¥åå°
   */
  private handleAppBackground(): void {
    this.logger.debug('NotificationRepository: App entered background');
    // å¯ä»¥åœ¨è¿™é‡Œæ‰§è¡Œä¸€äº›åå°æ“ä½œï¼Œå¦‚ä¿å­˜æ•°æ®ç­‰
    this.saveAllData();
  }
  
  /**
   * å¤„ç†ç½‘ç»œåœ¨çº¿
   */
  private handleNetworkOnline(): void {
    this.logger.debug('NotificationRepository: Network online');
    // å¯ä»¥åœ¨è¿™é‡Œæ‰§è¡Œä¸€äº›ç½‘ç»œæ¢å¤åçš„æ“ä½?  }
  
  /**
   * å¤„ç†ç½‘ç»œç¦»çº¿
   */
  private handleNetworkOffline(): void {
    this.logger.debug('NotificationRepository: Network offline');
    // å¯ä»¥åœ¨è¿™é‡Œæ‰§è¡Œä¸€äº›ç½‘ç»œæ–­å¼€åçš„æ“ä½œ
  }
  
  /**
   * å¤„ç†å­˜å‚¨å˜åŒ–
   */
  private handleStorageChanged(event: Record<string, string | number | boolean | null> instanceof Error ? string | number | boolean | null> : new Error(String(string | number | boolean | null>))): void {
    this.logger.debug('NotificationRepository: Storage changed', event instanceof Error ? event : new Error(String(event instanceof Error ? event instanceof Error ? event : new Error(String(event : new Error(String(event instanceof Error ? event : new Error(String(event)))));
    // å¯ä»¥åœ¨è¿™é‡Œå¤„ç†å­˜å‚¨å˜åŒ–äº‹ä»?  }
  
  /**
   * ä¿å­˜æ‰€æœ‰æ•°æ?   */
  private async saveAllData(): Promise<void> {
    try {
      await Promise.all([
        this.saveNotifications(),
        this.saveConfig(),
        this.saveStats(),
        this.saveGroups(),
        this.saveBadgeCount()
      ]);
      this.logger.debug('NotificationRepository: All data saved successfully');
    } catch (error) {
      this.Logger.error('Failed to save all notification data:', error);
    }
  }
  
  /**
   * è·å–é€šçŸ¥é…ç½®
   */
  public getConfig(): NotificationConfig {
    return { ...this.config };
  }
  
  /**
   * æ›´æ–°é€šçŸ¥é…ç½®
   */
  public async updateConfig(updates: Partial<NotificationConfig>): Promise<void> {
    this.config = { ...this.config, ...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig( instanceof Error ? ...updates };
    await this.saveConfig( : new Error(String(...updates };
    await this.saveConfig()))))));
  }
  
  /**
   * é‡ç½®é€šçŸ¥é…ç½®ä¸ºé»˜è®¤å€?   */
  public async resetConfig(): Promise<void> {
    this.config = this.defaultConfig;
    await this.saveConfig();
  }
  
  /**
   * æ£€æŸ¥é€šçŸ¥ç±»å‹æ˜¯å¦å¯ç”¨
   */
  public isTypeEnabled(type: NotificationType): boolean {
    return this.config.enabledTypes.includes(type) && 
           !this.config.mutedTypes.includes(type);
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦åœ¨å…æ‰“æ‰°æ—¶é—´æ®µ
   */
  public isInDoNotDisturb(): boolean {
    if (!this.config.enableDoNotDisturb) {
      return false;
    }
    
    const now = new Date();
    const currentTime = now.getHours() * 60 + now.getMinutes();
    
    const [startHour, startMinute] = this.config.doNotDisturbStart.split(':').map(Number);
    const [endHour, endMinute] = this.config.doNotDisturbEnd.split(':').map(Number);
    
    const startTime = startHour * 60 + startMinute;
    const endTime = endHour * 60 + endMinute;
    
    if (startTime < endTime) {
      return currentTime >= startTime && currentTime < endTime;
    } else {
      return currentTime >= startTime || currentTime < endTime;
    }
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥å‘é€é€šçŸ¥
   */
  public canSendNotification(notification: Notification): boolean {
    if (!this.config.enableNotifications) {
      return false;
    }
    
    if (!this.isTypeEnabled(notification.type)) {
      return false;
    }
    
    if (this.isInDoNotDisturb() && notification.priority !== NotificationPriority.URGENT) {
      return false;
    }
    
    if (this.getPriorityLevel(notification.priority) < this.getPriorityLevel(this.config.minPriority)) {
      return false;
    }
    
    return true;
  }
  
  /**
   * è·å–ä¼˜å…ˆçº§çº§åˆ?   */
  private getPriorityLevel(priority: NotificationPriority): number {
    switch (priority) {
      case NotificationPriority.URGENT: return 4;
      case NotificationPriority.HIGH: return 3;
      case NotificationPriority.MEDIUM: return 2;
      case NotificationPriority.LOW: return 1;
      default: return 0;
    }
  }
  
  /**
   * æ·»åŠ é€šçŸ¥
   */
  public async addNotification(notification: Notification): Promise<boolean> {
    if (!this.canSendNotification(notification)) {
      this.logger.debug('Notification blocked by settings:', notification.id);
      return false;
    }
    
    try {
      // æ£€æŸ¥é€šçŸ¥æ˜¯å¦å·²å­˜åœ?      if (this.notifications.has(notification.id)) {
        this.logger.debug('Notification already exists:', notification.id);
        return false;
      }
      
      // æ·»åŠ é€šçŸ¥
      this.notifications.set(notification.id, notification);
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.updateStatsForNewNotification(notification);
      
      // æ›´æ–°å¾½ç« è®¡æ•°
      if (notification.status === NotificationStatus.NEW) {
        this.badgeCount++;
        await this.saveBadgeCount();
      }
      
      // æ›´æ–°åˆ†ç»„
      await this.updateGroupsForNotification(notification);
      
      // ä¿å­˜æ•°æ®
      await this.saveNotifications();
      await this.saveStats();
      
      // å‘å¸ƒé€šçŸ¥æ¥æ”¶äº‹ä»¶
      this.eventBus.emit(NotificationEventType.RECEIVED, {
        type: NotificationEventType.RECEIVED,
        timestamp: Date.now(),
        notification: notification
      });
      
      this.logger.debug('Notification added successfully:', notification.id);
      return true;
    } catch (error) {
      this.Logger.error('Failed to add notification:', error);
      return false;
    }
  }
  
  /**
   * æ‰¹é‡æ·»åŠ é€šçŸ¥
   */
  public async addNotifications(notifications: Notification[]): Promise<number> {
    let successCount = 0;
    
    for (const notification of notifications) {
      if (await this.addNotification(notification)) {
        successCount++;
      }
    }
    
    this.logger.debug(`Added ${successCount} out of ${notifications.length} notifications`);
    return successCount;
  }
  
  /**
   * è·å–é€šçŸ¥
   */
  public getNotification(id: string): Notification | undefined {
    return this.notifications.get(id);
  }
  
  /**
   * è·å–æ‰€æœ‰é€šçŸ¥
   */
  public getAllNotifications(): Notification[] {
    return Array.from(this.notifications.values());
  }
  
  /**
   * è·å–è¿‡æ»¤åçš„é€šçŸ¥
   */
  public getFilteredNotifications(filter: NotificationFilter): Notification[] {
    let notifications = this.getAllNotifications();
    
    // æŒ‰ç±»å‹è¿‡æ»?    if (filter.types && filter.types.length > 0) {
      notifications = notifications.filter(n => filter.types!.includes(n.type));
    }
    
    // æŒ‰çŠ¶æ€è¿‡æ»?    if (filter.status && filter.status.length > 0) {
      notifications = notifications.filter(n => filter.status!.includes(n.status));
    }
    
    // æŒ‰ä¼˜å…ˆçº§è¿‡æ»¤
    if (filter.priorities && filter.priorities.length > 0) {
      notifications = notifications.filter(n => filter.priorities!.includes(n.priority));
    }
    
    // æŒ‰æ—¶é—´èŒƒå›´è¿‡æ»?    if (filter.startDate) {
      notifications = notifications.filter(n => n.metadata.timestamp >= filter.startDate!);
    }
    
    if (filter.endDate) {
      notifications = notifications.filter(n => n.metadata.timestamp <= filter.endDate!);
    }
    
    // æŒ‰æœç´¢è¯è¿‡æ»¤
    if (filter.searchTerm) {
      const searchTerm = filter.searchTerm.toLowerCase();
      notifications = notifications.filter(n => 
        n.content.title.toLowerCase().includes(searchTerm) ||
        n.content.body.toLowerCase().includes(searchTerm)
      );
    }
    
    // æŒ‰ç›¸å…³å®ä½“è¿‡æ»?    if (filter.relatedEntityId) {
      notifications = notifications.filter(n => n.metadata.relatedEntityId === filter.relatedEntityId);
    }
    
    if (filter.relatedEntityType) {
      notifications = notifications.filter(n => n.metadata.relatedEntityType === filter.relatedEntityType);
    }
    
    // æŒ‰å‘é€è€…è¿‡æ»?    if (filter.senderId) {
      notifications = notifications.filter(n => n.metadata.senderId === filter.senderId);
    }
    
    // æ’åºï¼ˆæŒ‰æ—¶é—´å€’åºï¼?    notifications.sort((a, b instanceof Error ? b : new Error(String(b instanceof Error ? b instanceof Error ? b : new Error(String(b : new Error(String(b instanceof Error ? b : new Error(String(b instanceof Error ? b instanceof Error ? b : new Error(String(b instanceof Error ? b instanceof Error ? b : new Error(String(b : new Error(String(b instanceof Error ? b : new Error(String(b : new Error(String(b instanceof Error ? b : new Error(String(b instanceof Error ? b instanceof Error ? b : new Error(String(b : new Error(String(b instanceof Error ? b : new Error(String(b))))))) => b.metadata.timestamp - a.metadata.timestamp);
    
    // åˆ†é¡µ
    if (filter.limit) {
      const offset = filter.offset || 0;
      notifications = notifications.slice(offset, offset + filter.limit);
    }
    
    return notifications;
  }
  
  /**
   * æ ‡è®°é€šçŸ¥ä¸ºå·²è¯?   */
  public async markAsRead(id: string): Promise<boolean> {
    try {
      const notification = this.notifications.get(id);
      if (!notification) {
        return false;
      }
      
      if (notification.status === NotificationStatus.READ) {
        return true; // å·²ç»æ˜¯å·²è¯»çŠ¶æ€?      }
      
      // æ›´æ–°çŠ¶æ€?      notification.status = NotificationStatus.READ;
      notification.readAt = Date.now();
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.updateStatsForStatusChange(notification, NotificationStatus.READ);
      
      // æ›´æ–°å¾½ç« è®¡æ•°
      if (this.badgeCount > 0) {
        this.badgeCount--;
        await this.saveBadgeCount();
      }
      
      // ä¿å­˜æ•°æ®
      await this.saveNotifications();
      await this.saveStats();
      
      // å‘å¸ƒé€šçŸ¥å·²è¯»äº‹ä»¶
      this.eventBus.emit(NotificationEventType.READ, {
        type: NotificationEventType.READ,
        timestamp: Date.now(),
        notification: notification
      });
      
      this.logger.debug('Notification marked as read:', id);
      return true;
    } catch (error) {
      this.Logger.error('Failed to mark notification as read:', error);
      return false;
    }
  }
  
  /**
   * æ‰¹é‡æ ‡è®°ä¸ºå·²è¯?   */
  public async markAsReadBatch(ids: string[]): Promise<number> {
    let successCount = 0;
    
    for (const id of ids) {
      if (await this.markAsRead(id)) {
        successCount++;
      }
    }
    
    if (successCount > 0) {
      // å‘å¸ƒæ‰¹é‡æ ‡è®°å·²è¯»äº‹ä»¶
      this.eventBus.emit(NotificationEventType.BATCH_MARKED_READ, {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_MARKED_READ,
        timestamp: Date.now())))))),
        notificationIds: ids,
        count: successCount
      });
    }
    
    this.logger.debug(`Marked ${successCount} out of ${ids.length} notifications as read`);
    return successCount;
  }
  
  /**
   * æ ‡è®°é€šçŸ¥ä¸ºå·²å…³é—­
   */
  public async dismissNotification(id: string): Promise<boolean> {
    try {
      const notification = this.notifications.get(id);
      if (!notification) {
        return false;
      }
      
      if (notification.status === NotificationStatus.DISMISSED) {
        return true; // å·²ç»æ˜¯å·²å…³é—­çŠ¶æ€?      }
      
      // æ›´æ–°çŠ¶æ€?      notification.status = NotificationStatus.DISMISSED;
      notification.dismissedAt = Date.now();
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.updateStatsForStatusChange(notification, NotificationStatus.DISMISSED);
      
      // æ›´æ–°å¾½ç« è®¡æ•°
      if (notification.status === NotificationStatus.NEW && this.badgeCount > 0) {
        this.badgeCount--;
        await this.saveBadgeCount();
      }
      
      // ä¿å­˜æ•°æ®
      await this.saveNotifications();
      await this.saveStats();
      
      // å‘å¸ƒé€šçŸ¥å…³é—­äº‹ä»¶
      this.eventBus.emit(NotificationEventType.DISMISSED, {
        type: NotificationEventType.DISMISSED,
        timestamp: Date.now(),
        notification: notification
      });
      
      this.logger.debug('Notification dismissed:', id);
      return true;
    } catch (error) {
      this.Logger.error('Failed to dismiss notification:', error);
      return false;
    }
  }
  
  /**
   * æ‰¹é‡æ ‡è®°ä¸ºå·²å…³é—­
   */
  public async dismissNotificationsBatch(ids: string[]): Promise<number> {
    let successCount = 0;
    
    for (const id of ids) {
      if (await this.dismissNotification(id)) {
        successCount++;
      }
    }
    
    if (successCount > 0) {
      // å‘å¸ƒæ‰¹é‡å…³é—­äº‹ä»¶
      this.eventBus.emit(NotificationEventType.BATCH_DISMISSED, {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_DISMISSED,
        timestamp: Date.now())))))),
        notificationIds: ids,
        count: successCount
      });
    }
    
    this.logger.debug(`Dismissed ${successCount} out of ${ids.length} notifications`);
    return successCount;
  }
  
  /**
   * å½’æ¡£é€šçŸ¥
   */
  public async archiveNotification(id: string): Promise<boolean> {
    try {
      const notification = this.notifications.get(id);
      if (!notification) {
        return false;
      }
      
      if (notification.status === NotificationStatus.ARCHIVED) {
        return true; // å·²ç»æ˜¯å½’æ¡£çŠ¶æ€?      }
      
      // æ›´æ–°çŠ¶æ€?      notification.status = NotificationStatus.ARCHIVED;
      notification.archivedAt = Date.now();
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.updateStatsForStatusChange(notification, NotificationStatus.ARCHIVED);
      
      // æ›´æ–°å¾½ç« è®¡æ•°
      if (notification.status === NotificationStatus.NEW && this.badgeCount > 0) {
        this.badgeCount--;
        await this.saveBadgeCount();
      }
      
      // ä¿å­˜æ•°æ®
      await this.saveNotifications();
      await this.saveStats();
      
      // å‘å¸ƒé€šçŸ¥å½’æ¡£äº‹ä»¶
      this.eventBus.emit(NotificationEventType.ARCHIVED, {
        type: NotificationEventType.ARCHIVED,
        timestamp: Date.now(),
        notification: notification
      });
      
      this.logger.debug('Notification archived:', id);
      return true;
    } catch (error) {
      this.Logger.error('Failed to archive notification:', error);
      return false;
    }
  }
  
  /**
   * æ‰¹é‡å½’æ¡£é€šçŸ¥
   */
  public async archiveNotificationsBatch(ids: string[]): Promise<number> {
    let successCount = 0;
    
    for (const id of ids) {
      if (await this.archiveNotification(id)) {
        successCount++;
      }
    }
    
    if (successCount > 0) {
      // å‘å¸ƒæ‰¹é‡å½’æ¡£äº‹ä»¶
      this.eventBus.emit(NotificationEventType.BATCH_ARCHIVED, {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.BATCH_ARCHIVED,
        timestamp: Date.now())))))),
        notificationIds: ids,
        count: successCount
      });
    }
    
    this.logger.debug(`Archived ${successCount} out of ${ids.length} notifications`);
    return successCount;
  }
  
  /**
   * æ¢å¤é€šçŸ¥
   */
  public async restoreNotification(id: string): Promise<boolean> {
    try {
      const notification = this.notifications.get(id);
      if (!notification) {
        return false;
      }
      
      if (notification.status === NotificationStatus.NEW) {
        return true; // å·²ç»æ˜¯æ–°çŠ¶æ€?      }
      
      // æ¢å¤çŠ¶æ€?      const oldStatus = notification.status;
      notification.status = NotificationStatus.NEW;
      notification.readAt = undefined;
      notification.dismissedAt = undefined;
      notification.archivedAt = undefined;
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.updateStatsForStatusChange(notification, oldStatus, NotificationStatus.NEW);
      
      // æ›´æ–°å¾½ç« è®¡æ•°
      this.badgeCount++;
      await this.saveBadgeCount();
      
      // ä¿å­˜æ•°æ®
      await this.saveNotifications();
      await this.saveStats();
      
      // å‘å¸ƒé€šçŸ¥æ¢å¤äº‹ä»¶
      this.eventBus.emit(NotificationEventType.RESTORED, {
        type: NotificationEventType.RESTORED,
        timestamp: Date.now(),
        notification: notification
      });
      
      this.logger.debug('Notification restored:', id);
      return true;
    } catch (error) {
      this.Logger.error('Failed to restore notification:', error);
      return false;
    }
  }
  
  /**
   * åˆ é™¤é€šçŸ¥
   */
  public async deleteNotification(id: string): Promise<boolean> {
    try {
      const notification = this.notifications.get(id);
      if (!notification) {
        return false;
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.updateStatsForDelete(notification);
      
      // æ›´æ–°å¾½ç« è®¡æ•°
      if (notification.status === NotificationStatus.NEW && this.badgeCount > 0) {
        this.badgeCount--;
        await this.saveBadgeCount();
      }
      
      // åˆ é™¤é€šçŸ¥
      this.notifications.delete(id);
      
      // ä»åˆ†ç»„ä¸­ç§»é™¤
      await this.removeNotificationFromGroups(id);
      
      // ä¿å­˜æ•°æ®
      await this.saveNotifications();
      await this.saveStats();
      
      this.logger.debug('Notification deleted:', id instanceof Error ? id : new Error(String(id instanceof Error ? id instanceof Error ? id : new Error(String(id : new Error(String(id instanceof Error ? id : new Error(String(id instanceof Error ? id instanceof Error ? id : new Error(String(id instanceof Error ? id instanceof Error ? id : new Error(String(id : new Error(String(id instanceof Error ? id : new Error(String(id : new Error(String(id instanceof Error ? id : new Error(String(id instanceof Error ? id instanceof Error ? id : new Error(String(id : new Error(String(id instanceof Error ? id : new Error(String(id)))))));
      return true;
    } catch (error) {
      this.Logger.error('Failed to delete notification:', error);
      return false;
    }
  }
  
  /**
   * æ‰¹é‡åˆ é™¤é€šçŸ¥
   */
  public async deleteNotificationsBatch(ids: string[]): Promise<number> {
    let successCount = 0;
    
    for (const id of ids) {
      if (await this.deleteNotification(id)) {
        successCount++;
      }
    }
    
    this.logger.debug(`Deleted ${successCount} out of ${ids.length} notifications`);
    return successCount;
  }
  
  /**
   * æ¸…ç©ºæ‰€æœ‰é€šçŸ¥
   */
  public async clearAllNotifications(): Promise<boolean> {
    try {
      const notificationCount = this.notifications.size;
      
      // æ¸…ç©ºæ‰€æœ‰é€šçŸ¥
      this.notifications.clear();
      
      // æ¸…ç©ºåˆ†ç»„
      this.groups.clear();
      
      // é‡ç½®ç»Ÿè®¡ä¿¡æ¯
      this.stats = this.createDefaultStats();
      
      // é‡ç½®å¾½ç« è®¡æ•°
      this.badgeCount = 0;
      
      // ä¿å­˜æ•°æ®
      await this.saveNotifications();
      await this.saveGroups();
      await this.saveStats();
      await this.saveBadgeCount();
      
      // å‘å¸ƒæ¸…ç©ºäº‹ä»¶
      this.eventBus.emit(NotificationEventType.CLEARED_ALL, {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( instanceof Error ? {
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now( : new Error(String({
        type: NotificationEventType.CLEARED_ALL,
        timestamp: Date.now())))))),
        count: notificationCount
      });
      
      this.logger.debug('All notifications cleared');
      return true;
    } catch (error) {
      this.Logger.error('Failed to clear all notifications:', error);
      return false;
    }
  }
  
  /**
   * æ›´æ–°æ–°é€šçŸ¥çš„ç»Ÿè®¡ä¿¡æ?   */
  private updateStatsForNewNotification(notification: Notification): void {
    this.stats.totalCount++;
    this.stats.newCount++;
    this.stats.lastReceivedTime = Math.max(this.stats.lastReceivedTime, notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp : new Error(String(notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp : new Error(String(notification.metadata.timestamp : new Error(String(notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp : new Error(String(notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp : new Error(String(notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp : new Error(String(notification.metadata.timestamp : new Error(String(notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp : new Error(String(notification.metadata.timestamp : new Error(String(notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp : new Error(String(notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp : new Error(String(notification.metadata.timestamp : new Error(String(notification.metadata.timestamp instanceof Error ? notification.metadata.timestamp : new Error(String(notification.metadata.timestamp)))))));
    
    // æŒ‰ç±»å‹ç»Ÿè®?    const typeCount = this.stats.byType.get(notification.type) || 0;
    this.stats.byType.set(notification.type, typeCount + 1);
    
    // æŒ‰ä¼˜å…ˆçº§ç»Ÿè®¡
    const priorityCount = this.stats.byPriority.get(notification.priority) || 0;
    this.stats.byPriority.set(notification.priority, priorityCount + 1);
    
    // æŒ‰å‘é€è€…ç»Ÿè®?    if (notification.metadata.senderId) {
      const senderCount = this.stats.bySender.get(notification.metadata.senderId) || 0;
      this.stats.bySender.set(notification.metadata.senderId, senderCount + 1);
    }
  }
  
  /**
   * æ›´æ–°çŠ¶æ€å˜æ›´çš„ç»Ÿè®¡ä¿¡æ¯
   */
  private updateStatsForStatusChange(notification: Notification, newStatus: NotificationStatus): void;
  private updateStatsForStatusChange(notification: Notification, oldStatus: NotificationStatus, newStatus: NotificationStatus): void;
  private updateStatsForStatusChange(notification: Notification, oldStatusOrNewStatus: NotificationStatus, newStatus?: NotificationStatus): void {
    const oldStatus = newStatus ? oldStatusOrNewStatus : notification.status;
    const actualNewStatus = newStatus || oldStatusOrNewStatus;
    
    // å‡å°‘æ—§çŠ¶æ€çš„è®¡æ•°
    switch (oldStatus) {
      case NotificationStatus.NEW:
        this.stats.newCount--;
        break;
      case NotificationStatus.READ:
        this.stats.readCount--;
        break;
      case NotificationStatus.DISMISSED:
        this.stats.dismissedCount--;
        break;
      case NotificationStatus.ARCHIVED:
        this.stats.archivedCount--;
        break;
    }
    
    // å¢åŠ æ–°çŠ¶æ€çš„è®¡æ•°
    switch (actualNewStatus) {
      case NotificationStatus.NEW:
        this.stats.newCount++;
        break;
      case NotificationStatus.READ:
        this.stats.readCount++;
        this.stats.lastReadTime = Date.now();
        break;
      case NotificationStatus.DISMISSED:
        this.stats.dismissedCount++;
        break;
      case NotificationStatus.ARCHIVED:
        this.stats.archivedCount++;
        break;
    }
  }
  
  /**
   * æ›´æ–°åˆ é™¤é€šçŸ¥çš„ç»Ÿè®¡ä¿¡æ?   */
  private updateStatsForDelete(notification: Notification): void {
    this.stats.totalCount--;
    
    // å‡å°‘çŠ¶æ€çš„è®¡æ•°
    switch (notification.status) {
      case NotificationStatus.NEW:
        this.stats.newCount--;
        break;
      case NotificationStatus.READ:
        this.stats.readCount--;
        break;
      case NotificationStatus.DISMISSED:
        this.stats.dismissedCount--;
        break;
      case NotificationStatus.ARCHIVED:
        this.stats.archivedCount--;
        break;
    }
    
    // å‡å°‘ç±»å‹ç»Ÿè®¡
    const typeCount = this.stats.byType.get(notification.type) || 0;
    if (typeCount > 1) {
      this.stats.byType.set(notification.type, typeCount - 1);
    } else {
      this.stats.byType.delete(notification.type);
    }
    
    // å‡å°‘ä¼˜å…ˆçº§ç»Ÿè®?    const priorityCount = this.stats.byPriority.get(notification.priority) || 0;
    if (priorityCount > 1) {
      this.stats.byPriority.set(notification.priority, priorityCount - 1);
    } else {
      this.stats.byPriority.delete(notification.priority);
    }
    
    // å‡å°‘å‘é€è€…ç»Ÿè®?    if (notification.metadata.senderId) {
      const senderCount = this.stats.bySender.get(notification.metadata.senderId) || 0;
      if (senderCount > 1) {
        this.stats.bySender.set(notification.metadata.senderId, senderCount - 1);
      } else {
        this.stats.bySender.delete(notification.metadata.senderId);
      }
    }
  }
  
  /**
   * æ›´æ–°é€šçŸ¥çš„åˆ†ç»?   */
  private async updateGroupsForNotification(notification: Notification): Promise<void> {
    // æ ¹æ®é€šçŸ¥ç±»å‹å’Œå‘é€è€…åˆ›å»ºæˆ–æ›´æ–°åˆ†ç»„
    const groupId = this.generateGroupId(notification);
    
    let group = this.groups.get(groupId);
    if (!group) {
      group = {
        id: groupId,
        title: this.getGroupTitle(notification),
        summary: this.getGroupSummary(notification),
        notificationIds: [],
        count: 0,
        newCount: 0,
        timestamp: notification.metadata.timestamp,
        type: notification.type,
        priority: notification.priority,
        senderId: notification.metadata.senderId,
        relatedEntityId: notification.metadata.relatedEntityId
      };
      this.groups.set(groupId, group);
    }
    
    // æ›´æ–°åˆ†ç»„ä¿¡æ¯
    group.notificationIds.push(notification.id);
    group.count++;
    if (notification.status === NotificationStatus.NEW) {
      group.newCount++;
    }
    group.timestamp = Math.max(group.timestamp, notification.metadata.timestamp);
    
    // ä¿å­˜åˆ†ç»„ä¿¡æ¯
    await this.saveGroups();
    
    // å‘å¸ƒåˆ†ç»„æ›´æ–°äº‹ä»¶
    this.eventBus.emit(NotificationEventType.GROUP_UPDATED, {
      type: NotificationEventType.GROUP_UPDATED,
      timestamp: Date.now(),
      group: group
    });
  }
  
  /**
   * ä»åˆ†ç»„ä¸­ç§»é™¤é€šçŸ¥
   */
  private async removeNotificationFromGroups(notificationId: string): Promise<void> {
    for (const [groupId, group] of this.groups.entries()) {
      const index = group.notificationIds.indexOf(notificationId);
      if (index !== -1) {
        group.notificationIds.splice(index, 1);
        group.count--;
        
        // å¦‚æœåˆ†ç»„ä¸ºç©ºï¼Œåˆ é™¤åˆ†ç»?        if (group.count === 0) {
          this.groups.delete(groupId);
        } else {
          // æ›´æ–°æ–°é€šçŸ¥è®¡æ•°
          const notification = this.notifications.get(notificationId);
          if (notification && notification.status === NotificationStatus.NEW) {
            group.newCount = Math.max(0, group.newCount - 1);
          }
          
          // ä¿å­˜åˆ†ç»„ä¿¡æ¯
          await this.saveGroups();
          
          // å‘å¸ƒåˆ†ç»„æ›´æ–°äº‹ä»¶
          this.eventBus.emit(NotificationEventType.GROUP_UPDATED, {
            type: NotificationEventType.GROUP_UPDATED,
            timestamp: Date.now(),
            group: group
          });
        }
        break;
      }
    }
  }
  
  /**
   * ç”Ÿæˆåˆ†ç»„ID
   */
  private generateGroupId(notification: Notification): string {
    return `${notification.type}:${notification.metadata.senderId || 'system'}:${notification.metadata.relatedEntityId || 'general'}`;
  }
  
  /**
   * è·å–åˆ†ç»„æ ‡é¢˜
   */
  private getGroupTitle(notification: Notification): string {
    switch (notification.type) {
      case NotificationType.LIVE_START:
        return 'ç›´æ’­å¼€å§‹é€šçŸ¥';
      case NotificationType.COMMENT_REPLY:
        return 'è¯„è®ºå›å¤';
      case NotificationType.MENTIONED:
        return 'æåŠé€šçŸ¥';
      case NotificationType.LIKE:
        return 'ç‚¹èµé€šçŸ¥';
      case NotificationType.SYSTEM_ANNOUNCEMENT:
        return 'ç³»ç»Ÿå…¬å‘Š';
      default:
        return 'å…¶ä»–é€šçŸ¥';
    }
  }
  
  /**
   * è·å–åˆ†ç»„æ‘˜è¦
   */
  private getGroupSummary(notification: Notification): string {
    return `æœ?{notification.metadata.senderName ? notification.metadata.senderName + 'çš? : ''}æ–°é€šçŸ¥`;
  }
  
  /**
   * è·å–é€šçŸ¥ç»Ÿè®¡ä¿¡æ¯
   */
  public getStats(): NotificationStats {
    return { ...this.stats };
  }
  
  /**
   * è·å–å¾½ç« è®¡æ•°
   */
  public getBadgeCount(): number {
    return this.badgeCount;
  }
  
  /**
   * è·å–æ‰€æœ‰åˆ†ç»?   */
  public getAllGroups(): NotificationGroup[] {
    return Array.from(this.groups.values());
  }
  
  /**
   * è·å–åˆ†ç»„
   */
  public getGroup(id: string): NotificationGroup | undefined {
    return this.groups.get(id);
  }
  
  /**
   * è·å–åˆ†ç»„ä¸­çš„é€šçŸ¥
   */
  public getNotificationsInGroup(groupId: string): Notification[] {
    const group = this.groups.get(groupId);
    if (!group) {
      return [];
    }
    
    return group.notificationIds
      .map(id => this.notifications.get(id))
      .filter((notification): notification is Notification => notification !== undefined);
  }
  
  /**
   * æ¸…ç†è¿‡æœŸé€šçŸ¥
   */
  public async cleanupExpiredNotifications(): Promise<number> {
    try {
      const now = Date.now();
      const expiredNotifications: string[] = [];
      
      for (const [id, notification] of this.notifications.entries()) {
        if (notification.metadata.expiresAt && notification.metadata.expiresAt < now) {
          expiredNotifications.push(id);
        }
      }
      
      const deletedCount = await this.deleteNotificationsBatch(expiredNotifications);
      this.logger.debug(`Cleaned up ${deletedCount} expired notifications`);
      return deletedCount;
    } catch (error) {
      this.Logger.error('Failed to cleanup expired notifications:', error);
      return 0;
    }
  }
  
  /**
   * æ¸…ç†æ—§é€šçŸ¥
   */
  public async cleanupOldNotifications(): Promise<number> {
    try {
      const cutoffTime = Date.now() - (this.config.notificationHistoryDays * 24 * 60 * 60 * 1000);
      const oldNotifications: string[] = [];
      
      for (const [id, notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries( instanceof Error ? notification] of this.notifications.entries( : new Error(String(notification] of this.notifications.entries()))))))) {
        if (notification.metadata.timestamp < cutoffTime) {
          oldNotifications.push(id);
        }
      }
      
      const deletedCount = await this.deleteNotificationsBatch(oldNotifications);
      this.logger.debug(`Cleaned up ${deletedCount} old notifications`);
      return deletedCount;
    } catch (error) {
      this.Logger.error('Failed to cleanup old notifications:', error);
      return 0;
    }
  }
  
  /**
   * æ£€æŸ¥é€šçŸ¥æ˜¯å¦å­˜åœ¨
   */
  public hasNotification(id: string): boolean {
    return this.notifications.has(id);
  }
  
  /**
   * è·å–é€šçŸ¥æ•°é‡
   */
  public getNotificationCount(): number {
    return this.notifications.size;
  }
  
  /**
   * è·å–æ–°é€šçŸ¥æ•°é‡
   */
  public getNewNotificationCount(): number {
    return this.stats.newCount;
  }
  
  /**
   * è·å–æœªè¯»é€šçŸ¥æ•°é‡
   */
  public getUnreadNotificationCount(): number {
    return this.stats.newCount + this.stats.readCount; // æ–°é€šçŸ¥å’Œå·²è¯»é€šçŸ¥éƒ½ç®—æœªè¯»
  }
  
  /**
   * åº”ç”¨é€šçŸ¥è¿‡æ»¤å™?   */
  public applyFilter(filter: NotificationFilter): Notification[] {
    const filteredNotifications = this.getFilteredNotifications(filter);
    
    // å‘å¸ƒè¿‡æ»¤åº”ç”¨äº‹ä»¶
    this.eventBus.emit(NotificationEventType.FILTER_APPLIED, {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( instanceof Error ? {
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now( : new Error(String({
      type: NotificationEventType.FILTER_APPLIED,
      timestamp: Date.now())))))),
      filter: filter,
      notifications: filteredNotifications
    });
    
    return filteredNotifications;
  }
  
  /**
   * å…³é—­ä»“åº“
   */
  public async shutdown(): Promise<void> {
    try {
      // ä¿å­˜æ‰€æœ‰æ•°æ?      await this.saveAllData();
      
      // æ¸…ç†ç¼“å­˜
      await this.cacheService.delete(this.cacheKeys.notifications);
      await this.cacheService.delete(this.cacheKeys.config);
      await this.cacheService.delete(this.cacheKeys.stats);
      await this.cacheService.delete(this.cacheKeys.groups);
      
      this.isInitialized = false;
      this.logger.info('NotificationRepository shutdown successfully');
    } catch (error) {
      this.logger.error('Failed to shutdown NotificationRepository:', error);
    }
  }
}


