// AuthRepository - è®¤è¯æˆæƒä»“åº“ç±?// è´Ÿè´£å¤„ç†ç”¨æˆ·è®¤è¯ã€æˆæƒå’Œä¼šè¯ç®¡ç†ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘

import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import NetworkUtil from '../../common/util/NetworkUtil';
import EventBusUtil from '../../common/util/EventBusUtil';
import CacheService from '../../service/cache/CacheService';
import { LocalStorageType } from '../model/LocalModel';
import { CacheType } from '../model/CacheModel';
import { UserInfo, UserCredentials, UserRegisterInfo } from '../../service/user/UserService';

/**
 * è®¤è¯çŠ¶æ€æšä¸? */
export enum AuthStatus {
  UNAUTHENTICATED = 'unauthenticated',
  AUTHENTICATING = 'authenticating',
  AUTHENTICATED = 'authenticated',
  TOKEN_EXPIRED = 'token_expired',
  REFRESHING = 'refreshing',
  ERROR = 'error'
}

/**
 * è®¤è¯ä»¤ç‰Œæ¥å£
 */
export interface AuthToken {
  accessToken: string;
  refreshToken: string;
  expiresIn: number; // è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼?  tokenType: string;
  scope: string;
  issuedAt: number; // ç­¾å‘æ—¶é—´æˆ?}

/**
 * è®¤è¯å“åº”æ¥å£
 */
export interface AuthResponse {
  token: AuthToken;
  user: UserInfo;
  expiresAt: number;
  isFirstLogin?: boolean;
  sessionId?: string;
}

/**
 * åˆ·æ–°ä»¤ç‰Œå“åº”æ¥å£
 */
export interface RefreshTokenResponse {
  token: AuthToken;
  expiresAt: number;
}

/**
 * è®¤è¯é”™è¯¯æ¥å£
 */
export interface AuthError {
  code: string;
  message: string;
  details?: string | number | boolean | null;
  timestamp: number;
}

/**
 * è®¤è¯é…ç½®æ¥å£
 */
export interface AuthConfig {
  enableBiometricAuth: boolean;
  enableAutoLogin: boolean;
  autoLoginTimeout: number; // è‡ªåŠ¨ç™»å½•è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  tokenRefreshThreshold: number; // ä»¤ç‰Œåˆ·æ–°é˜ˆå€¼ï¼ˆç§’ï¼‰
  sessionTimeout: number; // ä¼šè¯è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼?  rememberMeDuration: number; // è®°ä½æˆ‘æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
  enableTokenRotation: boolean; // æ˜¯å¦å¯ç”¨ä»¤ç‰Œè½®æ¢
  secureTokenStorage: boolean; // æ˜¯å¦ä½¿ç”¨å®‰å…¨å­˜å‚¨
}

/**
 * è®¤è¯äº‹ä»¶ç±»å‹
 */
export const AuthEventType = {
  LOGIN_START: 'auth:loginStart',
  LOGIN_SUCCESS: 'auth:loginSuccess',
  LOGIN_FAILURE: 'auth:loginFailure',
  LOGOUT_START: 'auth:logoutStart',
  LOGOUT_SUCCESS: 'auth:logoutSuccess',
  LOGOUT_FAILURE: 'auth:logoutFailure',
  TOKEN_REFRESH_START: 'auth:tokenRefreshStart',
  TOKEN_REFRESH_SUCCESS: 'auth:tokenRefreshSuccess',
  TOKEN_REFRESH_FAILURE: 'auth:tokenRefreshFailure',
  SESSION_EXPIRED: 'auth:sessionExpired',
  PERMISSION_DENIED: 'auth:permissionDenied',
  AUTH_STATUS_CHANGED: 'auth:statusChanged',
  AUTH_CONFIG_CHANGED: 'auth:configChanged',
  PASSWORD_RESET_REQUEST: 'auth:passwordResetRequest',
  PASSWORD_RESET_SUCCESS: 'auth:passwordResetSuccess',
  REGISTRATION_SUCCESS: 'auth:registrationSuccess',
  BIOMETRIC_AUTH_SUCCESS: 'auth:biometricAuthSuccess',
  BIOMETRIC_AUTH_FAILURE: 'auth:biometricAuthFailure'
} as const;

/**
 * è®¤è¯äº‹ä»¶æ•°æ®
 */
export interface AuthEvent {
  type: string;
  timestamp: number;
  data?: string | number | boolean | null;
  error?: AuthError;
}

/**
 * æƒé™æ¥å£
 */
export interface Permission {
  id: string;
  name: string;
  description: string;
  category: string;
  level: number; // æƒé™çº§åˆ«ï¼?-æœ€ä½ï¼Œ10-æœ€é«?  isEnabled: boolean;
}

/**
 * è§’è‰²æ¥å£
 */
export interface Role {
  id: string;
  name: string;
  description: string;
  permissions: string[]; // æƒé™IDåˆ—è¡¨
  isDefault: boolean;
  level: number; // è§’è‰²çº§åˆ«
}

/**
 * ç”¨æˆ·æƒé™æ¥å£
 */
export interface UserPermissions {
  userId: string;
  roles: Role[];
  permissions: Permission[];
  grantedPermissions: string[]; // ç”¨æˆ·ç›´æ¥æˆäºˆçš„æƒé™IDåˆ—è¡¨
  deniedPermissions: string[]; // ç”¨æˆ·è¢«æ‹’ç»çš„æƒé™IDåˆ—è¡¨
  updatedAt: number;
}

/**
 * æƒé™æ£€æŸ¥è¯·æ±? */
export interface PermissionCheckRequest {
  permissionId: string;
  userId?: string;
  context?: string | number | boolean | null;
}

/**
 * è®¤è¯ä»“åº“ç±? */
export class AuthRepository {
  private static instance: AuthRepository;

  private logger = Logger.getInstance();
  private storageUtil = StorageUtil.getInstance();
  private networkUtil = NetworkUtil.getInstance();
  private eventBus = EventBusUtil.getInstance();
  private cacheService = CacheService.getInstance();
  
  // APIç«¯ç‚¹é…ç½®
  private apiEndpoints = {
    baseUrl: 'https://api.raytv.example.com',
    login: '/auth/login',
    logout: '/auth/logout',
    refreshToken: '/auth/refresh',
    register: '/auth/register',
    forgotPassword: '/auth/forgot-password',
    resetPassword: '/auth/reset-password',
    verifyEmail: '/auth/verify-email',
    resendVerification: '/auth/resend-verification',
    userPermissions: '/auth/permissions',
    checkPermission: '/auth/permissions/check',
    roles: '/auth/roles',
    biometricAuth: '/auth/biometric'
  };
  
  // å­˜å‚¨é”®é…ç½?  private storageKeys = {
    authToken: 'auth:token',
    currentUser: 'auth:currentUser',
    authConfig: 'auth:config',
    lastLoginTimestamp: 'auth:lastLoginTimestamp',
    rememberMeCredentials: 'auth:rememberMeCredentials',
    userPermissions: 'auth:userPermissions',
    authStatus: 'auth:status',
    sessionId: 'auth:sessionId',
    biometricData: 'auth:biometricData'
  };
  
  // é»˜è®¤é…ç½®
  private defaultConfig: AuthConfig = {
    enableBiometricAuth: false,
    enableAutoLogin: false,
    autoLoginTimeout: 1800000, // 30åˆ†é’Ÿ
    tokenRefreshThreshold: 300, // 5åˆ†é’Ÿ
    sessionTimeout: 3600, // 1å°æ—¶
    rememberMeDuration: 604800, // 7å¤?    enableTokenRotation: true,
    secureTokenStorage: true
  };
  
  // ç¼“å­˜çš„é…ç½?  private cachedConfig: AuthConfig | null = null;
  
  // å½“å‰è®¤è¯çŠ¶æ€?  private currentStatus: AuthStatus = AuthStatus.UNAUTHENTICATED;
  
  // ç¼“å­˜çš„è®¤è¯ä»¤ç‰?  private cachedToken: AuthToken | null = null;
  
  // ç¼“å­˜çš„ç”¨æˆ·ä¿¡æ?  private cachedUser: UserInfo | null = null;
  
  // ç¼“å­˜çš„ç”¨æˆ·æƒé™?  private cachedUserPermissions: UserPermissions | null = null;
  
  // ä»¤ç‰Œåˆ·æ–°ä¸­æ ‡å¿?  private isRefreshingToken: boolean = false;
  
  // ç™»å½•å°è¯•æ¬¡æ•°
  private loginAttempts: number = 0;
  
  // ä¸Šæ¬¡ç™»å½•æ—¶é—´
  private lastLoginAttempt: number = 0;

  /**
   * ç§æœ‰æ„é€ å‡½æ•?   */
  private constructor() {
    this.logger.info('AuthRepository initialized');
    this.setupEventListeners();
    this.initialize();
  }

  /**
   * è·å–AuthRepositoryå•ä¾‹å®ä¾‹
   */
  public static getInstance(): AuthRepository {
    if (!AuthRepository.instance) {
      AuthRepository.instance = new AuthRepository();
    }
    return AuthRepository.instance;
  }

  /**
   * åˆå§‹åŒ–è®¤è¯ä»“åº?   */
  public async initialize(): Promise<void> {
    try {
      // åŠ è½½é…ç½®
      await this.loadConfig();
      
      // æ¢å¤è®¤è¯çŠ¶æ€?      await this.restoreAuthState();
      
      this.logger.info('AuthRepository initialization completed');
    } catch (error) {
      this.Logger.error('Failed to initialize AuthRepository', error as Error);
      // å‡ºé”™æ—¶é‡ç½®è®¤è¯çŠ¶æ€?      await this.resetAuthState();
    }
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬å™?   */
  private setupEventListeners(): void {
    // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ?    this.eventBus.on('network:statusChanged', async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean } instanceof Error ? async (status: { isOnline: boolean } : new Error(String(async (status: { isOnline: boolean }))))))) => {
      if (status.isOnline && this.cachedToken && this.isTokenExpiredSoon()) {
        // ç½‘ç»œæ¢å¤ä¸”ä»¤ç‰Œå³å°†è¿‡æœŸæ—¶ï¼Œå°è¯•åˆ·æ–°ä»¤ç‰?        this.refreshTokenIfNeeded().catch(err => {
          this.logger.warn('Failed to refresh token after network recovery', err);
        });
      }
    });
    
    // ç›‘å¬åº”ç”¨å‰å°/åå°åˆ‡æ¢
    this.eventBus.on('app:stateChanged', async (state: { isActive: boolean }) => {
      if (state.isActive && this.cachedToken) {
        // åº”ç”¨åˆ‡æ¢åˆ°å‰å°æ—¶ï¼Œæ£€æŸ¥ä»¤ç‰Œæ˜¯å¦è¿‡æœ?        if (this.isTokenExpired()) {
          this.handleTokenExpiry().catch(err => {
            this.logger.warn('Failed to handle token expiry when app becomes active', err);
          });
        } else if (this.isTokenExpiredSoon()) {
          // ä»¤ç‰Œå³å°†è¿‡æœŸï¼Œå°è¯•åˆ·æ–?          this.refreshTokenIfNeeded().catch(err => {
            this.logger.warn('Failed to refresh token when app becomes active', err);
          });
        }
      }
    });
  }

  /**
   * åŠ è½½é…ç½®
   */
  private async loadConfig(): Promise<void> {
    try {
      const config = await this.storageUtil.getObject<AuthConfig>(
        this.storageKeys.authConfig,
        LocalStorageType.DEFAULT
      );
      
      this.cachedConfig = config ? {
        ...this.defaultConfig,
        ...config
      } : { ...this.defaultConfig };
      
      // éªŒè¯é…ç½®
      this.validateConfig(this.cachedConfig);
      
      this.logger.debug('Auth configuration loaded');
    } catch (error) {
      this.Logger.error('Failed to load auth config', error as Error);
      this.cachedConfig = { ...this.defaultConfig };
    }
  }

  /**
   * è®¾ç½®é…ç½®
   */
  public async setConfig(config: Partial<AuthConfig>): Promise<AuthConfig> {
    try {
      // è·å–å½“å‰é…ç½®
      const currentConfig = await this.getConfig();
      
      // åˆå¹¶æ–°é…ç½?      const updatedConfig: AuthConfig = {
        ...currentConfig, ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig instanceof Error ? ...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig : new Error(String(...config
      };
      
      // éªŒè¯é…ç½®
      this.validateConfig(updatedConfig)))))));
      
      // ä¿å­˜é…ç½®
      this.cachedConfig = updatedConfig;
      await this.storageUtil.setObject(
        this.storageKeys.authConfig,
        updatedConfig,
        LocalStorageType.DEFAULT
      );
      
      // å‘å¸ƒé…ç½®å˜æ›´äº‹ä»¶
      this.eventBus.emit(AuthEventType.AUTH_CONFIG_CHANGED, {
        type: AuthEventType.AUTH_CONFIG_CHANGED,
        timestamp: Date.now(),
        data: updatedConfig
      } as AuthEvent);
      
      this.logger.info('Auth configuration updated');
      
      return updatedConfig;
    } catch (error) {
      this.Logger.error('Failed to set auth config', error as Error);
      throw error;
    }
  }

  /**
   * è·å–é…ç½®
   */
  public async getConfig(): Promise<AuthConfig> {
    try {
      // å¦‚æœç¼“å­˜ä¸ºç©ºï¼ŒåŠ è½½é…ç½?      if (!this.cachedConfig) {
        await this.loadConfig();
      }
      
      return { ...this.cachedConfig! };
    } catch (error) {
      this.logger.error('Failed to get auth config', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
      return { ...this.defaultConfig };
    }
  }

  /**
   * éªŒè¯é…ç½®
   */
  private validateConfig(config: AuthConfig): void {
    const errors: string[] = [];
    
    if (config.autoLoginTimeout < 0) {
      errors.push('autoLoginTimeout must be non-negative');
    }
    
    if (config.tokenRefreshThreshold < 0 || config.tokenRefreshThreshold > 3600) {
      errors.push('tokenRefreshThreshold must be between 0 and 3600');
    }
    
    if (config.sessionTimeout < 0) {
      errors.push('sessionTimeout must be non-negative');
    }
    
    if (config.rememberMeDuration < 0) {
      errors.push('rememberMeDuration must be non-negative');
    }
    
    if (errors.length > 0) {
      throw new Error(errors.join(', '));
    }
  }

  /**
   * æ¢å¤è®¤è¯çŠ¶æ€?   */
  private async restoreAuthState(): Promise<void> {
    try {
      // åŠ è½½ä»¤ç‰Œ
      const savedToken = await this.storageUtil.getObject<AuthToken>(
        this.storageKeys.authToken,
        this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
      );
      
      if (savedToken) {
        this.cachedToken = savedToken;
        
        // æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦å·²è¿‡æœŸ
        if (this.isTokenExpired()) {
          this.logger.warn('Restored token is expired');
          this.currentStatus = AuthStatus.TOKEN_EXPIRED;
          
          // å°è¯•åˆ·æ–°ä»¤ç‰Œ
          this.handleTokenExpiry().catch(err => {
            this.logger.warn('Failed to refresh expired token during restore', err);
          });
        } else {
          // åŠ è½½ç”¨æˆ·ä¿¡æ¯
          const savedUser = await this.storageUtil.getObject<UserInfo>(
            this.storageKeys.currentUser,
            this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
          );
          
          if (savedUser) {
            this.cachedUser = savedUser;
            this.currentStatus = AuthStatus.AUTHENTICATED;
            
            this.logger.info('Auth state restored successfully');
            
            // å‘å¸ƒè®¤è¯çŠ¶æ€å˜æ›´äº‹ä»?            this.emitAuthStatusChange(AuthStatus.AUTHENTICATED);
          } else {
            // åªæœ‰ä»¤ç‰Œä½†æ²¡æœ‰ç”¨æˆ·ä¿¡æ¯ï¼Œæ¸…é™¤ä»¤ç‰Œ
            this.logger.warn('Token exists but user info is missing, clearing auth state');
            await this.resetAuthState();
          }
        }
      }
      
      // åŠ è½½è®¤è¯çŠ¶æ€?      const savedStatus = await this.storageUtil.getString(
        this.storageKeys.authStatus,
        LocalStorageType.DEFAULT
      );
      
      if (savedStatus && this.getAuthStatusValues().includes(savedStatus)) {
        this.currentStatus = savedStatus as AuthStatus;
      }
      
    } catch (error) {
      this.Logger.error('Failed to restore auth state', error as Error);
      await this.resetAuthState();
    }
  }

  /**
   * è·å–AuthStatusæšä¸¾çš„æ‰€æœ‰æœ‰æ•ˆå€¼ï¼ˆArkTSå…¼å®¹æ–¹æ³•ï¼?   */
  private getAuthStatusValues(): string[] {
    return [
      AuthStatus.UNAUTHENTICATED, AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo instanceof Error ? AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo : new Error(String(AuthStatus.AUTHENTICATING,
      AuthStatus.AUTHENTICATED,
      AuthStatus.TOKEN_EXPIRED,
      AuthStatus.REFRESHING,
      AuthStatus.ERROR
    ];
  }

  /**
   * ä¿å­˜è®¤è¯çŠ¶æ€?   */
  private async saveAuthState(token: AuthToken, user: UserInfo))))))): Promise<void> {
    try {
      // ä¿å­˜ä»¤ç‰Œ
      await this.storageUtil.setObject(
        this.storageKeys.authToken,
        token,
        this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
      );
      
      // ä¿å­˜ç”¨æˆ·ä¿¡æ¯
      await this.storageUtil.setObject(
        this.storageKeys.currentUser,
        user,
        this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
      );
      
      // ä¿å­˜è®¤è¯çŠ¶æ€?      await this.storageUtil.setString(
        this.storageKeys.authStatus,
        AuthStatus.AUTHENTICATED,
        LocalStorageType.DEFAULT
      );
      
      // æ›´æ–°ç¼“å­˜
      this.cachedToken = token;
      this.cachedUser = user;
      this.currentStatus = AuthStatus.AUTHENTICATED;
      
      // è®°å½•ç™»å½•æ—¶é—´
      await this.storageUtil.setNumber(
        this.storageKeys.lastLoginTimestamp,
        Date.now(),
        LocalStorageType.DEFAULT
      );
      
      this.logger.info('Auth state saved successfully');
    } catch (error) {
      this.Logger.error('Failed to save auth state', error as Error);
      throw error;
    }
  }

  /**
   * é‡ç½®è®¤è¯çŠ¶æ€?   */
  private async resetAuthState(): Promise<void> {
    try {
      // æ¸…é™¤ä»¤ç‰Œ
      await this.storageUtil.remove(
        this.storageKeys.authToken, this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       instanceof Error ? this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
       : new Error(String(this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
      )))))));
      
      // æ¸…é™¤ç”¨æˆ·ä¿¡æ¯
      await this.storageUtil.remove(
        this.storageKeys.currentUser,
        this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
      );
      
      // æ¸…é™¤ç”¨æˆ·æƒé™
      await this.storageUtil.remove(
        this.storageKeys.userPermissions,
        LocalStorageType.DEFAULT
      );
      
      // æ¸…é™¤è®¤è¯çŠ¶æ€?      await this.storageUtil.remove(
        this.storageKeys.authStatus,
        LocalStorageType.DEFAULT
      );
      
      // æ¸…é™¤ä¼šè¯ID
      await this.storageUtil.remove(
        this.storageKeys.sessionId,
        LocalStorageType.DEFAULT
      );
      
      // é‡ç½®ç¼“å­˜
      this.cachedToken = null;
      this.cachedUser = null;
      this.cachedUserPermissions = null;
      this.currentStatus = AuthStatus.UNAUTHENTICATED;
      
      // æ¸…é™¤ç™»å½•å°è¯•è®¡æ•°
      this.loginAttempts = 0;
      this.lastLoginAttempt = 0;
      
      this.logger.info('Auth state reset successfully');
    } catch (error) {
      this.Logger.error('Failed to reset auth state', error as Error);
    }
  }

  /**
   * ç”¨æˆ·ç™»å½•
   */
  public async login(credentials: UserCredentials, rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false : new Error(String(rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false : new Error(String(rememberMe: boolean = false : new Error(String(rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false : new Error(String(rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false : new Error(String(rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false : new Error(String(rememberMe: boolean = false : new Error(String(rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false : new Error(String(rememberMe: boolean = false : new Error(String(rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false : new Error(String(rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false : new Error(String(rememberMe: boolean = false : new Error(String(rememberMe: boolean = false instanceof Error ? rememberMe: boolean = false : new Error(String(rememberMe: boolean = false))))))): Promise<AuthResponse> {
    try {
      // æ£€æŸ¥ç™»å½•é¢‘ç‡é™åˆ?      this.checkLoginRateLimit();
      
      // è®°å½•ç™»å½•å°è¯•
      this.loginAttempts++;
      this.lastLoginAttempt = Date.now();
      
      // å‘å¸ƒç™»å½•å¼€å§‹äº‹ä»?      this.eventBus.emit(AuthEventType.LOGIN_START, {
        type: AuthEventType.LOGIN_START,
        timestamp: Date.now(),
        data: { username: credentials.username, rememberMe }
      } as AuthEvent);
      
      // æ›´æ–°çŠ¶æ€ä¸ºè®¤è¯ä¸?      this.updateAuthStatus(AuthStatus.AUTHENTICATING);
      
      // è°ƒç”¨ç™»å½•API
      const response = await this.networkUtil.post<AuthResponse>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.login}`,
        { ...credentials, rememberMe }
      );
      
      const authResponse = response.data;
      
      // ä¿å­˜è®¤è¯çŠ¶æ€?      await this.saveAuthState(authResponse.token, authResponse.user);
      
      // ä¿å­˜ä¼šè¯ID
      if (authResponse.sessionId) {
        await this.storageUtil.setString(
          this.storageKeys.sessionId,
          authResponse.sessionId,
          LocalStorageType.DEFAULT
        );
      }
      
      // é‡ç½®ç™»å½•å°è¯•è®¡æ•°
      this.loginAttempts = 0;
      
      // æ›´æ–°çŠ¶æ€ä¸ºå·²è®¤è¯?      this.updateAuthStatus(AuthStatus.AUTHENTICATED);
      
      // å‘å¸ƒç™»å½•æˆåŠŸäº‹ä»¶
      this.eventBus.emit(AuthEventType.LOGIN_SUCCESS, {
        type: AuthEventType.LOGIN_SUCCESS,
        timestamp: Date.now(),
        data: authResponse
      } as AuthEvent);
      
      // æ›´æ–°è®¤è¯çŠ¶æ€å˜æ›´äº‹ä»?      this.emitAuthStatusChange(AuthStatus.AUTHENTICATED);
      
      this.logger.info(`User ${authResponse.user.username} logged in successfully`);
      
      return authResponse;
    } catch (error) {
      this.Logger.error('Login failed', error as Error);
      
      // æ›´æ–°çŠ¶æ€ä¸ºæœªè®¤è¯?      this.updateAuthStatus(AuthStatus.UNAUTHENTICATED);
      
      // æ„å»ºè®¤è¯é”™è¯¯
      const authError: AuthError = {
        code: error instanceof Error ? error.name : 'UNKNOWN_ERROR', message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( instanceof Error ? message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now( : new Error(String(message: error instanceof Error ? error.message : 'Login failed',
        timestamp: Date.now()))))))
      };
      
      // å‘å¸ƒç™»å½•å¤±è´¥äº‹ä»¶
      this.eventBus.emit(AuthEventType.LOGIN_FAILURE, {
        type: AuthEventType.LOGIN_FAILURE,
        timestamp: Date.now(),
        error: authError,
        data: { username: credentials.username, loginAttempts: this.loginAttempts }
      } as AuthEvent);
      
      throw authError;
    }
  }

  /**
   * æ£€æŸ¥ç™»å½•é¢‘ç‡é™åˆ?   */
  private checkLoginRateLimit(): void {
    // å¦‚æœç™»å½•å°è¯•æ¬¡æ•°è¿‡å¤šï¼Œåº”ç”¨ä¸´æ—¶é”å®?    const MAX_ATTEMPTS = 5;
    const LOCK_DURATION = 300000; // 5åˆ†é’Ÿ
    
    if (this.loginAttempts >= MAX_ATTEMPTS) {
      const timeSinceLastAttempt = Date.now() - this.lastLoginAttempt;
      
      if (timeSinceLastAttempt < LOCK_DURATION) {
        const remainingTime = Math.ceil((LOCK_DURATION - timeSinceLastAttempt) / 1000);
        throw new Error(`Too many login attempts. Please try again in ${remainingTime} seconds.`);
      } else {
        // é”å®šæ—¶é—´å·²è¿‡ï¼Œé‡ç½®å°è¯•è®¡æ•?        this.loginAttempts = 0;
      }
    }
  }

  /**
   * ç”¨æˆ·ç™»å‡º
   */
  public async logout(): Promise<void> {
    try {
      // å‘å¸ƒç™»å‡ºå¼€å§‹äº‹ä»?      this.eventBus.emit(AuthEventType.LOGOUT_START, {
        type: AuthEventType.LOGOUT_START,
        timestamp: Date.now()
      } as AuthEvent);
      
      // å¦‚æœæœ‰ä»¤ç‰Œï¼Œè°ƒç”¨ç™»å‡ºAPI
      if (this.cachedToken) {
        try {
          await this.networkUtil.post(
            `${this.apiEndpoints.baseUrl}${this.apiEndpoints.logout}`,
            { token: this.cachedToken.accessToken }
          );
        } catch (error) {
          // ç™»å‡ºAPIè°ƒç”¨å¤±è´¥ä¸å½±å“æœ¬åœ°ç™»å‡?          this.logger.warn('Logout API call failed, proceeding with local logout', error);
        }
      }
      
      // é‡ç½®è®¤è¯çŠ¶æ€?      await this.resetAuthState();
      
      // æ›´æ–°çŠ¶æ€ä¸ºæœªè®¤è¯?      this.updateAuthStatus(AuthStatus.UNAUTHENTICATED);
      
      // å‘å¸ƒç™»å‡ºæˆåŠŸäº‹ä»¶
      this.eventBus.emit(AuthEventType.LOGOUT_SUCCESS, {
        type: AuthEventType.LOGOUT_SUCCESS,
        timestamp: Date.now()
      } as AuthEvent);
      
      // æ›´æ–°è®¤è¯çŠ¶æ€å˜æ›´äº‹ä»?      this.emitAuthStatusChange(AuthStatus.UNAUTHENTICATED);
      
      this.logger.info('User logged out successfully');
    } catch (error) {
      this.Logger.error('Logout failed', error as Error);
      
      // å‘å¸ƒç™»å‡ºå¤±è´¥äº‹ä»¶
      this.eventBus.emit(AuthEventType.LOGOUT_FAILURE, {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.LOGOUT_FAILURE,
        timestamp: Date.now())))))),
        error: {
          code: error instanceof Error ? error.name : 'UNKNOWN_ERROR',
          message: error instanceof Error ? error.message : 'Logout failed',
          timestamp: Date.now()
        }
      } as AuthEvent);
      
      throw error;
    }
  }

  /**
   * è·å–å½“å‰è®¤è¯çŠ¶æ€?   */
  public getAuthStatus(): AuthStatus {
    return this.currentStatus;
  }

  /**
   * è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
   */
  public getCurrentUser(): UserInfo | null {
    return this.cachedUser;
  }

  /**
   * è·å–å½“å‰ä»¤ç‰Œ
   */
  public getCurrentToken(): AuthToken | null {
    return this.cachedToken;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²è®¤è¯
   */
  public isAuthenticated(): boolean {
    return this.currentStatus === AuthStatus.AUTHENTICATED && 
           this.cachedToken !== null && 
           this.cachedUser !== null;
  }

  /**
   * æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦è¿‡æœ?   */
  public isTokenExpired(): boolean {
    if (!this.cachedToken) {
      return true;
    }
    
    const now = Date.now();
    const expiryTime = this.cachedToken.issuedAt + (this.cachedToken.expiresIn * 1000);
    return now >= expiryTime;
  }

  /**
   * æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦å³å°†è¿‡æœ?   */
  public isTokenExpiredSoon(): boolean {
    if (!this.cachedToken) {
      return true;
    }
    
    const now = Date.now();
    const expiryTime = this.cachedToken.issuedAt + (this.cachedToken.expiresIn * 1000);
    const threshold = this.cachedConfig?.tokenRefreshThreshold || 300;
    
    return (expiryTime - now) <= (threshold * 1000);
  }

  /**
   * åˆ·æ–°ä»¤ç‰Œ
   */
  public async refreshToken(): Promise<RefreshTokenResponse> {
    if (this.isRefreshingToken) {
      throw new Error('Token refresh already in progress');
    }
    
    if (!this.cachedToken?.refreshToken) {
      throw new Error('No refresh token available');
    }
    
    this.isRefreshingToken = true;
    
    try {
      // å‘å¸ƒä»¤ç‰Œåˆ·æ–°å¼€å§‹äº‹ä»?      this.eventBus.emit(AuthEventType.TOKEN_REFRESH_START, {
        type: AuthEventType.TOKEN_REFRESH_START,
        timestamp: Date.now()
      } as AuthEvent);
      
      // æ›´æ–°çŠ¶æ€ä¸ºåˆ·æ–°ä¸?      this.updateAuthStatus(AuthStatus.REFRESHING);
      
      // è°ƒç”¨åˆ·æ–°ä»¤ç‰ŒAPI
      const response = await this.networkUtil.post<RefreshTokenResponse>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.refreshToken}`,
        { refreshToken: this.cachedToken.refreshToken }
      );
      
      const refreshResponse = response.data;
      
      // æ›´æ–°ä»¤ç‰Œ
      this.cachedToken = refreshResponse.token;
      
      // ä¿å­˜æ–°çš„ä»¤ç‰Œ
      await this.storageUtil.setObject(
        this.storageKeys.authToken,
        refreshResponse.token,
        this.cachedConfig?.secureTokenStorage ? LocalStorageType.SECURE : LocalStorageType.DEFAULT
      );
      
      // æ›´æ–°çŠ¶æ€ä¸ºå·²è®¤è¯?      this.updateAuthStatus(AuthStatus.AUTHENTICATED);
      
      // å‘å¸ƒä»¤ç‰Œåˆ·æ–°æˆåŠŸäº‹ä»¶
      this.eventBus.emit(AuthEventType.TOKEN_REFRESH_SUCCESS, {
        type: AuthEventType.TOKEN_REFRESH_SUCCESS,
        timestamp: Date.now(),
        data: refreshResponse
      } as AuthEvent);
      
      this.logger.info('Token refreshed successfully');
      
      return refreshResponse;
    } catch (error) {
      this.Logger.error('Token refresh failed', error as Error);
      
      // æ›´æ–°çŠ¶æ€ä¸ºä»¤ç‰Œè¿‡æœŸ
      this.updateAuthStatus(AuthStatus.TOKEN_EXPIRED);
      
      // å‘å¸ƒä»¤ç‰Œåˆ·æ–°å¤±è´¥äº‹ä»¶
      this.eventBus.emit(AuthEventType.TOKEN_REFRESH_FAILURE, {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( instanceof Error ? {
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now( : new Error(String({
        type: AuthEventType.TOKEN_REFRESH_FAILURE,
        timestamp: Date.now())))))),
        error: {
          code: error instanceof Error ? error.name : 'UNKNOWN_ERROR',
          message: error instanceof Error ? error.message : 'Token refresh failed',
          timestamp: Date.now()
        }
      } as AuthEvent);
      
      throw error;
    } finally {
      this.isRefreshingToken = false;
    }
  }

  /**
   * å¦‚æœéœ€è¦ï¼Œåˆ·æ–°ä»¤ç‰Œ
   */
  public async refreshTokenIfNeeded(): Promise<boolean> {
    if (this.isTokenExpiredSoon() && !this.isTokenExpired()) {
      try {
        await this.refreshToken();
        return true;
      } catch (error) {
        this.logger.warn('Token refresh not needed or failed', error);
        return false;
      }
    }
    return false;
  }

  /**
   * å¤„ç†ä»¤ç‰Œè¿‡æœŸ
   */
  private async handleTokenExpiry(): Promise<void> {
    try {
      // å°è¯•åˆ·æ–°ä»¤ç‰Œ
      await this.refreshToken();
    } catch (error) {
      // åˆ·æ–°å¤±è´¥ï¼Œå‘å¸ƒä¼šè¯è¿‡æœŸäº‹ä»?      this.eventBus.emit(AuthEventType.SESSION_EXPIRED, {
        type: AuthEventType.SESSION_EXPIRED,
        timestamp: Date.now(),
        error: {
          code: 'SESSION_EXPIRED',
          message: 'Session has expired, please login again',
          timestamp: Date.now()
        }
      } as AuthEvent);
      
      // é‡ç½®è®¤è¯çŠ¶æ€?      await this.resetAuthState();
      
      this.logger.warn('Session expired, user needs to login again');
    }
  }

  /**
   * æ›´æ–°è®¤è¯çŠ¶æ€?   */
  private updateAuthStatus(status: AuthStatus): void {
    if (this.currentStatus !== status) {
      this.currentStatus = status;
      
      // ä¿å­˜çŠ¶æ€åˆ°å­˜å‚¨
      this.storageUtil.setString(
        this.storageKeys.authStatus,
        status,
        LocalStorageType.DEFAULT
      ).catch(err => {
        this.logger.warn('Failed to save auth status', err);
      });
      
      this.emitAuthStatusChange(status);
    }
  }

  /**
   * å‘å¸ƒè®¤è¯çŠ¶æ€å˜æ›´äº‹ä»?   */
  private emitAuthStatusChange(status: AuthStatus): void {
    this.eventBus.emit(AuthEventType.AUTH_STATUS_CHANGED, {
      type: AuthEventType.AUTH_STATUS_CHANGED,
      timestamp: Date.now(),
      data: { status }
    } as AuthEvent);
  }

  /**
   * ç”¨æˆ·æ³¨å†Œ
   */
  public async register(userInfo: UserRegisterInfo): Promise<AuthResponse> {
    try {
      // è°ƒç”¨æ³¨å†ŒAPI
      const response = await this.networkUtil.post<AuthResponse>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.register}`,
        userInfo
      );
      
      const authResponse = response.data;
      
      // ä¿å­˜è®¤è¯çŠ¶æ€?      await this.saveAuthState(authResponse.token, authResponse.user);
      
      // å‘å¸ƒæ³¨å†ŒæˆåŠŸäº‹ä»¶
      this.eventBus.emit(AuthEventType.REGISTRATION_SUCCESS, {
        type: AuthEventType.REGISTRATION_SUCCESS,
        timestamp: Date.now(),
        data: authResponse
      } as AuthEvent);
      
      this.logger.info(`User ${authResponse.user.username} registered successfully`);
      
      return authResponse;
    } catch (error) {
      this.Logger.error('Registration failed', error as Error);
      throw error;
    }
  }

  /**
   * å¿˜è®°å¯†ç 
   */
  public async forgotPassword(email: string): Promise<void> {
    try {
      // è°ƒç”¨å¿˜è®°å¯†ç API
      await this.networkUtil.post(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.forgotPassword}`, { email }
       instanceof Error ? { email }
       : new Error(String({ email }
       instanceof Error ? { email }
       instanceof Error ? { email }
       : new Error(String({ email }
       : new Error(String({ email }
       instanceof Error ? { email }
       : new Error(String({ email }
       instanceof Error ? { email }
       instanceof Error ? { email }
       : new Error(String({ email }
       instanceof Error ? { email }
       instanceof Error ? { email }
       : new Error(String({ email }
       : new Error(String({ email }
       instanceof Error ? { email }
       : new Error(String({ email }
       : new Error(String({ email }
       instanceof Error ? { email }
       : new Error(String({ email }
       instanceof Error ? { email }
       instanceof Error ? { email }
       : new Error(String({ email }
       : new Error(String({ email }
       instanceof Error ? { email }
       : new Error(String({ email }
      )))))));
      
      // å‘å¸ƒå¿˜è®°å¯†ç è¯·æ±‚äº‹ä»¶
      this.eventBus.emit(AuthEventType.PASSWORD_RESET_REQUEST, {
        type: AuthEventType.PASSWORD_RESET_REQUEST,
        timestamp: Date.now(),
        data: { email }
      } as AuthEvent);
      
      this.logger.info(`Password reset request sent for ${email}`);
    } catch (error) {
      this.Logger.error('Forgot password request failed', error as Error);
      throw error;
    }
  }

  /**
   * é‡ç½®å¯†ç 
   */
  public async resetPassword(token: string, newPassword: string instanceof Error ? newPassword: string : new Error(String(newPassword: string instanceof Error ? newPassword: string instanceof Error ? newPassword: string : new Error(String(newPassword: string : new Error(String(newPassword: string instanceof Error ? newPassword: string : new Error(String(newPassword: string instanceof Error ? newPassword: string instanceof Error ? newPassword: string : new Error(String(newPassword: string instanceof Error ? newPassword: string instanceof Error ? newPassword: string : new Error(String(newPassword: string : new Error(String(newPassword: string instanceof Error ? newPassword: string : new Error(String(newPassword: string : new Error(String(newPassword: string instanceof Error ? newPassword: string : new Error(String(newPassword: string instanceof Error ? newPassword: string instanceof Error ? newPassword: string : new Error(String(newPassword: string : new Error(String(newPassword: string instanceof Error ? newPassword: string : new Error(String(newPassword: string))))))): Promise<void> {
    try {
      // è°ƒç”¨é‡ç½®å¯†ç API
      await this.networkUtil.post(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.resetPassword}`,
        { token, newPassword }
      );
      
      // å‘å¸ƒå¯†ç é‡ç½®æˆåŠŸäº‹ä»¶
      this.eventBus.emit(AuthEventType.PASSWORD_RESET_SUCCESS, {
        type: AuthEventType.PASSWORD_RESET_SUCCESS,
        timestamp: Date.now(),
        data: { token }
      } as AuthEvent);
      
      this.logger.info('Password reset successfully');
    } catch (error) {
      this.Logger.error('Password reset failed', error as Error);
      throw error;
    }
  }

  /**
   * éªŒè¯é‚®ç®±
   */
  public async verifyEmail(token: string): Promise<void> {
    try {
      // è°ƒç”¨éªŒè¯é‚®ç®±API
      await this.networkUtil.post(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.verifyEmail}`, { token }
       instanceof Error ? { token }
       : new Error(String({ token }
       instanceof Error ? { token }
       instanceof Error ? { token }
       : new Error(String({ token }
       : new Error(String({ token }
       instanceof Error ? { token }
       : new Error(String({ token }
       instanceof Error ? { token }
       instanceof Error ? { token }
       : new Error(String({ token }
       instanceof Error ? { token }
       instanceof Error ? { token }
       : new Error(String({ token }
       : new Error(String({ token }
       instanceof Error ? { token }
       : new Error(String({ token }
       : new Error(String({ token }
       instanceof Error ? { token }
       : new Error(String({ token }
       instanceof Error ? { token }
       instanceof Error ? { token }
       : new Error(String({ token }
       : new Error(String({ token }
       instanceof Error ? { token }
       : new Error(String({ token }
      )))))));
      
      this.logger.info('Email verified successfully');
    } catch (error) {
      this.Logger.error('Email verification failed', error as Error);
      throw error;
    }
  }

  /**
   * é‡æ–°å‘é€éªŒè¯é‚®ä»?   */
  public async resendVerification(email: string): Promise<void> {
    try {
      // è°ƒç”¨é‡æ–°å‘é€éªŒè¯é‚®ä»¶API
      await this.networkUtil.post(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.resendVerification}`, { email }
       instanceof Error ? { email }
       : new Error(String({ email }
       instanceof Error ? { email }
       instanceof Error ? { email }
       : new Error(String({ email }
       : new Error(String({ email }
       instanceof Error ? { email }
       : new Error(String({ email }
       instanceof Error ? { email }
       instanceof Error ? { email }
       : new Error(String({ email }
       instanceof Error ? { email }
       instanceof Error ? { email }
       : new Error(String({ email }
       : new Error(String({ email }
       instanceof Error ? { email }
       : new Error(String({ email }
       : new Error(String({ email }
       instanceof Error ? { email }
       : new Error(String({ email }
       instanceof Error ? { email }
       instanceof Error ? { email }
       : new Error(String({ email }
       : new Error(String({ email }
       instanceof Error ? { email }
       : new Error(String({ email }
      )))))));
      
      this.logger.info(`Verification email resent to ${email}`);
    } catch (error) {
      this.Logger.error('Failed to resend verification email', error as Error);
      throw error;
    }
  }

  /**
   * æ£€æŸ¥æƒé™?   */
  public async checkPermission(request: PermissionCheckRequest): Promise<boolean> {
    try {
      // è°ƒç”¨æƒé™æ£€æŸ¥API
      const response = await this.networkUtil.post<{ hasPermission: boolean }>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.checkPermission}`, request
       instanceof Error ? request
       : new Error(String(request
       instanceof Error ? request
       instanceof Error ? request
       : new Error(String(request
       : new Error(String(request
       instanceof Error ? request
       : new Error(String(request
       instanceof Error ? request
       instanceof Error ? request
       : new Error(String(request
       instanceof Error ? request
       instanceof Error ? request
       : new Error(String(request
       : new Error(String(request
       instanceof Error ? request
       : new Error(String(request
       : new Error(String(request
       instanceof Error ? request
       : new Error(String(request
       instanceof Error ? request
       instanceof Error ? request
       : new Error(String(request
       : new Error(String(request
       instanceof Error ? request
       : new Error(String(request
      )))))));
      
      return response.data.hasPermission;
    } catch (error) {
      this.Logger.error('Permission check failed', error as Error);
      return false;
    }
  }

  /**
   * è·å–ç”¨æˆ·æƒé™
   */
  public async getUserPermissions(userId: string): Promise<UserPermissions | null> {
    try {
      // å¦‚æœç¼“å­˜ä¸­æœ‰æƒé™ä¿¡æ¯ï¼Œç›´æ¥è¿”å›?      if (this.cachedUserPermissions && this.cachedUserPermissions.userId === userId) {
        return this.cachedUserPermissions;
      }
      
      // è°ƒç”¨è·å–ç”¨æˆ·æƒé™API
      const response = await this.networkUtil.get<UserPermissions>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.userPermissions}/${userId}`
      );
      
      this.cachedUserPermissions = response.data;
      
      // ä¿å­˜åˆ°å­˜å‚?      await this.storageUtil.setObject(
        this.storageKeys.userPermissions, this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       instanceof Error ? this.cachedUserPermissions,
        LocalStorageType.DEFAULT
       : new Error(String(this.cachedUserPermissions,
        LocalStorageType.DEFAULT
      )))))));
      
      return this.cachedUserPermissions;
    } catch (error) {
      this.Logger.error('Failed to get user permissions', error as Error);
      return null;
    }
  }

  /**
   * åŠ è½½ç”¨æˆ·æƒé™
   */
  private async loadUserPermissions(userId: string): Promise<void> {
    try {
      // ä»å­˜å‚¨åŠ è½½æƒé™ä¿¡æ?      const savedPermissions = await this.storageUtil.getObject<UserPermissions>(
        this.storageKeys.userPermissions, LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
       instanceof Error ? LocalStorageType.DEFAULT
       : new Error(String(LocalStorageType.DEFAULT
      )))))));
      
      if (savedPermissions && savedPermissions.userId === userId) {
        this.cachedUserPermissions = savedPermissions;
      } else {
        // ä»APIè·å–æƒé™ä¿¡æ¯
        await this.getUserPermissions(userId);
      }
    } catch (error) {
      this.logger.warn('Failed to load user permissions', error as Error);
    }
  }

  /**
   * è·å–æ‰€æœ‰è§’è‰?   */
  public async getRoles(): Promise<Role[]> {
    try {
      // è°ƒç”¨è·å–è§’è‰²API
      const response = await this.networkUtil.get<Role[]>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.roles}`
      );
      
      return response.data;
    } catch (error) {
      this.Logger.error('Failed to get roles', error as Error);
      return [];
    }
  }

  /**
   * ç”Ÿç‰©è®¤è¯
   */
  public async authenticateWithBiometric(): Promise<AuthResponse> {
    try {
      // æ£€æŸ¥æ˜¯å¦å¯ç”¨ç”Ÿç‰©è®¤è¯?      const config = await this.getConfig();
      if (!config.enableBiometricAuth) {
        throw new Error('Biometric authentication is not enabled');
      }
      
      // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥è°ƒç”¨è®¾å¤‡çš„ç”Ÿç‰©è®¤è¯API
      // ç”±äºæ˜¯ç¤ºä¾‹å®ç°ï¼Œè¿”å›é”™è¯¯
      throw new Error('Biometric authentication not implemented');
    } catch (error) {
      this.logger.error('Biometric authentication failed', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
      
      // å‘å¸ƒç”Ÿç‰©è®¤è¯å¤±è´¥äº‹ä»¶
      this.eventBus.emit(AuthEventType.BIOMETRIC_AUTH_FAILURE, {
        type: AuthEventType.BIOMETRIC_AUTH_FAILURE,
        timestamp: Date.now(),
        error: {
          code: error instanceof Error ? error.name : 'UNKNOWN_ERROR',
          message: error instanceof Error ? error.message : 'Biometric authentication failed',
          timestamp: Date.now()
        }
      } as AuthEvent);
      
      throw error;
    }
  }

  /**
   * æ¸…ç†èµ„æº
   */
  public async cleanup(): Promise<void> {
    try {
      // ç§»é™¤äº‹ä»¶ç›‘å¬å™?      this.eventBus.removeAllListeners('network:statusChanged');
      this.eventBus.removeAllListeners('app:stateChanged');
      
      // é‡ç½®å®ä¾‹
      AuthRepository.instance = null as any;
      
      this.logger.info('AuthRepository cleanup completed');
    } catch (error) {
      this.logger.error('Failed to cleanup AuthRepository', error as Error);
    }
  }
}


