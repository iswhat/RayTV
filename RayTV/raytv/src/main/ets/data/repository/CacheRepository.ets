// CacheRepository - ç¼“å­˜ä»“åº“ç±?// è´Ÿè´£ç®¡ç†åº”ç”¨ç¨‹åºçš„ç¼“å­˜æ•°æ®ï¼Œæä¾›ç»Ÿä¸€çš„ç¼“å­˜è¯»å†™å’Œç®¡ç†æ¥å£

import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import FileUtil from '../../common/util/FileUtil';
import EventBusUtil from '../../common/util/EventBusUtil';
import FormatUtil from '../../common/util/FormatUtil';
import {
  CacheType,
  CachePolicy,
  CachePriority,
  CacheItem,
  CacheMetadata,
  CacheConfig,
  CacheStatistics,
  CacheCleanupOptions,
  CacheSearchParams
} from '../model/CacheModel';
import { LocalStorageType } from '../model/LocalModel';

/**
 * ç¼“å­˜äº‹ä»¶ç±»å‹
 */
export const CacheEventType = {
  CACHE_ADDED: 'cache:added',
  CACHE_UPDATED: 'cache:updated',
  CACHE_REMOVED: 'cache:removed',
  CACHE_CLEARED: 'cache:cleared',
  CACHE_EXPIRED: 'cache:expired',
  CACHE_SIZE_CHANGED: 'cache:sizeChanged',
  CACHE_STATISTICS_UPDATED: 'cache:statisticsUpdated',
  CACHE_ERROR: 'cache:error'
} as const;

/**
 * ç¼“å­˜å˜æ›´äº‹ä»¶æ•°æ®
 */
export interface CacheChangeEvent<T = unknown> {
  key: string;          // ç¼“å­˜é”?  type: CacheType;      // ç¼“å­˜ç±»å‹
  value?: T;            // ç¼“å­˜å€¼ï¼ˆæ·»åŠ /æ›´æ–°æ—¶ï¼‰
  metadata?: CacheMetadata; // ç¼“å­˜å…ƒæ•°æ?}

/**
 * ç¼“å­˜ä»“åº“ç±? */
export class CacheRepository {
  private static instance: CacheRepository;
  private logger = Logger.getInstance();
  private storageUtil = StorageUtil.getInstance();
  private fileUtil = FileUtil.getInstance();
  private eventBus = EventBusUtil.getInstance();
  private formatUtil = FormatUtil.getInstance();
  
  // å†…å­˜ç¼“å­˜
  private memoryCache: Map<string, CacheItem<unknown>> = new Map();
  
  // ç¼“å­˜é…ç½®
  private cacheConfig: CacheConfig = {
    maxSize: 512 * 1024 * 1024, // 512MB
    defaultExpiry: 3600 * 1000, // 1å°æ—¶
    cleanupInterval: 300000,    // 5åˆ†é’Ÿ
    memoryLimit: 64 * 1024 * 1024, // 64MB
    diskLimit: 448 * 1024 * 1024,  // 448MB
    evictionPolicy: 'LRU'      // æœ€è¿‘æœ€å°‘ä½¿ç”¨ç­–ç•?  };
  
  // ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
  private cacheStatistics: CacheStatistics = {
    hits: 0,
    misses: 0,
    requests: 0,
    memoryItems: 0,
    diskItems: 0,
    memorySize: 0,
    diskSize: 0,
    evictions: 0,
    expirations: 0
  };
  
  // ç¼“å­˜ç›®å½•
  private cacheDirectory: string | null = null;
  
  // å®šæ—¶æ¸…ç†å™?  private cleanupTimer: number | null = null;
  
  // æ˜¯å¦å·²åˆå§‹åŒ–
  private initialized: boolean = false;
  
  // æ‰¹é‡æ“ä½œæ ‡å¿—
  private batchOperation: boolean = false;
  private pendingEvents: CacheChangeEvent[] = [];

  /**
   * ç§æœ‰æ„é€ å‡½æ•?   */
  private constructor() {
    this.logger.info('CacheRepository initialized');
    this.setupEventListeners();
  }

  /**
   * è·å–CacheRepositoryå•ä¾‹å®ä¾‹
   */
  public static getInstance(): CacheRepository {
    if (!CacheRepository.instance) {
      CacheRepository.instance = new CacheRepository();
    }
    return CacheRepository.instance;
  }

  /**
   * åˆå§‹åŒ–ç¼“å­˜ä»“åº?   * @param config ç¼“å­˜é…ç½®
   * @param cacheDir ç¼“å­˜ç›®å½•
   */
  public async initialize(config?: Partial<CacheConfig>, cacheDir?: string): Promise<void> {
    try {
      if (this.initialized) {
        this.logger.warn('CacheRepository already initialized');
        return;
      }
      
      // æ›´æ–°é…ç½®
      if (config) {
        this.cacheConfig = { ...this.cacheConfig, ...config };
      }
      
      // è®¾ç½®ç¼“å­˜ç›®å½•
      if (cacheDir) {
        this.cacheDirectory = cacheDir;
        
        // ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
        await this.fileUtil.ensureDirectoryExists(cacheDir);
      }
      
      // åŠ è½½ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
      await this.loadCacheStatistics();
      
      // å¯åŠ¨å®šæ—¶æ¸…ç†
      this.startPeriodicCleanup();
      
      this.initialized = true;
      this.logger.info('CacheRepository initialized successfully', {
        maxSize: this.formatUtil.formatFileSize(this.cacheConfig.maxSize),
        defaultExpiry: this.formatUtil.formatTime(this.cacheConfig.defaultExpiry),
        cacheDir: this.cacheDirectory
      });
    } catch (error) {
      this.Logger.error('Failed to initialize CacheRepository', error as Error);
      
      // å‘å¸ƒç¼“å­˜é”™è¯¯äº‹ä»¶
      this.eventBus.emit(CacheEventType.CACHE_ERROR, { error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error })))))));
    }
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬å™?   */
  private setupEventListeners(): void {
    // ç›‘å¬åº”ç”¨é€€å‡ºäº‹ä»¶ï¼Œä¿å­˜ç»Ÿè®¡ä¿¡æ¯
    this.eventBus.on('app:exit', async () => {
      await this.shutdown();
    });
  }

  /**
   * æ·»åŠ æˆ–æ›´æ–°ç¼“å­?   * @param key ç¼“å­˜é”?   * @param value ç¼“å­˜å€?   * @param options ç¼“å­˜é€‰é¡¹
   */
  public async setCache<T>(key: string, value: T, options?: {
    expiry?: number;          // è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    type?: CacheType;         // ç¼“å­˜ç±»å‹
    priority?: CachePriority; // ä¼˜å…ˆçº?    policy?: CachePolicy;     // ç¼“å­˜ç­–ç•¥
    tags?: string[];          // ç¼“å­˜æ ‡ç­¾
  }): Promise<void> {
    // æ£€æŸ¥æ˜¯å¦åˆå§‹åŒ–
    if (!this.initialized) {
      throw new Error('CacheRepository not initialized');
    }
    
    try {
      const now = Date.now();
      const expiry = options?.expiry || this.cacheConfig.defaultExpiry;
      const cacheType = options?.type || CacheType.MEMORY;
      const priority = options?.priority || CachePriority.NORMAL;
      const tags = options?.tags || [];
      
      // åˆ›å»ºç¼“å­˜å…ƒæ•°æ?      const metadata: CacheMetadata = {
        key,
        type: cacheType,
        priority,
        policy: options?.policy || CachePolicy.STANDARD,
        createdAt: now,
        updatedAt: now,
        lastAccessedAt: now,
        expiry: expiry > 0 ? now + expiry : 0, // 0è¡¨ç¤ºæ°¸ä¸è¿‡æœŸ
        size: this.calculateSize(value),
        tags
      };
      
      // åˆ›å»ºç¼“å­˜é¡?      const cacheItem: CacheItem<T> = {
        value,
        metadata
      };
      
      // æ£€æŸ¥ç¼“å­˜å¤§å°é™åˆ?      if (!this.checkCacheSizeLimit(metadata.size)) {
        // å°è¯•æ¸…ç†ç©ºé—´
        await this.cleanupCache({
          targetSizeReduction: metadata.size,
          priorityThreshold: priority
        });
        
        // å†æ¬¡æ£€æŸ?        if (!this.checkCacheSizeLimit(metadata.size)) {
          this.logger.warn(`Cache size limit exceeded, cannot store item: ${key}`);
          throw new Error('Cache size limit exceeded');
        }
      }
      
      // å­˜å‚¨åˆ°å†…å­?      if (cacheType === CacheType.MEMORY || cacheType === CacheType.MEMORY_DISK) {
        // ç§»é™¤æ—§ç¼“å­˜é¡¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        const oldItem = this.memoryCache.get(key);
        if (oldItem) {
          this.updateCacheSizeStats(-oldItem.metadata.size, true);
        }
        
        this.memoryCache.set(key, cacheItem);
        this.updateCacheSizeStats(metadata.size, true);
        this.updateItemCountStats(true);
      }
      
      // å­˜å‚¨åˆ°ç£ç›?      if (cacheType === CacheType.DISK || cacheType === CacheType.MEMORY_DISK) {
        await this.storeToDisk(key, cacheItem);
      }
      
      // æ„å»ºäº‹ä»¶
      const event: CacheChangeEvent<T> = {
        key,
        type: cacheType,
        value,
        metadata
      };
      
      // å¤„ç†äº‹ä»¶
      if (this.batchOperation) {
        this.pendingEvents.push(event);
      } else {
        // å‘å¸ƒç¼“å­˜æ·»åŠ /æ›´æ–°äº‹ä»¶
        const eventType = this.memoryCache.has(key) && !oldItem ? CacheEventType.CACHE_UPDATED : CacheEventType.CACHE_ADDED;
        this.eventBus.emit(eventType, event);
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        this.updateStatistics();
      }
      
      this.logger.debug(`Cache set: ${key}`, {
        type: cacheType,
        size: this.formatUtil.formatFileSize(metadata.size),
        expiry: expiry > 0 ? this.formatUtil.formatTime(expiry) : 'never'
      });
    } catch (error) {
      this.Logger.error(`Failed to set cache: ${key}`, error as Error);
      
      // å‘å¸ƒç¼“å­˜é”™è¯¯äº‹ä»¶
      this.eventBus.emit(CacheEventType.CACHE_ERROR, { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error })))))));
      
      throw error;
    }
  }

  /**
   * è·å–ç¼“å­˜
   * @param key ç¼“å­˜é”?   * @param options è·å–é€‰é¡¹
   */
  public async getCache<T>(key: string, options?: {
    ignoreExpiry?: boolean;  // æ˜¯å¦å¿½ç•¥è¿‡æœŸ
    updateAccessTime?: boolean; // æ˜¯å¦æ›´æ–°è®¿é—®æ—¶é—´
  }): Promise<T | null> {
    // æ£€æŸ¥æ˜¯å¦åˆå§‹åŒ–
    if (!this.initialized) {
      throw new Error('CacheRepository not initialized');
    }
    
    try {
      this.cacheStatistics.requests++;
      
      // ä¼˜å…ˆä»å†…å­˜è·å?      const memoryItem = this.memoryCache.get(key);
      if (memoryItem) {
        // æ£€æŸ¥æ˜¯å¦è¿‡æœ?        if (!options?.ignoreExpiry && this.isExpired(memoryItem.metadata)) {
          this.cacheStatistics.misses++;
          this.cacheStatistics.expirations++;
          
          // ç§»é™¤è¿‡æœŸç¼“å­˜
          await this.removeCache(key);
          
          // å‘å¸ƒè¿‡æœŸäº‹ä»¶
          this.eventBus.emit(CacheEventType.CACHE_EXPIRED, {
            key,
            type: memoryItem.metadata.type,
            metadata: memoryItem.metadata
          });
          
          return null;
        }
        
        // æ›´æ–°è®¿é—®æ—¶é—´
        if (options?.updateAccessTime !== false) {
          memoryItem.metadata.lastAccessedAt = Date.now();
        }
        
        this.cacheStatistics.hits++;
        
        this.logger.debug(`Cache hit (memory): ${key}`);
        return memoryItem.value as T;
      }
      
      // ä»ç£ç›˜è·å?      const diskItem = await this.getFromDisk(key);
      if (diskItem) {
        // æ£€æŸ¥æ˜¯å¦è¿‡æœ?        if (!options?.ignoreExpiry && this.isExpired(diskItem.metadata)) {
          this.cacheStatistics.misses++;
          this.cacheStatistics.expirations++;
          
          // ç§»é™¤è¿‡æœŸç¼“å­˜
          await this.removeCache(key);
          
          // å‘å¸ƒè¿‡æœŸäº‹ä»¶
          this.eventBus.emit(CacheEventType.CACHE_EXPIRED, {
            key,
            type: diskItem.metadata.type,
            metadata: diskItem.metadata
          });
          
          return null;
        }
        
        // æ›´æ–°è®¿é—®æ—¶é—´
        if (options?.updateAccessTime !== false) {
          diskItem.metadata.lastAccessedAt = Date.now();
          await this.storeToDisk(key, diskItem);
        }
        
        this.cacheStatistics.hits++;
        
        this.logger.debug(`Cache hit (disk): ${key}`);
        return diskItem.value as T;
      }
      
      // ç¼“å­˜æœªå‘½ä¸?      this.cacheStatistics.misses++;
      this.logger.debug(`Cache miss: ${key}`);
      
      return null;
    } catch (error) {
      this.Logger.error(`Failed to get cache: ${key}`, error as Error);
      
      // å‘å¸ƒç¼“å­˜é”™è¯¯äº‹ä»¶
      this.eventBus.emit(CacheEventType.CACHE_ERROR, { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error })))))));
      
      throw error;
    }
  }

  /**
   * æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ?   * @param key ç¼“å­˜é”?   */
  public hasCache(key: string): boolean {
    if (!this.initialized) {
      return false;
    }
    
    return this.memoryCache.has(key) || this.fileUtil.fileExists(this.getDiskCachePath(key));
  }

  /**
   * åˆ é™¤ç¼“å­˜
   * @param key ç¼“å­˜é”?   */
  public async removeCache(key: string): Promise<void> {
    if (!this.initialized) {
      return;
    }
    
    try {
      let removedItem: CacheItem<unknown> | null = null;
      
      // ä»å†…å­˜åˆ é™?      const memoryItem = this.memoryCache.get(key);
      if (memoryItem) {
        removedItem = memoryItem;
        this.memoryCache.delete(key);
        this.updateCacheSizeStats(-memoryItem.metadata.size, true);
        this.updateItemCountStats(false);
      }
      
      // ä»ç£ç›˜åˆ é™?      const diskPath = this.getDiskCachePath(key);
      if (this.fileUtil.fileExists(diskPath)) {
        if (!removedItem) {
          removedItem = await this.getFromDisk(key);
        }
        await this.fileUtil.deleteFile(diskPath);
        this.updateCacheSizeStats(-(removedItem?.metadata.size || 0), false);
        this.updateItemCountStats(false);
      }
      
      if (removedItem) {
        // æ„å»ºäº‹ä»¶
        const event: CacheChangeEvent = {
          key,
          type: removedItem.metadata.type,
          metadata: removedItem.metadata
        };
        
        // å¤„ç†äº‹ä»¶
        if (this.batchOperation) {
          this.pendingEvents.push(event);
        } else {
          // å‘å¸ƒç¼“å­˜åˆ é™¤äº‹ä»¶
          this.eventBus.emit(CacheEventType.CACHE_REMOVED, event);
          
          // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
          this.updateStatistics();
        }
        
        this.logger.debug(`Cache removed: ${key}`);
      }
    } catch (error) {
      this.Logger.error(`Failed to remove cache: ${key}`, error as Error);
      
      // å‘å¸ƒç¼“å­˜é”™è¯¯äº‹ä»¶
      this.eventBus.emit(CacheEventType.CACHE_ERROR, { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error } instanceof Error ? { key, error } instanceof Error ? { key, error } : new Error(String({ key, error } : new Error(String({ key, error } instanceof Error ? { key, error } : new Error(String({ key, error })))))));
      
      throw error;
    }
  }

  /**
   * æ¸…ç©ºç¼“å­˜
   * @param options æ¸…ç©ºé€‰é¡¹
   */
  public async clearCache(options?: {
    type?: CacheType;        // ç¼“å­˜ç±»å‹
    priority?: CachePriority; // ä¼˜å…ˆçº§é˜ˆå€?    tags?: string[];         // æ ‡ç­¾è¿‡æ»¤
  }): Promise<void> {
    if (!this.initialized) {
      return;
    }
    
    try {
      const keysToRemove: string[] = [];
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é”?      for (const [key, item] of this.memoryCache.entries()) {
        if (this.shouldRemoveItem(item.metadata, options)) {
          keysToRemove.push(key);
        }
      }
      
      // åˆ é™¤å†…å­˜ç¼“å­˜
      for (const key of keysToRemove) {
        const item = this.memoryCache.get(key);
        if (item) {
          this.updateCacheSizeStats(-item.metadata.size, true);
          this.updateItemCountStats(false);
        }
        this.memoryCache.delete(key);
      }
      
      // åˆ é™¤ç£ç›˜ç¼“å­˜
      if (this.cacheDirectory) {
        const files = await this.fileUtil.listFiles(this.cacheDirectory);
        for (const file of files) {
          if (file.endsWith('.json')) {
            const key = file.replace('.json', '');
            const item = await this.getFromDisk(key);
            if (item && this.shouldRemoveItem(item.metadata, options)) {
              await this.fileUtil.deleteFile(file);
              this.updateCacheSizeStats(-item.metadata.size, false);
              this.updateItemCountStats(false);
            }
          }
        }
      }
      
      // å‘å¸ƒç¼“å­˜æ¸…ç©ºäº‹ä»¶
      if (!this.batchOperation) {
        this.eventBus.emit(CacheEventType.CACHE_CLEARED, {
          type: options?.type,
          priority: options?.priority,
          tags: options?.tags
        });
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        this.updateStatistics();
      }
      
      this.logger.info(`Cache cleared`, {
        memoryItemsRemoved: keysToRemove.length,
        options
      });
    } catch (error) {
      this.Logger.error('Failed to clear cache', error as Error);
      
      // å‘å¸ƒç¼“å­˜é”™è¯¯äº‹ä»¶
      this.eventBus.emit(CacheEventType.CACHE_ERROR, { error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error })))))));
      
      throw error;
    }
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   */
  public getStatistics(): CacheStatistics {
    return { ...this.cacheStatistics };
  }

  /**
   * å¼€å§‹æ‰¹é‡æ“ä½?   */
  public startBatchOperation(): void {
    this.batchOperation = true;
    this.pendingEvents = [];
  }

  /**
   * ç»“æŸæ‰¹é‡æ“ä½œ
   */
  public async endBatchOperation(): Promise<void> {
    this.batchOperation = false;
    
    // å‘å¸ƒæ‰€æœ‰å¾…å¤„ç†äº‹ä»¶
    for (const event of this.pendingEvents) {
      // æ ¹æ®äº‹ä»¶ç±»å‹å‘å¸ƒç›¸åº”äº‹ä»¶
      // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”æ ¹æ®äº‹ä»¶ç±»å‹åŒºåˆ?      this.eventBus.emit(CacheEventType.CACHE_UPDATED, event);
    }
    
    this.pendingEvents = [];
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    this.updateStatistics();
  }

  /**
   * æœç´¢ç¼“å­˜
   * @param params æœç´¢å‚æ•°
   */
  public async searchCache(params: CacheSearchParams): Promise<CacheItem<unknown>[]> {
    if (!this.initialized) {
      return [];
    }
    
    try {
      const results: CacheItem<unknown>[] = [];
      
      // æœç´¢å†…å­˜ç¼“å­˜
      for (const item of this.memoryCache.values()) {
        if (this.matchesSearchCriteria(item.metadata, params)) {
          results.push(item);
        }
      }
      
      // æœç´¢ç£ç›˜ç¼“å­˜
      if (this.cacheDirectory && params.includeDisk) {
        const files = await this.fileUtil.listFiles(this.cacheDirectory);
        for (const file of files) {
          if (file.endsWith('.json')) {
            const item = await this.getFromDisk(file.replace('.json', ''));
            if (item && this.matchesSearchCriteria(item.metadata, params)) {
              results.push(item);
            }
          }
        }
      }
      
      // æ’åºç»“æœ
      if (params.sortBy) {
        results.sort((a, b) => {
          const aValue = this.getSortValue(a.metadata, params.sortBy!);
          const bValue = this.getSortValue(b.metadata, params.sortBy!);
          
          if (aValue < bValue) return params.sortOrder === 'asc' ? -1 : 1;
          if (aValue > bValue) return params.sortOrder === 'asc' ? 1 : -1;
          return 0;
        });
      }
      
      // é™åˆ¶ç»“æœæ•°é‡
      if (params.limit && results.length > params.limit) {
        results.splice(params.limit);
      }
      
      return results;
    } catch (error) {
      this.Logger.error('Failed to search cache', error as Error);
      
      // å‘å¸ƒç¼“å­˜é”™è¯¯äº‹ä»¶
      this.eventBus.emit(CacheEventType.CACHE_ERROR, { error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error })))))));
      
      throw error;
    }
  }

  /**
   * å…³é—­ç¼“å­˜ä»“åº“
   */
  public async shutdown(): Promise<void> {
    if (!this.initialized) {
      return;
    }
    
    try {
      // åœæ­¢å®šæ—¶æ¸…ç†
      this.stopPeriodicCleanup();
      
      // ä¿å­˜ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
      await this.saveCacheStatistics();
      
      // æ¸…ç©ºå†…å­˜ç¼“å­˜
      this.memoryCache.clear();
      
      this.initialized = false;
      this.logger.info('CacheRepository shutdown');
    } catch (error) {
      this.Logger.error('Failed to shutdown CacheRepository', error as Error);
      
      // å‘å¸ƒç¼“å­˜é”™è¯¯äº‹ä»¶
      this.eventBus.emit(CacheEventType.CACHE_ERROR, { error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error } instanceof Error ? { error } instanceof Error ? { error } : new Error(String({ error } : new Error(String({ error } instanceof Error ? { error } : new Error(String({ error })))))));
      
      throw error;
    }
  }

  // ç§æœ‰è¾…åŠ©æ–¹æ³•

  /**
   * åŠ è½½ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   */
  private async loadCacheStatistics(): Promise<void> {
    try {
      const stats = await this.storageUtil.get(LocalStorageType.CACHE_STATISTICS);
      if (stats) {
        this.cacheStatistics = { ...this.cacheStatistics, ...JSON.parse(stats) };
      }
    } catch (error) {
      this.logger.warn('Failed to load cache statistics, using defaults');
    }
  }

  /**
   * ä¿å­˜ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   */
  private async saveCacheStatistics(): Promise<void> {
    try {
      await this.storageUtil.set(
        LocalStorageType.CACHE_STATISTICS,
        JSON.stringify(this.cacheStatistics)
      );
    } catch (error) {
      this.logger.warn('Failed to save cache statistics');
    }
  }

  /**
   * å¯åŠ¨å®šæ—¶æ¸…ç†
   */
  private startPeriodicCleanup(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
    }
    
    this.cleanupTimer = setInterval(async () => {
      try {
        await this.cleanupExpiredCache();
        await this.cleanupCacheBySize();
      } catch (error) {
        this.Logger.error('Periodic cleanup failed', error as Error);
      }
    }, this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval instanceof Error ? this.cacheConfig.cleanupInterval : new Error(String(this.cacheConfig.cleanupInterval))))))) as unknown as number;
  }

  /**
   * åœæ­¢å®šæ—¶æ¸…ç†
   */
  private stopPeriodicCleanup(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
  }

  /**
   * æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœ?   */
  private isExpired(metadata: CacheMetadata): boolean {
    return metadata.expiry > 0 && Date.now() > metadata.expiry;
  }

  /**
   * è®¡ç®—å¯¹è±¡å¤§å°
   */
  private calculateSize(value: Record<string, string | number | boolean | null>): number {
    try {
      const jsonString = JSON.stringify(value);
      return new Blob([jsonString]).size;
    } catch {
      return 1024; // é»˜è®¤å¤§å°
    }
  }

  /**
   * æ£€æŸ¥ç¼“å­˜å¤§å°é™åˆ?   */
  private checkCacheSizeLimit(newSize: number): boolean {
    const totalSize = this.cacheStatistics.memorySize + this.cacheStatistics.diskSize;
    return totalSize + newSize <= this.cacheConfig.maxSize;
  }

  /**
   * æ›´æ–°ç¼“å­˜å¤§å°ç»Ÿè®¡
   */
  private updateCacheSizeStats(sizeDelta: number, isMemory: boolean): void {
    if (isMemory) {
      this.cacheStatistics.memorySize += sizeDelta;
    } else {
      this.cacheStatistics.diskSize += sizeDelta;
    }
    
    // å‘å¸ƒå¤§å°å˜æ›´äº‹ä»¶
    if (!this.batchOperation) {
      this.eventBus.emit(CacheEventType.CACHE_SIZE_CHANGED, {
        memorySize: this.cacheStatistics.memorySize,
        diskSize: this.cacheStatistics.diskSize,
        totalSize: this.cacheStatistics.memorySize + this.cacheStatistics.diskSize
      });
    }
  }

  /**
   * æ›´æ–°ç¼“å­˜é¡¹æ•°é‡ç»Ÿè®?   */
  private updateItemCountStats(isMemory: boolean): void {
    if (isMemory) {
      this.cacheStatistics.memoryItems = this.memoryCache.size;
    } else {
      // ç£ç›˜é¡¹æ•°é‡éœ€è¦æ‰«ææ–‡ä»¶ç³»ç»Ÿï¼Œè¿™é‡Œç®€åŒ–å¤„ç?      this.cacheStatistics.diskItems = Math.max(0, this.cacheStatistics.diskItems);
    }
  }

  /**
   * æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
   */
  private updateStatistics(): void {
    if (!this.batchOperation) {
      this.eventBus.emit(CacheEventType.CACHE_STATISTICS_UPDATED, {
        ...this.cacheStatistics
      });
    }
  }

  /**
   * è·å–ç£ç›˜ç¼“å­˜è·¯å¾„
   */
  private getDiskCachePath(key: string): string {
    if (!this.cacheDirectory) {
      throw new Error('Cache directory not set');
    }
    
    // å¯¹keyè¿›è¡Œå®‰å…¨ç¼–ç 
    const safeKey = encodeURIComponent(key).replace(/%/g, '_');
    return `${this.cacheDirectory}/${safeKey}.json`;
  }

  /**
   * å­˜å‚¨åˆ°ç£ç›?   */
  private async storeToDisk<T>(key: string, item: CacheItem<T>): Promise<void> {
    if (!this.cacheDirectory) {
      return;
    }
    
    const filePath = this.getDiskCachePath(key);
    const content = JSON.stringify(item, null, 2);
    
    await this.fileUtil.writeFile(filePath, content);
  }

  /**
   * ä»ç£ç›˜è·å?   */
  private async getFromDisk<T>(key: string): Promise<CacheItem<T> | null> {
    if (!this.cacheDirectory) {
      return null;
    }
    
    const filePath = this.getDiskCachePath(key);
    
    if (!this.fileUtil.fileExists(filePath)) {
      return null;
    }
    
    try {
      const content = await this.fileUtil.readFile(filePath);
      return JSON.parse(content) as CacheItem<T>;
    } catch (error) {
      this.logger.warn(`Failed to read cache from disk: ${key}`, error as Error);
      
      // åˆ é™¤æŸåçš„æ–‡ä»?      await this.fileUtil.deleteFile(filePath);
      
      return null;
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  private async cleanupExpiredCache(): Promise<void> {
    try {
      const expiredKeys: string[] = [];
      
      // æ£€æŸ¥å†…å­˜ç¼“å­?      for (const [key, item] of this.memoryCache.entries()) {
        if (this.isExpired(item.metadata)) {
          expiredKeys.push(key);
        }
      }
      
      // åˆ é™¤è¿‡æœŸç¼“å­˜
      for (const key of expiredKeys) {
        await this.removeCache(key);
      }
      
      // æ£€æŸ¥ç£ç›˜ç¼“å­?      if (this.cacheDirectory) {
        const files = await this.fileUtil.listFiles(this.cacheDirectory);
        for (const file of files) {
          if (file.endsWith('.json')) {
            const key = file.replace('.json', '');
            const item = await this.getFromDisk(key);
            if (item && this.isExpired(item.metadata)) {
              await this.removeCache(key);
            }
          }
        }
      }
      
      if (expiredKeys.length > 0) {
        this.logger.info(`Cleaned up ${expiredKeys.length} expired cache items`);
      }
    } catch (error) {
      this.Logger.error('Failed to cleanup expired cache', error as Error);
      throw error;
    }
  }

  /**
   * æ ¹æ®å¤§å°æ¸…ç†ç¼“å­˜
   */
  private async cleanupCacheBySize(): Promise<void> {
    try {
      const totalSize = this.cacheStatistics.memorySize + this.cacheStatistics.diskSize;
      
      if (totalSize <= this.cacheConfig.maxSize) {
        return;
      }
      
      const targetReduction = totalSize - this.cacheConfig.maxSize * 0.9; // æ¸…ç†åˆ?0%å®¹é‡
      
      await this.cleanupCache({
        targetSizeReduction: targetReduction, priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      } instanceof Error ? priorityThreshold: CachePriority.LOW
      } : new Error(String(priorityThreshold: CachePriority.LOW
      })))))));
    } catch (error) {
      this.Logger.error('Failed to cleanup cache by size', error as Error);
      throw error;
    }
  }

  /**
   * æ¸…ç†ç¼“å­˜
   */
  private async cleanupCache(options: CacheCleanupOptions): Promise<void> {
    try {
      const itemsToRemove: Array<{key: string, metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( instanceof Error ? metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries( : new Error(String(metadata: CacheMetadata}> = [];
      let totalSizeToRemove = 0;
      
      // æ”¶é›†è¦åˆ é™¤çš„ç¼“å­˜é¡?      for (const [key, item] of this.memoryCache.entries()))))))) {
        if (item.metadata.priority <= (options.priorityThreshold || CachePriority.LOW)) {
          itemsToRemove.push({ key, metadata: item.metadata });
          totalSizeToRemove += item.metadata.size;
          
          if (totalSizeToRemove >= options.targetSizeReduction) {
            break;
          }
        }
      }
      
      // å¦‚æœå†…å­˜ç¼“å­˜ä¸å¤Ÿï¼Œæ£€æŸ¥ç£ç›˜ç¼“å­?      if (totalSizeToRemove < options.targetSizeReduction && this.cacheDirectory) {
        const files = await this.fileUtil.listFiles(this.cacheDirectory);
        
        for (const file of files) {
          if (file.endsWith('.json')) {
            const key = file.replace('.json', '');
            const item = await this.getFromDisk(key);
            
            if (item && item.metadata.priority <= (options.priorityThreshold || CachePriority.LOW)) {
              itemsToRemove.push({ key, metadata: item.metadata });
              totalSizeToRemove += item.metadata.size;
              
              if (totalSizeToRemove >= options.targetSizeReduction) {
                break;
              }
            }
          }
        }
      }
      
      // åˆ é™¤ç¼“å­˜é¡?      for (const { key } of itemsToRemove) {
        await this.removeCache(key);
      }
      
      this.cacheStatistics.evictions += itemsToRemove.length;
      
      if (itemsToRemove.length > 0) {
        this.logger.info(`Cleaned up ${itemsToRemove.length} cache items`, {
          totalSizeRemoved: this.formatUtil.formatFileSize(totalSizeToRemove),
          priorityThreshold: options.priorityThreshold
        });
      }
    } catch (error) {
      this.Logger.error('Failed to cleanup cache', error as Error);
      throw error;
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦åº”è¯¥åˆ é™¤ç¼“å­˜é¡¹
   */
  private shouldRemoveItem(metadata: CacheMetadata, options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } instanceof Error ? options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  } : new Error(String(options?: {
    type?: CacheType;
    priority?: CachePriority;
    tags?: string[];
  }))))))): boolean {
    // æ£€æŸ¥ç±»å?    if (options?.type && metadata.type !== options.type) {
      return false;
    }
    
    // æ£€æŸ¥ä¼˜å…ˆçº§
    if (options?.priority && metadata.priority > options.priority) {
      return false;
    }
    
    // æ£€æŸ¥æ ‡ç­?    if (options?.tags && options.tags.length > 0) {
      const hasMatchingTag = options.tags.some(tag => metadata.tags.includes(tag));
      if (!hasMatchingTag) {
        return false;
      }
    }
    
    return true;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦åŒ¹é…æœç´¢æ¡ä»?   */
  private matchesSearchCriteria(metadata: CacheMetadata, params: CacheSearchParams): boolean {
    // æ£€æŸ¥ç±»å?    if (params.type && metadata.type !== params.type) {
      return false;
    }
    
    // æ£€æŸ¥ä¼˜å…ˆçº§
    if (params.priority && metadata.priority !== params.priority) {
      return false;
    }
    
    // æ£€æŸ¥æ ‡ç­?    if (params.tags && params.tags.length > 0) {
      const hasMatchingTag = params.tags.some(tag => metadata.tags.includes(tag));
      if (!hasMatchingTag) {
        return false;
      }
    }
    
    // æ£€æŸ¥åˆ›å»ºæ—¶é—´èŒƒå›?    if (params.createdAfter && metadata.createdAt < params.createdAfter) {
      return false;
    }
    
    if (params.createdBefore && metadata.createdAt > params.createdBefore) {
      return false;
    }
    
    // æ£€æŸ¥è®¿é—®æ—¶é—´èŒƒå›?    if (params.accessedAfter && metadata.lastAccessedAt < params.accessedAfter) {
      return false;
    }
    
    if (params.accessedBefore && metadata.lastAccessedAt > params.accessedBefore) {
      return false;
    }
    
    // æ£€æŸ¥è¿‡æœŸçŠ¶æ€?    if (params.expiredOnly && !this.isExpired(metadata)) {
      return false;
    }
    
    if (params.nonExpiredOnly && this.isExpired(metadata)) {
      return false;
    }
    
    return true;
  }

  /**
   * è·å–æ’åºå€?   */
  private getSortValue(metadata: CacheMetadata, sortBy: keyof CacheMetadata): number | string {
    const value = metadata[sortBy];
    
    if (typeof value === 'number' || typeof value === 'string') {
      return value;
    }
    
    return 0;
  }
}


