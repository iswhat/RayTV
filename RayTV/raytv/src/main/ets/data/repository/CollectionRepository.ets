// CollectionRepository.ets - Êî∂ËóèÊï∞ÊçÆ‰ªìÂ∫ì
// Ë¥üË¥£Êî∂ËóèÂÜÖÂÆπÁõ∏ÂÖ≥Êï∞ÊçÆÁöÑÂ≠òÂÇ®„ÄÅËØªÂèñÂíåÁÆ°ÁêÜ

import { SQLiteHelper, QueryCondition } from '../db/SQLiteHelper';
import { COLLECTION_TABLE, COLLECTION_FOLDER_TABLE } from '../db/TableSchema';
import { CollectionItemType, CollectionVisibility, CollectionSortType } from '../model/LocalModel';
import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';

const TAG = 'CollectionRepository';
const COLLECTION_CACHE_PREFIX = 'collection_item_';
const COLLECTION_LIST_CACHE = 'collection_list_cache';

export interface CollectionItem {
  id?: string;
  title: string;
  subtitle?: string;
  coverUrl?: string;
  itemType: CollectionItemType;
  contentType: string;
  siteId: string;
  contentId: string;
  folderId?: string;
  tags?: string[];
  sortOrder?: number;
  visibility?: CollectionVisibility;
  createTime?: number;
  updateTime?: number;
  extraData?: Record<string, unknown>;
}

export interface CollectionFolder {
  id?: string;
  name: string;
  description?: string;
  coverUrl?: string;
  sortOrder?: number;
  createTime?: number;
  updateTime?: number;
  itemCount?: number;
}

export class CollectionRepository {
  private static instance: CollectionRepository;
  private sqliteHelper: SQLiteHelper;
  private storageUtil: StorageUtil;
  
  private constructor() {
    this.sqliteHelper = SQLiteHelper.getInstance();
    this.storageUtil = StorageUtil.getInstance();
  }
  
  /**
   * Ëé∑ÂèñÊî∂Ëóè‰ªìÂ∫ìÂçï‰æãÂÆû‰æã
   */
  public static getInstance(): CollectionRepository {
    if (!CollectionRepository.instance) {
      CollectionRepository.instance = new CollectionRepository();
    }
    return CollectionRepository.instance;
  }
  
  /**
   * Ê∑ªÂä†Êî∂Ëóè
   * @param item Êî∂ËóèÈ°?   * @returns ÊòØÂê¶Ê∑ªÂä†ÊàêÂäü
   */
  public async addCollection(item: CollectionItem): Promise<boolean> {
    try {
      Logger.debug(TAG, `Adding collection: ${item.title}`);
      
      // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®Áõ∏ÂêåÂÜÖÂÆπÁöÑÊî∂Ëó?      if (await this.isContentCollected(item.contentType, item.contentId)) {
        Logger.warn(TAG, `Content already collected: ${item.contentId}`);
        return false;
      }
      
      const collectionData = {
        [COLLECTION_TABLE.COLUMNS.TITLE]: item.title,
        [COLLECTION_TABLE.COLUMNS.SUBTITLE]: item.subtitle || '',
        [COLLECTION_TABLE.COLUMNS.COVER_URL]: item.coverUrl || '',
        [COLLECTION_TABLE.COLUMNS.ITEM_TYPE]: item.itemType,
        [COLLECTION_TABLE.COLUMNS.CONTENT_TYPE]: item.contentType,
        [COLLECTION_TABLE.COLUMNS.SITE_ID]: item.siteId,
        [COLLECTION_TABLE.COLUMNS.CONTENT_ID]: item.contentId,
        [COLLECTION_TABLE.COLUMNS.FOLDER_ID]: item.folderId || null,
        [COLLECTION_TABLE.COLUMNS.TAGS]: item.tags?.join(',') || '',
        [COLLECTION_TABLE.COLUMNS.SORT_ORDER]: item.sortOrder || 0,
        [COLLECTION_TABLE.COLUMNS.VISIBILITY]: item.visibility || CollectionVisibility.PUBLIC,
        [COLLECTION_TABLE.COLUMNS.CREATE_TIME]: Date.now(),
        [COLLECTION_TABLE.COLUMNS.UPDATE_TIME]: Date.now(),
        [COLLECTION_TABLE.COLUMNS.EXTRA_DATA]: JSON.stringify(item.extraData || {})
      };
      
      const result = await this.sqliteHelper.insert(COLLECTION_TABLE.TABLE_NAME, collectionData);
      
      if (result.success && result.lastInsertRowId) {
        item.id = result.lastInsertRowId.toString();
        
        // Êõ¥Êñ∞ÁºìÂ≠ò
        await this.cacheCollectionItem(item);
        await this.invalidateCollectionListCache();
        
        Logger.info(TAG, `Collection added successfully: ${item.title}`);
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to add collection: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * Êõ¥Êñ∞Êî∂ËóèÈ°?   * @param item Êî∂ËóèÈ°?   * @returns ÊòØÂê¶Êõ¥Êñ∞ÊàêÂäü
   */
  public async updateCollection(item: CollectionItem): Promise<boolean> {
    try {
      if (!item.id) {
        Logger.error(TAG, 'Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' : new Error(String('Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' : new Error(String('Collection ID is required for update' : new Error(String('Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' : new Error(String('Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' : new Error(String('Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' : new Error(String('Collection ID is required for update' : new Error(String('Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' : new Error(String('Collection ID is required for update' : new Error(String('Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' : new Error(String('Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' : new Error(String('Collection ID is required for update' : new Error(String('Collection ID is required for update' instanceof Error ? 'Collection ID is required for update' : new Error(String('Collection ID is required for update')))))));
        return false;
      }
      
      Logger.debug(TAG, `Updating collection: ${item.id}`);
      
      const collectionData = {
        [COLLECTION_TABLE.COLUMNS.TITLE]: item.title,
        [COLLECTION_TABLE.COLUMNS.SUBTITLE]: item.subtitle || '',
        [COLLECTION_TABLE.COLUMNS.COVER_URL]: item.coverUrl || '',
        [COLLECTION_TABLE.COLUMNS.ITEM_TYPE]: item.itemType,
        [COLLECTION_TABLE.COLUMNS.CONTENT_TYPE]: item.contentType,
        [COLLECTION_TABLE.COLUMNS.SITE_ID]: item.siteId,
        [COLLECTION_TABLE.COLUMNS.FOLDER_ID]: item.folderId || null,
        [COLLECTION_TABLE.COLUMNS.TAGS]: item.tags?.join(',') || '',
        [COLLECTION_TABLE.COLUMNS.SORT_ORDER]: item.sortOrder || 0,
        [COLLECTION_TABLE.COLUMNS.VISIBILITY]: item.visibility || CollectionVisibility.PUBLIC,
        [COLLECTION_TABLE.COLUMNS.UPDATE_TIME]: Date.now(),
        [COLLECTION_TABLE.COLUMNS.EXTRA_DATA]: JSON.stringify(item.extraData || {})
      };
      
      const conditions: QueryCondition[] = [{
        column: COLLECTION_TABLE.COLUMNS.ID,
        value: item.id
      }];
      
      const result = await this.sqliteHelper.update(COLLECTION_TABLE.TABLE_NAME, collectionData, conditions);
      
      if (result.success) {
        // Êõ¥Êñ∞ÁºìÂ≠ò
        await this.cacheCollectionItem(item);
        await this.invalidateCollectionListCache();
        
        Logger.info(TAG, `Collection updated successfully: ${item.id}`);
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to update collection: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * Âà†Èô§Êî∂ËóèÈ°?   * @param collectionId Êî∂ËóèÈ°πID
   * @returns ÊòØÂê¶Âà†Èô§ÊàêÂäü
   */
  public async removeCollection(collectionId: string): Promise<boolean> {
    try {
      Logger.debug(TAG, `Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}` instanceof Error ? `Removing collection: ${collectionId}` : new Error(String(`Removing collection: ${collectionId}`)))))));
      
      const conditions: QueryCondition[] = [{
        column: COLLECTION_TABLE.COLUMNS.ID,
        value: collectionId
      }];
      
      const result = await this.sqliteHelper.delete(COLLECTION_TABLE.TABLE_NAME, conditions);
      
      if (result.success) {
        // Ê∏ÖÈô§ÁºìÂ≠ò
        await this.removeCachedCollectionItem(collectionId);
        await this.invalidateCollectionListCache();
        
        Logger.info(TAG, `Collection removed successfully: ${collectionId}`);
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to remove collection: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * ÊâπÈáèÂà†Èô§Êî∂ËóèÈ°?   * @param collectionIds Êî∂ËóèÈ°πIDÂàóË°®
   * @returns Âà†Èô§ÊàêÂäüÁöÑÊï∞Èá?   */
  public async batchRemoveCollections(collectionIds: string[]): Promise<number> {
    if (!collectionIds || collectionIds.length === 0) {
      return 0;
    }
    
    try {
      Logger.debug(TAG, `Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections` instanceof Error ? `Batch removing ${collectionIds.length} collections` : new Error(String(`Batch removing ${collectionIds.length} collections`)))))));
      
      const conditions: QueryCondition[] = [{
        column: COLLECTION_TABLE.COLUMNS.ID,
        operator: 'IN',
        value: collectionIds
      }];
      
      const result = await this.sqliteHelper.delete(COLLECTION_TABLE.TABLE_NAME, conditions);
      
      if (result.success) {
        // Ê∏ÖÈô§ÁºìÂ≠ò
        for (const id of collectionIds) {
          await this.removeCachedCollectionItem(id);
        }
        await this.invalidateCollectionListCache();
        
        Logger.info(TAG, `Batch removed ${result.affectedRows} collections`);
      }
      
      return result.affectedRows || 0;
    } catch (error) {
      Logger.error(TAG, `Failed to batch remove collections: ${JSON.stringify(error)}`);
      return 0;
    }
  }
  
  /**
   * Ëé∑ÂèñÊâÄÊúâÊî∂ËóèÈ°π
   * @param sortType ÊéíÂ∫èÁ±ªÂûã
   * @param limit ÈôêÂà∂Êï∞Èáè
   * @param offset ÂÅèÁßªÈá?   * @returns Êî∂ËóèÈ°πÂàóË°?   */
  public async getAllCollections(
    sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC, limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
   instanceof Error ? limit: number = 50,
    offset: number = 0
   : new Error(String(limit: number = 50,
    offset: number = 0
  ))))))): Promise<CollectionItem[]> {
    try {
      // ÊûÑÂª∫ÊéíÂ∫èÈÄâÈ°π
      const sortOptions = this.buildSortOptions(sortType);
      
      // Êü•ËØ¢Êï∞ÊçÆÂ∫?      const collectionRecords = await this.sqliteHelper.query(
        COLLECTION_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit,
        offset
      );
      
      // ËΩ¨Êç¢‰∏∫CollectionItemÂØπË±°
      const collections = this.convertToCollectionObjects(collectionRecords);
      
      Logger.info(TAG, `Retrieved ${collections.length} collections`);
      return collections;
    } catch (error) {
      Logger.error(TAG, `Failed to get all collections: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * Ê†πÊçÆIDËé∑ÂèñÊî∂ËóèÈ°?   * @param collectionId Êî∂ËóèÈ°πID
   * @returns Êî∂ËóèÈ°πÊàñnull
   */
  public async getCollectionById(collectionId: string): Promise<CollectionItem | null> {
    try {
      // Â∞ùËØï‰ªéÁºìÂ≠òËé∑Âè?      const cachedItem = await this.getCachedCollectionItem(collectionId);
      if (cachedItem) {
        Logger.debug(TAG, `Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache` instanceof Error ? `Returning collection ${collectionId} from cache` : new Error(String(`Returning collection ${collectionId} from cache`)))))));
        return cachedItem;
      }
      
      // Êü•ËØ¢Êï∞ÊçÆÂ∫?      const conditions: QueryCondition[] = [{
        column: COLLECTION_TABLE.COLUMNS.ID,
        value: collectionId
      }];
      
      const collectionRecord = await this.sqliteHelper.getFirst(
        COLLECTION_TABLE.TABLE_NAME,
        ['*'],
        conditions
      );
      
      if (!collectionRecord) {
        return null;
      }
      
      // ËΩ¨Êç¢‰∏∫CollectionItemÂØπË±°
      const collection = this.convertToCollectionObject(collectionRecord);
      
      // Êõ¥Êñ∞ÁºìÂ≠ò
      await this.cacheCollectionItem(collection);
      
      return collection;
    } catch (error) {
      Logger.error(TAG, `Failed to get collection by ID: ${JSON.stringify(error)}`);
      return null;
    }
  }
  
  /**
   * Ê†πÊçÆÂÜÖÂÆπIDÊ£ÄÊü•ÊòØÂê¶Â∑≤Êî∂Ëóè
   * @param contentType ÂÜÖÂÆπÁ±ªÂûã
   * @param contentId ÂÜÖÂÆπID
   * @returns ÊòØÂê¶Â∑≤Êî∂Ëó?   */
  public async isContentCollected(contentType: string, contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string))))))): Promise<boolean> {
    try {
      const conditions: QueryCondition[] = [{
        column: COLLECTION_TABLE.COLUMNS.CONTENT_TYPE,
        value: contentType
      }, {
        column: COLLECTION_TABLE.COLUMNS.CONTENT_ID,
        value: contentId
      }];
      
      return await this.sqliteHelper.exists(COLLECTION_TABLE.TABLE_NAME, conditions);
    } catch (error) {
      Logger.error(TAG, `Failed to check if content is collected: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * Ê†πÊçÆÂÜÖÂÆπIDËé∑ÂèñÊî∂ËóèÈ°?   * @param contentType ÂÜÖÂÆπÁ±ªÂûã
   * @param contentId ÂÜÖÂÆπID
   * @returns Êî∂ËóèÈ°πÊàñnull
   */
  public async getCollectionByContent(contentType: string, contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string : new Error(String(contentId: string instanceof Error ? contentId: string : new Error(String(contentId: string))))))): Promise<CollectionItem | null> {
    try {
      const conditions: QueryCondition[] = [{
        column: COLLECTION_TABLE.COLUMNS.CONTENT_TYPE,
        value: contentType
      }, {
        column: COLLECTION_TABLE.COLUMNS.CONTENT_ID,
        value: contentId
      }];
      
      const collectionRecord = await this.sqliteHelper.getFirst(
        COLLECTION_TABLE.TABLE_NAME,
        ['*'],
        conditions
      );
      
      if (!collectionRecord) {
        return null;
      }
      
      return this.convertToCollectionObject(collectionRecord);
    } catch (error) {
      Logger.error(TAG, `Failed to get collection by content: ${JSON.stringify(error)}`);
      return null;
    }
  }
  
  /**
   * ÊåâÊñá‰ª∂Â§πËé∑ÂèñÊî∂ËóèÈ°?   * @param folderId Êñá‰ª∂Â§πID
   * @param sortType ÊéíÂ∫èÁ±ªÂûã
   * @returns Êî∂ËóèÈ°πÂàóË°?   */
  public async getCollectionsByFolder(
    folderId: string, sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
  ))))))): Promise<CollectionItem[]> {
    try {
      const conditions: QueryCondition[] = [{
        column: COLLECTION_TABLE.COLUMNS.FOLDER_ID,
        value: folderId
      }];
      
      const sortOptions = this.buildSortOptions(sortType);
      
      const collectionRecords = await this.sqliteHelper.query(
        COLLECTION_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
      );
      
      const collections = this.convertToCollectionObjects(collectionRecords);
      Logger.info(TAG, `Retrieved ${collections.length} collections from folder ${folderId}`);
      return collections;
    } catch (error) {
      Logger.error(TAG, `Failed to get collections by folder: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * ÊåâÊ†áÁ≠æËé∑ÂèñÊî∂ËóèÈ°π
   * @param tag Ê†áÁ≠æ
   * @param sortType ÊéíÂ∫èÁ±ªÂûã
   * @returns Êî∂ËóèÈ°πÂàóË°?   */
  public async getCollectionsByTag(
    tag: string, sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.CREATE_TIME_DESC
  ))))))): Promise<CollectionItem[]> {
    try {
      // ‰ΩøÁî®LIKEÊü•ËØ¢ÂåÖÂê´ÊåáÂÆöÊ†áÁ≠æÁöÑÊî∂ËóèÈ°π
      const conditions: QueryCondition[] = [{
        column: COLLECTION_TABLE.COLUMNS.TAGS,
        operator: 'LIKE',
        value: `%${tag}%`
      }];
      
      const sortOptions = this.buildSortOptions(sortType);
      
      const collectionRecords = await this.sqliteHelper.query(
        COLLECTION_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
      );
      
      // ËøáÊª§Âá∫Á°ÆÂÆûÂåÖÂê´ÊåáÂÆöÊ†áÁ≠æÁöÑÈ°πÔºàÈÅøÂÖçLIKEÂåπÈÖç‰∏çÂáÜÁ°ÆÔºâ
      const collections = this.convertToCollectionObjects(collectionRecords).filter(item => 
        item.tags?.includes(tag)
      );
      
      Logger.info(TAG, `Retrieved ${collections.length} collections with tag ${tag}`);
      return collections;
    } catch (error) {
      Logger.error(TAG, `Failed to get collections by tag: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * ÊåâÁ±ªÂûãËé∑ÂèñÊî∂ËóèÈ°π
   * @param contentType ÂÜÖÂÆπÁ±ªÂûã
   * @param sortType ÊéíÂ∫èÁ±ªÂûã
   * @returns Êî∂ËóèÈ°πÂàóË°?   */
  public async getCollectionsByContentType(
    contentType: string, sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   instanceof Error ? sortType: CollectionSortType = CollectionSortType.TITLE_ASC
   : new Error(String(sortType: CollectionSortType = CollectionSortType.TITLE_ASC
  ))))))): Promise<CollectionItem[]> {
    try {
      const conditions: QueryCondition[] = [{
        column: COLLECTION_TABLE.COLUMNS.CONTENT_TYPE,
        value: contentType
      }];
      
      const sortOptions = this.buildSortOptions(sortType);
      
      const collectionRecords = await this.sqliteHelper.query(
        COLLECTION_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
      );
      
      const collections = this.convertToCollectionObjects(collectionRecords);
      Logger.info(TAG, `Retrieved ${collections.length} collections of type ${contentType}`);
      return collections;
    } catch (error) {
      Logger.error(TAG, `Failed to get collections by content type: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * Ëé∑ÂèñÊî∂ËóèÈ°πÊÄªÊï∞
   * @returns Êî∂ËóèÈ°πÊÄªÊï∞
   */
  public async getCollectionCount(): Promise<number> {
    try {
      return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME);
    } catch (error) {
      Logger.error(TAG, `Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error instanceof Error ? `Failed to get collection count: ${JSON.stringify(error : new Error(String(`Failed to get collection count: ${JSON.stringify(error)))))))}`);
      return 0;
    }
  }
  
  /**
   * ÂàõÂª∫Êî∂ËóèÊñá‰ª∂Â§?   * @param folder Êñá‰ª∂Â§π‰ø°ÊÅ?   * @returns ÊòØÂê¶ÂàõÂª∫ÊàêÂäü
   */
  public async createFolder(folder: CollectionFolder): Promise<boolean> {
    try {
      Logger.debug(TAG, `Creating collection folder: ${folder.name}`);
      
      const folderData: Record<string, string | number | boolean | null> = { ... };
      
      const result = await this.sqliteHelper.insert(COLLECTION_FOLDER_TABLE.TABLE_NAME, folderData);
      
      if (result.success && result.lastInsertRowId) {
        folder.id = result.lastInsertRowId.toString();
        Logger.info(TAG, `Collection folder created successfully: ${folder.name}`);
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to create collection folder: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * Êõ¥Êñ∞Êî∂ËóèÊñá‰ª∂Â§?   * @param folder Êñá‰ª∂Â§π‰ø°ÊÅ?   * @returns ÊòØÂê¶Êõ¥Êñ∞ÊàêÂäü
   */
  public async updateFolder(folder: CollectionFolder): Promise<boolean> {
    try {
      if (!folder.id) {
        Logger.error(TAG, 'Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' : new Error(String('Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' : new Error(String('Folder ID is required for update' : new Error(String('Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' : new Error(String('Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' : new Error(String('Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' : new Error(String('Folder ID is required for update' : new Error(String('Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' : new Error(String('Folder ID is required for update' : new Error(String('Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' : new Error(String('Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' : new Error(String('Folder ID is required for update' : new Error(String('Folder ID is required for update' instanceof Error ? 'Folder ID is required for update' : new Error(String('Folder ID is required for update')))))));
        return false;
      }
      
      Logger.debug(TAG, `Updating collection folder: ${folder.id}`);
      
      const folderData: Record<string, string | number | boolean | null> = { ... };
      
      const conditions: QueryCondition[] = [{
        column: COLLECTION_FOLDER_TABLE.COLUMNS.ID,
        value: folder.id
      }];
      
      const result = await this.sqliteHelper.update(COLLECTION_FOLDER_TABLE.TABLE_NAME, folderData, conditions);
      
      if (result.success) {
        Logger.info(TAG, `Collection folder updated successfully: ${folder.id}`);
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to update collection folder: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * Âà†Èô§Êî∂ËóèÊñá‰ª∂Â§?   * @param folderId Êñá‰ª∂Â§πID
   * @returns ÊòØÂê¶Âà†Èô§ÊàêÂäü
   */
  public async deleteFolder(folderId: string): Promise<boolean> {
    try {
      Logger.debug(TAG, `Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}` instanceof Error ? `Deleting collection folder: ${folderId}` : new Error(String(`Deleting collection folder: ${folderId}`)))))));
      
      // È¶ñÂÖàÂ∞ÜËØ•Êñá‰ª∂Â§π‰∏ãÁöÑÊî∂ËóèÈ°πÁßªÂà∞Ê†πÁõÆÂΩ?      const updateResult = await this.sqliteHelper.update(
        COLLECTION_TABLE.TABLE_NAME,
        { [COLLECTION_TABLE.COLUMNS.FOLDER_ID]: null },
        [{ column: COLLECTION_TABLE.COLUMNS.FOLDER_ID, value: folderId }]
      );
      
      if (!updateResult.success) {
        Logger.error(TAG, 'Failed to update collections in folder before deletion');
        return false;
      }
      
      // ÁÑ∂ÂêéÂà†Èô§Êñá‰ª∂Â§?      const conditions: QueryCondition[] = [{
        column: COLLECTION_FOLDER_TABLE.COLUMNS.ID, value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
      }];
      
      const deleteResult = await this.sqliteHelper.delete(COLLECTION_FOLDER_TABLE.TABLE_NAME, conditions)))))));
      
      if (deleteResult.success) {
        await this.invalidateCollectionListCache();
        Logger.info(TAG, `Collection folder deleted successfully: ${folderId}`);
      }
      
      return deleteResult.success;
    } catch (error) {
      Logger.error(TAG, `Failed to delete collection folder: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * Ëé∑ÂèñÊâÄÊúâÊî∂ËóèÊñá‰ª∂Â§π
   * @returns Êñá‰ª∂Â§πÂàóË°?   */
  public async getAllFolders(): Promise<CollectionFolder[]> {
    try {
      const sortOptions = [{
        column: COLLECTION_FOLDER_TABLE.COLUMNS.SORT_ORDER, order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       instanceof Error ? order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
       : new Error(String(order: 'ASC'
      }, {
        column: COLLECTION_FOLDER_TABLE.COLUMNS.NAME,
        order: 'ASC'
      }];
      
      const folderRecords = await this.sqliteHelper.query(
        COLLECTION_FOLDER_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions
      )))))));
      
      // Ëé∑ÂèñÊØè‰∏™Êñá‰ª∂Â§πÁöÑÈ°πÁõÆÊï∞Èáè
      const folders: CollectionFolder[] = [];
      for (const record of folderRecords) {
        const folderId = record[COLLECTION_FOLDER_TABLE.COLUMNS.ID].toString();
        const itemCount = await this.getCollectionCountByFolder(folderId);
        
        folders.push({
          id: folderId,
          name: record[COLLECTION_FOLDER_TABLE.COLUMNS.NAME],
          description: record[COLLECTION_FOLDER_TABLE.COLUMNS.DESCRIPTION],
          coverUrl: record[COLLECTION_FOLDER_TABLE.COLUMNS.COVER_URL],
          sortOrder: record[COLLECTION_FOLDER_TABLE.COLUMNS.SORT_ORDER],
          createTime: record[COLLECTION_FOLDER_TABLE.COLUMNS.CREATE_TIME],
          updateTime: record[COLLECTION_FOLDER_TABLE.COLUMNS.UPDATE_TIME],
          itemCount
        });
      }
      
      Logger.info(TAG, `Retrieved ${folders.length} collection folders`);
      return folders;
    } catch (error) {
      Logger.error(TAG, `Failed to get all folders: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * Ëé∑ÂèñÊñá‰ª∂Â§π‰∏≠ÁöÑÊî∂ËóèÈ°πÊï∞Èáè
   * @param folderId Êñá‰ª∂Â§πID
   * @returns Êî∂ËóèÈ°πÊï∞Èá?   */
  private async getCollectionCountByFolder(folderId: string): Promise<number> {
    const conditions: QueryCondition[] = [{
      column: COLLECTION_TABLE.COLUMNS.FOLDER_ID, value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions instanceof Error ? value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions : new Error(String(value: folderId
    }];
    
    return await this.sqliteHelper.count(COLLECTION_TABLE.TABLE_NAME, conditions)))))));
  }
  
  /**
   * ÊûÑÂª∫ÊéíÂ∫èÈÄâÈ°π
   */
  private buildSortOptions(sortType: CollectionSortType): {column: string, order: string}[] {
    const sortOptions: {column: string, order: string}[] = [];
    
    switch (sortType) {
      case CollectionSortType.TITLE_ASC:
        sortOptions.push({ column: COLLECTION_TABLE.COLUMNS.TITLE, order: 'ASC' });
        break;
      case CollectionSortType.TITLE_DESC:
        sortOptions.push({ column: COLLECTION_TABLE.COLUMNS.TITLE, order: 'DESC' });
        break;
      case CollectionSortType.CREATE_TIME_ASC:
        sortOptions.push({ column: COLLECTION_TABLE.COLUMNS.CREATE_TIME, order: 'ASC' });
        break;
      case CollectionSortType.CREATE_TIME_DESC:
      default:
        sortOptions.push({ column: COLLECTION_TABLE.COLUMNS.CREATE_TIME, order: 'DESC' });
        break;
      case CollectionSortType.UPDATE_TIME_ASC:
        sortOptions.push({ column: COLLECTION_TABLE.COLUMNS.UPDATE_TIME, order: 'ASC' });
        break;
      case CollectionSortType.UPDATE_TIME_DESC:
        sortOptions.push({ column: COLLECTION_TABLE.COLUMNS.UPDATE_TIME, order: 'DESC' });
        break;
      case CollectionSortType.CUSTOM:
        sortOptions.push({ column: COLLECTION_TABLE.COLUMNS.SORT_ORDER, order: 'ASC' });
        sortOptions.push({ column: COLLECTION_TABLE.COLUMNS.TITLE, order: 'ASC' });
        break;
    }
    
    return sortOptions;
  }
  
  /**
   * ÁºìÂ≠òÊî∂ËóèÈ°?   */
  private async cacheCollectionItem(item: CollectionItem): Promise<void> {
    try {
      if (item.id) {
        await this.storageUtil.setObject(`${COLLECTION_CACHE_PREFIX}${item.id}`, item);
      }
    } catch (error) {
      Logger.warn(TAG, `Failed to cache collection item: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * Ëé∑ÂèñÁºìÂ≠òÁöÑÊî∂ËóèÈ°π
   */
  private async getCachedCollectionItem(collectionId: string): Promise<CollectionItem | null> {
    try {
      return await this.storageUtil.getObject<CollectionItem>(`${COLLECTION_CACHE_PREFIX}${collectionId}`);
    } catch (error) {
      return null;
    }
  }
  
  /**
   * ÁßªÈô§ÁºìÂ≠òÁöÑÊî∂ËóèÈ°π
   */
  private async removeCachedCollectionItem(collectionId: string): Promise<void> {
    try {
      await this.storageUtil.remove(`${COLLECTION_CACHE_PREFIX}${collectionId}`);
    } catch (error) {
      Logger.warn(TAG, `Failed to remove cached collection item: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * ‰ΩøÊî∂ËóèÂàóË°®ÁºìÂ≠òÂ§±Êï?   */
  private async invalidateCollectionListCache(): Promise<void> {
    try {
      await this.storageUtil.remove(COLLECTION_LIST_CACHE);
    } catch (error) {
      Logger.warn(TAG, `Failed to invalidate collection list cache: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * Â∞ÜÊï∞ÊçÆÂ∫ìËÆ∞ÂΩïËΩ¨Êç¢‰∏∫CollectionItemÂØπË±°
   */
  private convertToCollectionObject(record: Record<string, unknown>): CollectionItem {
    return {
      id: record[COLLECTION_TABLE.COLUMNS.ID]?.toString(),
      title: record[COLLECTION_TABLE.COLUMNS.TITLE],
      subtitle: record[COLLECTION_TABLE.COLUMNS.SUBTITLE],
      coverUrl: record[COLLECTION_TABLE.COLUMNS.COVER_URL],
      itemType: record[COLLECTION_TABLE.COLUMNS.ITEM_TYPE],
      contentType: record[COLLECTION_TABLE.COLUMNS.CONTENT_TYPE],
      siteId: record[COLLECTION_TABLE.COLUMNS.SITE_ID],
      contentId: record[COLLECTION_TABLE.COLUMNS.CONTENT_ID],
      folderId: record[COLLECTION_TABLE.COLUMNS.FOLDER_ID]?.toString(),
      tags: record[COLLECTION_TABLE.COLUMNS.TAGS] ? record[COLLECTION_TABLE.COLUMNS.TAGS].split(',') : [],
      sortOrder: record[COLLECTION_TABLE.COLUMNS.SORT_ORDER],
      visibility: record[COLLECTION_TABLE.COLUMNS.VISIBILITY],
      createTime: record[COLLECTION_TABLE.COLUMNS.CREATE_TIME],
      updateTime: record[COLLECTION_TABLE.COLUMNS.UPDATE_TIME],
      extraData: record[COLLECTION_TABLE.COLUMNS.EXTRA_DATA] ? JSON.parse(record[COLLECTION_TABLE.COLUMNS.EXTRA_DATA]) : {}
    };
  }
  
  /**
   * Â∞ÜÊï∞ÊçÆÂ∫ìËÆ∞ÂΩïÂàóË°®ËΩ¨Êç¢‰∏∫CollectionItemÂØπË±°ÂàóË°®
   */
  private convertToCollectionObjects(records: Record<string, unknown>[]): CollectionItem[] {
    return records.map(record => this.convertToCollectionObject(record));
  }
}


