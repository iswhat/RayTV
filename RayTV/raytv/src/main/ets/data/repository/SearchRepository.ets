/*
 * Copyright (c) 2024 RayTV. All rights reserved.
 */

import Logger from '@ohos:raytv/src/main/ets/utils/Logger';
import StorageUtil from '@ohos:raytv/src/main/ets/utils/StorageUtil';
import NetworkUtil from '@ohos:raytv/src/main/ets/utils/NetworkUtil';
import EventBusUtil from '@ohos:raytv/src/main/ets/utils/EventBusUtil';
import CacheService from '@ohos:raytv/src/main/ets/service/CacheService';
import { CacheType } from '@ohos:raytv/src/main/ets/service/CacheService';
import { LocalStorageType } from '@ohos:raytv/src/main/ets/utils/StorageUtil';

/**
 * æœç´¢ç±»å‹æšä¸¾
 */
export enum SearchType {
  ALL = 'all',
  VIDEO = 'video',
  LIVE = 'live',
  USER = 'user',
  CHANNEL = 'channel'
}

/**
 * æœç´¢æ’åºæšä¸¾
 */
export enum SearchSort {
  DEFAULT = 'default',
  LATEST = 'latest',
  HOTTEST = 'hottest',
  RATING_DESC = 'rating_desc',
  RATING_ASC = 'rating_asc',
  RELEASE_DATE_DESC = 'release_date_desc',
  RELEASE_DATE_ASC = 'release_date_asc'
}

/**
 * æœç´¢äº‹ä»¶ç±»å‹å¸¸é‡
 */
export const SearchEventType = {
  SEARCH_PERFORMED: 'search:performed',
  SEARCH_COMPLETED: 'search:completed',
  SEARCH_ERROR: 'search:error',
  SEARCH_CACHED: 'search:cached',
  SEARCH_SUGGESTIONS_LOADED: 'search:suggestions:loaded',
  TRENDING_SEARCHES_LOADED: 'search:trending:loaded',
  SEARCH_HISTORY_ADDED: 'search:history:added',
  SEARCH_HISTORY_CLEARED: 'search:history:cleared'
} as const;

/**
 * æœç´¢äº‹ä»¶æ¥å£
 */
export interface SearchEvent {
  query: string;
  type: SearchType;
  sort?: SearchSort;
  timestamp: number;
  results?: SearchResult;
  error?: Error;
  suggestions?: SearchSuggestion[];
}

/**
 * æœç´¢è¯·æ±‚æ¥å£
 */
export interface SearchRequest {
  query: string;
  type: SearchType;
  sort: SearchSort;
  page: number;
  pageSize: number;
  filters?: Record<string, unknown>;
}

/**
 * æœç´¢ç»“æœæ¥å£
 */
export interface SearchResult {
  items: SearchResultItem[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}

/**
 * æœç´¢ç»“æœé¡¹æ¥å? */
export interface SearchResultItem {
  id: string;
  title: string;
  description?: string;
  type: SearchType;
  thumbnailUrl?: string;
  duration?: number;
  metadata?: Record<string, unknown>;
}

/**
 * æœç´¢å»ºè®®æ¥å£
 */
export interface SearchSuggestion {
  text: string;
  type: SearchType;
  popularity: number;
  recent?: boolean;
}

/**
 * çƒ­é—¨æœç´¢æ¥å£
 */
export interface TrendingSearch {
  query: string;
  type: SearchType;
  count: number;
  trend: 'up' | 'down' | 'stable';
}

/**
 * æœç´¢å†å²é¡¹æ¥å? */
export interface SearchHistoryItem {
  query: string;
  type: SearchType;
  timestamp: number;
  resultCount?: number;
}

/**
 * è§†é¢‘ä¿¡æ¯æ¥å£ï¼ˆç”¨äºæœç´¢ç»“æœé¡¹è¯¦æƒ…ï¼? */
export interface VideoInfo {
  id: string;
  title: string;
  description: string;
  coverUrl: string;
  duration: number;
  videoType: string;
  quality: string;
  viewCount: number;
  uploadTime: number;
}

/**
 * æœç´¢ä»“åº“ç±? */
export class SearchRepository {
  private static instance: SearchRepository | null = null;
  
  // æœç´¢ç±»å‹æšä¸¾å€?  private getSearchTypeValues(): SearchType[] {
    return [
      SearchType.ALL,
      SearchType.VIDEO,
      SearchType.LIVE,
      SearchType.USER,
      SearchType.CHANNEL
    ];
  }
  
  // æœç´¢æ’åºæšä¸¾å€?  private getSearchSortValues(): SearchSort[] {
    return [
      SearchSort.DEFAULT,
      SearchSort.LATEST,
      SearchSort.HOTTEST,
      SearchSort.RATING_DESC,
      SearchSort.RATING_ASC,
      SearchSort.RELEASE_DATE_DESC,
      SearchSort.RELEASE_DATE_ASC
    ];
  }
  
  private logger = Logger.getInstance();
  private storageUtil = StorageUtil.getInstance();
  private networkUtil = NetworkUtil.getInstance();
  private eventBus = EventBusUtil.getInstance();
  private cacheService = CacheService.getInstance();
  
  // APIç«¯ç‚¹é…ç½®
  private apiEndpoints = {
    baseUrl: 'https://api.raytv.example.com',
    search: '/search',
    suggestions: '/search/suggestions',
    trending: '/search/trending',
    popular: '/search/popular'
  };
  
  // å­˜å‚¨å’Œç¼“å­˜é”®é…ç½®
  private storageKeys = {
    searchHistory: 'search:history',
    searchPreferences: 'search:preferences',
    searchResults: 'search:results:',
    trendingSearches: 'search:trending',
    popularSearches: 'search:popular'
  };
  
  // æœç´¢é…ç½®
  private searchConfig = {
    maxHistoryItems: 50, // æœ€å¤§å†å²è®°å½•æ•°
    historyExpiryDays: 30, // å†å²è®°å½•è¿‡æœŸå¤©æ•°
    resultCacheDuration: 3600, // æœç´¢ç»“æœç¼“å­˜æ—¶é—´ï¼ˆç§’ï¼?    suggestionsCacheDuration: 300, // æœç´¢å»ºè®®ç¼“å­˜æ—¶é—´ï¼ˆç§’ï¼?    trendingCacheDuration: 3600, // çƒ­é—¨æœç´¢ç¼“å­˜æ—¶é—´ï¼ˆç§’ï¼?    minSearchLength: 1, // æœ€å°æœç´¢é•¿åº?    debounceTime: 300 // æœç´¢é˜²æŠ–æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  };
  
  // æœç´¢é˜²æŠ–å®šæ—¶å™?  private searchDebounceTimer: number | null = null;

  /**
   * ç§æœ‰æ„é€ å‡½æ•?   */
  private constructor() {
    this.logger.info('SearchRepository initialized');
    this.setupEventListeners();
    this.initialize();
  }

  /**
   * è·å–SearchRepositoryå•ä¾‹å®ä¾‹
   */
  public static getInstance(): SearchRepository {
    if (!SearchRepository.instance) {
      SearchRepository.instance = new SearchRepository();
    }
    return SearchRepository.instance;
  }

  /**
   * åˆå§‹åŒ–æœç´¢ä»“åº?   */
  public async initialize(): Promise<void> {
    try {
      // æ¸…ç†è¿‡æœŸçš„æœç´¢å†å?      await this.cleanupExpiredHistory();
      
      // é¢„åŠ è½½çƒ­é—¨æœç´¢ï¼ˆå¼‚æ­¥ï¼?      this.loadTrendingSearches().catch(err => {
        this.logger.warn('Failed to preload trending searches', err);
      });
      
      this.logger.info('SearchRepository initialization completed');
    } catch (error) {
      this.Logger.error('Failed to initialize SearchRepository', error as Error);
    }
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬å™?   */
  private setupEventListeners(): void {
    // ç›‘å¬åº”ç”¨é€€å‡ºäº‹ä»¶ï¼Œç¡®ä¿æ•°æ®æŒä¹…åŒ?    this.eventBus.on('app:exit', async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ( instanceof Error ? async ( instanceof Error ? async ( : new Error(String(async ( : new Error(String(async ( instanceof Error ? async ( : new Error(String(async ())))))) => {
      // æ¸…ç†è¿‡æœŸå†å²è®°å½•
      await this.cleanupExpiredHistory();
    });
    
    // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ?    this.eventBus.on('network:statusChanged', async (status: { isOnline: boolean }) => {
      if (status.isOnline) {
        // åœ¨çº¿æ—¶åˆ·æ–°çƒ­é—¨æœç´?        await this.loadTrendingSearches();
      }
    });
  }

  /**
   * æ‰§è¡Œæœç´¢
   * @param request æœç´¢è¯·æ±‚
   * @param useCache æ˜¯å¦ä½¿ç”¨ç¼“å­˜
   */
  public async performSearch(request: SearchRequest, useCache: boolean = true): Promise<SearchResult> {
    try {
      // éªŒè¯æœç´¢è¯·æ±‚
      this.validateSearchRequest(request);
      
      const searchId = this.generateSearchId(request);
      
      // å‘å¸ƒæœç´¢å¼€å§‹äº‹ä»?      this.eventBus.emit(SearchEventType.SEARCH_PERFORMED, {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now()
      } as SearchEvent);
      
      // å°è¯•ä»ç¼“å­˜è·å–ç»“æ?      if (useCache) {
        const cachedResult = await this.getCachedSearchResult(searchId);
        if (cachedResult) {
          this.logger.debug(`Search result loaded from cache for: ${request.query}`);
          
          // å‘å¸ƒç¼“å­˜å‘½ä¸­äº‹ä»¶
          this.eventBus.emit(SearchEventType.SEARCH_CACHED, {
            query: request.query,
            type: request.type,
            sort: request.sort,
            timestamp: Date.now(),
            results: cachedResult
          } as SearchEvent);
          
          // æ›´æ–°æœç´¢å†å²
          this.addToSearchHistory(request, cachedResult.items.length);
          
          return cachedResult;
        }
      }
      
      // æ„å»ºæœç´¢å‚æ•°
      const searchParams = this.buildSearchParams(request);
      
      // è°ƒç”¨APIè¿›è¡Œæœç´¢
      const response = await this.networkUtil.get<SearchResult>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.search}`,
        {
          params: searchParams
        }
      );
      
      const searchResult = response.data;
      
      // ç¼“å­˜æœç´¢ç»“æœ
      await this.cacheSearchResult(searchId, searchResult);
      
      // æ›´æ–°æœç´¢å†å²
      this.addToSearchHistory(request, searchResult.items.length);
      
      // è®°å½•ç”¨æˆ·æœç´¢è¡Œä¸ºï¼ˆå¼‚æ­¥ï¼‰
      this.trackSearch(request, searchResult.items.length);
      
      // å‘å¸ƒæœç´¢å®Œæˆäº‹ä»¶
      this.eventBus.emit(SearchEventType.SEARCH_COMPLETED, {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now(),
        results: searchResult
      } as SearchEvent);
      
      this.logger.info(`Search completed for: ${request.query}, found ${searchResult.items.length} items`);
      
      return searchResult;
    } catch (error) {
      this.Logger.error('Search failed', error as Error);
      
      // å‘å¸ƒæœç´¢é”™è¯¯äº‹ä»¶
      this.eventBus.emit(SearchEventType.SEARCH_ERROR, {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( instanceof Error ? {
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now( : new Error(String({
        query: request.query,
        type: request.type,
        sort: request.sort,
        timestamp: Date.now())))))),
        error: error as Error
      } as SearchEvent);
      
      throw error;
    }
  }

  /**
   * æ‰§è¡Œé˜²æŠ–æœç´¢
   * @param request æœç´¢è¯·æ±‚
   * @param callback å›è°ƒå‡½æ•°
   */
  public debouncedSearch(
    request: SearchRequest,
    callback: (result: SearchResult | null, error?: Error) => void
  ): void {
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (this.searchDebounceTimer !== null) {
      clearTimeout(this.searchDebounceTimer);
    }
    
    // è®¾ç½®æ–°çš„å®šæ—¶å™?    this.searchDebounceTimer = setTimeout(async () => {
      try {
        const result = await this.performSearch(request);
        callback(result);
      } catch (error) {
        callback(null, error as Error);
      } finally {
        this.searchDebounceTimer = null;
      }
    }, this.searchConfig.debounceTime) as unknown as number;
  }

  /**
   * è·å–æœç´¢å»ºè®®
   * @param query æœç´¢æŸ¥è¯¢
   * @param type æœç´¢ç±»å‹
   */
  public async getSearchSuggestions(query: string, type?: SearchType): Promise<SearchSuggestion[]> {
    try {
      // éªŒè¯æŸ¥è¯¢é•¿åº¦
      if (query.trim().length < this.searchConfig.minSearchLength) {
        return [];
      }
      
      // ç”Ÿæˆç¼“å­˜é”?      const cacheKey = `search:suggestions:${query}:${type || 'all'}`;
      
      // å°è¯•ä»ç¼“å­˜è·å?      const cachedSuggestions = await this.cacheService.getCache<SearchSuggestion[]>(cacheKey);
      if (cachedSuggestions) {
        return cachedSuggestions;
      }
      
      // æ„å»ºå»ºè®®å‚æ•°
      const params: Record<string, unknown> = {
        q: query.trim(),
        limit: 10
      };
      
      if (type) {
        params.type = type;
      }
      
      // è°ƒç”¨APIè·å–å»ºè®®
      const response = await this.networkUtil.get<SearchSuggestion[]>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.suggestions}`,
        {
          params
        }
      );
      
      const suggestions = response.data;
      
      // è·å–ç”¨æˆ·æœç´¢å†å²ï¼Œæ ‡è®°æœ€è¿‘æœç´?      const history = await this.getSearchHistory();
      suggestions.forEach(suggestion => {
        const recent = history.find(h => 
          h.query.toLowerCase() === suggestion.text.toLowerCase() && 
          (!type || h.type === type)
        );
        suggestion.recent = !!recent;
      });
      
      // ç¼“å­˜å»ºè®®ç»“æœ
      await this.cacheService.setCache(
        cacheKey,
        suggestions,
        {
          type: CacheType.MEMORY,
          expiry: this.searchConfig.suggestionsCacheDuration * 1000
        }
      );
      
      // å‘å¸ƒå»ºè®®åŠ è½½äº‹ä»¶
      this.eventBus.emit(SearchEventType.SEARCH_SUGGESTIONS_LOADED, {
        query,
        type,
        suggestions
      });
      
      return suggestions;
    } catch (error) {
      this.logger.warn('Failed to get search suggestions', error as Error);
      
      // å¤±è´¥æ—¶å°è¯•ä»æœ¬åœ°å†å²ç”Ÿæˆå»ºè®®
      return this.generateLocalSuggestions(query, type);
    }
  }

  /**
   * è·å–çƒ­é—¨æœç´¢
   */
  public async getTrendingSearches(): Promise<TrendingSearch[]> {
    // é¦–å…ˆå°è¯•ä»ç¼“å­˜æˆ–å†…å­˜è·å–
    const cached = await this.cacheService.getCache<TrendingSearch[]>(this.storageKeys.trendingSearches);
    if (cached) {
      return cached;
    }
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼ŒåŠ è½½æ–°æ•°æ?    return this.loadTrendingSearches();
  }

  /**
   * åŠ è½½çƒ­é—¨æœç´¢
   */
  private async loadTrendingSearches(): Promise<TrendingSearch[]> {
    try {
      const response = await this.networkUtil.get<TrendingSearch[]>(
        `${this.apiEndpoints.baseUrl}${this.apiEndpoints.trending}`,
        {
          params: {
            limit: 15,
            period: 'week'
          }
        }
      );
      
      const trendingSearches = response.data;
      
      // ç¼“å­˜çƒ­é—¨æœç´¢
      await this.cacheService.setCache(
        this.storageKeys.trendingSearches,
        trendingSearches,
        {
          type: CacheType.MEMORY_DISK,
          expiry: this.searchConfig.trendingCacheDuration * 1000
        }
      );
      
      // å‘å¸ƒçƒ­é—¨æœç´¢åŠ è½½äº‹ä»¶
      this.eventBus.emit(SearchEventType.TRENDING_SEARCHES_LOADED, trendingSearches);
      
      return trendingSearches;
    } catch (error) {
      this.logger.warn('Failed to load trending searches', error as Error);
      
      // å°è¯•ä»æœ¬åœ°å­˜å‚¨è·å–ç¼“å­˜çš„çƒ­é—¨æœç´¢
      return await this.cacheService.getCache<TrendingSearch[]>(this.storageKeys.trendingSearches) || [];
    }
  }

  /**
   * è·å–æœç´¢å†å²
   * @param limit é™åˆ¶æ•°é‡
   * @param type ç­›é€‰ç±»å?   */
  public async getSearchHistory(limit?: number, type?: SearchType): Promise<SearchHistoryItem[]> {
    try {
      const history = await this.storageUtil.getObject<SearchHistoryItem[]>(
        this.storageKeys.searchHistory,
        LocalStorageType.DEFAULT
      ) || [];
      
      // ç­›é€‰ç±»å?      let filtered = history;
      if (type) {
        filtered = history.filter(item => item.type === type);
      }
      
      // æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼?      filtered.sort((a, b) => b.timestamp - a.timestamp);
      
      // é™åˆ¶æ•°é‡
      if (limit && limit > 0) {
        filtered = filtered.slice(0, limit);
      }
      
      return filtered;
    } catch (error) {
      this.Logger.error('Failed to get search history', error as Error);
      return [];
    }
  }

  /**
   * æ¸…é™¤æœç´¢å†å²
   * @param type å¯é€‰çš„ç±»å‹ç­›é€?   */
  public async clearSearchHistory(type?: SearchType): Promise<void> {
    try {
      if (type) {
        // æ¸…é™¤ç‰¹å®šç±»å‹çš„å†å?        const history = await this.getSearchHistory();
        const filteredHistory = history.filter(item => item.type !== type);
        await this.storageUtil.setObject(
          this.storageKeys.searchHistory, filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
         instanceof Error ? filteredHistory,
          LocalStorageType.DEFAULT
         : new Error(String(filteredHistory,
          LocalStorageType.DEFAULT
        )))))));
      } else {
        // æ¸…é™¤æ‰€æœ‰å†å?        await this.storageUtil.remove(this.storageKeys.searchHistory, LocalStorageType.DEFAULT);
      }
      
      // å‘å¸ƒå†å²æ¸…é™¤äº‹ä»¶
      this.eventBus.emit(SearchEventType.SEARCH_HISTORY_CLEARED, { type });
      
      this.logger.info(`Search history cleared${type ? ` for type ${type}` : ''}`);
    } catch (error) {
      this.Logger.error('Failed to clear search history', error as Error);
      throw error;
    }
  }

  /**
   * ä»æœç´¢å†å²ä¸­ç§»é™¤ç‰¹å®šé¡?   * @param query æœç´¢æŸ¥è¯¢
   * @param type æœç´¢ç±»å‹
   */
  public async removeFromSearchHistory(query: string, type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType))))))): Promise<void> {
    try {
      const history = await this.getSearchHistory();
      const filteredHistory = history.filter(
        item => !(item.query.toLowerCase() === query.toLowerCase() && item.type === type)
      );
      
      await this.storageUtil.setObject(
        this.storageKeys.searchHistory,
        filteredHistory,
        LocalStorageType.DEFAULT
      );
      
      this.logger.info(`Removed item from search history: ${query}`);
    } catch (error) {
      this.Logger.error('Failed to remove item from search history', error as Error);
    }
  }

  /**
   * æ ¹æ®IDè·å–æœç´¢ç»“æœé¡¹è¯¦æƒ?   * @param id æœç´¢ç»“æœé¡¹ID
   * @param type æœç´¢ç»“æœé¡¹ç±»å?   */
  public async getSearchResultItemById(id: string, type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType : new Error(String(type: SearchType instanceof Error ? type: SearchType : new Error(String(type: SearchType))))))): Promise<SearchResultItem | null> {
    try {
      // æ„å»ºç¼“å­˜é”?      const cacheKey = `search:item:${type}:${id}`;
      
      // å°è¯•ä»ç¼“å­˜è·å?      let item = await this.cacheService.getCache<SearchResultItem>(cacheKey);
      if (item) {
        return item;
      }
      
      // ç¼“å­˜æœªå‘½ä¸­ï¼Œæ ¹æ®ç±»å‹è·å–è¯¦æƒ…
      switch (type) {
        case SearchType.VIDEO:
          // è°ƒç”¨è§†é¢‘è¯¦æƒ…API
          const response = await this.networkUtil.get<VideoInfo>(
            `${this.apiEndpoints.baseUrl}/videos/${id}`
          );
          
          // è½¬æ¢ä¸ºæœç´¢ç»“æœé¡¹æ ¼å¼
          item = {
            id: response.data.id,
            title: response.data.title,
            description: response.data.description,
            type: SearchType.VIDEO,
            thumbnailUrl: response.data.coverUrl,
            duration: response.data.duration,
            metadata: {
              videoType: response.data.videoType,
              quality: response.data.quality,
              viewCount: response.data.viewCount,
              uploadTime: response.data.uploadTime
            }
          };
          break;
          
        case SearchType.LIVE:
          // è°ƒç”¨ç›´æ’­è¯¦æƒ…API
          const liveResponse = await this.networkUtil.get(
            `${this.apiEndpoints.baseUrl}/live/${id}`
          );
          
          // è½¬æ¢ä¸ºæœç´¢ç»“æœé¡¹æ ¼å¼
          item = {
            id: liveResponse.data.id,
            title: liveResponse.data.title,
            description: liveResponse.data.description,
            type: SearchType.LIVE,
            thumbnailUrl: liveResponse.data.coverUrl,
            metadata: {
              status: liveResponse.data.status,
              viewerCount: liveResponse.data.viewerCount,
              startTime: liveResponse.data.startTime
            }
          };
          break;
          
        default:
          return null;
      }
      
      // ç¼“å­˜ç»“æœé¡?      if (item) {
        await this.cacheService.setCache(
          cacheKey,
          item,
          {
            type: CacheType.MEMORY,
            expiry: 3600 * 1000 // 1å°æ—¶
          }
        );
      }
      
      return item;
    } catch (error) {
      this.Logger.error(`Failed to get search result item by ID: ${id}`, error as Error);
      return null;
    }
  }

  /**
   * éªŒè¯æœç´¢è¯·æ±‚
   */
  private validateSearchRequest(request: SearchRequest): void {
    const errors: string[] = [];
    
    if (!request.query || request.query.trim().length < this.searchConfig.minSearchLength) {
      errors.push(`Search query must be at least ${this.searchConfig.minSearchLength} characters`);
    }
    
    if (!this.getSearchTypeValues().includes(request.type)) {
      errors.push('Invalid search type');
    }
    
    if (!this.getSearchSortValues().includes(request.sort)) {
      errors.push('Invalid sort option');
    }
    
    if (request.page < 1) {
      errors.push('Page number must be at least 1');
    }
    
    if (request.pageSize < 1 || request.pageSize > 100) {
      errors.push('Page size must be between 1 and 100');
    }
    
    if (errors.length > 0) {
      throw new Error(errors.join(', ' instanceof Error ? ' : new Error(String(' instanceof Error ? ' instanceof Error ? ' : new Error(String(' : new Error(String(' instanceof Error ? ' : new Error(String(' instanceof Error ? ' instanceof Error ? ' : new Error(String(' instanceof Error ? ' instanceof Error ? ' : new Error(String(' : new Error(String(' instanceof Error ? ' : new Error(String(' : new Error(String(' instanceof Error ? ' : new Error(String(' instanceof Error ? ' instanceof Error ? ' : new Error(String(' : new Error(String(' instanceof Error ? ' : new Error(String('))))))));
    }
  }

  /**
   * æ„å»ºæœç´¢å‚æ•°
   */
  private buildSearchParams(request: SearchRequest): Record<string, unknown> {
    const params: Record<string, unknown> = {
      q: request.query.trim(),
      type: request.type,
      sort: request.sort,
      page: request.page,
      pageSize: request.pageSize
    };
    
    // æ·»åŠ è¿‡æ»¤æ¡ä»¶
    if (request.filters) {
      Object.entries(request.filters).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          params[`filter[${key}]`] = value;
        }
      });
    }
    
    return params;
  }

  /**
   * ç”Ÿæˆæœç´¢IDï¼ˆç”¨äºç¼“å­˜ï¼‰
   */
  private generateSearchId(request: SearchRequest): string {
    const filtersString = request.filters ? 
      JSON.stringify(request.filters) : '';
    
    return `search:${request.query.toLowerCase()}:${request.type}:${request.sort}:${request.page}:${request.pageSize}:${filtersString}`;
  }

  /**
   * è·å–ç¼“å­˜çš„æœç´¢ç»“æ?   */
  private async getCachedSearchResult(searchId: string): Promise<SearchResult | null> {
    try {
      return await this.cacheService.getCache<SearchResult>(searchId);
    } catch (error) {
      this.logger.warn('Failed to get cached search result', error as Error);
      return null;
    }
  }

  /**
   * ç¼“å­˜æœç´¢ç»“æœ
   */
  private async cacheSearchResult(searchId: string, result: SearchResult): Promise<void> {
    try {
      await this.cacheService.setCache(
        searchId,
        result,
        {
          type: CacheType.MEMORY,
          expiry: this.searchConfig.resultCacheDuration * 1000
        }
      );
    } catch (error) {
      this.logger.warn('Failed to cache search result', error as Error);
    }
  }

  /**
   * æ·»åŠ åˆ°æœç´¢å†å?   */
  private async addToSearchHistory(request: SearchRequest, resultCount: number): Promise<void> {
    try {
      // ç”Ÿæˆå†å²è®°å½•é¡?      const historyItem: SearchHistoryItem = {
        query: request.query.trim(),
        type: request.type,
        timestamp: Date.now(),
        resultCount
      };
      
      // è·å–ç°æœ‰å†å²
      const history = await this.getSearchHistory();
      
      // ç§»é™¤é‡å¤é¡¹ï¼ˆå¦‚æœå­˜åœ¨ç›¸åŒçš„æŸ¥è¯¢å’Œç±»å‹ï¼?      const filteredHistory = history.filter(
        item => !(item.query.toLowerCase() === historyItem.query.toLowerCase() && item.type === historyItem.type)
      );
      
      // æ·»åŠ æ–°é¡¹åˆ°å¼€å¤?      filteredHistory.unshift(historyItem);
      
      // é™åˆ¶å†å²è®°å½•æ•°é‡
      const limitedHistory = filteredHistory.slice(0, this.searchConfig.maxHistoryItems);
      
      // ä¿å­˜å†å²è®°å½•
      await this.storageUtil.setObject(
        this.storageKeys.searchHistory,
        limitedHistory,
        LocalStorageType.DEFAULT
      );
      
      // å‘å¸ƒå†å²æ·»åŠ äº‹ä»¶
      this.eventBus.emit(SearchEventType.SEARCH_HISTORY_ADDED, historyItem);
    } catch (error) {
      this.logger.warn('Failed to add to search history', error as Error);
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸçš„æœç´¢å†å?   */
  private async cleanupExpiredHistory(): Promise<void> {
    try {
      const history = await this.getSearchHistory();
      const expiryTime = Date.now() - (this.searchConfig.historyExpiryDays * 24 * 60 * 60 * 1000);
      
      // è¿‡æ»¤æ‰è¿‡æœŸçš„å†å²è®°å½•
      const validHistory = history.filter(item => item.timestamp > expiryTime);
      
      if (validHistory.length !== history.length) {
        await this.storageUtil.setObject(
          this.storageKeys.searchHistory,
          validHistory,
          LocalStorageType.DEFAULT
        );
        
        this.logger.debug(`Cleaned up ${history.length - validHistory.length} expired search history items`);
      }
    } catch (error) {
      this.logger.warn('Failed to cleanup expired search history', error as Error);
    }
  }

  /**
   * ç”Ÿæˆæœ¬åœ°æœç´¢å»ºè®®ï¼ˆå½“APIå¤±è´¥æ—¶ï¼‰
   */
  private async generateLocalSuggestions(query: string, type?: SearchType): Promise<SearchSuggestion[]> {
    try {
      const history = await this.getSearchHistory(20, type);
      const lowerQuery = query.toLowerCase();
      
      // ä»å†å²è®°å½•ä¸­åŒ¹é…å»ºè®®
      const suggestions: SearchSuggestion[] = history
        .filter(item => item.query.toLowerCase().includes(lowerQuery))
        .map(item => ({
          text: item.query,
          type: item.type,
          popularity: 1,
          recent: true
        }));
      
      // å»é‡å¹¶é™åˆ¶æ•°é‡?      const uniqueSuggestions = this.deduplicateSuggestions(suggestions).slice(0, 5);
      
      return uniqueSuggestions;
    } catch (error) {
      this.logger.warn('Failed to generate local suggestions', error as Error);
      return [];
    }
  }

  /**
   * å»é‡æœç´¢å»ºè®®
   */
  private deduplicateSuggestions(suggestions: SearchSuggestion[]): SearchSuggestion[] {
    const seen = new Set<string>();
    return suggestions.filter(suggestion => {
      const key = `${suggestion.text.toLowerCase()}:${suggestion.type}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  /**
   * è·Ÿè¸ªæœç´¢è¡Œä¸ºï¼ˆç”¨äºåˆ†æï¼‰
   */
  private trackSearch(request: SearchRequest, resultCount: number): void {
    try {
      // è¿™é‡Œå¯ä»¥æ·»åŠ æœç´¢è¡Œä¸ºåˆ†æé€»è¾‘
      // ä¾‹å¦‚å‘é€æœç´¢ç»Ÿè®¡ä¿¡æ¯åˆ°åˆ†ææœåŠ¡å™?      
      this.logger.debug(`Tracking search: ${request.query}, results: ${resultCount}`);
    } catch (error) {
      // åˆ†æå¤±è´¥ä¸å½±å“æœç´¢åŠŸèƒ?      this.logger.warn('Failed to track search', error as Error);
    }
  }

  /**
   * è·å–æœç´¢ç»Ÿè®¡ä¿¡æ¯
   */
  public async getSearchStatistics(): Promise<{
    totalSearches: number;
    recentSearches: number;
    mostSearchedType: SearchType | null;
    averageResults: number;
  }> {
    try {
      const history = await this.getSearchHistory();
      
      // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
      const totalSearches = history.length;
      
      // æœ€è¿?å¤©çš„æœç´¢æ•?      const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
      const recentSearches = history.filter(item => item.timestamp > weekAgo).length;
      
      // æœ€å¸¸æœç´¢çš„ç±»å‹
      const typeCount: Record<string, number> = {};
      history.forEach(item => {
        typeCount[item.type] = (typeCount[item.type] || 0) + 1;
      });
      
      let mostSearchedType: SearchType | null = null;
      let maxCount = 0;
      
      Object.entries(typeCount).forEach(([type, count]) => {
        if (count > maxCount) {
          maxCount = count;
          mostSearchedType = type as SearchType;
        }
      });
      
      // å¹³å‡ç»“æœæ•?      const resultsSum = history.reduce((sum, item) => sum + (item.resultCount || 0), 0);
      const averageResults = history.length > 0 ? resultsSum / history.length : 0;
      
      return {
        totalSearches,
        recentSearches,
        mostSearchedType,
        averageResults
      };
    } catch (error) {
      this.Logger.error('Failed to get search statistics', error as Error);
      
      // è¿”å›é»˜è®¤ç»Ÿè®¡ä¿¡æ¯
      return {
        totalSearches: 0, recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( instanceof Error ? recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance( : new Error(String(recentSearches: 0,
        mostSearchedType: null,
        averageResults: 0
      };
    }
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default SearchRepository.getInstance()))))));


