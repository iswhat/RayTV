// VodRepository.ets - ç‚¹æ’­å†…å®¹æ•°æ®ä»“åº“
// è´Ÿè´£ç‚¹æ’­å†…å®¹çš„ç¼“å­˜ã€æœç´¢å’Œç®¡ç†

import { SQLiteHelper, QueryCondition, SortOption, QueryResult } from '../db/SQLiteHelper';
import { VOD_CACHE_TABLE, VOD_HISTORY_TABLE } from '../db/TableSchema';
import {
  Vod,
  VodItem,
  Episode,
  Actor,
  Director,
  VodCategory,
  VodTag,
  VodDetail
} from '../bean/Vod';
import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';

const TAG = 'VodRepository';

// ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
const CACHE_EXPIRY_TIME = 3600000; // 1å°æ—¶

// æ‰¹é‡æ“ä½œçš„æ‰¹æ¬¡å¤§å°?
const BATCH_SIZE = 100;

export class VodRepository {
  private static instance: VodRepository;
  private sqliteHelper: SQLiteHelper;
  private storageUtil: StorageUtil;
  private recentVodsCache: Map<string, VodItem[]> = new Map(); // æŒ‰ç«™ç‚¹IDç¼“å­˜æœ€è¿‘å†…å®?
  private popularVodsCache: Map<string, VodItem[]> = new Map(); // æŒ‰ç«™ç‚¹IDç¼“å­˜çƒ­é—¨å†…å®¹
  
  private constructor() {
    this.sqliteHelper = SQLiteHelper.getInstance();
    this.storageUtil = StorageUtil.getInstance();
  }
  
  /**
   * è·å–ç‚¹æ’­å†…å®¹ä»“åº“å•ä¾‹å®ä¾‹
   */
  public static getInstance(): VodRepository {
    if (!VodRepository.instance) {
      VodRepository.instance = new VodRepository();
    }
    return VodRepository.instance;
  }
  
  /**
   * ä¿å­˜ç‚¹æ’­å†…å®¹åˆ°ç¼“å­?
   * @param vodItem ç‚¹æ’­å†…å®¹é¡?
   * @returns æ˜¯å¦ä¿å­˜æˆåŠŸ
   */
  public async cacheVodItem(vodItem: VodItem): Promise<boolean> {
    try {
      Logger.debug(TAG, `Caching VOD item: ${vodItem.id} - ${vodItem.title}`);
      
      const cacheData: Record<string, string | number | boolean | null> = { ... };
      
      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
      const exists = await this.isVodItemCached(vodItem.id, vodItem.siteId);
      
      if (exists) {
        // æ›´æ–°ç°æœ‰è®°å½•
        const conditions: QueryCondition[] = [{
          column: VOD_CACHE_TABLE.COLUMNS.ID,
          value: vodItem.id
        }, {
          column: VOD_CACHE_TABLE.COLUMNS.SITE_ID,
          value: vodItem.siteId
        }];
        
        return (await this.sqliteHelper.update(VOD_CACHE_TABLE.TABLE_NAME, cacheData, conditions)).success;
      } else {
        // æ’å…¥æ–°è®°å½?
        return (await this.sqliteHelper.insert(VOD_CACHE_TABLE.TABLE_NAME, cacheData)).success;
      }
    } catch (error) {
      Logger.error(TAG, `Failed to cache VOD item ${vodItem.id}: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * æ‰¹é‡ç¼“å­˜ç‚¹æ’­å†…å®¹
   * @param vodItems ç‚¹æ’­å†…å®¹é¡¹åˆ—è¡?
   * @returns æˆåŠŸç¼“å­˜çš„æ•°é‡?
   */
  public async batchCacheVodItems(vodItems: VodItem[]): Promise<number> {
    if (!vodItems || vodItems.length === 0) {
      return 0;
    }
    
    let successCount = 0;
    
    // åˆ†æ‰¹å¤„ç†ä»¥é¿å…æ€§èƒ½é—®é¢˜
    for (let i = 0; i < vodItems.length; i += BATCH_SIZE) {
      const batch = vodItems.slice(i, i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE : new Error(String(i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE : new Error(String(i + BATCH_SIZE : new Error(String(i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE : new Error(String(i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE : new Error(String(i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE : new Error(String(i + BATCH_SIZE : new Error(String(i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE : new Error(String(i + BATCH_SIZE : new Error(String(i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE : new Error(String(i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE : new Error(String(i + BATCH_SIZE : new Error(String(i + BATCH_SIZE instanceof Error ? i + BATCH_SIZE : new Error(String(i + BATCH_SIZE)))))));
      
      const batchData = batch.map(vodItem => ({
        [VOD_CACHE_TABLE.COLUMNS.ID]: vodItem.id,
        [VOD_CACHE_TABLE.COLUMNS.SITE_ID]: vodItem.siteId,
        [VOD_CACHE_TABLE.COLUMNS.TITLE]: vodItem.title,
        [VOD_CACHE_TABLE.COLUMNS.SUBTITLE]: vodItem.subtitle || '',
        [VOD_CACHE_TABLE.COLUMNS.COVER]: vodItem.cover || '',
        [VOD_CACHE_TABLE.COLUMNS.POSTER]: vodItem.poster || '',
        [VOD_CACHE_TABLE.COLUMNS.YEAR]: vodItem.year || '',
        [VOD_CACHE_TABLE.COLUMNS.SCORE]: vodItem.score || '',
        [VOD_CACHE_TABLE.COLUMNS.TYPE]: vodItem.type || '',
        [VOD_CACHE_TABLE.COLUMNS.STATUS]: vodItem.status || '',
        [VOD_CACHE_TABLE.COLUMNS.PLAY_URL]: vodItem.playUrl || '',
        [VOD_CACHE_TABLE.COLUMNS.DATA]: JSON.stringify(vodItem),
        [VOD_CACHE_TABLE.COLUMNS.CATEGORY_IDS]: vodItem.categoryIds ? JSON.stringify(vodItem.categoryIds) : '[]',
        [VOD_CACHE_TABLE.COLUMNS.TAG_IDS]: vodItem.tagIds ? JSON.stringify(vodItem.tagIds) : '[]',
        [VOD_CACHE_TABLE.COLUMNS.CREATE_TIME]: Date.now(),
        [VOD_CACHE_TABLE.COLUMNS.UPDATE_TIME]: Date.now(),
        [VOD_CACHE_TABLE.COLUMNS.EXPIRY_TIME]: Date.now() + CACHE_EXPIRY_TIME
      }));
      
      // ä½¿ç”¨æ‰¹é‡æ’å…¥
      const result = await this.sqliteHelper.batchInsert(VOD_CACHE_TABLE.TABLE_NAME, batchData);
      successCount += result.successCount;
    }
    
    Logger.info(TAG, `Batch cached ${successCount}/${vodItems.length} VOD items`);
    return successCount;
  }
  
  /**
   * è·å–ç¼“å­˜çš„ç‚¹æ’­å†…å®?
   * @param id å†…å®¹ID
   * @param siteId ç«™ç‚¹ID
   * @returns ç‚¹æ’­å†…å®¹é¡¹æˆ–null
   */
  public async getCachedVodItem(id: string, siteId: string): Promise<VodItem | null> {
    try {
      const conditions: QueryCondition[] = [{
        column: VOD_CACHE_TABLE.COLUMNS.ID,
        value: id
      }, {
        column: VOD_CACHE_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }];
      
      const record = await this.sqliteHelper.getFirst(
        VOD_CACHE_TABLE.TABLE_NAME,
        ['*'],
        conditions
      );
      
      if (!record) {
        return null;
      }
      
      // æ£€æŸ¥æ˜¯å¦è¿‡æœ?
      const expiryTime = record[VOD_CACHE_TABLE.COLUMNS.EXPIRY_TIME];
      if (expiryTime < Date.now()) {
        Logger.debug(TAG, `VOD item ${id} expired, removing from cache`);
        await this.removeCachedVodItem(id, siteId);
        return null;
      }
      
      try {
        return JSON.parse(record[VOD_CACHE_TABLE.COLUMNS.DATA]) as VodItem;
      } catch (e) {
        Logger.error(TAG, `Failed to parse VOD item data: ${JSON.stringify(e)}`);
        return null;
      }
    } catch (error) {
      Logger.error(TAG, `Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error instanceof Error ? `Failed to get cached VOD item ${id}: ${JSON.stringify(error : new Error(String(`Failed to get cached VOD item ${id}: ${JSON.stringify(error)))))))}`);
      return null;
    }
  }
  
  /**
   * æ£€æŸ¥ç‚¹æ’­å†…å®¹æ˜¯å¦å·²ç¼“å­˜
   * @param id å†…å®¹ID
   * @param siteId ç«™ç‚¹ID
   * @returns æ˜¯å¦å·²ç¼“å­?
   */
  public async isVodItemCached(id: string, siteId: string): Promise<boolean> {
    try {
      const conditions: QueryCondition[] = [{
        column: VOD_CACHE_TABLE.COLUMNS.ID,
        value: id
      }, {
        column: VOD_CACHE_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }];
      
      return await this.sqliteHelper.exists(VOD_CACHE_TABLE.TABLE_NAME, conditions);
    } catch (error) {
      Logger.error(TAG, `Failed to check VOD item cache status: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * ç§»é™¤ç¼“å­˜çš„ç‚¹æ’­å†…å®?
   * @param id å†…å®¹ID
   * @param siteId ç«™ç‚¹ID
   * @returns æ˜¯å¦ç§»é™¤æˆåŠŸ
   */
  public async removeCachedVodItem(id: string, siteId: string instanceof Error ? siteId: string : new Error(String(siteId: string instanceof Error ? siteId: string instanceof Error ? siteId: string : new Error(String(siteId: string : new Error(String(siteId: string instanceof Error ? siteId: string : new Error(String(siteId: string instanceof Error ? siteId: string instanceof Error ? siteId: string : new Error(String(siteId: string instanceof Error ? siteId: string instanceof Error ? siteId: string : new Error(String(siteId: string : new Error(String(siteId: string instanceof Error ? siteId: string : new Error(String(siteId: string : new Error(String(siteId: string instanceof Error ? siteId: string : new Error(String(siteId: string instanceof Error ? siteId: string instanceof Error ? siteId: string : new Error(String(siteId: string : new Error(String(siteId: string instanceof Error ? siteId: string : new Error(String(siteId: string))))))): Promise<boolean> {
    try {
      const conditions: QueryCondition[] = [{
        column: VOD_CACHE_TABLE.COLUMNS.ID,
        value: id
      }, {
        column: VOD_CACHE_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }];
      
      return (await this.sqliteHelper.delete(VOD_CACHE_TABLE.TABLE_NAME, conditions)).success;
    } catch (error) {
      Logger.error(TAG, `Failed to remove cached VOD item ${id}: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * ä¿å­˜æœ€è¿‘æ’­æ”¾çš„ç‚¹æ’­å†…å®¹
   * @param vodItem ç‚¹æ’­å†…å®¹é¡?
   * @param episodeIndex å½“å‰é›†æ•°ç´¢å¼•
   * @param progress æ’­æ”¾è¿›åº¦ï¼ˆæ¯«ç§’ï¼‰
   * @returns æ˜¯å¦ä¿å­˜æˆåŠŸ
   */
  public async saveVodHistory(vodItem: VodItem, episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0 instanceof Error ? episodeIndex: number = 0, progress: number = 0 : new Error(String(episodeIndex: number = 0, progress: number = 0))))))): Promise<boolean> {
    try {
      Logger.debug(TAG, `Saving VOD history: ${vodItem.title}`);
      
      const historyData: Record<string, string | number | boolean | null> = { ... };
      
      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨å†å²è®°å½•
      const conditions: QueryCondition[] = [{
        column: VOD_HISTORY_TABLE.COLUMNS.VOD_ID,
        value: vodItem.id
      }, {
        column: VOD_HISTORY_TABLE.COLUMNS.SITE_ID,
        value: vodItem.siteId
      }];
      
      const exists = await this.sqliteHelper.exists(VOD_HISTORY_TABLE.TABLE_NAME, conditions);
      
      if (exists) {
        // æ›´æ–°ç°æœ‰å†å²è®°å½•
        const existingRecord = await this.sqliteHelper.getFirst(
          VOD_HISTORY_TABLE.TABLE_NAME,
          [VOD_HISTORY_TABLE.COLUMNS.PLAY_COUNT],
          conditions
        );
        
        if (existingRecord) {
          historyData[VOD_HISTORY_TABLE.COLUMNS.PLAY_COUNT] = 
            (existingRecord[VOD_HISTORY_TABLE.COLUMNS.PLAY_COUNT] || 0) + 1;
        }
        
        return (await this.sqliteHelper.update(VOD_HISTORY_TABLE.TABLE_NAME, historyData, conditions)).success;
      } else {
        // æ’å…¥æ–°å†å²è®°å½?
        return (await this.sqliteHelper.insert(VOD_HISTORY_TABLE.TABLE_NAME, historyData)).success;
      }
    } catch (error) {
      Logger.error(TAG, `Failed to save VOD history: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * æ›´æ–°æ’­æ”¾è¿›åº¦
   * @param vodId å†…å®¹ID
   * @param siteId ç«™ç‚¹ID
   * @param episodeIndex é›†æ•°ç´¢å¼•
   * @param progress æ’­æ”¾è¿›åº¦ï¼ˆæ¯«ç§’ï¼‰
   * @returns æ˜¯å¦æ›´æ–°æˆåŠŸ
   */
  public async updatePlayProgress(vodId: string, siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number instanceof Error ? siteId: string, episodeIndex: number, progress: number : new Error(String(siteId: string, episodeIndex: number, progress: number))))))): Promise<boolean> {
    try {
      const conditions: QueryCondition[] = [{
        column: VOD_HISTORY_TABLE.COLUMNS.VOD_ID,
        value: vodId
      }, {
        column: VOD_HISTORY_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }];
      
      const updateData: Record<string, string | number | boolean | null> = { ... };
      
      return (await this.sqliteHelper.update(VOD_HISTORY_TABLE.TABLE_NAME, updateData, conditions)).success;
    } catch (error) {
      Logger.error(TAG, `Failed to update play progress for ${vodId}: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * è·å–æ’­æ”¾å†å²
   * @param limit é™åˆ¶æ•°é‡
   * @param offset åç§»é‡?
   * @returns æ’­æ”¾å†å²åˆ—è¡¨
   */
  public async getVodHistory(limit: number = 50, offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0))))))): Promise<Record<string, unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: VOD_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        VOD_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit,
        offset
      );
      
      return records;
    } catch (error) {
      Logger.error(TAG, `Failed to get VOD history: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * æœç´¢ç‚¹æ’­å†…å®¹
   * @param keyword æœç´¢å…³é”®è¯?
   * @param siteId ç«™ç‚¹IDï¼ˆå¯é€‰ï¼‰
   * @param limit é™åˆ¶æ•°é‡
   * @returns æœç´¢ç»“æœ
   */
  public async searchVod(keyword: string, siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50 instanceof Error ? siteId?: string, limit: number = 50 : new Error(String(siteId?: string, limit: number = 50))))))): Promise<VodItem[]> {
    try {
      const conditions: QueryCondition[] = [{
        column: VOD_CACHE_TABLE.COLUMNS.TITLE,
        value: `%${keyword}%`,
        operator: 'LIKE'
      }];
      
      if (siteId) {
        conditions.push({
          column: VOD_CACHE_TABLE.COLUMNS.SITE_ID,
          value: siteId
        });
      }
      
      // æ·»åŠ ä¸è¿‡æœŸæ¡ä»?
      conditions.push({
        column: VOD_CACHE_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now(),
        operator: '>'
      });
      
      const records = await this.sqliteHelper.query(
        VOD_CACHE_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        undefined,
        limit
      );
      
      const results: VodItem[] = [];
      for (const record of records) {
        try {
          results.push(JSON.parse(record[VOD_CACHE_TABLE.COLUMNS.DATA]) as VodItem);
        } catch (e) {
          Logger.error(TAG, `Failed to parse VOD item data: ${JSON.stringify(e)}`);
        }
      }
      
      return results;
    } catch (error) {
      Logger.error(TAG, `Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error instanceof Error ? `Failed to search VOD: ${JSON.stringify(error : new Error(String(`Failed to search VOD: ${JSON.stringify(error)))))))}`);
      return [];
    }
  }
  
  /**
   * æ ¹æ®åˆ†ç±»è·å–ç‚¹æ’­å†…å®¹
   * @param categoryId åˆ†ç±»ID
   * @param siteId ç«™ç‚¹ID
   * @param limit é™åˆ¶æ•°é‡
   * @param offset åç§»é‡?
   * @returns ç‚¹æ’­å†…å®¹åˆ—è¡¨
   */
  public async getVodsByCategory(categoryId: string, siteId: string, limit: number = 50, offset: number = 0): Promise<VodItem[]> {
    try {
      // è¿™é‡Œéœ€è¦ä½¿ç”¨JSON_CONTAINSæˆ–è€…ç±»ä¼¼çš„æ–¹æ³•æŸ¥è¯¢JSONæ•°ç»„
      // ç”±äºSQLiteç‰ˆæœ¬é™åˆ¶ï¼Œè¿™é‡Œä½¿ç”¨LIKEè¿›è¡Œç®€å•åŒ¹é…?
      const conditions: QueryCondition[] = [{
        column: VOD_CACHE_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }, {
        column: VOD_CACHE_TABLE.COLUMNS.CATEGORY_IDS,
        value: `%${categoryId}%`,
        operator: 'LIKE'
      }, {
        column: VOD_CACHE_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now(),
        operator: '>'
      }];
      
      const sortOptions: SortOption[] = [{
        column: VOD_CACHE_TABLE.COLUMNS.UPDATE_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        VOD_CACHE_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions,
        limit,
        offset
      );
      
      const results: VodItem[] = [];
      for (const record of records) {
        try {
          results.push(JSON.parse(record[VOD_CACHE_TABLE.COLUMNS.DATA]) as VodItem);
        } catch (e) {
          Logger.error(TAG, `Failed to parse VOD item data: ${JSON.stringify(e)}`);
        }
      }
      
      return results;
    } catch (error) {
      Logger.error(TAG, `Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by category: ${JSON.stringify(error : new Error(String(`Failed to get VODs by category: ${JSON.stringify(error)))))))}`);
      return [];
    }
  }
  
  /**
   * æ ¹æ®æ ‡ç­¾è·å–ç‚¹æ’­å†…å®¹
   * @param tagId æ ‡ç­¾ID
   * @param siteId ç«™ç‚¹ID
   * @param limit é™åˆ¶æ•°é‡
   * @param offset åç§»é‡?
   * @returns ç‚¹æ’­å†…å®¹åˆ—è¡¨
   */
  public async getVodsByTag(tagId: string, siteId: string, limit: number = 50, offset: number = 0): Promise<VodItem[]> {
    try {
      // ç±»ä¼¼åˆ†ç±»æŸ¥è¯¢
      const conditions: QueryCondition[] = [{
        column: VOD_CACHE_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }, {
        column: VOD_CACHE_TABLE.COLUMNS.TAG_IDS,
        value: `%${tagId}%`,
        operator: 'LIKE'
      }, {
        column: VOD_CACHE_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now(),
        operator: '>'
      }];
      
      const sortOptions: SortOption[] = [{
        column: VOD_CACHE_TABLE.COLUMNS.UPDATE_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        VOD_CACHE_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions,
        limit,
        offset
      );
      
      const results: VodItem[] = [];
      for (const record of records) {
        try {
          results.push(JSON.parse(record[VOD_CACHE_TABLE.COLUMNS.DATA]) as VodItem);
        } catch (e) {
          Logger.error(TAG, `Failed to parse VOD item data: ${JSON.stringify(e)}`);
        }
      }
      
      return results;
    } catch (error) {
      Logger.error(TAG, `Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error instanceof Error ? `Failed to get VODs by tag: ${JSON.stringify(error : new Error(String(`Failed to get VODs by tag: ${JSON.stringify(error)))))))}`);
      return [];
    }
  }
  
  /**
   * ç¼“å­˜æœ€è¿‘æ›´æ–°çš„ç‚¹æ’­å†…å®¹
   * @param siteId ç«™ç‚¹ID
   * @param vodItems ç‚¹æ’­å†…å®¹åˆ—è¡¨
   */
  public cacheRecentVods(siteId: string, vodItems: VodItem[]): void {
    this.recentVodsCache.set(siteId, vodItems);
    Logger.debug(TAG, `Cached ${vodItems.length} recent VODs for site ${siteId}`);
  }
  
  /**
   * è·å–æœ€è¿‘æ›´æ–°çš„ç‚¹æ’­å†…å®¹
   * @param siteId ç«™ç‚¹ID
   * @returns æœ€è¿‘æ›´æ–°çš„å†…å®¹åˆ—è¡¨
   */
  public getRecentVods(siteId: string): VodItem[] {
    return this.recentVodsCache.get(siteId) || [];
  }
  
  /**
   * ç¼“å­˜çƒ­é—¨ç‚¹æ’­å†…å®¹
   * @param siteId ç«™ç‚¹ID
   * @param vodItems ç‚¹æ’­å†…å®¹åˆ—è¡¨
   */
  public cachePopularVods(siteId: string, vodItems: VodItem[]): void {
    this.popularVodsCache.set(siteId, vodItems);
    Logger.debug(TAG, `Cached ${vodItems.length} popular VODs for site ${siteId}`);
  }
  
  /**
   * è·å–çƒ­é—¨ç‚¹æ’­å†…å®¹
   * @param siteId ç«™ç‚¹ID
   * @returns çƒ­é—¨å†…å®¹åˆ—è¡¨
   */
  public getPopularVods(siteId: string): VodItem[] {
    return this.popularVodsCache.get(siteId) || [];
  }
  
  /**
   * æ¸…ç©ºè¿‡æœŸçš„ç¼“å­?
   * @returns æ¸…é™¤çš„è®°å½•æ•°é‡?
   */
  public async clearExpiredCache(): Promise<number> {
    try {
      const conditions: QueryCondition[] = [{
        column: VOD_CACHE_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now(),
        operator: '<'
      }];
      
      const result = await this.sqliteHelper.delete(VOD_CACHE_TABLE.TABLE_NAME, conditions);
      
      Logger.info(TAG, `Cleared ${result.affectedRows} expired VOD cache records`);
      return result.affectedRows;
    } catch (error) {
      Logger.error(TAG, `Failed to clear expired VOD cache: ${JSON.stringify(error)}`);
      return 0;
    }
  }
  
  /**
   * æ¸…ç©ºæ‰€æœ‰ç¼“å­?
   * @returns æ˜¯å¦æ¸…ç©ºæˆåŠŸ
   */
  public async clearAllCache(): Promise<boolean> {
    try {
      const result = await this.sqliteHelper.delete(VOD_CACHE_TABLE.TABLE_NAME);
      
      // æ¸…ç©ºå†…å­˜ç¼“å­˜
      this.recentVodsCache.clear();
      this.popularVodsCache.clear();
      
      Logger.info(TAG, `Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records instanceof Error ? `Cleared all VOD cache (${result.affectedRows} records : new Error(String(`Cleared all VOD cache (${result.affectedRows} records)))))))`);
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to clear all VOD cache: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * æ¸…ç©ºæ’­æ”¾å†å²
   * @returns æ˜¯å¦æ¸…ç©ºæˆåŠŸ
   */
  public async clearVodHistory(): Promise<boolean> {
    try {
      const result = await this.sqliteHelper.delete(VOD_HISTORY_TABLE.TABLE_NAME);
      
      Logger.info(TAG, `Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records instanceof Error ? `Cleared all VOD history (${result.affectedRows} records : new Error(String(`Cleared all VOD history (${result.affectedRows} records)))))))`);
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to clear VOD history: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * ä¼°ç®—ç¼“å­˜å¤§å°
   * @returns ç¼“å­˜å¤§å°ï¼ˆå­—èŠ‚ï¼‰
   */
  public async estimateCacheSize(): Promise<number> {
    try {
      // è¿™é‡Œä½¿ç”¨è¿‘ä¼¼è®¡ç®—ï¼Œå®é™…é¡¹ç›®ä¸­å¯èƒ½éœ€è¦æ›´ç²¾ç¡®çš„è®¡ç®?
      const records = await this.sqliteHelper.query(
        VOD_CACHE_TABLE.TABLE_NAME, ['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(*)))))))', 'SUM(LENGTH(' + VOD_CACHE_TABLE.COLUMNS.DATA + ')) as total_size']
      );
      
      if (records && records.length > 0 && records[0].total_size) {
        return Number(records[0].total_size);
      }
      
      return 0;
    } catch (error) {
      Logger.error(TAG, `Failed to estimate VOD cache size: ${JSON.stringify(error)}`);
      return 0;
    }
  }
  
  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   */
  public async getCacheStats(): Promise<{
    totalItems: number;
    expiredItems: number;
    cacheSize: number;
    oldestItemTime: number;
    newestItemTime: number;
  }> {
    try {
      // è·å–æ€»æ¡ç›®æ•°
      const totalResult = await this.sqliteHelper.query(
        VOD_CACHE_TABLE.TABLE_NAME, ['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(* : new Error(String(['COUNT(* instanceof Error ? ['COUNT(* : new Error(String(['COUNT(*))))))) as count']
      );
      const totalItems = totalResult && totalResult.length > 0 ? Number(totalResult[0].count) : 0;
      
      // è·å–è¿‡æœŸæ¡ç›®æ•?
      const expiredResult = await this.sqliteHelper.query(
        VOD_CACHE_TABLE.TABLE_NAME,
        ['COUNT(*) as count'],
        [{
          column: VOD_CACHE_TABLE.COLUMNS.EXPIRY_TIME,
          value: Date.now(),
          operator: '<'
        }]
      );
      const expiredItems = expiredResult && expiredResult.length > 0 ? Number(expiredResult[0].count) : 0;
      
      // è·å–ç¼“å­˜å¤§å°
      const cacheSize = await this.estimateCacheSize();
      
      // è·å–æœ€æ—§å’Œæœ€æ–°çš„æ¡ç›®æ—¶é—´
      const timeResult = await this.sqliteHelper.query(
        VOD_CACHE_TABLE.TABLE_NAME,
        ['MIN(' + VOD_CACHE_TABLE.COLUMNS.CREATE_TIME + ') as oldest', 
         'MAX(' + VOD_CACHE_TABLE.COLUMNS.CREATE_TIME + ') as newest']
      );
      
      return {
        totalItems,
        expiredItems,
        cacheSize,
        oldestItemTime: timeResult && timeResult.length > 0 && timeResult[0].oldest ? Number(timeResult[0].oldest) : 0,
        newestItemTime: timeResult && timeResult.length > 0 && timeResult[0].newest ? Number(timeResult[0].newest) : 0
      };
    } catch (error) {
      Logger.error(TAG, `Failed to get VOD cache stats: ${JSON.stringify(error)}`);
      return {
        totalItems: 0,
        expiredItems: 0,
        cacheSize: 0,
        oldestItemTime: 0,
        newestItemTime: 0
      };
    }
  }
}


