// LocalRepository - æœ¬åœ°å­˜å‚¨ä»“åº“
// è´Ÿè´£å¤„ç†æœ¬åœ°æ–‡ä»¶å’Œå­˜å‚¨ç›¸å…³çš„æ“ä½œ

import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import FileUtil from '../../common/util/FileUtil';
import { LocalStorageType, FileMetadata } from '../model/LocalModel';
import { FileService } from '../service/FileService';

/**
 * æœ¬åœ°å­˜å‚¨ä»“åº“ç±? * å°è£…æ‰€æœ‰æœ¬åœ°å­˜å‚¨å’Œæ–‡ä»¶æ“ä½œ
 */
class LocalRepository {
  private static instance: LocalRepository;
  private fileService: FileService;
  private initialized: boolean = false;

  // ç§æœ‰æ„é€ å‡½æ•?  private constructor() {
    this.fileService = FileService.getInstance();
    this.initialize();
  }

  /**
   * è·å–LocalRepositoryå®ä¾‹
   * @returns LocalRepositoryå•ä¾‹å®ä¾‹
   */
  public static getInstance(): LocalRepository {
    if (!LocalRepository.instance) {
      LocalRepository.instance = new LocalRepository();
    }
    return LocalRepository.instance;
  }

  /**
   * åˆå§‹åŒ–æœ¬åœ°ä»“åº?   */
  public async initialize(): Promise<void> {
    try {
      Logger.info('Initializing local repository');
      
      // ç¡®ä¿å¿…è¦çš„ç›®å½•å­˜åœ?      await this.ensureDirectories();
      
      this.initialized = true;
      Logger.info('Local repository initialized successfully');
    } catch (error) {
      Logger.error('Failed to initialize local repository', error);
      this.initialized = false;
    }
  }

  /**
   * ç¡®ä¿å¿…è¦çš„ç›®å½•å­˜åœ?   */
  private async ensureDirectories(): Promise<void> {
    try {
      // ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
      await this.fileService.ensureDirectoryExists('cache');
      // ç¡®ä¿ä¸‹è½½ç›®å½•å­˜åœ¨
      await this.fileService.ensureDirectoryExists('downloads');
      // ç¡®ä¿å­—å¹•ç›®å½•å­˜åœ¨
      await this.fileService.ensureDirectoryExists('subtitles');
      // ç¡®ä¿ç”¨æˆ·æ•°æ®ç›®å½•å­˜åœ¨
      await this.fileService.ensureDirectoryExists('user_data');
    } catch (error) {
      Logger.error('Failed to ensure directories', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      throw error;
    }
  }

  /**
   * ä¿å­˜æ•°æ®åˆ°æœ¬åœ°å­˜å‚?   * @param key å­˜å‚¨é”®å
   * @param value å­˜å‚¨å€?   * @param type å­˜å‚¨ç±»å‹
   */
  public async saveData(key: string, value: string | number | boolean | null, type: LocalStorageType = LocalStorageType.DEFAULT): Promise<void> {
    try {
      const prefixedKey = this.getPrefixedKey(key, type);
      
      switch (type) {
        case LocalStorageType.DEFAULT:
        case LocalStorageType.TEMPORARY:
        case LocalStorageType.SECURE:
          await StorageUtil.setObject(prefixedKey, value);
          break;
        case LocalStorageType.PERSISTENT:
          // æŒä¹…åŒ–å­˜å‚¨ä½¿ç”¨æ–‡ä»?          const filePath = await this.getPersistentFilePath(key);
          await FileUtil.writeFile(filePath, JSON.stringify(value));
          break;
      }
      
      Logger.debug(`Data saved: ${key}, type: ${LocalStorageType[type]}`);
    } catch (error) {
      Logger.error(`Failed to save data: ${key}`, error);
      throw error;
    }
  }

  /**
   * ä»æœ¬åœ°å­˜å‚¨è¯»å–æ•°æ?   * @param key å­˜å‚¨é”®å
   * @param type å­˜å‚¨ç±»å‹
   * @returns å­˜å‚¨çš„æ•°æ®æˆ–null
   */
  public async getData<T>(key: string, type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT))))))): Promise<T | null> {
    try {
      const prefixedKey = this.getPrefixedKey(key, type);
      
      switch (type) {
        case LocalStorageType.DEFAULT:
        case LocalStorageType.TEMPORARY:
        case LocalStorageType.SECURE:
          return await StorageUtil.getObject<T>(prefixedKey);
        case LocalStorageType.PERSISTENT:
          const filePath = await this.getPersistentFilePath(key);
          if (await FileUtil.exists(filePath)) {
            const content = await FileUtil.readFile(filePath);
            return JSON.parse(content) as T;
          }
          return null;
      }
    } catch (error) {
      Logger.error(`Failed to get data: ${key}`, error);
      return null;
    }
  }

  /**
   * åˆ é™¤æœ¬åœ°å­˜å‚¨æ•°æ®
   * @param key å­˜å‚¨é”®å
   * @param type å­˜å‚¨ç±»å‹
   * @returns æ˜¯å¦åˆ é™¤æˆåŠŸ
   */
  public async removeData(key: string, type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT))))))): Promise<boolean> {
    try {
      const prefixedKey = this.getPrefixedKey(key, type);
      
      switch (type) {
        case LocalStorageType.DEFAULT:
        case LocalStorageType.TEMPORARY:
        case LocalStorageType.SECURE:
          await StorageUtil.remove(prefixedKey);
          break;
        case LocalStorageType.PERSISTENT:
          const filePath = await this.getPersistentFilePath(key);
          if (await FileUtil.exists(filePath)) {
            await FileUtil.deleteFile(filePath);
          }
          break;
      }
      
      Logger.debug(`Data removed: ${key}, type: ${LocalStorageType[type]}`);
      return true;
    } catch (error) {
      Logger.error(`Failed to remove data: ${key}`, error);
      return false;
    }
  }

  /**
   * æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
   * @param key å­˜å‚¨é”®å
   * @param type å­˜å‚¨ç±»å‹
   * @returns æ˜¯å¦å­˜åœ¨
   */
  public async hasData(key: string, type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT instanceof Error ? type: LocalStorageType = LocalStorageType.DEFAULT : new Error(String(type: LocalStorageType = LocalStorageType.DEFAULT))))))): Promise<boolean> {
    try {
      const prefixedKey = this.getPrefixedKey(key, type);
      
      switch (type) {
        case LocalStorageType.DEFAULT:
        case LocalStorageType.TEMPORARY:
        case LocalStorageType.SECURE:
          return await StorageUtil.hasKey(prefixedKey);
        case LocalStorageType.PERSISTENT:
          const filePath = await this.getPersistentFilePath(key);
          return await FileUtil.exists(filePath);
      }
    } catch (error) {
      Logger.error(`Failed to check data existence: ${key}`, error);
      return false;
    }
  }

  /**
   * è·å–å¸¦å‰ç¼€çš„é”®å?   * @param key åŸå§‹é”®å
   * @param type å­˜å‚¨ç±»å‹
   * @returns å¸¦å‰ç¼€çš„é”®å?   */
  private getPrefixedKey(key: string, type: LocalStorageType instanceof Error ? type: LocalStorageType : new Error(String(type: LocalStorageType instanceof Error ? type: LocalStorageType instanceof Error ? type: LocalStorageType : new Error(String(type: LocalStorageType : new Error(String(type: LocalStorageType instanceof Error ? type: LocalStorageType : new Error(String(type: LocalStorageType instanceof Error ? type: LocalStorageType instanceof Error ? type: LocalStorageType : new Error(String(type: LocalStorageType instanceof Error ? type: LocalStorageType instanceof Error ? type: LocalStorageType : new Error(String(type: LocalStorageType : new Error(String(type: LocalStorageType instanceof Error ? type: LocalStorageType : new Error(String(type: LocalStorageType : new Error(String(type: LocalStorageType instanceof Error ? type: LocalStorageType : new Error(String(type: LocalStorageType instanceof Error ? type: LocalStorageType instanceof Error ? type: LocalStorageType : new Error(String(type: LocalStorageType : new Error(String(type: LocalStorageType instanceof Error ? type: LocalStorageType : new Error(String(type: LocalStorageType))))))): string {
    const prefixes: Record<string, string | number | boolean | null> = { ... };
    return `${prefixes[type]}${key}`;
  }

  /**
   * è·å–æŒä¹…åŒ–æ–‡ä»¶è·¯å¾?   * @param key å­˜å‚¨é”®å
   * @returns æ–‡ä»¶è·¯å¾„
   */
  private async getPersistentFilePath(key: string): Promise<string> {
    const dirPath = await this.fileService.getDirectoryPath('user_data');
    return `${dirPath}/${this.sanitizeFileName(key)}.json`;
  }

  /**
   * æ¸…ç†æ–‡ä»¶å?   * @param fileName åŸå§‹æ–‡ä»¶å?   * @returns æ¸…ç†åçš„æ–‡ä»¶å?   */
  private sanitizeFileName(fileName: string): string {
    return fileName.replace(/[^a-zA-Z0-9_-]/g, '_');
  }

  /**
   * ä¿å­˜æ–‡æœ¬æ–‡ä»¶
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @param content æ–‡ä»¶å†…å®¹
   * @returns æ˜¯å¦ä¿å­˜æˆåŠŸ
   */
  public async saveTextFile(filePath: string, content: string): Promise<boolean> {
    try {
      await FileUtil.writeFile(filePath, content);
      Logger.debug(`Text file saved: ${filePath}`);
      return true;
    } catch (error) {
      Logger.error(`Failed to save text file: ${filePath}`, error);
      return false;
    }
  }

  /**
   * è¯»å–æ–‡æœ¬æ–‡ä»¶
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @returns æ–‡ä»¶å†…å®¹æˆ–null
   */
  public async readTextFile(filePath: string): Promise<string | null> {
    try {
      if (await FileUtil.exists(filePath)) {
        const content = await FileUtil.readFile(filePath);
        return content;
      }
      return null;
    } catch (error) {
      Logger.error(`Failed to read text file: ${filePath}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return null;
    }
  }

  /**
   * ä¿å­˜JSONæ–‡ä»¶
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @param data JSONæ•°æ®
   * @returns æ˜¯å¦ä¿å­˜æˆåŠŸ
   */
  public async saveJsonFile(filePath: string, data: string | number | boolean | null): Promise<boolean> {
    try {
      const jsonString = JSON.stringify(data, null, 2);
      return await this.saveTextFile(filePath, jsonString);
    } catch (error) {
      Logger.error(`Failed to save JSON file: ${filePath}`, error);
      return false;
    }
  }

  /**
   * è¯»å–JSONæ–‡ä»¶
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @returns JSONæ•°æ®æˆ–null
   */
  public async readJsonFile<T>(filePath: string): Promise<T | null> {
    try {
      const content = await this.readTextFile(filePath);
      if (content) {
        return JSON.parse(content) as T;
      }
      return null;
    } catch (error) {
      Logger.error(`Failed to read JSON file: ${filePath}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return null;
    }
  }

  /**
   * è·å–æ–‡ä»¶å…ƒæ•°æ?   * @param filePath æ–‡ä»¶è·¯å¾„
   * @returns æ–‡ä»¶å…ƒæ•°æ®æˆ–null
   */
  public async getFileMetadata(filePath: string): Promise<FileMetadata | null> {
    try {
      if (await FileUtil.exists(filePath)) {
        const stats = await FileUtil.getFileStats(filePath);
        return {
          path: filePath,
          name: FileUtil.getFileName(filePath),
          size: stats.size,
          modifiedAt: stats.mtimeMs,
          isDirectory: stats.isDirectory
        };
      }
      return null;
    } catch (error) {
      Logger.error(`Failed to get file metadata: ${filePath}`, error);
      return null;
    }
  }

  /**
   * åˆ—å‡ºç›®å½•å†…å®¹
   * @param dirPath ç›®å½•è·¯å¾„
   * @returns æ–‡ä»¶åˆ—è¡¨
   */
  public async listDirectory(dirPath: string): Promise<string[]> {
    try {
      return await FileUtil.listFiles(dirPath);
    } catch (error) {
      Logger.error(`Failed to list directory: ${dirPath}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return [];
    }
  }

  /**
   * åˆ›å»ºç›®å½•
   * @param dirPath ç›®å½•è·¯å¾„
   * @returns æ˜¯å¦åˆ›å»ºæˆåŠŸ
   */
  public async createDirectory(dirPath: string): Promise<boolean> {
    try {
      await FileUtil.createDirectory(dirPath);
      Logger.debug(`Directory created: ${dirPath}`);
      return true;
    } catch (error) {
      Logger.error(`Failed to create directory: ${dirPath}`, error);
      return false;
    }
  }

  /**
   * åˆ é™¤æ–‡ä»¶æˆ–ç›®å½?   * @param path æ–‡ä»¶æˆ–ç›®å½•è·¯å¾?   * @returns æ˜¯å¦åˆ é™¤æˆåŠŸ
   */
  public async delete(path: string): Promise<boolean> {
    try {
      if (await FileUtil.exists(path)) {
        const stats = await FileUtil.getFileStats(path);
        if (stats.isDirectory) {
          await FileUtil.deleteDirectory(path);
          Logger.debug(`Directory deleted: ${path}`);
        } else {
          await FileUtil.deleteFile(path);
          Logger.debug(`File deleted: ${path}`);
        }
        return true;
      }
      return false;
    } catch (error) {
      Logger.error(`Failed to delete: ${path}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return false;
    }
  }

  /**
   * å¤åˆ¶æ–‡ä»¶
   * @param sourcePath æºæ–‡ä»¶è·¯å¾?   * @param destPath ç›®æ ‡æ–‡ä»¶è·¯å¾„
   * @returns æ˜¯å¦å¤åˆ¶æˆåŠŸ
   */
  public async copyFile(sourcePath: string, destPath: string): Promise<boolean> {
    try {
      await FileUtil.copyFile(sourcePath, destPath);
      Logger.debug(`File copied from ${sourcePath} to ${destPath}`);
      return true;
    } catch (error) {
      Logger.error(`Failed to copy file from ${sourcePath} to ${destPath}`, error);
      return false;
    }
  }

  /**
   * ç§»åŠ¨æ–‡ä»¶
   * @param sourcePath æºæ–‡ä»¶è·¯å¾?   * @param destPath ç›®æ ‡æ–‡ä»¶è·¯å¾„
   * @returns æ˜¯å¦ç§»åŠ¨æˆåŠŸ
   */
  public async moveFile(sourcePath: string, destPath: string instanceof Error ? destPath: string : new Error(String(destPath: string instanceof Error ? destPath: string instanceof Error ? destPath: string : new Error(String(destPath: string : new Error(String(destPath: string instanceof Error ? destPath: string : new Error(String(destPath: string instanceof Error ? destPath: string instanceof Error ? destPath: string : new Error(String(destPath: string instanceof Error ? destPath: string instanceof Error ? destPath: string : new Error(String(destPath: string : new Error(String(destPath: string instanceof Error ? destPath: string : new Error(String(destPath: string : new Error(String(destPath: string instanceof Error ? destPath: string : new Error(String(destPath: string instanceof Error ? destPath: string instanceof Error ? destPath: string : new Error(String(destPath: string : new Error(String(destPath: string instanceof Error ? destPath: string : new Error(String(destPath: string))))))): Promise<boolean> {
    try {
      await FileUtil.moveFile(sourcePath, destPath);
      Logger.debug(`File moved from ${sourcePath} to ${destPath}`);
      return true;
    } catch (error) {
      Logger.error(`Failed to move file from ${sourcePath} to ${destPath}`, error);
      return false;
    }
  }

  /**
   * æ¸…ç©ºä¸´æ—¶å­˜å‚¨
   */
  public async clearTemporaryStorage(): Promise<void> {
    try {
      // è·å–æ‰€æœ‰ä¸´æ—¶é”®å¹¶åˆ é™?      const allKeys = await StorageUtil.getAllKeys();
      const tempKeys = allKeys.filter(key => key.startsWith('temp_'));
      
      for (const key of tempKeys) {
        await StorageUtil.remove(key);
      }
      
      // æ¸…ç©ºä¸´æ—¶ç›®å½•
      const tempDir = await this.fileService.getDirectoryPath('cache');
      const files = await this.listDirectory(tempDir);
      
      for (const file of files) {
        await this.delete(`${tempDir}/${file}`);
      }
      
      Logger.info('Temporary storage cleared');
    } catch (error) {
      Logger.error('Failed to clear temporary storage', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * é‡ç½®ä»“åº“
   */
  public async reset(): Promise<void> {
    try {
      Logger.info('Resetting local repository');
      
      // æ¸…ç©ºæ‰€æœ‰å­˜å‚?      await this.clearTemporaryStorage();
      
      // é‡ç½®å…¶ä»–å¿…è¦çš„çŠ¶æ€?      
      Logger.info('Local repository reset completed');
    } catch (error) {
      Logger.error('Failed to reset local repository', error);
      throw error;
    }
  }

  /**
   * è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µ
   * @returns ä½¿ç”¨æƒ…å†µç»Ÿè®¡
   */
  public async getStorageUsage(): Promise<Record<string, number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories instanceof Error ? number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories : new Error(String(number>> {
    try {
      const usage: Record<string, number> = {};
      const directories = ['cache', 'downloads', 'subtitles', 'user_data'];
      
      for (const dir of directories))))))) {
        const dirPath = await this.fileService.getDirectoryPath(dir);
        if (await FileUtil.exists(dirPath)) {
          const size = await FileUtil.getDirectorySize(dirPath);
          usage[dir] = size;
        }
      }
      
      return usage;
    } catch (error) {
      Logger.error('Failed to get storage usage', error);
      return {};
    }
  }
}

export default LocalRepository;



