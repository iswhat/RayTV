// ConfigRepository - é…ç½®ä»“åº“ | Config repository
// è´Ÿè´£å¤„ç†åº”ç”¨é…ç½®çš„å­˜å‚¨å’Œç®¡ç† | Responsible for handling application configuration storage and management

import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import { ConfigKey, ConfigValue, ConfigCategory } from '../model/ConfigModel';
import DatabaseRepository from './DatabaseRepository';

/**
 * é…ç½®ä»“åº“ | Config repository
 * ç®¡ç†åº”ç”¨çš„æ‰€æœ‰é…ç½®é¡¹ï¼Œæ”¯æŒå¤šå±‚å­˜å‚¨ç­–ç•?| Manage all application configuration items, support multi-layer storage strategy
 */
class ConfigRepository {
  private static instance: ConfigRepository;
  private databaseRepository: DatabaseRepository;
  private configCache: Map<string, ConfigValue> = new Map();
  private defaultConfigs: Map<string, ConfigValue> = new Map();
  private initialized: boolean = false;

  // ç§æœ‰æ„é€ å‡½æ•?| Private constructor
  private constructor() {
    this.databaseRepository = DatabaseRepository.getInstance();
    this.initializeDefaultConfigs();
    this.initialize();
  }

  /**
   * è·å–ConfigRepositoryå®ä¾‹ | Get ConfigRepository instance
   * @returns ConfigRepositoryå•ä¾‹å®ä¾‹ | ConfigRepository singleton instance
   */
  public static getInstance(): ConfigRepository {
    if (!ConfigRepository.instance) {
      ConfigRepository.instance = new ConfigRepository();
    }
    return ConfigRepository.instance;
  }

  /**
   * åˆå§‹åŒ–é»˜è®¤é…ç½?| Initialize default configs
   */
  private initializeDefaultConfigs(): void {
    // åº”ç”¨åŸºç¡€é…ç½® | Application basic configuration
    this.defaultConfigs.set(ConfigKey.APP_VERSION, {
      value: '1.0.0',
      type: 'string',
      category: ConfigCategory.APPLICATION
    });
    
    this.defaultConfigs.set(ConfigKey.LANGUAGE, {
      value: 'zh-CN',
      type: 'string',
      category: ConfigCategory.APPLICATION
    });
    
    this.defaultConfigs.set(ConfigKey.THEME, {
      value: 'dark',
      type: 'string',
      category: ConfigCategory.UI
    });
    
    // æ’­æ”¾é…ç½® | Playback configuration
    this.defaultConfigs.set(ConfigKey.DEFAULT_QUALITY, {
      value: 'auto',
      type: 'string',
      category: ConfigCategory.PLAYBACK
    });
    
    this.defaultConfigs.set(ConfigKey.AUTO_PLAY, {
      value: true,
      type: 'boolean',
      category: ConfigCategory.PLAYBACK
    });
    
    this.defaultConfigs.set(ConfigKey.REMEMBER_POSITION, {
      value: true,
      type: 'boolean',
      category: ConfigCategory.PLAYBACK
    });
    
    // ç½‘ç»œé…ç½® | Network configuration
    this.defaultConfigs.set(ConfigKey.NETWORK_TIMEOUT, {
      value: 30000,
      type: 'number',
      category: ConfigCategory.NETWORK
    });
    
    this.defaultConfigs.set(ConfigKey.USE_PROXY, {
      value: false,
      type: 'boolean',
      category: ConfigCategory.NETWORK
    });
    
    this.defaultConfigs.set(ConfigKey.MAX_CONNECTIONS, {
      value: 5,
      type: 'number',
      category: ConfigCategory.NETWORK
    });
    
    // ä¸‹è½½é…ç½® | Download configuration
    this.defaultConfigs.set(ConfigKey.DOWNLOAD_PATH, {
      value: '',
      type: 'string',
      category: ConfigCategory.DOWNLOAD
    });
    
    this.defaultConfigs.set(ConfigKey.MAX_DOWNLOAD_TASKS, {
      value: 2,
      type: 'number',
      category: ConfigCategory.DOWNLOAD
    });
    
    this.defaultConfigs.set(ConfigKey.DOWNLOAD_ONLY_WIFI, {
      value: true,
      type: 'boolean',
      category: ConfigCategory.DOWNLOAD
    });
    
    // å­—å¹•é…ç½® | Subtitle configuration
    this.defaultConfigs.set(ConfigKey.SUBTITLE_FONT_SIZE, {
      value: 16,
      type: 'number',
      category: ConfigCategory.SUBTITLE
    });
    
    this.defaultConfigs.set(ConfigKey.SUBTITLE_COLOR, {
      value: '#FFFFFF',
      type: 'string',
      category: ConfigCategory.SUBTITLE
    });
    
    this.defaultConfigs.set(ConfigKey.SUBTITLE_BACKGROUND, {
      value: 'rgba(0,0,0,0.5)',
      type: 'string',
      category: ConfigCategory.SUBTITLE
    });
  }

  /**
   * åˆå§‹åŒ–é…ç½®ç³»ç»?| Initialize configuration system
   */
  public async initialize(): Promise<void> {
    try {
      Logger.info('Initializing config repository');
      
      // ä»æ•°æ®åº“åŠ è½½é…ç½® | Load configs from database
      await this.loadConfigsFromDatabase();
      
      // ç¡®ä¿é»˜è®¤é…ç½®å·²è®¾ç½?| Ensure default configs are set
      await this.ensureDefaultConfigs();
      
      this.initialized = true;
      Logger.info('Config repository initialized successfully');
    } catch (error) {
      Logger.error('Failed to initialize config repository', error);
      this.initialized = false;
    }
  }

  /**
   * ä»æ•°æ®åº“åŠ è½½é…ç½® | Load configs from database
   */
  private async loadConfigsFromDatabase(): Promise<void> {
    try {
      const configs = await this.databaseRepository.getAll('configs');
      
      for (const config of configs) {
        let parsedValue: unknown = config.value;
        
        // æ ¹æ®ç±»å‹è§£æå€?| Parse value based on type
        switch (config.type) {
          case 'number':
            parsedValue = Number(config.value);
            break;
          case 'boolean':
            parsedValue = config.value === 'true' || config.value === true;
            break;
          case 'object':
            try {
              parsedValue = JSON.parse(config.value);
            } catch {
              parsedValue = config.value;
            }
            break;
        }
        
        this.configCache.set(config.key, {
          value: parsedValue,
          type: config.type,
          category: config.category || ConfigCategory.GENERAL
        });
      }
      
      Logger.debug(`Loaded ${configs.length} configs from database`);
    } catch (error) {
      Logger.error('Failed to load configs from database', error);
    }
  }

  /**
   * ç¡®ä¿é»˜è®¤é…ç½®å·²è®¾ç½?| Ensure default configs are set
   */
  private async ensureDefaultConfigs(): Promise<void> {
    try {
      for (const [key, defaultConfig] of this.defaultConfigs.entries()) {
        if (!this.configCache.has(key)) {
          await this.setConfig(key, defaultConfig.value, defaultConfig.type, defaultConfig.category);
        }
      }
    } catch (error) {
      Logger.error('Failed to ensure default configs', error);
    }
  }

  /**
   * è·å–é…ç½®å€?| Get config value
   * @param key é…ç½®é”?| Config key
   * @param defaultValue é»˜è®¤å€?| Default value
   * @returns é…ç½®å€¼æˆ–é»˜è®¤å€?| Config value or default value
   */
  public async getConfig<T>(key: string, defaultValue?: T): Promise<T> {
    try {
      const config = this.configCache.get(key);
      
      if (config !== undefined) {
        return config.value as T;
      }
      
      // å¦‚æœç¼“å­˜ä¸­æ²¡æœ‰ï¼Œå°è¯•ä»æ•°æ®åº“è·å– | If not in cache, try to get from database
      const dbConfig = await this.databaseRepository.query('configs', [{ field: 'key', operator: '=', value: key }]);
      if (dbConfig.length > 0) {
        const configData = dbConfig[0];
        let parsedvalue: unknown = configData.value;
        
        // è§£æå€¼ç±»å?| Parse value type
        switch (configData.type) {
          case 'number':
            parsedValue = Number(configData.value);
            break;
          case 'boolean':
            parsedValue = configData.value === 'true' || configData.value === true;
            break;
          case 'object':
            try {
              parsedValue = JSON.parse(configData.value);
            } catch {
              parsedValue = configData.value;
            }
            break;
        }
        
        this.configCache.set(key, {
          value: parsedValue,
          type: configData.type,
          category: configData.category || ConfigCategory.GENERAL
        });
        
        return parsedValue as T;
      }
      
      // å¦‚æœæ•°æ®åº“ä¸­ä¹Ÿæ²¡æœ‰ï¼Œè¿”å›é»˜è®¤å€¼æˆ–é»˜è®¤é…ç½®ä¸­çš„å€?| If not in database, return default value or value from default config
      const defaultConfig = this.defaultConfigs.get(key);
      return (defaultConfig ? defaultConfig.value : defaultValue) as T;
    } catch (error) {
      Logger.error(`Failed to get config: ${key}`, error);
      return defaultValue as T;
    }
  }

  /**
   * è®¾ç½®é…ç½®å€?| Set config value
   * @param key é…ç½®é”?| Config key
   * @param value é…ç½®å€?| Config value
   * @param type å€¼ç±»å?| Value type
   * @param category é…ç½®åˆ†ç±» | Config category
   */
  public async setConfig(key: string, value: unknown, type: string = 'string', category: string = ConfigCategory.GENERAL): Promise<void> {
    try {
      // æ›´æ–°ç¼“å­˜ | Update cache
      this.configCache.set(key, {
        value,
        type,
        category
      });
      
      // å‡†å¤‡å­˜å‚¨å€?| Prepare storage value
      let storageValue: string | unknown = value;
      if (type === 'object') {
        storageValue = JSON.stringify(value);
      } else if (type === 'boolean') {
        storageValue = value.toString();
      }
      
      // æ£€æŸ¥é…ç½®æ˜¯å¦å·²å­˜åœ¨ | Check if config exists
      const existingConfigs = await this.databaseRepository.query('configs', [{ field: 'key', operator: '=', value: key }]);
      
      if (existingConfigs.length > 0) {
        // æ›´æ–°ç°æœ‰é…ç½® | Update existing config
        await this.databaseRepository.update('configs', existingConfigs[0].id, {
          value: storageValue,
          type,
          category,
          updated_at: Date.now()
        });
      } else {
        // æ’å…¥æ–°é…ç½?| Insert new config
        await this.databaseRepository.insert('configs', {
          key,
          value: storageValue,
          type,
          category,
          created_at: Date.now(),
          updated_at: Date.now()
        });
      }
      
      Logger.debug(`Config set: ${key} = ${String(value)}, type: ${type}, category: ${category}`);
    } catch (error) {
      Logger.error(`Failed to set config: ${key}`, error);
      throw error;
    }
  }

  /**
   * åˆ é™¤é…ç½® | Delete config
   * @param key é…ç½®é”?| Config key
   * @returns æ˜¯å¦åˆ é™¤æˆåŠŸ | Whether deletion succeeded
   */
  public async deleteConfig(key: string): Promise<boolean> {
    try {
      // ä»ç¼“å­˜ä¸­åˆ é™¤ | Delete from cache
      this.configCache.delete(key);
      
      // ä»æ•°æ®åº“ä¸­åˆ é™?| Delete from database
      const configs = await this.databaseRepository.query('configs', [{ field: 'key', operator: '=', value: key }]);
      
      if (configs.length > 0) {
        await this.databaseRepository.delete('configs', configs[0].id);
        Logger.debug(`Config deleted: ${key}`);
        return true;
      }
      
      return false;
    } catch (error) {
      Logger.error(`Failed to delete config: ${key}`, error);
      return false;
    }
  }

  /**
   * æ‰¹é‡è®¾ç½®é…ç½® | Batch set configs
   * @param configs é…ç½®å¯¹è±¡ | Config object
   */
  public async setConfigs(configs: Record<string, unknown>): Promise<void> {
    try {
      for (const [key, value] of Object.entries(configs)) {
        const type = this.getValueType(value);
        await this.setConfig(key, value, type);
      }
      Logger.debug(`Batch set ${Object.keys(configs).length} configs`);
    } catch (error) {
      Logger.error('Failed to set configs in batch', error);
      throw error;
    }
  }

  /**
   * è·å–é…ç½®åˆ†ç±» | Get configs by category
   * @param category é…ç½®åˆ†ç±» | Config category
   * @returns è¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰é…ç½?| All configs under this category
   */
  public async getConfigsByCategory(category: string): Promise<Map<string, ConfigValue>> {
    try {
      const result = new Map<string, ConfigValue>();
      
      for (const [key, config] of this.configCache.entries()) {
        if (config.category === category) {
          result.set(key, config);
        }
      }
      
      return result;
    } catch (error) {
      Logger.error(`Failed to get configs by category: ${category}`, error);
      return new Map();
    }
  }

  /**
   * é‡ç½®é…ç½®åˆ°é»˜è®¤å€?| Reset config to default value
   * @param key é…ç½®é”®ï¼ˆå¯é€‰ï¼Œä¸æä¾›åˆ™é‡ç½®æ‰€æœ‰ï¼‰ | Config key (optional, reset all if not provided)
   */
  public async resetToDefault(key?: string): Promise<void> {
    try {
      if (key) {
        // é‡ç½®å•ä¸ªé…ç½® | Reset single config
        const defaultConfig = this.defaultConfigs.get(key);
        if (defaultConfig) {
          await this.setConfig(key, defaultConfig.value, defaultConfig.type, defaultConfig.category);
          Logger.debug(`Config reset to default: ${key}`);
        }
      } else {
        // é‡ç½®æ‰€æœ‰é…ç½?| Reset all configs
        for (const [defaultKey, defaultConfig] of this.defaultConfigs.entries()) {
          await this.setConfig(defaultKey, defaultConfig.value, defaultConfig.type, defaultConfig.category);
        }
        Logger.debug('All configs reset to default');
      }
    } catch (error) {
      Logger.error(`Failed to reset config to default${key ? `: ${key}` : ''}`, error);
      throw error;
    }
  }

  /**
   * å¯¼å‡ºæ‰€æœ‰é…ç½?| Export all configs
   * @returns é…ç½®å¯¹è±¡ | Config object
   */
  public async exportConfigs(): Promise<Record<string, unknown>> {
    try {
      const exportData: Record<string, unknown> = {};
      
      for (const [key, config] of this.configCache.entries()) {
        exportData[key] = {
          value: config.value,
          type: config.type,
          category: config.category
        };
      }
      
      Logger.info('Configs exported successfully');
      return exportData;
    } catch (error) {
      Logger.error('Failed to export configs', error);
      return {};
    }
  }

  /**
   * å¯¼å…¥é…ç½® | Import configs
   * @param configs é…ç½®å¯¹è±¡ | Config object
   */
  public async importConfigs(configs: Record<string, unknown>): Promise<void> {
    try {
      for (const [key, config] of Object.entries(configs)) {
        if (typeof config === 'object' && config !== null) {
          await this.setConfig(key, (config as any).value, (config as any).type, (config as any).category);
        } else {
          // å…¼å®¹æ—§æ ¼å¼?| Compatible with old format
          const type = this.getValueType(config);
          await this.setConfig(key, config, type);
        }
      }
      
      Logger.info(`Imported ${Object.keys(configs).length} configs`);
    } catch (error) {
      Logger.error('Failed to import configs', error);
      throw error;
    }
  }

  /**
   * è·å–å€¼çš„ç±»å‹ | Get value type
   * @param value å€?| Value
   * @returns ç±»å‹å­—ç¬¦ä¸?| Type string
   */
  private getValueType(value: unknown): string {
    if (value === null) return 'null';
    if (Array.isArray(value)) return 'array';
    if (typeof value === 'object') return 'object';
    return typeof value;
  }

  /**
   * æ£€æŸ¥é…ç½®æ˜¯å¦å­˜åœ?| Check if config exists
   * @param key é…ç½®é”?| Config key
   * @returns æ˜¯å¦å­˜åœ¨ | Whether exists
   */
  public async hasConfig(key: string): Promise<boolean> {
    return this.configCache.has(key);
  }

  /**
   * è·å–æ‰€æœ‰é…ç½®é”® | Get all config keys
   * @returns é…ç½®é”®æ•°ç»?| Config key array
   */
  public getAllConfigKeys(): string[] {
    return Array.from(this.configCache.keys());
  }
  
  /**
   * æ›´æ–°é…ç½®ç¼“å­˜ | Refresh config cache
   */
  public async refreshCache(): Promise<void> {
    try {
      this.configCache.clear();
      await this.loadConfigsFromDatabase();
      Logger.debug('Config cache refreshed');
    } catch (error) {
      Logger.error('Failed to refresh config cache', error);
    }
  }

  /**
   * é‡ç½®ä»“åº“ | Reset repository
   */
  public async reset(): Promise<void> {
    try {
      Logger.info('Resetting config repository');
      
      // æ¸…ç©ºç¼“å­˜ | Clear cache
      this.configCache.clear();
      
      // æ¸…ç©ºæ•°æ®åº“ä¸­çš„é…ç½?| Clear configs in database
      await this.databaseRepository.clearTable('configs');
      
      // é‡æ–°åˆå§‹åŒ–é»˜è®¤é…ç½?| Reinitialize default configs
      this.initializeDefaultConfigs();
      await this.ensureDefaultConfigs();
      
      Logger.info('Config repository reset completed');
    } catch (error) {
      Logger.error('Failed to reset config repository', error);
      throw error;
    }
  }
}

export default ConfigRepository;
