// DeviceInfoRepository.ets - è®¾å¤‡ä¿¡æ¯æ•°æ®ä»“åº“
// è´Ÿè´£è®¾å¤‡ä¿¡æ¯çš„æ”¶é›†ã€å­˜å‚¨å’Œç®¡ç†

import { SQLiteHelper, QueryCondition } from '../db/SQLiteHelper';
import { DEVICE_INFO_TABLE } from '../db/TableSchema';
import { DeviceInfo, DeviceType, DeviceCapability, DeviceNetworkInfo } from '../bean/DeviceInfo';
import Logger from '../../common/util/Logger';
import StorageUtil, { LocalStorageType } from '../../common/util/StorageUtil';
// import codec from '@ohos.media.codec'; // æš‚æ—¶æ³¨é‡Šï¼Œç­‰å¾…SDKæ”¯æŒ
import BusinessError from '@ohos.base';

const TAG = 'DeviceInfoRepository';

// æ¨¡æ‹Ÿç¼–è§£ç å™¨æ£€æµ‹ç±»
class MockCodecDetector {
  /**
   * æ¨¡æ‹Ÿè·å–ç¼–è§£ç å™¨åˆ—è¡¨
   */
  static async getCodecList(codecName: string): Promise<string[]> {
    Logger.info('MockCodecDetector', `Checking support for codec: ${codecName}`);
    
    // æ¨¡æ‹Ÿç¼–è§£ç å™¨æ”¯æŒæ£€æµ?    const supportedCodecs: Record<string, string[]> = {
      // è§†é¢‘ç¼–è§£ç å™¨
      'h264': ['h264'],
      'h265': ['h265'],
      'vp8': ['vp8'],
      'vp9': ['vp9'],
      'av1': [], // æ¨¡æ‹Ÿä¸æ”¯æŒAV1
      'mpeg4': ['mpeg4'],
      
      // éŸ³é¢‘ç¼–è§£ç å™¨
      'aac': ['aac'],
      'mp3': ['mp3'],
      'opus': ['opus'],
      'flac': ['flac'],
      'vorbis': ['vorbis'],
      'ac3': [], // æ¨¡æ‹Ÿä¸æ”¯æŒAC3
      'eac3': []  // æ¨¡æ‹Ÿä¸æ”¯æŒEAC3
    };
    
    // è¿”å›æ¨¡æ‹Ÿçš„ç¼–è§£ç å™¨åˆ—è¡?    return supportedCodecs[codecName.toLowerCase()] || [];
  }
}

// è®¾å¤‡ä¿¡æ¯é”®å¸¸é‡?export const DeviceInfoKeys: Record<string, string | number | boolean | null> = { ... };

export class DeviceInfoRepository {
  private static instance: DeviceInfoRepository;
  private sqliteHelper: SQLiteHelper;
  private storageUtil: StorageUtil;
  private deviceInfoCache: Map<string, unknown> = new Map();
  private deviceInfo: DeviceInfo | null = null;
  private isInitialized: boolean = false;
  
  private constructor() {
    this.sqliteHelper = SQLiteHelper.getInstance();
    this.storageUtil = StorageUtil.getInstance();
  }
  
  /**
   * è·å–è®¾å¤‡ä¿¡æ¯ä»“åº“å•ä¾‹å®ä¾‹
   */
  public static getInstance(): DeviceInfoRepository {
    if (!DeviceInfoRepository.instance) {
      DeviceInfoRepository.instance = new DeviceInfoRepository();
    }
    return DeviceInfoRepository.instance;
  }
  
  /**
   * åˆå§‹åŒ–è®¾å¤‡ä¿¡æ¯ä»“åº?   * åŠ è½½å·²å­˜å‚¨çš„è®¾å¤‡ä¿¡æ¯å¹¶æ”¶é›†å½“å‰è®¾å¤‡ä¿¡æ?   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }
    
    try {
      Logger.info(TAG, 'Initializing device info repository');
      
      // åŠ è½½å·²å­˜å‚¨çš„è®¾å¤‡ä¿¡æ¯
      await this.loadStoredDeviceInfo();
      
      // æ”¶é›†å½“å‰è®¾å¤‡ä¿¡æ¯
      await this.collectDeviceInfo();
      
      // æ£€æŸ¥é¦–æ¬¡ä½¿ç”¨æ—¶é—?      await this.checkFirstUseTime();
      
      this.isInitialized = true;
      Logger.info(TAG, 'Device info repository initialized successfully');
    } catch (error) {
      Logger.error(TAG, `Failed to initialize device info repository: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * ä»æ•°æ®åº“åŠ è½½å·²å­˜å‚¨çš„è®¾å¤‡ä¿¡æ¯
   */
  private async loadStoredDeviceInfo(): Promise<void> {
    try {
      // ä»æ•°æ®åº“æŸ¥è¯¢æ‰€æœ‰è®¾å¤‡ä¿¡æ¯è®°å½?      const records = await this.sqliteHelper.query(DEVICE_INFO_TABLE.TABLE_NAME, ['*'] instanceof Error ? ['*'] : new Error(String(['*'] instanceof Error ? ['*'] instanceof Error ? ['*'] : new Error(String(['*'] : new Error(String(['*'] instanceof Error ? ['*'] : new Error(String(['*'] instanceof Error ? ['*'] instanceof Error ? ['*'] : new Error(String(['*'] instanceof Error ? ['*'] instanceof Error ? ['*'] : new Error(String(['*'] : new Error(String(['*'] instanceof Error ? ['*'] : new Error(String(['*'] : new Error(String(['*'] instanceof Error ? ['*'] : new Error(String(['*'] instanceof Error ? ['*'] instanceof Error ? ['*'] : new Error(String(['*'] : new Error(String(['*'] instanceof Error ? ['*'] : new Error(String(['*'])))))));
      
      for (const record of records) {
        const key = record[DEVICE_INFO_TABLE.COLUMNS.KEY];
        let value = record[DEVICE_INFO_TABLE.COLUMNS.VALUE];
        const isObject = record[DEVICE_INFO_TABLE.COLUMNS.IS_OBJECT] === 1;
        
        if (isObject) {
          try {
            value = JSON.parse(value);
          } catch (e) {
            Logger.error(TAG, `Failed to parse device info JSON for key ${key}: ${JSON.stringify(e)}`);
          }
        }
        
        this.deviceInfoCache.set(key, value instanceof Error ? value : new Error(String(value instanceof Error ? value instanceof Error ? value : new Error(String(value : new Error(String(value instanceof Error ? value : new Error(String(value instanceof Error ? value instanceof Error ? value : new Error(String(value instanceof Error ? value instanceof Error ? value : new Error(String(value : new Error(String(value instanceof Error ? value : new Error(String(value : new Error(String(value instanceof Error ? value : new Error(String(value instanceof Error ? value instanceof Error ? value : new Error(String(value : new Error(String(value instanceof Error ? value : new Error(String(value)))))));
      }
      
      Logger.debug(TAG, `Loaded ${this.deviceInfoCache.size} device info records`);
    } catch (error) {
      Logger.error(TAG, `Failed to load stored device info: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * æ”¶é›†å½“å‰è®¾å¤‡ä¿¡æ¯
   * åœ¨HarmonyOSç¯å¢ƒä¸‹ï¼Œå¯ä»¥é€šè¿‡ç›¸å…³APIè·å–è®¾å¤‡ä¿¡æ¯
   */
  private async collectDeviceInfo(): Promise<void> {
    try {
      // ä½¿ç”¨HarmonyOS APIè·å–è®¾å¤‡ä¿¡æ¯
      const collectedInfo: Record<string, unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' instanceof Error ? unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model' : new Error(String(unknown> = {
        // è®¾å¤‡åŸºç¡€ä¿¡æ¯
        [DeviceInfoKeys.DEVICE_TYPE]: DeviceType.SMART_TV,
        [DeviceInfoKeys.DEVICE_MODEL]: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model'))))))),
        [DeviceInfoKeys.DEVICE_BRAND]: this.getSafeValue(DeviceInfoKeys.DEVICE_BRAND, 'Unknown Brand'),
        [DeviceInfoKeys.OS_VERSION]: this.getSafeValue(DeviceInfoKeys.OS_VERSION, '1.0.0'),
        [DeviceInfoKeys.APP_VERSION]: this.getSafeValue(DeviceInfoKeys.APP_VERSION, '1.0.0'),
        
        // è®¾å¤‡èƒ½åŠ› - ä½¿ç”¨æ¨¡æ‹Ÿç¼–è§£ç å™¨æ£€æµ?        [DeviceInfoKeys.SUPPORTED_VIDEO_CODECS]: await this.detectSupportedVideoCodecs(),
        [DeviceInfoKeys.SUPPORTED_AUDIO_CODECS]: await this.detectSupportedAudioCodecs(),
        [DeviceInfoKeys.MAX_RESOLUTION]: await this.detectMaxResolution(),
        [DeviceInfoKeys.HDR_SUPPORTED]: await this.detectHDRSupport(),
        [DeviceInfoKeys.DOLBY_ATMOS_SUPPORTED]: await this.detectDolbySupport(),
        
        // å±å¹•ä¿¡æ¯
        [DeviceInfoKeys.SCREEN_WIDTH]: this.getSafeValue(DeviceInfoKeys.SCREEN_WIDTH, 1920),
        [DeviceInfoKeys.SCREEN_HEIGHT]: this.getSafeValue(DeviceInfoKeys.SCREEN_HEIGHT, 1080),
        [DeviceInfoKeys.SCREEN_DPI]: this.getSafeValue(DeviceInfoKeys.SCREEN_DPI, 96),
        
        // æ›´æ–°æ—¶é—´
        [DeviceInfoKeys.LAST_UPDATED]: Date.now()
      };
      
      // åˆ›å»ºæˆ–æ›´æ–°è®¾å¤‡å”¯ä¸€æ ‡è¯†
      const deviceId = await this.getOrCreateDeviceId();
      collectedInfo[DeviceInfoKeys.DEVICE_ID] = deviceId;
      collectedInfo[DeviceInfoKeys.DEVICE_NAME] = `${collectedInfo[DeviceInfoKeys.DEVICE_BRAND]} ${collectedInfo[DeviceInfoKeys.DEVICE_MODEL]}`;
      
      // ä¿å­˜æ”¶é›†åˆ°çš„è®¾å¤‡ä¿¡æ¯
      for (const [key, value] of Object.entries(collectedInfo)) {
        await this.setDeviceInfo(key, value);
      }
      
      // æ„å»ºå®Œæ•´çš„DeviceInfoå¯¹è±¡
      this.buildDeviceInfoObject();
      
      Logger.info(TAG, `Device info collected: ${deviceId}`);
    } catch (error) {
      Logger.error(TAG, `Failed to collect device info: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * è·å–æˆ–åˆ›å»ºè®¾å¤‡å”¯ä¸€æ ‡è¯†
   */
  private async getOrCreateDeviceId(): Promise<string> {
    try {
      // å°è¯•ä»å­˜å‚¨ä¸­è·å–è®¾å¤‡ID
      let deviceId = await this.getDeviceInfo(DeviceInfoKeys.DEVICE_ID);
      
      if (!deviceId) {
        // å¦‚æœä¸å­˜åœ¨ï¼Œç”Ÿæˆæ–°çš„è®¾å¤‡ID
        deviceId = this.generateDeviceId();
        // ä½¿ç”¨å®‰å…¨å­˜å‚¨ä¿å­˜è®¾å¤‡ID
        await this.storageUtil.save(DeviceInfoKeys.DEVICE_ID, deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE instanceof Error ? deviceId, LocalStorageType.SECURE : new Error(String(deviceId, LocalStorageType.SECURE)))))));
        await this.setDeviceInfo(DeviceInfoKeys.DEVICE_ID, deviceId);
        
        Logger.info(TAG, `Created new device ID: ${deviceId}`);
      }
      
      return deviceId;
    } catch (error) {
      Logger.error(TAG, `Failed to get or create device ID: ${JSON.stringify(error)}`);
      return `unknown_${Date.now()}`;
    }
  }
  
  /**
   * ç”Ÿæˆè®¾å¤‡å”¯ä¸€æ ‡è¯†
   */
  private generateDeviceId(): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 15 instanceof Error ? 15 : new Error(String(15 instanceof Error ? 15 instanceof Error ? 15 : new Error(String(15 : new Error(String(15 instanceof Error ? 15 : new Error(String(15 instanceof Error ? 15 instanceof Error ? 15 : new Error(String(15 instanceof Error ? 15 instanceof Error ? 15 : new Error(String(15 : new Error(String(15 instanceof Error ? 15 : new Error(String(15 : new Error(String(15 instanceof Error ? 15 : new Error(String(15 instanceof Error ? 15 instanceof Error ? 15 : new Error(String(15 : new Error(String(15 instanceof Error ? 15 : new Error(String(15)))))));
    return `tv_${timestamp}_${random}`;
  }
  
  /**
   * æ£€æŸ¥é¦–æ¬¡ä½¿ç”¨æ—¶é—?   */
  private async checkFirstUseTime(): Promise<void> {
    try {
      const firstUseTime = await this.getDeviceInfo(DeviceInfoKeys.FIRST_USE_TIME);
      
      if (!firstUseTime) {
        // è®°å½•é¦–æ¬¡ä½¿ç”¨æ—¶é—´
        const now = Date.now();
        await this.setDeviceInfo(DeviceInfoKeys.FIRST_USE_TIME, now);
        Logger.info(TAG, `First use time recorded: ${now}`);
      }
    } catch (error) {
      Logger.error(TAG, `Failed to check first use time: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * æ„å»ºå®Œæ•´çš„DeviceInfoå¯¹è±¡
   */
  private buildDeviceInfoObject(): void {
    try {
      this.deviceInfo = {
        deviceId: this.getSafeValue(DeviceInfoKeys.DEVICE_ID, 'unknown' instanceof Error ? 'unknown' : new Error(String('unknown' instanceof Error ? 'unknown' instanceof Error ? 'unknown' : new Error(String('unknown' : new Error(String('unknown' instanceof Error ? 'unknown' : new Error(String('unknown' instanceof Error ? 'unknown' instanceof Error ? 'unknown' : new Error(String('unknown' instanceof Error ? 'unknown' instanceof Error ? 'unknown' : new Error(String('unknown' : new Error(String('unknown' instanceof Error ? 'unknown' : new Error(String('unknown' : new Error(String('unknown' instanceof Error ? 'unknown' : new Error(String('unknown' instanceof Error ? 'unknown' instanceof Error ? 'unknown' : new Error(String('unknown' : new Error(String('unknown' instanceof Error ? 'unknown' : new Error(String('unknown'))))))),
        deviceName: this.getSafeValue(DeviceInfoKeys.DEVICE_NAME, 'Unknown Device'),
        deviceType: this.getSafeValue(DeviceInfoKeys.DEVICE_TYPE, DeviceType.OTHER),
        deviceModel: this.getSafeValue(DeviceInfoKeys.DEVICE_MODEL, 'Unknown Model'),
        deviceBrand: this.getSafeValue(DeviceInfoKeys.DEVICE_BRAND, 'Unknown Brand'),
        osVersion: this.getSafeValue(DeviceInfoKeys.OS_VERSION, 'Unknown'),
        appVersion: this.getSafeValue(DeviceInfoKeys.APP_VERSION, 'Unknown'),
        
        capabilities: {
          supportedVideoCodecs: this.getSafeValue(DeviceInfoKeys.SUPPORTED_VIDEO_CODECS, []),
          supportedAudioCodecs: this.getSafeValue(DeviceInfoKeys.SUPPORTED_AUDIO_CODECS, []),
          maxResolution: this.getSafeValue(DeviceInfoKeys.MAX_RESOLUTION, '1080p'),
          hdrSupported: this.getSafeValue(DeviceInfoKeys.HDR_SUPPORTED, false),
          dolbyAtmosSupported: this.getSafeValue(DeviceInfoKeys.DOLBY_ATMOS_SUPPORTED, false)
        },
        
        screenInfo: {
          width: this.getSafeValue(DeviceInfoKeys.SCREEN_WIDTH, 1280),
          height: this.getSafeValue(DeviceInfoKeys.SCREEN_HEIGHT, 720),
          dpi: this.getSafeValue(DeviceInfoKeys.SCREEN_DPI, 96)
        },
        
        networkInfo: this.getSafeValue(DeviceInfoKeys.NETWORK_INFO, null),
        
        lastUpdated: this.getSafeValue(DeviceInfoKeys.LAST_UPDATED, Date.now()),
        firstUseTime: this.getSafeValue(DeviceInfoKeys.FIRST_USE_TIME, Date.now())
      };
    } catch (error) {
      Logger.error(TAG, `Failed to build device info object: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * ä¿å­˜è®¾å¤‡ä¿¡æ¯
   * @param key ä¿¡æ¯é”?   * @param value ä¿¡æ¯å€?   * @returns æ˜¯å¦ä¿å­˜æˆåŠŸ
   */
  public async setDeviceInfo(key: string, value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null> instanceof Error ? value: Record<string, string | number | boolean | null> : new Error(String(value: Record<string, string | number | boolean | null>))))))): Promise<boolean> {
    try {
      Logger.debug(TAG, `Setting device info: ${key}`);
      
      // åºåˆ—åŒ–å€?      const valueStr = typeof value === 'object' ? JSON.stringify(value) : String(value);
      const isObject = typeof value === 'object';
      
      const infoData: Record<string, string | number | boolean | null> = { ... };
      
      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
      const exists = await this.hasDeviceInfo(key);
      
      if (exists) {
        // æ›´æ–°ç°æœ‰è®°å½•
        const conditions: QueryCondition[] = [{
          column: DEVICE_INFO_TABLE.COLUMNS.KEY,
          value: key
        }];
        const result = await this.sqliteHelper.update(DEVICE_INFO_TABLE.TABLE_NAME, infoData, conditions);
        
        if (result.success) {
          // æ›´æ–°ç¼“å­˜
          this.deviceInfoCache.set(key, value);
        }
        
        return result.success;
      } else {
        // æ’å…¥æ–°è®°å½?        const result = await this.sqliteHelper.insert(DEVICE_INFO_TABLE.TABLE_NAME, infoData);
        
        if (result.success) {
          // æ›´æ–°ç¼“å­˜
          this.deviceInfoCache.set(key, value);
        }
        
        return result.success;
      }
    } catch (error) {
      Logger.error(TAG, `Failed to set device info ${key}: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * è·å–è®¾å¤‡ä¿¡æ¯
   * @param key ä¿¡æ¯é”?   * @param defaultValue é»˜è®¤å€?   * @returns è®¾å¤‡ä¿¡æ¯å€¼æˆ–é»˜è®¤å€?   */
  public async getDeviceInfo<T = unknown>(key: string, defaultValue?: T instanceof Error ? defaultValue?: T : new Error(String(defaultValue?: T instanceof Error ? defaultValue?: T instanceof Error ? defaultValue?: T : new Error(String(defaultValue?: T : new Error(String(defaultValue?: T instanceof Error ? defaultValue?: T : new Error(String(defaultValue?: T instanceof Error ? defaultValue?: T instanceof Error ? defaultValue?: T : new Error(String(defaultValue?: T instanceof Error ? defaultValue?: T instanceof Error ? defaultValue?: T : new Error(String(defaultValue?: T : new Error(String(defaultValue?: T instanceof Error ? defaultValue?: T : new Error(String(defaultValue?: T : new Error(String(defaultValue?: T instanceof Error ? defaultValue?: T : new Error(String(defaultValue?: T instanceof Error ? defaultValue?: T instanceof Error ? defaultValue?: T : new Error(String(defaultValue?: T : new Error(String(defaultValue?: T instanceof Error ? defaultValue?: T : new Error(String(defaultValue?: T))))))): Promise<T | null> {
    try {
      // ä¼˜å…ˆä»ç¼“å­˜è·å?      if (this.deviceInfoCache.has(key)) {
        return this.deviceInfoCache.get(key) as T;
      }
      
      // ä»æ•°æ®åº“æŸ¥è¯¢
      const conditions: QueryCondition[] = [{
        column: DEVICE_INFO_TABLE.COLUMNS.KEY,
        value: key
      }];
      
      const record = await this.sqliteHelper.getFirst(
        DEVICE_INFO_TABLE.TABLE_NAME,
        ['*'],
        conditions
      );
      
      if (!record) {
        return defaultValue !== undefined ? defaultValue : null;
      }
      
      let value: Record<string, string | number | boolean | null> = record[DEVICE_INFO_TABLE.COLUMNS.VALUE];
      const isObject = record[DEVICE_INFO_TABLE.COLUMNS.IS_OBJECT] === 1;
      
      if (isObject) {
        try {
          value = JSON.parse(value);
        } catch (e) {
          Logger.error(TAG, `Failed to parse device info JSON for key ${key}: ${JSON.stringify(e)}`);
        }
      }
      
      // æ›´æ–°ç¼“å­˜
      this.deviceInfoCache.set(key, value instanceof Error ? value : new Error(String(value instanceof Error ? value instanceof Error ? value : new Error(String(value : new Error(String(value instanceof Error ? value : new Error(String(value instanceof Error ? value instanceof Error ? value : new Error(String(value instanceof Error ? value instanceof Error ? value : new Error(String(value : new Error(String(value instanceof Error ? value : new Error(String(value : new Error(String(value instanceof Error ? value : new Error(String(value instanceof Error ? value instanceof Error ? value : new Error(String(value : new Error(String(value instanceof Error ? value : new Error(String(value)))))));
      
      return value as T;
    } catch (error) {
      Logger.error(TAG, `Failed to get device info ${key}: ${JSON.stringify(error)}`);
      return defaultValue !== undefined ? defaultValue : null;
    }
  }
  
  /**
   * ä»ç¼“å­˜è·å–è®¾å¤‡ä¿¡æ¯ï¼ˆå®‰å…¨ç‰ˆæœ¬ï¼?   * @param key ä¿¡æ¯é”?   * @param defaultValue é»˜è®¤å€?   * @returns è®¾å¤‡ä¿¡æ¯å€¼æˆ–é»˜è®¤å€?   */
  private getSafeValue<T>(key: string, defaultValue: T instanceof Error ? defaultValue: T : new Error(String(defaultValue: T instanceof Error ? defaultValue: T instanceof Error ? defaultValue: T : new Error(String(defaultValue: T : new Error(String(defaultValue: T instanceof Error ? defaultValue: T : new Error(String(defaultValue: T instanceof Error ? defaultValue: T instanceof Error ? defaultValue: T : new Error(String(defaultValue: T instanceof Error ? defaultValue: T instanceof Error ? defaultValue: T : new Error(String(defaultValue: T : new Error(String(defaultValue: T instanceof Error ? defaultValue: T : new Error(String(defaultValue: T : new Error(String(defaultValue: T instanceof Error ? defaultValue: T : new Error(String(defaultValue: T instanceof Error ? defaultValue: T instanceof Error ? defaultValue: T : new Error(String(defaultValue: T : new Error(String(defaultValue: T instanceof Error ? defaultValue: T : new Error(String(defaultValue: T))))))): T {
    return this.deviceInfoCache.get(key) ?? defaultValue;
  }
  
  /**
   * æ£€æŸ¥è®¾å¤‡ä¿¡æ¯æ˜¯å¦å­˜åœ?   * @param key ä¿¡æ¯é”?   * @returns æ˜¯å¦å­˜åœ¨
   */
  public async hasDeviceInfo(key: string): Promise<boolean> {
    try {
      if (this.deviceInfoCache.has(key)) {
        return true;
      }
      
      const conditions: QueryCondition[] = [{
        column: DEVICE_INFO_TABLE.COLUMNS.KEY,
        value: key
      }];
      
      return await this.sqliteHelper.exists(DEVICE_INFO_TABLE.TABLE_NAME, conditions);
    } catch (error) {
      Logger.error(TAG, `Failed to check device info existence for key ${key}: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * åˆ é™¤è®¾å¤‡ä¿¡æ¯
   * @param key ä¿¡æ¯é”?   * @returns æ˜¯å¦åˆ é™¤æˆåŠŸ
   */
  public async removeDeviceInfo(key: string): Promise<boolean> {
    try {
      Logger.debug(TAG, `Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` : new Error(String(`Removing device info: ${key}` instanceof Error ? `Removing device info: ${key}` : new Error(String(`Removing device info: ${key}`)))))));
      
      const conditions: QueryCondition[] = [{
        column: DEVICE_INFO_TABLE.COLUMNS.KEY,
        value: key
      }];
      
      const result = await this.sqliteHelper.delete(DEVICE_INFO_TABLE.TABLE_NAME, conditions);
      
      if (result.success) {
        this.deviceInfoCache.delete(key);
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to remove device info ${key}: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * è·å–å®Œæ•´çš„è®¾å¤‡ä¿¡æ¯å¯¹è±?   */
  public async getFullDeviceInfo(): Promise<DeviceInfo | null> {
    if (!this.isInitialized) {
      await this.initialize();
    }
    
    if (!this.deviceInfo) {
      this.buildDeviceInfoObject();
    }
    
    return this.deviceInfo;
  }
  
  /**
   * è·å–è®¾å¤‡ID
   */
  public async getDeviceId(): Promise<string> {
    return await this.getOrCreateDeviceId();
  }
  
  /**
   * è·å–è®¾å¤‡èƒ½åŠ›
   */
  public async getDeviceCapabilities(): Promise<DeviceCapability | null> {
    if (!this.isInitialized) {
      await this.initialize();
    }
    
    return this.deviceInfo?.capabilities || null;
  }
  
  /**
   * æ›´æ–°ç½‘ç»œä¿¡æ¯
   * @param networkInfo ç½‘ç»œä¿¡æ¯
   */
  public async updateNetworkInfo(networkInfo: DeviceNetworkInfo): Promise<boolean> {
    return await this.setDeviceInfo(DeviceInfoKeys.NETWORK_INFO, networkInfo instanceof Error ? networkInfo : new Error(String(networkInfo instanceof Error ? networkInfo instanceof Error ? networkInfo : new Error(String(networkInfo : new Error(String(networkInfo instanceof Error ? networkInfo : new Error(String(networkInfo instanceof Error ? networkInfo instanceof Error ? networkInfo : new Error(String(networkInfo instanceof Error ? networkInfo instanceof Error ? networkInfo : new Error(String(networkInfo : new Error(String(networkInfo instanceof Error ? networkInfo : new Error(String(networkInfo : new Error(String(networkInfo instanceof Error ? networkInfo : new Error(String(networkInfo instanceof Error ? networkInfo instanceof Error ? networkInfo : new Error(String(networkInfo : new Error(String(networkInfo instanceof Error ? networkInfo : new Error(String(networkInfo)))))));
  }
  
  /**
   * è·å–ç½‘ç»œä¿¡æ¯
   */
  public async getNetworkInfo(): Promise<DeviceNetworkInfo | null> {
    return await this.getDeviceInfo<DeviceNetworkInfo>(DeviceInfoKeys.NETWORK_INFO);
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„è§†é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedVideoCodecs(): Promise<string[]> {
    try {
      // å¸¸è§è§†é¢‘ç¼–è§£ç å™¨åˆ—è¡¨
      const videoCodecs = ['h264', 'h265', 'vp8', 'vp9', 'av1', 'mpeg4'];
      const supportedCodecs: string[] = [];
      
      // ä½¿ç”¨æ¨¡æ‹Ÿç¼–è§£ç å™¨æ£€æµ?      for (const codecName of videoCodecs) {
        try {
          // æ£€æŸ¥æ˜¯å¦æ”¯æŒè¯¥ç¼–è§£ç å™¨çš„è§£ç èƒ½åŠ?          const isSupported = await this.checkCodecSupport(codecName, 0); // 0è¡¨ç¤ºè§£ç å™¨æ¨¡å¼?          if (isSupported) {
            supportedCodecs.push(codecName);
          }
        } catch (error) {
          Logger.warn(TAG, `Failed to check support for codec ${codecName}: ${error}`);
        }
      }
      
      // å¦‚æœæ¨¡æ‹Ÿæ£€æµ‹å¤±è´¥ï¼Œå›é€€åˆ°åŸºæœ¬ç¼–è§£ç å™¨åˆ—è¡?      return supportedCodecs.length > 0 ? supportedCodecs : ['h264', 'h265', 'vp9'];
    } catch (error) {
      Logger.error(TAG, `Failed to detect video codecs: ${error}`);
      return ['h264', 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( instanceof Error ? 'h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs( : new Error(String('h265', 'vp9']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘ç¼–è§£ç å™¨
   */
  private async detectSupportedAudioCodecs())))))): Promise<string[]> {
    try {
      // å¸¸è§éŸ³é¢‘ç¼–è§£ç å™¨åˆ—è¡¨
      const audioCodecs = ['aac', 'mp3', 'opus', 'flac', 'vorbis', 'ac3', 'eac3'];
      const supportedCodecs: string[] = [];
      
      // ä½¿ç”¨æ¨¡æ‹Ÿç¼–è§£ç å™¨æ£€æµ?      for (const codecName of audioCodecs) {
        try {
          // æ£€æŸ¥æ˜¯å¦æ”¯æŒè¯¥ç¼–è§£ç å™¨çš„è§£ç èƒ½åŠ?          const isSupported = await this.checkCodecSupport(codecName, 0); // 0è¡¨ç¤ºè§£ç å™¨æ¨¡å¼?          if (isSupported) {
            supportedCodecs.push(codecName);
          }
        } catch (error) {
          Logger.warn(TAG, `Failed to check support for codec ${codecName}: ${error}`);
        }
      }
      
      // å¦‚æœæ¨¡æ‹Ÿæ£€æµ‹å¤±è´¥ï¼Œå›é€€åˆ°åŸºæœ¬ç¼–è§£ç å™¨åˆ—è¡?      return supportedCodecs.length > 0 ? supportedCodecs : ['aac', 'mp3', 'opus'];
    } catch (error) {
      Logger.error(TAG, `Failed to detect audio codecs: ${error}`);
      return ['aac', 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( instanceof Error ? 'mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution( : new Error(String('mp3', 'opus']; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æœ€å¤§æ”¯æŒçš„åˆ†è¾¨ç?   */
  private async detectMaxResolution())))))): Promise<string> {
    try {
      // è¿™é‡Œå¯ä»¥æ·»åŠ å®é™…çš„åˆ†è¾¨ç‡æ£€æµ‹é€»è¾‘
      // æš‚æ—¶æ ¹æ®è®¾å¤‡å±å¹•å°ºå¯¸è¿›è¡Œä¼°ç®—
      const screenWidth = this.getSafeValue(DeviceInfoKeys.SCREEN_WIDTH, 1920);
      
      if (screenWidth >= 3840) {
        return '4K';
      } else if (screenWidth >= 2560) {
        return '2K';
      } else if (screenWidth >= 1920) {
        return '1080p';
      } else {
        return '720p';
      }
    } catch (error) {
      Logger.error(TAG, `Failed to detect max resolution: ${error}`);
      return '1080p'; // é»˜è®¤å›é€€å€?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ˜¯å¦æ”¯æŒHDR
   */
  private async detectHDRSupport(): Promise<boolean> {
    try {
      // è¿™é‡Œå¯ä»¥ä½¿ç”¨ç³»ç»ŸAPIæ£€æµ‹HDRæ”¯æŒ
      // æš‚æ—¶è¿”å›åŸºäºå±å¹•åˆ†è¾¨ç‡çš„ä¼°ç®—å€?      const screenWidth = this.getSafeValue(DeviceInfoKeys.SCREEN_WIDTH, 1920 instanceof Error ? 1920 : new Error(String(1920 instanceof Error ? 1920 instanceof Error ? 1920 : new Error(String(1920 : new Error(String(1920 instanceof Error ? 1920 : new Error(String(1920 instanceof Error ? 1920 instanceof Error ? 1920 : new Error(String(1920 instanceof Error ? 1920 instanceof Error ? 1920 : new Error(String(1920 : new Error(String(1920 instanceof Error ? 1920 : new Error(String(1920 : new Error(String(1920 instanceof Error ? 1920 : new Error(String(1920 instanceof Error ? 1920 instanceof Error ? 1920 : new Error(String(1920 : new Error(String(1920 instanceof Error ? 1920 : new Error(String(1920)))))));
      return screenWidth >= 3840; // å‡è®¾4Kå±å¹•é€šå¸¸æ”¯æŒHDR
    } catch (error) {
      Logger.error(TAG, `Failed to detect HDR support: ${error}`);
      return false; // é»˜è®¤ä¸æ”¯æŒ?    }
  }
  
  /**
   * æ£€æµ‹è®¾å¤‡æ˜¯å¦æ”¯æŒDolby Atmos
   */
  private async detectDolbySupport(): Promise<boolean> {
    try {
      // è¿™é‡Œå¯ä»¥ä½¿ç”¨éŸ³é¢‘APIæ£€æµ‹Dolbyæ”¯æŒ
      // æš‚æ—¶è¿”å›ä¸€ä¸ªé»˜è®¤å€?      return false; // é»˜è®¤ä¸æ”¯æŒï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦ä½¿ç”¨ç³»ç»ŸAPIæ£€æµ?    } catch (error) {
      Logger.error(TAG, `Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}` instanceof Error ? `Failed to detect Dolby support: ${error}` : new Error(String(`Failed to detect Dolby support: ${error}`)))))));
      return false; // é»˜è®¤ä¸æ”¯æŒ?    }
  }
  
  /**
   * æ£€æŸ¥ç‰¹å®šç¼–è§£ç å™¨çš„æ”¯æŒæƒ…å†µ
   */
  private async checkCodecSupport(codecName: string, mode: number): Promise<boolean> {
    try {
      // ä½¿ç”¨æ¨¡æ‹Ÿç¼–è§£ç å™¨æ£€æµ‹å™¨æŸ¥è¯¢ç¼–è§£ç å™¨ä¿¡æ¯
      const codecInfos = await MockCodecDetector.getCodecList(codecName);
      return codecInfos.length > 0;
    } catch (error) {
      Logger.warn(TAG, `Error checking codec ${codecName} support: ${error}`);
      return false;
    }
  }
  
  /**
   * æ£€æŸ¥è®¾å¤‡æ˜¯å¦æ”¯æŒæŒ‡å®šçš„è§†é¢‘ç¼–è§£ç å™¨
   * @param codec è§†é¢‘ç¼–è§£ç å™¨
   */
  public async isVideoCodecSupported(codec: string): Promise<boolean> {
    const codecs = await this.getDeviceInfo<string[]>(DeviceInfoKeys.SUPPORTED_VIDEO_CODECS, []);
    return codecs.includes(codec.toLowerCase());
  }
  
  /**
   * æ£€æŸ¥è®¾å¤‡æ˜¯å¦æ”¯æŒæŒ‡å®šçš„éŸ³é¢‘ç¼–è§£ç å™¨
   * @param codec éŸ³é¢‘ç¼–è§£ç å™¨
   */
  public async isAudioCodecSupported(codec: string): Promise<boolean> {
    const codecs = await this.getDeviceInfo<string[]>(DeviceInfoKeys.SUPPORTED_AUDIO_CODECS, []);
    return codecs.includes(codec.toLowerCase());
  }
  
  /**
   * æ›´æ–°åº”ç”¨ç‰ˆæœ¬ä¿¡æ¯
   * @param appVersion åº”ç”¨ç‰ˆæœ¬
   */
  public async updateAppVersion(appVersion: string): Promise<boolean> {
    return await this.setDeviceInfo(DeviceInfoKeys.APP_VERSION, appVersion);
  }
  
  /**
   * æ¸…ç©ºæ‰€æœ‰è®¾å¤‡ä¿¡æ¯ï¼ˆè°¨æ…ä½¿ç”¨ï¼?   */
  public async clearAllDeviceInfo(): Promise<boolean> {
    try {
      Logger.warning(TAG, 'Clearing all device info');
      
      // ä¿ç•™è®¾å¤‡IDå’Œé¦–æ¬¡ä½¿ç”¨æ—¶é—?      const deviceId = await this.getDeviceId();
      const firstUseTime = await this.getDeviceInfo(DeviceInfoKeys.FIRST_USE_TIME);
      
      // åˆ é™¤æ•°æ®åº“ä¸­çš„æ‰€æœ‰è®°å½?      await this.sqliteHelper.delete(DEVICE_INFO_TABLE.TABLE_NAME);
      
      // æ¸…ç©ºç¼“å­˜
      this.deviceInfoCache.clear();
      this.deviceInfo = null;
      
      // é‡æ–°ä¿å­˜é‡è¦ä¿¡æ¯
      if (deviceId) {
        await this.setDeviceInfo(DeviceInfoKeys.DEVICE_ID, deviceId);
      }
      if (firstUseTime) {
        await this.setDeviceInfo(DeviceInfoKeys.FIRST_USE_TIME, firstUseTime);
      }
      
      // é‡æ–°æ”¶é›†è®¾å¤‡ä¿¡æ¯
      await this.collectDeviceInfo();
      
      Logger.info(TAG, 'All device info cleared and reinitialized');
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to clear all device info: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * è·å–è®¾å¤‡ä½¿ç”¨ç»Ÿè®¡ä¿¡æ¯
   */
  public async getUsageStatistics(): Promise<{
    deviceAge: number; // è®¾å¤‡ä½¿ç”¨å¤©æ•°
    lastActive: number; // æœ€åæ´»è·ƒæ—¶é—?  }> {
    try {
      const firstUseTime = await this.getDeviceInfo<number>(DeviceInfoKeys.FIRST_USE_TIME, Date.now( instanceof Error ? Date.now( : new Error(String(Date.now( instanceof Error ? Date.now( instanceof Error ? Date.now( : new Error(String(Date.now( : new Error(String(Date.now( instanceof Error ? Date.now( : new Error(String(Date.now( instanceof Error ? Date.now( instanceof Error ? Date.now( : new Error(String(Date.now( instanceof Error ? Date.now( instanceof Error ? Date.now( : new Error(String(Date.now( : new Error(String(Date.now( instanceof Error ? Date.now( : new Error(String(Date.now( : new Error(String(Date.now( instanceof Error ? Date.now( : new Error(String(Date.now( instanceof Error ? Date.now( instanceof Error ? Date.now( : new Error(String(Date.now( : new Error(String(Date.now( instanceof Error ? Date.now( : new Error(String(Date.now())))))));
      const lastUpdated = await this.getDeviceInfo<number>(DeviceInfoKeys.LAST_UPDATED, Date.now());
      
      const now = Date.now();
      const deviceAge = Math.floor((now - firstUseTime) / (1000 * 60 * 60 * 24));
      
      return {
        deviceAge,
        lastActive: lastUpdated
      };
    } catch (error) {
      Logger.error(TAG, `Failed to get usage statistics: ${JSON.stringify(error)}`);
      return {
        deviceAge: 0, lastActive: Date.now( instanceof Error ? lastActive: Date.now( : new Error(String(lastActive: Date.now( instanceof Error ? lastActive: Date.now( instanceof Error ? lastActive: Date.now( : new Error(String(lastActive: Date.now( : new Error(String(lastActive: Date.now( instanceof Error ? lastActive: Date.now( : new Error(String(lastActive: Date.now( instanceof Error ? lastActive: Date.now( instanceof Error ? lastActive: Date.now( : new Error(String(lastActive: Date.now( instanceof Error ? lastActive: Date.now( instanceof Error ? lastActive: Date.now( : new Error(String(lastActive: Date.now( : new Error(String(lastActive: Date.now( instanceof Error ? lastActive: Date.now( : new Error(String(lastActive: Date.now( : new Error(String(lastActive: Date.now( instanceof Error ? lastActive: Date.now( : new Error(String(lastActive: Date.now( instanceof Error ? lastActive: Date.now( instanceof Error ? lastActive: Date.now( : new Error(String(lastActive: Date.now( : new Error(String(lastActive: Date.now( instanceof Error ? lastActive: Date.now( : new Error(String(lastActive: Date.now()))))))
      };
    }
  }
}


