// LiveRepository.ets - ç›´æ’­å†…å®¹æ•°æ®ä»“åº“
// è´Ÿè´£ç›´æ’­å†…å®¹çš„ç¼“å­˜ã€ç®¡ç†å’Œæ’­æ”¾å†å²è®°å½•

import { SQLiteHelper, QueryCondition, SortOption } from '../db/SQLiteHelper';
import { LIVE_CHANNEL_TABLE, LIVE_GROUP_TABLE } from '../db/TableSchema';
import {
  LiveChannel,
  LiveGroup,
  EpgItem,
  LiveStream
} from '../bean/Live';
import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';

const TAG = 'LiveRepository';

// ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
const CHANNEL_CACHE_EXPIRY = 7200000; // 2å°æ—¶
const EPG_CACHE_EXPIRY = 3600000; // 1å°æ—¶

// æ‰¹é‡æ“ä½œçš„æ‰¹æ¬¡å¤§å°?const BATCH_SIZE = 200;

export class LiveRepository {
  private static instance: LiveRepository;
  private storageUtil: StorageUtil;
  
  // å†…å­˜ç¼“å­˜
  private channelCache: Map<string, Map<string, LiveChannel>> = new Map(); // siteId -> channelId -> LiveChannel
  private groupCache: Map<string, LiveGroup[]> = new Map(); // siteId -> LiveGroup[]
  private epgCache: Map<string, Map<string, EpgItem[]>> = new Map(); // siteId -> channelId -> EpgItem[]
  
  private constructor() {
    this.storageUtil = StorageUtil.getInstance();
  }
  
  /**
   * è·å–ç›´æ’­ä»“åº“å•ä¾‹å®ä¾‹
   */
  public static getInstance(): LiveRepository {
    if (!LiveRepository.instance) {
      LiveRepository.instance = new LiveRepository();
    }
    return LiveRepository.instance;
  }
  
  /**
   * åˆå§‹åŒ–ç›´æ’­ä»“åº?   */
  public async init(): Promise<void> {
    try {
      Logger.info(TAG, 'Initializing LiveRepository');
      // ç®€åŒ–å®ç°ï¼Œä»…è®°å½•æ—¥å¿?    } catch (error) {
      Logger.error(TAG, new Error(`Failed to initialize LiveRepository: ${JSON.stringify(error)}`));
      throw error;
    }
  }
  
  /**
   * ä¿å­˜ç›´æ’­é¢‘é“æ•°æ®
   * @param siteId ç«™ç‚¹ID
   * @param channels é¢‘é“åˆ—è¡¨
   * @returns æ˜¯å¦ä¿å­˜æˆåŠŸ
   */
  public async saveChannels(siteId: string, channels: LiveChannel[]): Promise<boolean> {
    try {
      Logger.debug(TAG, `Saving ${channels.length} channels for site ${siteId}`);
      
      // ç®€åŒ–å®ç°ï¼Œä»…æ›´æ–°å†…å­˜ç¼“å­?      if (!this.channelCache.has(siteId)) {
        this.channelCache.set(siteId, new Map());
      }
      
      const channelMap = this.channelCache.get(siteId)!;
      channels.forEach(channel => {
        channelMap.set(channel.id, channel);
      });
      
      return true;
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to save channels: ${JSON.stringify(error)}`));
      return false;
    }
  }
  
  /**
   * è·å–ç›´æ’­é¢‘é“åˆ—è¡¨
   * @param siteId ç«™ç‚¹ID
   * @returns é¢‘é“åˆ—è¡¨
   */
  public async getChannels(siteId: string): Promise<LiveChannel[]> {
    try {
      // ä»å†…å­˜ç¼“å­˜è·å?      if (this.channelCache.has(siteId)) {
        return Array.from(this.channelCache.get(siteId)!.values());
      }
      return [];
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to get channels: ${JSON.stringify(error)}`));
      return [];
    }
  }
  
  /**
   * æ ¹æ®IDè·å–ç›´æ’­é¢‘é“
   * @param siteId ç«™ç‚¹ID
   * @param channelId é¢‘é“ID
   * @returns ç›´æ’­é¢‘é“æˆ–null
   */
  public async getChannelById(siteId: string, channelId: string): Promise<LiveChannel | null> {
    try {
      // ä»å†…å­˜ç¼“å­˜è·å?      if (this.channelCache.has(siteId)) {
        return this.channelCache.get(siteId)!.get(channelId) || null;
      }
      return null;
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error)}`));
      return null;
    }
  }
  
  /**
   * æœç´¢ç›´æ’­é¢‘é“
   * @param keyword æœç´¢å…³é”®è¯?   * @param siteId ç«™ç‚¹IDï¼ˆå¯é€‰ï¼‰
   * @returns æœç´¢ç»“æœ
   */
  public async searchChannels(keyword: string, siteId?: string): Promise<LiveChannel[]> {
    try {
      // ç®€åŒ–å®ç°ï¼Œä»å†…å­˜ç¼“å­˜æœç´?      const results: LiveChannel[] = [];
      
      const siteIds = siteId ? [siteId] : Array.from(this.channelCache.keys());
      
      for (const sid of siteIds) {
        if (this.channelCache.has(sid)) {
          const channels = Array.from(this.channelCache.get(sid)!.values());
          const matchedChannels = channels.filter(channel => 
            channel.name.includes(keyword)
          );
          results.push(...matchedChannels);
        }
      }
      
      return results;
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to search channels: ${JSON.stringify(error)}`));
      return [];
    }
  }
  
  /**
   * ä¿å­˜EPGæ•°æ®
   * @param siteId ç«™ç‚¹ID
   * @param channelId é¢‘é“ID
   * @param epgItems EPGèŠ‚ç›®åˆ—è¡¨
   * @returns æ˜¯å¦ä¿å­˜æˆåŠŸ
   */
  public async saveEpgData(siteId: string, channelId: string, epgItems: EpgItem[]): Promise<boolean> {
    try {
      Logger.debug(TAG, `Saving ${epgItems.length} EPG items for channel ${channelId}`);
      
      // ç®€åŒ–å®ç°ï¼Œä»…æ›´æ–°å†…å­˜ç¼“å­?      if (!this.epgCache.has(siteId)) {
        this.epgCache.set(siteId, new Map());
      }
      this.epgCache.get(siteId)!.set(channelId, epgItems);
      
      return true;
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to save EPG data: ${JSON.stringify(error)}`));
      return false;
    }
  }
  
  /**
   * è·å–EPGæ•°æ®
   * @param siteId ç«™ç‚¹ID
   * @param channelId é¢‘é“ID
   * @returns EPGèŠ‚ç›®åˆ—è¡¨
   */
  public async getEpgData(siteId: string, channelId: string): Promise<EpgItem[]> {
    try {
      // ä»å†…å­˜ç¼“å­˜è·å?      if (this.epgCache.has(siteId)) {
        return this.epgCache.get(siteId)!.get(channelId) || [];
      }
      return [];
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to get EPG data: ${JSON.stringify(error)}`));
      return [];
    }
  }
  
  /**
   * ä¿å­˜ç›´æ’­åˆ†ç»„
   * @param siteId ç«™ç‚¹ID
   * @param groups åˆ†ç»„åˆ—è¡¨
   * @returns æ˜¯å¦ä¿å­˜æˆåŠŸ
   */
  public async saveGroups(siteId: string, groups: LiveGroup[]): Promise<boolean> {
    try {
      Logger.debug(TAG, `Saving ${groups.length} groups for site ${siteId}`);
      
      // ç®€åŒ–å®ç°ï¼Œä»…æ›´æ–°å†…å­˜ç¼“å­?      this.groupCache.set(siteId, groups);
      
      return true;
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to save groups: ${JSON.stringify(error)}`));
      return false;
    }
  }
  
  /**
   * è·å–ç›´æ’­åˆ†ç»„åˆ—è¡¨
   * @param siteId ç«™ç‚¹ID
   * @returns åˆ†ç»„åˆ—è¡¨
   */
  public async getGroups(siteId: string): Promise<LiveGroup[]> {
    try {
      // ä»å†…å­˜ç¼“å­˜è·å?      return this.groupCache.get(siteId) || [];
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to get groups: ${JSON.stringify(error)}`));
      return [];
    }
  }
  
  /**
   * æ ¹æ®IDè·å–ç›´æ’­åˆ†ç»„
   * @param siteId ç«™ç‚¹ID
   * @param groupId åˆ†ç»„ID
   * @returns åˆ†ç»„æˆ–null
   */
  public async getGroupById(siteId: string, groupId: string): Promise<LiveGroup | null> {
    try {
      // ä»å†…å­˜ç¼“å­˜è·å?      const groups = this.groupCache.get(siteId);
      if (groups) {
        return groups.find(group => group.id === groupId) || null;
      }
      return null;
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to get group by ID ${groupId}: ${JSON.stringify(error)}`));
      return null;
    }
  }
  
  /**
   * ä¿å­˜é¢‘é“åˆ°æ”¶è—?   * @param siteId ç«™ç‚¹ID
   * @param channelId é¢‘é“ID
   * @returns æ˜¯å¦ä¿å­˜æˆåŠŸ
   */
  public async addChannelToFavorites(siteId: string, channelId: string): Promise<boolean> {
    try {
      // ç®€åŒ–å®ç°ï¼Œä»…æ›´æ–°å†…å­˜ç¼“å­?      if (this.channelCache.has(siteId)) {
        const channel = this.channelCache.get(siteId)!.get(channelId);
        if (channel) {
          channel.isFavorite = true;
          return true;
        }
      }
      return false;
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to add channel to favorites: ${JSON.stringify(error)}`));
      return false;
    }
  }
  
  /**
   * ä»æ”¶è—ä¸­ç§»é™¤é¢‘é“
   * @param siteId ç«™ç‚¹ID
   * @param channelId é¢‘é“ID
   * @returns æ˜¯å¦ç§»é™¤æˆåŠŸ
   */
  public async removeChannelFromFavorites(siteId: string, channelId: string): Promise<boolean> {
    try {
      // ç®€åŒ–å®ç°ï¼Œä»…æ›´æ–°å†…å­˜ç¼“å­?      if (this.channelCache.has(siteId)) {
        const channel = this.channelCache.get(siteId)!.get(channelId);
        if (channel) {
          channel.isFavorite = false;
          return true;
        }
      }
      return false;
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to remove channel from favorites: ${JSON.stringify(error)}`));
      return false;
    }
  }
  
  /**
   * è·å–æ”¶è—çš„é¢‘é“åˆ—è¡?   * @param siteId ç«™ç‚¹ID
   * @returns æ”¶è—çš„é¢‘é“åˆ—è¡?   */
  public async getFavoriteChannels(siteId: string): Promise<LiveChannel[]> {
    try {
      // ä»å†…å­˜ç¼“å­˜è·å?      if (this.channelCache.has(siteId)) {
        return Array.from(this.channelCache.get(siteId)!.values())
          .filter(channel => channel.isFavorite);
      }
      return [];
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to get favorite channels: ${JSON.stringify(error)}`));
      return [];
    }
  }
  
  /**
   * æ¸…é™¤æŒ‡å®šç«™ç‚¹çš„æ‰€æœ‰æ•°æ?   * @param siteId ç«™ç‚¹ID
   * @returns æ˜¯å¦æ¸…é™¤æˆåŠŸ
   */
  public async clearSiteData(siteId: string): Promise<boolean> {
    try {
      Logger.info(TAG, `Clearing all data for site ${siteId}`);
      
      // æ¸…ç©ºå†…å­˜ç¼“å­˜
      this.channelCache.delete(siteId);
      this.groupCache.delete(siteId);
      this.epgCache.delete(siteId);
      
      return true;
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to clear site data: ${JSON.stringify(error)}`));
      return false;
    }
  }
  
  /**
   * æ¸…é™¤æ‰€æœ‰æ•°æ?   * @returns æ˜¯å¦æ¸…é™¤æˆåŠŸ
   */
  public async clearAllData(): Promise<boolean> {
    try {
      Logger.info(TAG, 'Clearing all live data');
      
      // æ¸…ç©ºæ‰€æœ‰å†…å­˜ç¼“å­?      this.channelCache.clear();
      this.groupCache.clear();
      this.epgCache.clear();
      
      return true;
    } catch (error) {
      Logger.error(TAG, new Error(`Failed to clear all data: ${JSON.stringify(error)}`));
      return false;
    }
  }
  
  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   */
  public getCacheStats(): {
    totalChannels: number;
    totalGroups: number;
    totalEpgEntries: number;
  } {
    let totalChannels = 0;
    let totalGroups = 0;
    let totalEpgEntries = 0;
    
    // ç»Ÿè®¡å†…å­˜ç¼“å­˜
    for (const channelMap of this.channelCache.values()) {
      totalChannels += channelMap.size;
    }
    
    for (const groups of this.groupCache.values()) {
      totalGroups += groups.length;
    }
    
    for (const epgMap of this.epgCache.values()) {
      for (const epgItems of epgMap.values()) {
        totalEpgEntries += epgItems.length;
      }
    }
    
    return {
      totalChannels,
      totalGroups,
      totalEpgEntries
    };
  }
}
