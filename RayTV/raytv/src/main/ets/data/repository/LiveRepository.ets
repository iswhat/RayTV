// LiveRepository.ets - Áõ¥Êí≠ÂÜÖÂÆπÊï∞ÊçÆ‰ªìÂ∫ì
// Ë¥üË¥£Áõ¥Êí≠ÂÜÖÂÆπÁöÑÁºìÂ≠ò„ÄÅÁÆ°ÁêÜÂíåÊí≠ÊîæÂéÜÂè≤ËÆ∞ÂΩï

import { SQLiteHelper, QueryCondition, SortOption } from '../db/SQLiteHelper';
import { LIVE_CHANNEL_TABLE, LIVE_GROUP_TABLE, LIVE_PLAY_HISTORY_TABLE, EPG_TABLE } from '../db/TableSchema';
import {
  LiveChannel,
  LiveGroup,
  EpgItem,
  LiveStream
} from '../bean/Live';
import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';

const TAG = 'LiveRepository';

// ÁºìÂ≠òËøáÊúüÊó∂Èó¥ÔºàÊØ´ÁßíÔºâ
const CHANNEL_CACHE_EXPIRY = 7200000; // 2Â∞èÊó∂
const EPG_CACHE_EXPIRY = 3600000; // 1Â∞èÊó∂

// ÊâπÈáèÊìç‰ΩúÁöÑÊâπÊ¨°Â§ßÂ∞?
const BATCH_SIZE = 200;

export class LiveRepository {
  private static instance: LiveRepository;
  private sqliteHelper: SQLiteHelper;
  private storageUtil: StorageUtil;
  
  // ÂÜÖÂ≠òÁºìÂ≠ò
  private channelCache: Map<string, Map<string, LiveChannel>> = new Map(); // siteId -> channelId -> LiveChannel
  private groupCache: Map<string, LiveGroup[]> = new Map(); // siteId -> LiveGroup[]
  private epgCache: Map<string, Map<string, EpgItem[]>> = new Map(); // siteId -> channelId -> EpgItem[]
  
  private constructor() {
    this.sqliteHelper = SQLiteHelper.getInstance();
    this.storageUtil = StorageUtil.getInstance();
  }
  
  /**
   * Ëé∑ÂèñÁõ¥Êí≠‰ªìÂ∫ìÂçï‰æãÂÆû‰æã
   */
  public static getInstance(): LiveRepository {
    if (!LiveRepository.instance) {
      LiveRepository.instance = new LiveRepository();
    }
    return LiveRepository.instance;
  }
  
  /**
   * ÂàùÂßãÂåñÁõ¥Êí≠‰ªìÂ∫?
   */
  public async initialize(): Promise<void> {
    try {
      Logger.info(TAG, 'Initializing live repository');
      
      // È¢ÑÂä†ËΩΩÂ∏∏Áî®Êï∞ÊçÆÂà∞ÂÜÖÂ≠òÁºìÂ≠ò
      await this.preloadPopularSites();
      
      // Ê∏ÖÁêÜËøáÊúüÁºìÂ≠ò
      await this.clearExpiredCache();
      
      Logger.info(TAG, 'Live repository initialized successfully');
    } catch (error) {
      Logger.error(TAG, `Failed to initialize live repository: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * È¢ÑÂä†ËΩΩÂ∏∏Áî®Á´ôÁÇπÊï∞Êç?
   */
  private async preloadPopularSites(): Promise<void> {
    try {
      // ËøôÈáåÂèØ‰ª•È¢ÑÂä†ËΩΩÁî®Êà∑Â∏∏Áî®ÁöÑÂá†‰∏™Á´ôÁÇπÊï∞ÊçÆ
      // ÊöÇÊó∂‰∏∫Á©∫ÂÆûÁé∞ÔºåÂêéÁª≠ÂèØ‰ª•‰ªéÈÖçÁΩÆÊàñÁî®Êà∑Ë°å‰∏∫ÂàÜÊûêËé∑ÂèñÂ∏∏Áî®Á´ôÁÇ?
    } catch (error) {
      Logger.error(TAG, `Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error instanceof Error ? `Failed to preload popular sites: ${JSON.stringify(error : new Error(String(`Failed to preload popular sites: ${JSON.stringify(error)))))))}`);
    }
  }
  
  /**
   * ‰øùÂ≠òÁõ¥Êí≠ÂàÜÁªÑ
   * @param siteId Á´ôÁÇπID
   * @param groups ÂàÜÁªÑÂàóË°®
   * @returns ÊàêÂäü‰øùÂ≠òÁöÑÊï∞Èá?
   */
  public async saveLiveGroups(siteId: string, groups: LiveGroup[]): Promise<number> {
    if (!groups || groups.length === 0) {
      return 0;
    }
    
    try {
      Logger.debug(TAG, `Saving ${groups.length} live groups for site ${siteId}`);
      
      // ÂÖàÂà†Èô§ËØ•Á´ôÁÇπÁöÑÊâÄÊúâÂàÜÁª?
      await this.sqliteHelper.delete(LIVE_GROUP_TABLE.TABLE_NAME, [{
        column: LIVE_GROUP_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }]);
      
      // ÊâπÈáèÊèíÂÖ•Êñ∞ÂàÜÁª?
      const groupData = groups.map(group => ({
        [LIVE_GROUP_TABLE.COLUMNS.ID]: group.id,
        [LIVE_GROUP_TABLE.COLUMNS.SITE_ID]: siteId,
        [LIVE_GROUP_TABLE.COLUMNS.NAME]: group.name,
        [LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX]: group.orderIndex || 0,
        [LIVE_GROUP_TABLE.COLUMNS.ICON]: group.icon || '',
        [LIVE_GROUP_TABLE.COLUMNS.DATA]: JSON.stringify(group),
        [LIVE_GROUP_TABLE.COLUMNS.UPDATE_TIME]: Date.now()
      }));
      
      const result = await this.sqliteHelper.batchInsert(LIVE_GROUP_TABLE.TABLE_NAME, groupData);
      
      if (result.success) {
        // Êõ¥Êñ∞ÂÜÖÂ≠òÁºìÂ≠ò
        this.groupCache.set(siteId, groups);
      }
      
      return result.successCount;
    } catch (error) {
      Logger.error(TAG, `Failed to save live groups for site ${siteId}: ${JSON.stringify(error)}`);
      return 0;
    }
  }
  
  /**
   * Ëé∑ÂèñÁ´ôÁÇπÁöÑÊâÄÊúâÂàÜÁª?
   * @param siteId Á´ôÁÇπID
   * @returns ÂàÜÁªÑÂàóË°®
   */
  public async getLiveGroups(siteId: string): Promise<LiveGroup[]> {
    try {
      // ‰ºòÂÖà‰ªéÂÜÖÂ≠òÁºìÂ≠òËé∑Âè?
      if (this.groupCache.has(siteId)) {
        return this.groupCache.get(siteId)!;
      }
      
      // ‰ªéÊï∞ÊçÆÂ∫ìÊü•ËØ¢
      const conditions: QueryCondition[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.SITE_ID, value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       instanceof Error ? value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
       : new Error(String(value: siteId
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_GROUP_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
      )))))));
      
      const groups: LiveGroup[] = [];
      for (const record of records) {
        try {
          groups.push(JSON.parse(record[LIVE_GROUP_TABLE.COLUMNS.DATA]) as LiveGroup);
        } catch (e) {
          Logger.error(TAG, `Failed to parse live group data: ${JSON.stringify(e)}`);
        }
      }
      
      // Êõ¥Êñ∞ÂÜÖÂ≠òÁºìÂ≠ò
      this.groupCache.set(siteId, groups instanceof Error ? groups : new Error(String(groups instanceof Error ? groups instanceof Error ? groups : new Error(String(groups : new Error(String(groups instanceof Error ? groups : new Error(String(groups instanceof Error ? groups instanceof Error ? groups : new Error(String(groups instanceof Error ? groups instanceof Error ? groups : new Error(String(groups : new Error(String(groups instanceof Error ? groups : new Error(String(groups : new Error(String(groups instanceof Error ? groups : new Error(String(groups instanceof Error ? groups instanceof Error ? groups : new Error(String(groups : new Error(String(groups instanceof Error ? groups : new Error(String(groups)))))));
      
      return groups;
    } catch (error) {
      Logger.error(TAG, `Failed to get live groups for site ${siteId}: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * ‰øùÂ≠òÁõ¥Êí≠È¢ëÈÅì
   * @param siteId Á´ôÁÇπID
   * @param channels È¢ëÈÅìÂàóË°®
   * @returns ÊàêÂäü‰øùÂ≠òÁöÑÊï∞Èá?
   */
  public async saveLiveChannels(siteId: string, channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] : new Error(String(channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] : new Error(String(channels: LiveChannel[] : new Error(String(channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] : new Error(String(channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] : new Error(String(channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] : new Error(String(channels: LiveChannel[] : new Error(String(channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] : new Error(String(channels: LiveChannel[] : new Error(String(channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] : new Error(String(channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] : new Error(String(channels: LiveChannel[] : new Error(String(channels: LiveChannel[] instanceof Error ? channels: LiveChannel[] : new Error(String(channels: LiveChannel[]))))))): Promise<number> {
    if (!channels || channels.length === 0) {
      return 0;
    }
    
    let successCount = 0;
    
    try {
      Logger.debug(TAG, `Saving ${channels.length} live channels for site ${siteId}`);
      
      // ÂàÜÊâπÂ§ÑÁêÜ‰ª•ÈÅøÂÖçÊÄßËÉΩÈóÆÈ¢ò
      for (let i = 0; i < channels.length; i += BATCH_SIZE) {
        const batch = channels.slice(i, i + BATCH_SIZE);
        
        const channelData = batch.map(channel => ({
          [LIVE_CHANNEL_TABLE.COLUMNS.ID]: channel.id,
          [LIVE_CHANNEL_TABLE.COLUMNS.SITE_ID]: siteId,
          [LIVE_CHANNEL_TABLE.COLUMNS.GROUP_ID]: channel.groupId || '',
          [LIVE_CHANNEL_TABLE.COLUMNS.NAME]: channel.name,
          [LIVE_CHANNEL_TABLE.COLUMNS.NUMBER]: channel.number || '',
          [LIVE_CHANNEL_TABLE.COLUMNS.LOGO]: channel.logo || '',
          [LIVE_CHANNEL_TABLE.COLUMNS.PLAY_URL]: channel.playUrl || '',
          [LIVE_CHANNEL_TABLE.COLUMNS.STREAMS]: channel.streams ? JSON.stringify(channel.streams) : '[]',
          [LIVE_CHANNEL_TABLE.COLUMNS.TAGS]: channel.tags ? JSON.stringify(channel.tags) : '[]',
          [LIVE_CHANNEL_TABLE.COLUMNS.DATA]: JSON.stringify(channel),
          [LIVE_CHANNEL_TABLE.COLUMNS.ORDER_INDEX]: channel.orderIndex || 0,
          [LIVE_CHANNEL_TABLE.COLUMNS.UPDATE_TIME]: Date.now(),
          [LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME]: Date.now() + CHANNEL_CACHE_EXPIRY
        }));
        
        const result = await this.sqliteHelper.batchInsert(LIVE_CHANNEL_TABLE.TABLE_NAME, channelData);
        successCount += result.successCount;
      }
      
      // Êõ¥Êñ∞ÂÜÖÂ≠òÁºìÂ≠ò
      if (!this.channelCache.has(siteId)) {
        this.channelCache.set(siteId, new Map());
      }
      
      const siteChannelCache = this.channelCache.get(siteId)!;
      channels.forEach(channel => {
        siteChannelCache.set(channel.id, channel);
      });
      
      Logger.info(TAG, `Successfully saved ${successCount}/${channels.length} live channels for site ${siteId}`);
      return successCount;
    } catch (error) {
      Logger.error(TAG, `Failed to save live channels for site ${siteId}: ${JSON.stringify(error)}`);
      return successCount;
    }
  }
  
  /**
   * Ëé∑ÂèñÂàÜÁªÑ‰∏ãÁöÑÊâÄÊúâÈ¢ëÈÅ?
   * @param siteId Á´ôÁÇπID
   * @param groupId ÂàÜÁªÑID
   * @returns È¢ëÈÅìÂàóË°®
   */
  public async getChannelsByGroup(siteId: string, groupId: string instanceof Error ? groupId: string : new Error(String(groupId: string instanceof Error ? groupId: string instanceof Error ? groupId: string : new Error(String(groupId: string : new Error(String(groupId: string instanceof Error ? groupId: string : new Error(String(groupId: string instanceof Error ? groupId: string instanceof Error ? groupId: string : new Error(String(groupId: string instanceof Error ? groupId: string instanceof Error ? groupId: string : new Error(String(groupId: string : new Error(String(groupId: string instanceof Error ? groupId: string : new Error(String(groupId: string : new Error(String(groupId: string instanceof Error ? groupId: string : new Error(String(groupId: string instanceof Error ? groupId: string instanceof Error ? groupId: string : new Error(String(groupId: string : new Error(String(groupId: string instanceof Error ? groupId: string : new Error(String(groupId: string))))))): Promise<LiveChannel[]> {
    try {
      const conditions: QueryCondition[] = [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }, {
        column: LIVE_CHANNEL_TABLE.COLUMNS.GROUP_ID,
        value: groupId
      }, {
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now(),
        operator: '>'
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_CHANNEL_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
      );
      
      const channels: LiveChannel[] = [];
      for (const record of records) {
        try {
          channels.push(JSON.parse(record[LIVE_CHANNEL_TABLE.COLUMNS.DATA]) as LiveChannel);
        } catch (e) {
          Logger.error(TAG, `Failed to parse live channel data: ${JSON.stringify(e)}`);
        }
      }
      
      return channels;
    } catch (error) {
      Logger.error(TAG, `Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error instanceof Error ? `Failed to get channels by group ${groupId}: ${JSON.stringify(error : new Error(String(`Failed to get channels by group ${groupId}: ${JSON.stringify(error)))))))}`);
      return [];
    }
  }
  
  /**
   * Ëé∑ÂèñÁ´ôÁÇπÁöÑÊâÄÊúâÈ¢ëÈÅ?
   * @param siteId Á´ôÁÇπID
   * @returns È¢ëÈÅìÂàóË°®
   */
  public async getAllChannels(siteId: string): Promise<LiveChannel[]> {
    try {
      const conditions: QueryCondition[] = [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }, {
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now(),
        operator: '>'
      }];
      
      const sortOptions: SortOption[] = [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.GROUP_ID,
        order: 'ASC'
      }, {
        column: LIVE_CHANNEL_TABLE.COLUMNS.ORDER_INDEX,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_CHANNEL_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
      );
      
      const channels: LiveChannel[] = [];
      for (const record of records) {
        try {
          channels.push(JSON.parse(record[LIVE_CHANNEL_TABLE.COLUMNS.DATA]) as LiveChannel);
        } catch (e) {
          Logger.error(TAG, `Failed to parse live channel data: ${JSON.stringify(e)}`);
        }
      }
      
      return channels;
    } catch (error) {
      Logger.error(TAG, `Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error instanceof Error ? `Failed to get all channels for site ${siteId}: ${JSON.stringify(error : new Error(String(`Failed to get all channels for site ${siteId}: ${JSON.stringify(error)))))))}`);
      return [];
    }
  }
  
  /**
   * Ëé∑ÂèñÂçï‰∏™È¢ëÈÅì‰ø°ÊÅØ
   * @param siteId Á´ôÁÇπID
   * @param channelId È¢ëÈÅìID
   * @returns È¢ëÈÅì‰ø°ÊÅØÊàñnull
   */
  public async getChannelById(siteId: string, channelId: string): Promise<LiveChannel | null> {
    try {
      // ‰ºòÂÖà‰ªéÂÜÖÂ≠òÁºìÂ≠òËé∑Âè?
      if (this.channelCache.has(siteId)) {
        const siteChannelCache = this.channelCache.get(siteId)!;
        if (siteChannelCache.has(channelId)) {
          return siteChannelCache.get(channelId)!;
        }
      }
      
      // ‰ªéÊï∞ÊçÆÂ∫ìÊü•ËØ¢
      const conditions: QueryCondition[] = [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }, {
        column: LIVE_CHANNEL_TABLE.COLUMNS.ID,
        value: channelId
      }];
      
      const record = await this.sqliteHelper.getFirst(
        LIVE_CHANNEL_TABLE.TABLE_NAME,
        ['*'],
        conditions
      );
      
      if (!record) {
        return null;
      }
      
      // Ê£ÄÊü•ÊòØÂê¶ËøáÊú?
      const expiryTime = record[LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME];
      if (expiryTime < Date.now()) {
        Logger.debug(TAG, `Live channel ${channelId} expired, removing from cache`);
        await this.removeChannel(siteId, channelId);
        return null;
      }
      
      try {
        const channel = JSON.parse(record[LIVE_CHANNEL_TABLE.COLUMNS.DATA]) as LiveChannel;
        
        // Êõ¥Êñ∞ÂÜÖÂ≠òÁºìÂ≠ò
        if (!this.channelCache.has(siteId)) {
          this.channelCache.set(siteId, new Map());
        }
        this.channelCache.get(siteId)!.set(channelId, channel);
        
        return channel;
      } catch (e) {
        Logger.error(TAG, `Failed to parse live channel data: ${JSON.stringify(e)}`);
        return null;
      }
    } catch (error) {
      Logger.error(TAG, `Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error instanceof Error ? `Failed to get channel by ID ${channelId}: ${JSON.stringify(error : new Error(String(`Failed to get channel by ID ${channelId}: ${JSON.stringify(error)))))))}`);
      return null;
    }
  }
  
  /**
   * ÊêúÁ¥¢Áõ¥Êí≠È¢ëÈÅì
   * @param keyword ÊêúÁ¥¢ÂÖ≥ÈîÆËØ?
   * @param siteId Á´ôÁÇπIDÔºàÂèØÈÄâÔºâ
   * @returns ÊêúÁ¥¢ÁªìÊûú
   */
  public async searchChannels(keyword: string, siteId?: string): Promise<LiveChannel[]> {
    try {
      const conditions: QueryCondition[] = [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.NAME,
        value: `%${keyword}%`,
        operator: 'LIKE'
      }, {
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now(),
        operator: '>'
      }];
      
      if (siteId) {
        conditions.push({
          column: LIVE_CHANNEL_TABLE.COLUMNS.SITE_ID,
          value: siteId
        });
      }
      
      const records = await this.sqliteHelper.query(
        LIVE_CHANNEL_TABLE.TABLE_NAME,
        ['*'],
        conditions
      );
      
      const channels: LiveChannel[] = [];
      for (const record of records) {
        try {
          channels.push(JSON.parse(record[LIVE_CHANNEL_TABLE.COLUMNS.DATA]) as LiveChannel);
        } catch (e) {
          Logger.error(TAG, `Failed to parse live channel data: ${JSON.stringify(e)}`);
        }
      }
      
      return channels;
    } catch (error) {
      Logger.error(TAG, `Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error instanceof Error ? `Failed to search channels: ${JSON.stringify(error : new Error(String(`Failed to search channels: ${JSON.stringify(error)))))))}`);
      return [];
    }
  }
  
  /**
   * ‰øùÂ≠òEPGÊï∞ÊçÆ
   * @param siteId Á´ôÁÇπID
   * @param channelId È¢ëÈÅìID
   * @param epgItems EPGËäÇÁõÆÂàóË°®
   * @returns ÊòØÂê¶‰øùÂ≠òÊàêÂäü
   */
  public async saveEpgData(siteId: string, channelId: string, epgItems: EpgItem[]): Promise<boolean> {
    try {
      Logger.debug(TAG, `Saving ${epgItems.length} EPG items for channel ${channelId}`);
      
      // ÂÖàÂà†Èô§ËØ•È¢ëÈÅìÁöÑÊâÄÊúâEPGÊï∞ÊçÆ
      await this.sqliteHelper.delete(EPG_TABLE.TABLE_NAME, [{
        column: EPG_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }, {
        column: EPG_TABLE.COLUMNS.CHANNEL_ID,
        value: channelId
      }]);
      
      if (epgItems.length === 0) {
        return true;
      }
      
      // ÊâπÈáèÊèíÂÖ•EPGÊï∞ÊçÆ
      const epgData = epgItems.map(item => ({
        [EPG_TABLE.COLUMNS.ID]: `${siteId}_${channelId}_${item.startTime}`,
        [EPG_TABLE.COLUMNS.SITE_ID]: siteId,
        [EPG_TABLE.COLUMNS.CHANNEL_ID]: channelId,
        [EPG_TABLE.COLUMNS.TITLE]: item.title,
        [EPG_TABLE.COLUMNS.DESCRIPTION]: item.description || '',
        [EPG_TABLE.COLUMNS.START_TIME]: item.startTime,
        [EPG_TABLE.COLUMNS.END_TIME]: item.endTime,
        [EPG_TABLE.COLUMNS.POSTER]: item.poster || '',
        [EPG_TABLE.COLUMNS.CATEGORY]: item.category || '',
        [EPG_TABLE.COLUMNS.DATA]: JSON.stringify(item),
        [EPG_TABLE.COLUMNS.EXPIRY_TIME]: Date.now() + EPG_CACHE_EXPIRY
      }));
      
      const result = await this.sqliteHelper.batchInsert(EPG_TABLE.TABLE_NAME, epgData);
      
      if (result.success) {
        // Êõ¥Êñ∞ÂÜÖÂ≠òÁºìÂ≠ò
        if (!this.epgCache.has(siteId)) {
          this.epgCache.set(siteId, new Map());
        }
        this.epgCache.get(siteId)!.set(channelId, epgItems);
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to save EPG data for channel ${channelId}: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * Ëé∑ÂèñÈ¢ëÈÅìÁöÑEPGÊï∞ÊçÆ
   * @param siteId Á´ôÁÇπID
   * @param channelId È¢ëÈÅìID
   * @param startTime ÂºÄÂßãÊó∂Èó?
   * @param endTime ÁªìÊùüÊó∂Èó¥
   * @returns EPGËäÇÁõÆÂàóË°®
   */
  public async getEpgData(siteId: string, channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number instanceof Error ? channelId: string, startTime?: number, endTime?: number : new Error(String(channelId: string, startTime?: number, endTime?: number))))))): Promise<EpgItem[]> {
    try {
      // ‰ºòÂÖà‰ªéÂÜÖÂ≠òÁºìÂ≠òËé∑Âè?
      if (this.epgCache.has(siteId) && this.epgCache.get(siteId)!.has(channelId)) {
        const cachedEpg = this.epgCache.get(siteId)!.get(channelId)!;
        
        // Â¶ÇÊûúÊåáÂÆö‰∫ÜÊó∂Èó¥ËåÉÂõ¥ÔºåËøõË°åËøáÊª§
        if (startTime !== undefined && endTime !== undefined) {
          return cachedEpg.filter(item => 
            item.startTime < endTime && item.endTime > startTime
          );
        }
        
        return cachedEpg;
      }
      
      // ‰ªéÊï∞ÊçÆÂ∫ìÊü•ËØ¢
      const conditions: QueryCondition[] = [{
        column: EPG_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }, {
        column: EPG_TABLE.COLUMNS.CHANNEL_ID,
        value: channelId
      }, {
        column: EPG_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now(),
        operator: '>'
      }];
      
      // Ê∑ªÂä†Êó∂Èó¥ËåÉÂõ¥ËøáÊª§
      if (startTime !== undefined && endTime !== undefined) {
        conditions.push({
          column: EPG_TABLE.COLUMNS.START_TIME,
          value: endTime,
          operator: '<'
        });
        conditions.push({
          column: EPG_TABLE.COLUMNS.END_TIME,
          value: startTime,
          operator: '>'
        });
      }
      
      const sortOptions: SortOption[] = [{
        column: EPG_TABLE.COLUMNS.START_TIME,
        order: 'ASC'
      }];
      
      const records = await this.sqliteHelper.query(
        EPG_TABLE.TABLE_NAME,
        ['*'],
        conditions,
        sortOptions
      );
      
      const epgItems: EpgItem[] = [];
      for (const record of records) {
        try {
          epgItems.push(JSON.parse(record[EPG_TABLE.COLUMNS.DATA]) as EpgItem);
        } catch (e) {
          Logger.error(TAG, `Failed to parse EPG item data: ${JSON.stringify(e)}`);
        }
      }
      
      // Êõ¥Êñ∞ÂÜÖÂ≠òÁºìÂ≠òÔºàÂè™ÁºìÂ≠òÂÆåÊï¥ÂàóË°®Ôºå‰∏çÁºìÂ≠òËøáÊª§ÂêéÁöÑÔº?
      if (startTime === undefined && endTime === undefined) {
        if (!this.epgCache.has(siteId)) {
          this.epgCache.set(siteId, new Map( instanceof Error ? new Map( : new Error(String(new Map( instanceof Error ? new Map( instanceof Error ? new Map( : new Error(String(new Map( : new Error(String(new Map( instanceof Error ? new Map( : new Error(String(new Map( instanceof Error ? new Map( instanceof Error ? new Map( : new Error(String(new Map( instanceof Error ? new Map( instanceof Error ? new Map( : new Error(String(new Map( : new Error(String(new Map( instanceof Error ? new Map( : new Error(String(new Map( : new Error(String(new Map( instanceof Error ? new Map( : new Error(String(new Map( instanceof Error ? new Map( instanceof Error ? new Map( : new Error(String(new Map( : new Error(String(new Map( instanceof Error ? new Map( : new Error(String(new Map())))))));
        }
        this.epgCache.get(siteId)!.set(channelId, epgItems);
      }
      
      return epgItems;
    } catch (error) {
      Logger.error(TAG, `Failed to get EPG data for channel ${channelId}: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * Ëé∑ÂèñÂΩìÂâçÊ≠£Âú®Êí≠ÊîæÁöÑEPGËäÇÁõÆ
   * @param siteId Á´ôÁÇπID
   * @param channelId È¢ëÈÅìID
   * @returns ÂΩìÂâçEPGËäÇÁõÆÊàñnull
   */
  public async getCurrentEpgItem(siteId: string, channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string))))))): Promise<EpgItem | null> {
    try {
      const now = Date.now();
      const epgItems = await this.getEpgData(siteId, channelId, now - 3600000, now + 3600000);
      
      // Êü•ÊâæÂΩìÂâçÊó∂Èó¥Âú®Êí≠ÊîæÁöÑËäÇÁõÆ
      return epgItems.find(item => 
        item.startTime <= now && item.endTime > now
      ) || null;
    } catch (error) {
      Logger.error(TAG, `Failed to get current EPG item for channel ${channelId}: ${JSON.stringify(error)}`);
      return null;
    }
  }
  
  /**
   * ‰øùÂ≠òÊí≠ÊîæÂéÜÂè≤
   * @param siteId Á´ôÁÇπID
   * @param channelId È¢ëÈÅìID
   * @param channelName È¢ëÈÅìÂêçÁß∞
   * @param logo È¢ëÈÅìLogo
   * @returns ÊòØÂê¶‰øùÂ≠òÊàêÂäü
   */
  public async savePlayHistory(siteId: string, channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string instanceof Error ? channelId: string, channelName: string, logo: string : new Error(String(channelId: string, channelName: string, logo: string))))))): Promise<boolean> {
    try {
      Logger.debug(TAG, `Saving play history for channel ${channelName}`);
      
      const historyData: Record<string, string | number | boolean | null> = { ... };
      
      // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®ÂéÜÂè≤ËÆ∞ÂΩï
      const conditions: QueryCondition[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }, {
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.CHANNEL_ID,
        value: channelId
      }];
      
      const exists = await this.sqliteHelper.exists(LIVE_PLAY_HISTORY_TABLE.TABLE_NAME, conditions);
      
      if (exists) {
        // Êõ¥Êñ∞Áé∞ÊúâÂéÜÂè≤ËÆ∞ÂΩï
        const existingRecord = await this.sqliteHelper.getFirst(
          LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
          [LIVE_PLAY_HISTORY_TABLE.COLUMNS.PLAY_COUNT],
          conditions
        );
        
        if (existingRecord) {
          historyData[LIVE_PLAY_HISTORY_TABLE.COLUMNS.PLAY_COUNT] = 
            (existingRecord[LIVE_PLAY_HISTORY_TABLE.COLUMNS.PLAY_COUNT] || 0) + 1;
        }
        
        return (await this.sqliteHelper.update(LIVE_PLAY_HISTORY_TABLE.TABLE_NAME, historyData, conditions)).success;
      } else {
        // ÊèíÂÖ•Êñ∞ÂéÜÂè≤ËÆ∞ÂΩ?
        return (await this.sqliteHelper.insert(LIVE_PLAY_HISTORY_TABLE.TABLE_NAME, historyData)).success;
      }
    } catch (error) {
      Logger.error(TAG, `Failed to save play history: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * Ëé∑ÂèñÊí≠ÊîæÂéÜÂè≤
   * @param limit ÈôêÂà∂Êï∞Èáè
   * @returns Êí≠ÊîæÂéÜÂè≤ÂàóË°®
   */
  public async getPlayHistory(limit: number = 50): Promise<Record<string, unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       instanceof Error ? unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
       : new Error(String(unknown>[]> {
    try {
      const sortOptions: SortOption[] = [{
        column: LIVE_PLAY_HISTORY_TABLE.COLUMNS.LAST_PLAY_TIME,
        order: 'DESC'
      }];
      
      const records = await this.sqliteHelper.query(
        LIVE_PLAY_HISTORY_TABLE.TABLE_NAME,
        ['*'],
        undefined,
        sortOptions,
        limit
      )))))));
      
      return records;
    } catch (error) {
      Logger.error(TAG, `Failed to get play history: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * ÁßªÈô§È¢ëÈÅì
   * @param siteId Á´ôÁÇπID
   * @param channelId È¢ëÈÅìID
   * @returns ÊòØÂê¶ÁßªÈô§ÊàêÂäü
   */
  public async removeChannel(siteId: string, channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string : new Error(String(channelId: string instanceof Error ? channelId: string : new Error(String(channelId: string))))))): Promise<boolean> {
    try {
      const conditions: QueryCondition[] = [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }, {
        column: LIVE_CHANNEL_TABLE.COLUMNS.ID,
        value: channelId
      }];
      
      const result = await this.sqliteHelper.delete(LIVE_CHANNEL_TABLE.TABLE_NAME, conditions);
      
      if (result.success) {
        // ‰ªéÂÜÖÂ≠òÁºìÂ≠òÁßªÈô?
        if (this.channelCache.has(siteId)) {
          this.channelCache.get(siteId)!.delete(channelId);
        }
        
        // ÂêåÊó∂Âà†Èô§Áõ∏ÂÖ≥ÁöÑEPGÊï∞ÊçÆ
        await this.sqliteHelper.delete(EPG_TABLE.TABLE_NAME, [{
          column: EPG_TABLE.COLUMNS.SITE_ID,
          value: siteId
        }, {
          column: EPG_TABLE.COLUMNS.CHANNEL_ID,
          value: channelId
        }]);
        
        if (this.epgCache.has(siteId)) {
          this.epgCache.get(siteId)!.delete(channelId);
        }
      }
      
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to remove channel ${channelId}: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * Ê∏ÖÈô§ËøáÊúüÁºìÂ≠ò
   */
  public async clearExpiredCache(): Promise<void> {
    try {
      // Ê∏ÖÈô§ËøáÊúüÁöÑÈ¢ëÈÅìÁºìÂ≠?
      await this.sqliteHelper.delete(LIVE_CHANNEL_TABLE.TABLE_NAME, [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( instanceof Error ? [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now( : new Error(String([{
        column: LIVE_CHANNEL_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now())))))),
        operator: '<'
      }]);
      
      // Ê∏ÖÈô§ËøáÊúüÁöÑEPGÁºìÂ≠ò
      await this.sqliteHelper.delete(EPG_TABLE.TABLE_NAME, [{
        column: EPG_TABLE.COLUMNS.EXPIRY_TIME,
        value: Date.now(),
        operator: '<'
      }]);
      
      // Ê∏ÖÈô§Áõ∏ÂÖ≥ÁöÑÂÜÖÂ≠òÁºìÂ≠?
      this.invalidateMemoryCache();
      
      Logger.info(TAG, 'Expired live cache cleared');
    } catch (error) {
      Logger.error(TAG, `Failed to clear expired cache: ${JSON.stringify(error)}`);
    }
  }
  
  /**
   * Ê∏ÖÈô§Á´ôÁÇπÁöÑÊâÄÊúâÊï∞Êç?
   * @param siteId Á´ôÁÇπID
   * @returns ÊòØÂê¶Ê∏ÖÈô§ÊàêÂäü
   */
  public async clearSiteData(siteId: string): Promise<boolean> {
    try {
      Logger.warning(TAG, `Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}` instanceof Error ? `Clearing all data for site ${siteId}` : new Error(String(`Clearing all data for site ${siteId}`)))))));
      
      // Âà†Èô§ÂàÜÁªÑ
      await this.sqliteHelper.delete(LIVE_GROUP_TABLE.TABLE_NAME, [{
        column: LIVE_GROUP_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }]);
      
      // Âà†Èô§È¢ëÈÅì
      await this.sqliteHelper.delete(LIVE_CHANNEL_TABLE.TABLE_NAME, [{
        column: LIVE_CHANNEL_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }]);
      
      // Âà†Èô§EPGÊï∞ÊçÆ
      await this.sqliteHelper.delete(EPG_TABLE.TABLE_NAME, [{
        column: EPG_TABLE.COLUMNS.SITE_ID,
        value: siteId
      }]);
      
      // Ê∏ÖÈô§ÂÜÖÂ≠òÁºìÂ≠ò
      this.groupCache.delete(siteId);
      this.channelCache.delete(siteId);
      this.epgCache.delete(siteId);
      
      Logger.info(TAG, `All data for site ${siteId} cleared`);
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to clear site data for ${siteId}: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * Ê∏ÖÈô§ÊâÄÊúâÁºìÂ≠òÊï∞Êç?
   * @returns ÊòØÂê¶Ê∏ÖÈô§ÊàêÂäü
   */
  public async clearAllCache(): Promise<boolean> {
    try {
      Logger.warning(TAG, 'Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' : new Error(String('Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' : new Error(String('Clearing all live cache data' : new Error(String('Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' : new Error(String('Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' : new Error(String('Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' : new Error(String('Clearing all live cache data' : new Error(String('Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' : new Error(String('Clearing all live cache data' : new Error(String('Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' : new Error(String('Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' : new Error(String('Clearing all live cache data' : new Error(String('Clearing all live cache data' instanceof Error ? 'Clearing all live cache data' : new Error(String('Clearing all live cache data')))))));
      
      // Âà†Èô§ÊâÄÊúâÁõ∏ÂÖ≥Ë°®Êï∞ÊçÆ
      await this.sqliteHelper.delete(LIVE_GROUP_TABLE.TABLE_NAME);
      await this.sqliteHelper.delete(LIVE_CHANNEL_TABLE.TABLE_NAME);
      await this.sqliteHelper.delete(EPG_TABLE.TABLE_NAME);
      
      // Ê∏ÖÈô§ÂÜÖÂ≠òÁºìÂ≠ò
      this.invalidateMemoryCache();
      
      Logger.info(TAG, 'All live cache data cleared');
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to clear all cache: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * Ê∏ÖÈô§Êí≠ÊîæÂéÜÂè≤
   * @returns ÊòØÂê¶Ê∏ÖÈô§ÊàêÂäü
   */
  public async clearPlayHistory(): Promise<boolean> {
    try {
      const result = await this.sqliteHelper.delete(LIVE_PLAY_HISTORY_TABLE.TABLE_NAME);
      
      Logger.info(TAG, `Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records instanceof Error ? `Play history cleared (${result.affectedRows} records : new Error(String(`Play history cleared (${result.affectedRows} records)))))))`);
      return result.success;
    } catch (error) {
      Logger.error(TAG, `Failed to clear play history: ${JSON.stringify(error)}`);
      return false;
    }
  }
  
  /**
   * ‰ΩøÂÜÖÂ≠òÁºìÂ≠òÂ§±Êï?
   */
  public invalidateMemoryCache(): void {
    this.channelCache.clear();
    this.groupCache.clear();
    this.epgCache.clear();
    
    Logger.debug(TAG, 'Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' : new Error(String('Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' : new Error(String('Live memory cache invalidated' : new Error(String('Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' : new Error(String('Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' : new Error(String('Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' : new Error(String('Live memory cache invalidated' : new Error(String('Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' : new Error(String('Live memory cache invalidated' : new Error(String('Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' : new Error(String('Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' : new Error(String('Live memory cache invalidated' : new Error(String('Live memory cache invalidated' instanceof Error ? 'Live memory cache invalidated' : new Error(String('Live memory cache invalidated')))))));
  }
  
  /**
   * Ëé∑ÂèñÁºìÂ≠òÁªüËÆ°‰ø°ÊÅØ
   */
  public async getCacheStats(): Promise<{
    totalChannels: number;
    totalGroups: number;
    totalEpgItems: number;
    totalSites: number;
  }> {
    try {
      // Ëé∑ÂèñÁ´ôÁÇπÊï∞Èáè
      const sitesResult = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['DISTINCT ' + LIVE_GROUP_TABLE.COLUMNS.SITE_ID]
      );
      const totalSites = sitesResult.length;
      
      // Ëé∑ÂèñÈ¢ëÈÅìÊÄªÊï∞
      const channelsResult = await this.sqliteHelper.query(
        LIVE_CHANNEL_TABLE.TABLE_NAME,
        ['COUNT(*) as count']
      );
      const totalChannels = channelsResult && channelsResult.length > 0 ? Number(channelsResult[0].count) : 0;
      
      // Ëé∑ÂèñÂàÜÁªÑÊÄªÊï∞
      const groupsResult = await this.sqliteHelper.query(
        LIVE_GROUP_TABLE.TABLE_NAME,
        ['COUNT(*) as count']
      );
      const totalGroups = groupsResult && groupsResult.length > 0 ? Number(groupsResult[0].count) : 0;
      
      // Ëé∑ÂèñEPGÊù°ÁõÆÊÄªÊï∞
      const epgResult = await this.sqliteHelper.query(
        EPG_TABLE.TABLE_NAME,
        ['COUNT(*) as count']
      );
      const totalEpgItems = epgResult && epgResult.length > 0 ? Number(epgResult[0].count) : 0;
      
      return {
        totalChannels,
        totalGroups,
        totalEpgItems,
        totalSites
      };
    } catch (error) {
      Logger.error(TAG, `Failed to get cache stats: ${JSON.stringify(error)}`);
      return {
        totalChannels: 0,
        totalGroups: 0,
        totalEpgItems: 0,
        totalSites: 0
      };
    }
  }
}


