// DefaultNetworkRepository - ÁΩëÁªúÊúçÂä°ÈªòËÆ§ÂÆûÁé∞Á±?import Logger from '../../common/util/Logger';
import JsonUtil from '../../common/util/JsonUtil';
import NetworkUtil from '../../common/util/NetworkUtil';
import StorageUtil from '../../common/util/StorageUtil';
import http from '@ohos.net.http';
import NetworkRepository, {
  NetworkResult,
  NetworkConfig,
  SearchParams,
  PaginatedResponse,
  VideoSourceInfo,
  ChapterInfo,
  LiveChannelInfo,
  ParserInfo
} from './NetworkRepository';
import Movie from '../model/Movie';
import SearchResult, { ResultType } from '../model/SearchResult';
import { RequestConfig, Response } from '../../common/util/NetworkUtil';
import { getParserService } from '../../service/parser';

const TAG = 'DefaultNetworkRepository';
const DEFAULT_CACHE_KEY_PREFIX = 'network_cache_';
const DEFAULT_CACHE_EXPIRY = 3600000; // ÈªòËÆ§ÁºìÂ≠ò1Â∞èÊó∂

/**
 * ÁΩëÁªú‰ªìÂ∫ìÈªòËÆ§ÂÆûÁé∞Á±? * ÂÆûÁé∞‰∫ÜNetworkRepositoryÊé•Âè£ÔºåÊèê‰æõÂü∫‰∫éHTTPËØ∑Ê±ÇÁöÑÁΩëÁªúÊúçÂä°ÂäüËÉ? */
export default class DefaultNetworkRepository implements NetworkRepository {
  private config: NetworkConfig;
  private requestMap: Map<string, http.HttpRequest> = new Map();

  /**
   * ÊûÑÈÄ†ÂáΩÊï?   */
  constructor() {
    // ÈªòËÆ§ÈÖçÁΩÆ
    this.config = {
      baseUrl: '',
      timeout: 30000,
      retryCount: 3,
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'RayTV/1.0 HarmonyOS'
      },
      cacheEnabled: true,
      cacheExpiry: DEFAULT_CACHE_EXPIRY
    };
  }

  /**
 * ÂàùÂßãÂåñÁΩëÁªúÊúçÂä? * @param config ÁΩëÁªúÈÖçÁΩÆÂØπË±°ÔºåÂåÖÂê´Âü∫Á°ÄURL„ÄÅË∂ÖÊó∂Êó∂Èó¥„ÄÅÈáçËØïÊ¨°Êï∞Á≠â
 * @returns ÂàùÂßãÂåñÁªìÊûúÔºåÊàêÂäüÊàñÂ§±Ë¥•‰ø°ÊÅ? */
async initialize(config: NetworkConfig): Promise<NetworkResult<void>> {
    try {
      Logger.info(TAG, 'Initializing network repository...');
      
      // ÂêàÂπ∂ÈÖçÁΩÆ
      this.config = {
        baseUrl: config.baseUrl !== undefined ? config.baseUrl : this.config.baseUrl,
        timeout: config.timeout !== undefined ? config.timeout : this.config.timeout,
        retryCount: config.retryCount !== undefined ? config.retryCount : this.config.retryCount,
        headers: config.headers !== undefined ? config.headers : this.config.headers,
        cacheEnabled: config.cacheEnabled !== undefined ? config.cacheEnabled : this.config.cacheEnabled,
        cacheExpiry: config.cacheExpiry !== undefined ? config.cacheExpiry : this.config.cacheExpiry
      };
      
      // È™åËØÅÂøÖË¶ÅÈÖçÁΩÆ
      if (!this.config.baseUrl) {
        throw new Error('Base URL is required');
      }

      // ÊµãËØïËøûÊé•
      await this.testConnection();
      
      Logger.info(TAG, 'Network repository initialized successfully');
      return {
        success: true
      };
    } catch (error) {
      Logger.error(TAG, `Failed to initialize network repository`, error  as Error);
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'Network repository initialization failed'
      };
    }
  }

  /**
   * ËÆæÁΩÆÁΩëÁªúÈÖçÁΩÆ
   */
  setConfig(config: Partial<NetworkConfig>): void {
    this.config = {
      baseUrl: config.baseUrl !== undefined ? config.baseUrl : this.config.baseUrl,
      timeout: config.timeout !== undefined ? config.timeout : this.config.timeout,
      retryCount: config.retryCount !== undefined ? config.retryCount : this.config.retryCount,
      headers: config.headers !== undefined ? config.headers : this.config.headers,
      cacheEnabled: config.cacheEnabled !== undefined ? config.cacheEnabled : this.config.cacheEnabled,
      cacheExpiry: config.cacheExpiry !== undefined ? config.cacheExpiry : this.config.cacheExpiry
    };
    Logger.info(TAG, 'Network config updated');
  }

  /**
   * Ëé∑ÂèñÂΩìÂâçÁΩëÁªúÈÖçÁΩÆ
   */
  getConfig(): NetworkConfig {
    return {
      baseUrl: this.config.baseUrl,
      timeout: this.config.timeout,
      retryCount: this.config.retryCount,
      headers: this.config.headers,
      cacheEnabled: this.config.cacheEnabled,
      cacheExpiry: this.config.cacheExpiry
    };
  }

  /**
   * ÊµãËØïËøûÊé•
   */
  private async testConnection(): Promise<void> {
    try {
      // ÂèëÈÄÅ‰∏Ä‰∏™ÁÆÄÂçïÁöÑGETËØ∑Ê±ÇÊù•ÊµãËØïËøûÊé?      const testUrl = `${this.config.baseUrl}/api/test`;
      const response = await NetworkUtil.request<Record<string, string | number | boolean | null>>({ 
        url: testUrl,
        method: 'GET',
        timeout: this.config.timeout
      });
      
      // Ê£ÄÊü•ÂìçÂ∫îÁä∂ÊÄÅÁ†Å
      if (response.status < 200 || response.status >= 300) {
        throw new Error(`Connection test failed: HTTP ${response.status}`);
      }
    } catch (error) {
      Logger.warn(TAG, `Connection test failed, continuing anyway: ${error instanceof Error ? error.message : String(error)}`);
      // Âç≥‰ΩøÊµãËØïÂ§±Ë¥•‰πüÁªßÁª≠ÂàùÂßãÂåñÔºåÂõ†‰∏∫Êüê‰∫õAPIÂèØËÉΩ‰∏çÊèê‰æõÊµãËØïÁ´ØÁÇ?    }
  }

  /**
   * ÁîüÊàêËØ∑Ê±ÇID
   */
  private generateRequestId(url: string, method: string): string {
    return `${method}_${url}_${Date.now()}`;
  }

  /**
 * ÂàõÂª∫ËØ∑Ê±ÇÈÖçÁΩÆ
 * @param url ËØ∑Ê±ÇURLÔºåÂèØ‰ª•ÊòØÁõ∏ÂØπË∑ØÂæÑÊàñÁªùÂØπURL
 * @param method HTTPÊñπÊ≥ï (GET, POST, PUT, DELETEÁ≠?
 * @param data ËØ∑Ê±Ç‰ΩìÊï∞Êç? * @param params URLÊü•ËØ¢ÂèÇÊï∞
 * @param customHeaders Ëá™ÂÆö‰πâËØ∑Ê±ÇÂ§¥
 * @returns ÊûÑÂª∫Â•ΩÁöÑËØ∑Ê±ÇÈÖçÁΩÆÂØπË±°
 */
private createRequestConfig(
    url: string,
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD',
    data?: Record<string, string | number | boolean | null>,
    params?: Record<string, string | number | boolean | null>,
    customHeaders?: Record<string, string>
  ): RequestConfig {
    const requestUrl = url.startsWith('http') ? url : `${this.config.baseUrl}${url}`;
    // ÂêàÂπ∂headers
    const headers: Record<string, string> = {};
    
    // Â§çÂà∂ÈªòËÆ§headers
    if (this.config.headers) {
      for (const [key, value] of Object.entries(this.config.headers)) {
        headers[key] = value;
      }
    }
    
    // Â§çÂà∂Ëá™ÂÆö‰πâheadersÔºàË¶ÜÁõñÈªòËÆ§ÂÄºÔºâ
    if (customHeaders) {
      for (const [key, value] of Object.entries(customHeaders)) {
        headers[key] = value;
      }
    }
    
    // Â§ÑÁêÜËØ∑Ê±Ç‰ΩìÁ±ªÂû?    if (data && headers['Content-Type'] === 'application/json') {
      data = JsonUtil.stringify(data);
    }

    // ËøáÊª§Êéâparams‰∏≠ÁöÑnullÂÄºÔºåÁ°Æ‰øùÁ¨¶ÂêàRequestConfigÁöÑÁ±ªÂûãË¶ÅÊ±?    const filteredParams: Record<string, string | number | boolean | string[]> = {};
    if (params) {
      for (const [key, value] of Object.entries(params)) {
        if (value !== null) {
          filteredParams[key] = value as string | number | boolean | string[];
        }
      }
    }

    return {
      url: requestUrl,
      method,
      data,
      params: filteredParams,
      headers,
      timeout: this.config.timeout,
      retryCount: this.config.retryCount
    };
  }

  /**
   * Â§ÑÁêÜÁΩëÁªúÂìçÂ∫î
   */
  private processNetworkResponse<T>(response: Response<T>): NetworkResult<T> {
    return {
      success: true,
      data: response.data,
      headers: response.headers,
      statusCode: response.status
    };
  }

  /**
   * ÁîüÊàêÁºìÂ≠òÈî?   */
  private generateCacheKey(url: string, method: string, params?: Record<string, string | number | boolean | null>): string {
    const paramsStr = params ? JsonUtil.stringify(params) : '';
    return `${DEFAULT_CACHE_KEY_PREFIX}${method}_${url}_${paramsStr}`;
  }

  /**
   * Ëé∑ÂèñÁºìÂ≠òÊï∞ÊçÆ
   */
  private async getCachedData<T>(key: string): Promise<T | null> {
    if (!this.config.cacheEnabled) {
      return null;
    }

    try {
      const cached = await StorageUtil.get(key);
      if (cached && typeof cached === 'object') {
        // ‰ΩøÁî®Object.keysÊ£ÄÊü•Â±ûÊÄßÂ≠òÂú®ÊÄßÔºåÊõø‰ª£inÊìç‰ΩúÁ¨?        const cacheKeys = Object.keys(cached);
        if (cacheKeys.includes('data') && cacheKeys.includes('timestamp')) {
          const cacheItem = cached as { data: T; timestamp: number };
          const now = Date.now();
          const expiry = cacheItem.timestamp + (this.config.cacheExpiry || DEFAULT_CACHE_EXPIRY);
          
          if (now < expiry) {
            Logger.debug(TAG, `Cache hit for key: ${key}`);
            return cacheItem.data;
          } else {
            Logger.debug(TAG, `Cache expired for key: ${key}`);
            await StorageUtil.remove(key);
          }
        }
      }
    } catch (error) {
      Logger.warn(TAG, `Failed to get cache: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    return null;
  }

  /**
   * ËÆæÁΩÆÁºìÂ≠òÊï∞ÊçÆ
   */
  private async setCachedData<T>(key: string, data: T): Promise<void> {
    if (!this.config.cacheEnabled) {
      return;
    }

    try {
      const cacheItem: Record<string, string | number | boolean | null> = { ... };
      await StorageUtil.set(key, cacheItem);
      Logger.debug(TAG, `Cache set for key: ${key}`);
    } catch (error) {
      Logger.warn(TAG, `Failed to set cache: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  // ========== ÊêúÁ¥¢Áõ∏ÂÖ≥ÂÆûÁé∞ ==========

  async searchContent(params: SearchParams): Promise<NetworkResult<PaginatedResponse<SearchResult>>> {
    try {
      const requestUrl = '/api/search';
      const requestId = this.generateRequestId(requestUrl, 'GET');
      const cacheKey = this.generateCacheKey(requestUrl, 'GET', params);
      
      // Â∞ùËØï‰ªéÁºìÂ≠òËé∑Âè?      const cachedData = await this.getCachedData<PaginatedResponse<SearchResult>>(cacheKey);
      if (cachedData) {
        return {
          success: true,
          data: cachedData
        };
      }

      // ÂàõÂª∫AbortController
      const controller = new AbortController();
      this.requestMap.set(requestId, controller);

      // ÂèëÈÄÅËØ∑Ê±?      const requestConfig = this.createRequestConfig(requestUrl, 'GET', undefined, params);
      // ÊâãÂä®Ê∑ªÂä†signalÂ±ûÊÄßÔºå‰∏ç‰ΩøÁî®Â±ïÂºÄËøêÁÆóÁ¨?      (requestConfig as any).signal = controller.signal;
      const response = await NetworkUtil.request(requestUrl, requestConfig);

      // ‰ªéËØ∑Ê±ÇÊò†Â∞Ñ‰∏≠ÁßªÈô§
      this.requestMap.delete(requestId);

      const result = this.processNetworkResponse<PaginatedResponse<SearchResult>>(response);
      
      // ÁºìÂ≠òÊàêÂäüÁöÑÂìçÂ∫?      if (result.success && result.data) {
        await this.setCachedData(cacheKey, result.data);
      }

      return result;
    } catch (error) {
      Logger.error(TAG, `Failed to search content`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'Search failed'
      };
    }
  }

  async getHotSearchKeywords(limit: number = 20): Promise<NetworkResult<string[]>> {
    try {
      const requestUrl = '/api/search/hot';
      const params: Record<string, string | number | boolean | null> = { ... };
      const cacheKey = this.generateCacheKey(requestUrl, 'GET', params);
      
      // Â∞ùËØï‰ªéÁºìÂ≠òËé∑Âè?      const cachedData = await this.getCachedData<string[]>(cacheKey);
      if (cachedData) {
        return {
          success: true,
          data: cachedData
        };
      }

      const response = await NetworkUtil.request(requestUrl, this.createRequestConfig(requestUrl, 'GET', undefined, params));
      const result = this.processNetworkResponse<string[]>(response);
      
      // ÁºìÂ≠òÊàêÂäüÁöÑÂìçÂ∫?      if (result.success && result.data) {
        await this.setCachedData(cacheKey, result.data);
      }

      return result;
    } catch (error) {
      Logger.error(TAG, `Failed to get hot search keywords`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'Failed to get hot search keywords'
      };
    }
  }

  async getSearchSuggestions(keyword: string, limit: number = 10): Promise<NetworkResult<string[]>> {
    try {
      const requestUrl = '/api/search/suggestions';
      const params: Record<string, string | number> = { keyword, limit };
      
      const requestConfig = this.createRequestConfig(requestUrl, 'GET', undefined, params);
      const response = await NetworkUtil.request(requestUrl, requestConfig);
      return this.processNetworkResponse<string[]>(response);
    } catch (error) {
      Logger.error(TAG, `Failed to get search suggestions`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'Failed to get search suggestions'
      };
    }
  }

  // ========== ÁîµÂΩ±/ËßÜÈ¢ëÁõ∏ÂÖ≥ÂÆûÁé∞ ==========

  async getMovieDetail(movieId: string): Promise<NetworkResult<Movie>> {
    try {
      const requestUrl = `/api/movies/${movieId}`;
      const cacheKey = this.generateCacheKey(requestUrl, 'GET');
      
      // Â∞ùËØï‰ªéÁºìÂ≠òËé∑Âè?      const cachedData = await this.getCachedData<Movie>(cacheKey);
      if (cachedData) {
        return {
          success: true,
          data: cachedData
        };
      }

      const requestConfig = this.createRequestConfig(requestUrl, 'GET');
      const response = await NetworkUtil.request(requestUrl, requestConfig);
      const result = this.processNetworkResponse<Movie>(response);
      
      // ÁºìÂ≠òÊàêÂäüÁöÑÂìçÂ∫?      if (result.success && result.data) {
        // ËΩ¨Êç¢APIÂìçÂ∫îÊï∞ÊçÆ‰∏∫MovieÂØπË±°
        const movie = new Movie(result.data);
        result.data = movie;
        await this.setCachedData(cacheKey, movie);
      }

      return result;
    } catch (error) {
      Logger.error(TAG, `Failed to get movie detail`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'Failed to get movie detail'
      };
    }
  }

  async getMovieList(params: SearchParams): Promise<NetworkResult<PaginatedResponse<Movie>>> {
    try {
      const requestUrl = '/api/movies';
      const cacheKey = this.generateCacheKey(requestUrl, 'GET', params);
      
      // Â∞ùËØï‰ªéÁºìÂ≠òËé∑Âè?      const cachedData = await this.getCachedData<PaginatedResponse<Movie>>(cacheKey);
      if (cachedData) {
        return {
          success: true,
          data: cachedData
        };
      }

      const requestConfig = this.createRequestConfig(requestUrl, 'GET', undefined, params);
      const response = await NetworkUtil.request(requestUrl, requestConfig);
      const result = this.processNetworkResponse<PaginatedResponse<Movie>>(response);
      
      // ÁºìÂ≠òÊàêÂäüÁöÑÂìçÂ∫îÂπ∂ËΩ¨Êç¢Êï∞ÊçÆ
      if (result.success && result.data) {
        // ËΩ¨Êç¢APIÂìçÂ∫îÊï∞ÊçÆ‰∏∫MovieÂØπË±°Êï∞ÁªÑ
        result.data.items = result.data.items.map(item => new Movie(item));
        await this.setCachedData(cacheKey, result.data);
      }

      return result;
    } catch (error) {
      Logger.error(TAG, `Failed to get movie list`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'Failed to get movie list'
      };
    }
  }

  // ========== ÈÄöÁî®ÁΩëÁªúÊñπÊ≥ïÂÆûÁé∞ ==========

  async get<T>(url: string, params?: Record<string, unknown>, headers?: Record<string, string>): Promise<NetworkResult<T>> {
    try {
      const requestConfig = this.createRequestConfig(url, 'GET', undefined, params, headers);
      const response = await NetworkUtil.request(url, requestConfig);
      return this.processNetworkResponse<T>(response);
    } catch (error) {
      Logger.error(TAG, `Failed to send GET request`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'GET request failed'
      };
    }
  }

  async post<T>(url: string, data?: Record<string, unknown>, params?: Record<string, unknown>, headers?: Record<string, string>): Promise<NetworkResult<T>> {
    try {
      const requestConfig = this.createRequestConfig(url, 'POST', data, params, headers);
      const response = await NetworkUtil.request(url, requestConfig);
      return this.processNetworkResponse<T>(response);
    } catch (error) {
      Logger.error(TAG, `Failed to send POST request`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'POST request failed'
      };
    }
  }

  async put<T>(url: string, data?: Record<string, unknown>, params?: Record<string, unknown>, headers?: Record<string, string>): Promise<NetworkResult<T>> {
    try {
      const requestConfig = this.createRequestConfig(url, 'PUT', data, params, headers);
      const response = await NetworkUtil.request(url, requestConfig);
      return this.processNetworkResponse<T>(response);
    } catch (error) {
      Logger.error(TAG, `Failed to send PUT request`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'PUT request failed'
      };
    }
  }

  async delete<T>(url: string, params?: Record<string, unknown>, headers?: Record<string, string>): Promise<NetworkResult<T>> {
    try {
      const requestConfig = this.createRequestConfig(url, 'DELETE', undefined, params, headers);
      const response = await NetworkUtil.request(url, requestConfig);
      return this.processNetworkResponse<T>(response);
    } catch (error) {
      Logger.error(TAG, `Failed to send DELETE request`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'DELETE request failed'
      };
    }
  }

  async upload<T>(url: string, file: File, params?: Record<string, unknown>, headers?: Record<string, string>): Promise<NetworkResult<T>> {
    try {
      // ‰∏ä‰º†Êñá‰ª∂Êó∂ÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜContent-Type
      const uploadHeaders: Record<string, string> = {};
      
      // ÊâãÂä®Â§çÂà∂headersÔºåÊéíÈô§Content-Type
      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          if (key.toLowerCase() !== 'content-type') {
            uploadHeaders[key] = value;
          }
        }
      }

      const formData = new FormData();
      formData.append('file', file);
      
      if (params) {
        // ‰ΩøÁî®forÂæ™ÁéØÊõø‰ª£forEach
        const entries = Object.entries(params);
        for (let i = 0; i < entries.length; i++) {
          const [key, value] = entries[i];
          formData.append(key, String(value));
        }
      }

      // ÂàõÂª∫ËØ∑Ê±ÇÈÖçÁΩÆ
      const requestConfig = this.createRequestConfig(url, 'POST', undefined, undefined, uploadHeaders);
      // ËÆæÁΩÆËØ∑Ê±ÇÊï∞ÊçÆ
      requestConfig.data = formData;
      
      const response = await NetworkUtil.request(url, requestConfig);
      
      return this.processNetworkResponse<T>(response);
    } catch (error) {
      Logger.error(TAG, `Failed to upload file`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'File upload failed'
      };
    }
  }

  async download(url: string, savePath: string, headers?: Record<string, string>): Promise<NetworkResult<boolean>> {
    try {
      // ÊâãÂä®ÂêàÂπ∂headers
      const mergedHeaders: Record<string, string> = {};
      
      // Â§çÂà∂ÈªòËÆ§headers
      if (this.config.headers) {
        for (const [key, value] of Object.entries(this.config.headers)) {
          mergedHeaders[key] = value;
        }
      }
      
      // Â§çÂà∂Ëá™ÂÆö‰πâheadersÔºàË¶ÜÁõñÈªòËÆ§ÂÄºÔºâ
      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          mergedHeaders[key] = value;
        }
      }
      
      const response = await NetworkUtil.downloadFile(url, savePath, {
        headers: mergedHeaders,
        timeout: this.config.timeout
      });
      
      if (response.success) {
        return {
          success: true,
          data: true
        };
      } else {
        return {
          success: false,
          error: response.error,
          message: 'Download failed'
        };
      }
    } catch (error) {
      Logger.error(TAG, `Failed to download file`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'File download failed'
      };
    }
  }

  cancelAllRequests(): void {
    try {
      this.requestMap.forEach((request) => {
        request.destroy();
      });
      this.requestMap.clear();
      Logger.info(TAG, 'All requests cancelled');
    } catch (error) {
      Logger.error(TAG, `Failed to cancel all requests`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
    }
  }

  cancelRequest(requestId: string): void {
    try {
      const request = this.requestMap.get(requestId);
      if (request) {
        request.destroy();
        this.requestMap.delete(requestId);
        Logger.info(TAG, `Request cancelled: ${requestId}`);
      }
    } catch (error) {
      Logger.error(TAG, `Failed to cancel request`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
    }
  }

  // ========== Âç†‰ΩçÂÆûÁé∞ ==========
  // ‰∏∫‰∫Ü‰ª£Á†ÅËÉΩÁºñËØëÈÄöËøáÔºåÊèê‰æõÂü∫Á°ÄÁöÑÂç†‰ΩçÂÆûÁé?  async getRecommendedMovies(movieId: string, limit: number = 20): Promise<NetworkResult<Movie[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getRelatedMovies(movieId: string, limit: number = 20): Promise<NetworkResult<Movie[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getMovieRating(movieId: string): Promise<NetworkResult<Record<string, unknown>>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getVideoSources(contentId: string, contentType: string): Promise<NetworkResult<VideoSourceInfo[]>> { 
    try {
      Logger.info(TAG, `Getting video sources for contentId: ${contentId}, contentType: ${contentType}`);
      
      // ‰ΩøÁî®Ëß£ÊûêÂô®ÊúçÂä°Ëé∑ÂèñËßÜÈ¢ëÊ∫ê
      return await getParserService().getVideoSources(contentId, contentType);
    } catch (error) {
      Logger.error(TAG, `Failed to get video sources`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return { 
        success: false, 
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'Failed to get video sources' 
      };
    }
  }
  
  async parseVideoSource(sourceUrl: string, parserId?: string): Promise<NetworkResult<VideoSourceInfo>> { 
    try {
      Logger.info(TAG, `Parsing video source: ${sourceUrl}, parserId: ${parserId}`);
      
      // ‰ΩøÁî®Ëß£ÊûêÂô®ÊúçÂä°Ëß£ÊûêËßÜÈ¢ëÊ∫ê
      return await getParserService().parseVideoSource(sourceUrl, parserId);
    } catch (error) {
      Logger.error(TAG, `Failed to parse video source`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return { 
        success: false, 
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'Failed to parse video source' 
      };
    }
  }
  
  async getVideoChapters(contentId: string, season: number = 1): Promise<NetworkResult<ChapterInfo[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getVideoDanmaku(contentId: string, startTime: number, endTime: number): Promise<NetworkResult<Record<string, unknown>[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async submitDanmaku(contentId: string, danmaku: string, timestamp: number): Promise<NetworkResult<boolean>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getCategories(): Promise<NetworkResult<Record<string, string[]>>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getGenres(): Promise<NetworkResult<string[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getRegions(): Promise<NetworkResult<string[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getYears(): Promise<NetworkResult<number[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getRankings(type: string, limit: number = 20): Promise<NetworkResult<Movie[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getWeeklyHot(limit: number = 20): Promise<NetworkResult<Movie[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getMonthlyNew(limit: number = 20): Promise<NetworkResult<Movie[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getLiveChannels(category?: string): Promise<NetworkResult<LiveChannelInfo[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getLiveEpg(channelId: string): Promise<NetworkResult<Record<string, unknown>>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async searchLiveChannels(keyword: string): Promise<NetworkResult<LiveChannelInfo[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getParsers(): Promise<NetworkResult<ParserInfo[]>> { 
    try {
      Logger.info(TAG, 'Getting available parsers');
      
      // ‰ΩøÁî®Ëß£ÊûêÂô®ÊúçÂä°Ëé∑ÂèñÊâÄÊúâËß£ÊûêÂô®
      return await getParserService().getParsers();
    } catch (error) {
      Logger.error(TAG, `Failed to get parsers`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return { 
        success: false, 
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'Failed to get parsers' 
      };
    }
  }
  
  async checkParserAvailability(parserId: string): Promise<NetworkResult<boolean>> { 
    try {
      Logger.info(TAG, `Checking parser availability: ${parserId}`);
      
      // ‰ΩøÁî®Ëß£ÊûêÂô®ÊúçÂä°Ê£ÄÊü•Ëß£ÊûêÂô®ÂèØÁî®ÊÄ?      return await getParserService().checkParserAvailability(parserId);
    } catch (error) {
      Logger.error(TAG, `Failed to check parser availability`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return { 
        success: false, 
        error: error instanceof Error ? error : new Error(String(error)),
        message: 'Failed to check parser availability' 
      };
    }
  }
  
  async submitFeedback(feedback: string, contact?: string): Promise<NetworkResult<boolean>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async checkUpdate(currentVersion: string): Promise<NetworkResult<Record<string, unknown>>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getAppConfig(): Promise<NetworkResult<Record<string, unknown>>> { 
    return { success: false, message: 'Not implemented' }; 
  }
  
  async getAnnouncements(): Promise<NetworkResult<string[]>> { 
    return { success: false, message: 'Not implemented' }; 
  }
}



