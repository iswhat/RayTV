// DatabaseManager.ets - æ•°æ®åº“ç®¡ç†å™¨
// å®ç°åŸºäºHarmonyOS RelationalStoreçš„æ•°æ®åº“è¿æ¥å’Œç®¡ç?
import relationalStore from '@ohos.data.relationalStore';
import { getAllTables, INDEXES, DATABASE_INFO } from './TableSchema';
import Logger from '../../common/util/Logger';

const TAG = 'DatabaseManager';

export class DatabaseManager {
  private static instance: DatabaseManager;
  private database: relationalStore.RdbStore | null = null;
  private isInitialized: boolean = false;
  private initializationPromise: Promise<void> | null = null;
  
  private constructor() {}
  
  /**
   * è·å–æ•°æ®åº“ç®¡ç†å™¨å•ä¾‹å®ä¾‹
   */
  public static getInstance(): DatabaseManager {
    if (!DatabaseManager.instance) {
      DatabaseManager.instance = new DatabaseManager();
    }
    return DatabaseManager.instance;
  }
  
  /**
   * åˆå§‹åŒ–æ•°æ®åº“
   * @param context åº”ç”¨ä¸Šä¸‹æ–?   */
  public async initDatabase(context: Context): Promise<void> {
    // å¦‚æœå·²ç»åˆå§‹åŒ–æˆ–æ­£åœ¨åˆå§‹åŒ–ï¼Œè¿”å›ç°æœ‰Promise
    if (this.isInitialized) {
      return;
    }
    
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    
    // åˆ›å»ºæ–°çš„åˆå§‹åŒ–Promiseä»¥é¿å…é‡å¤åˆå§‹åŒ–
    this.initializationPromise = this.doInitialize(context);
    return this.initializationPromise;
  }
  
  /**
   * å®é™…çš„åˆå§‹åŒ–é€»è¾‘
   */
  private async doInitialize(context: Context): Promise<void> {
    try {
      Logger.info(TAG, 'Starting database initialization');
      
      const config: relationalStore.StoreConfig = {
        name: DATABASE_INFO.NAME,
        securityLevel: relationalStore.SecurityLevel[DATABASE_INFO.SECURITY_LEVEL as keyof typeof relationalStore.SecurityLevel]
      };
      
      // è·å–æ•°æ®åº“è¿æ?      this.database = await relationalStore.getRdbStore(context, config);
      
      // åˆ›å»ºè¡¨å’Œç´¢å¼•
      await this.createTables();
      await this.createIndexes();
      
      // æ£€æŸ¥æ•°æ®åº“ç‰ˆæœ¬
      await this.checkDatabaseVersion();
      
      this.isInitialized = true;
      Logger.info(TAG, 'Database initialized successfully');
    } catch (error) {
      Logger.error(TAG, `Failed to initialize database: ${JSON.stringify(error)}`);
      this.isInitialized = false;
      throw error;
    } finally {
      this.initializationPromise = null;
    }
  }
  
  /**
   * åˆ›å»ºæ•°æ®åº“è¡¨
   */
  private async createTables(): Promise<void> {
    if (!this.database) {
      throw new Error('Database not initialized');
    }
    
    try {
      const tables = getAllTables();
      Logger.info(TAG, `Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables` instanceof Error ? `Creating ${tables.length} tables` : new Error(String(`Creating ${tables.length} tables`)))))));
      
      for (const sql of tables) {
        await this.database.executeSql(sql);
        Logger.debug(TAG, `Created table with SQL: ${sql.substring(0, 100)}...`);
      }
      
      Logger.info(TAG, 'All tables created successfully');
    } catch (error) {
      Logger.error(TAG, `Failed to create tables: ${JSON.stringify(error)}`);
      throw error;
    }
  }
  
  /**
   * åˆ›å»ºç´¢å¼•
   */
  private async createIndexes(): Promise<void> {
    if (!this.database) {
      throw new Error('Database not initialized');
    }
    
    try {
      Logger.info(TAG, `Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes` instanceof Error ? `Creating ${INDEXES.CREATE_INDEXES.length} indexes` : new Error(String(`Creating ${INDEXES.CREATE_INDEXES.length} indexes`)))))));
      
      for (const indexSql of INDEXES.CREATE_INDEXES) {
        await this.database.executeSql(indexSql);
        Logger.debug(TAG, `Created index: ${indexSql.substring(0, 80)}...`);
      }
      
      Logger.info(TAG, 'All indexes created successfully');
    } catch (error) {
      Logger.error(TAG, `Failed to create indexes: ${JSON.stringify(error)}`);
      // ç´¢å¼•åˆ›å»ºå¤±è´¥ä¸å½±å“åº”ç”¨è¿è¡Œï¼Œè®°å½•é”™è¯¯ä½†ä¸æŠ›å‡ºå¼‚å¸¸
    }
  }
  
  /**
   * æ£€æŸ¥æ•°æ®åº“ç‰ˆæœ¬å¹¶æ‰§è¡Œè¿ç§?   */
  private async checkDatabaseVersion(): Promise<void> {
    try {
      Logger.info(TAG, `Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}` instanceof Error ? `Checking database version: ${DATABASE_INFO.VERSION}` : new Error(String(`Checking database version: ${DATABASE_INFO.VERSION}`)))))));
      
      // ä»æ•°æ®åº“å…ƒæ•°æ®è¡¨ä¸­è·å–å½“å‰ç‰ˆæœ?      let currentVersion = 0;
      const resultSet = await this.database.querySql(
        'SELECT version FROM database_meta WHERE id = 1',
        []
      );
      
      if (resultSet.goToFirstRow()) {
        currentVersion = resultSet.getLong(0) || 0;
      }
      resultSet.close();
      
      Logger.info(TAG, `Current database version: ${currentVersion}, Target version: ${DATABASE_INFO.VERSION}`);
      
      // å¦‚æœéœ€è¦å‡çº?      if (currentVersion < DATABASE_INFO.VERSION) {
        await this.migrateDatabase(currentVersion, DATABASE_INFO.VERSION);
        // æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
        await this.database.executeSql(
          'INSERT OR REPLACE INTO database_meta (id, version, last_updated) VALUES (1, ?, ?)',
          [DATABASE_INFO.VERSION, Date.now()]
        );
        Logger.info(TAG, `Database version updated to: ${DATABASE_INFO.VERSION}`);
      }
      
      Logger.info(TAG, `Database version: ${DATABASE_INFO.VERSION}`);
    } catch (error) {
      Logger.error(TAG, `Failed to check database version: ${JSON.stringify(error)}`);
      throw error; // ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥åº”è¯¥æŠ›å‡ºå¼‚å¸¸ï¼Œå› ä¸ºè¿™æ˜¯å…³é”®åŠŸèƒ½
    }
  }
  
  /**
   * æ‰§è¡Œæ•°æ®åº“è¿ç§?   * @param fromVersion æºç‰ˆæœ?   * @param toVersion ç›®æ ‡ç‰ˆæœ¬
   */
  private async migrateDatabase(fromVersion: number, toVersion: number instanceof Error ? toVersion: number : new Error(String(toVersion: number instanceof Error ? toVersion: number instanceof Error ? toVersion: number : new Error(String(toVersion: number : new Error(String(toVersion: number instanceof Error ? toVersion: number : new Error(String(toVersion: number instanceof Error ? toVersion: number instanceof Error ? toVersion: number : new Error(String(toVersion: number instanceof Error ? toVersion: number instanceof Error ? toVersion: number : new Error(String(toVersion: number : new Error(String(toVersion: number instanceof Error ? toVersion: number : new Error(String(toVersion: number : new Error(String(toVersion: number instanceof Error ? toVersion: number : new Error(String(toVersion: number instanceof Error ? toVersion: number instanceof Error ? toVersion: number : new Error(String(toVersion: number : new Error(String(toVersion: number instanceof Error ? toVersion: number : new Error(String(toVersion: number))))))): Promise<void> {
    try {
      Logger.info(TAG, `Migrating database from version ${fromVersion} to ${toVersion}`);
      
      // å¼€å§‹äº‹åŠ?      await this.executeTransaction(async (db) => {
        // æ ¹æ®ç‰ˆæœ¬é€æ­¥æ‰§è¡Œè¿ç§»è„šæœ¬
        for (let version = fromVersion + 1; version <= toVersion; version++) {
          Logger.info(TAG, `Applying migration for version ${version}`);
          // è¿™é‡Œå¯ä»¥æ ¹æ®ä¸åŒçš„ç‰ˆæœ¬æ‰§è¡Œä¸åŒçš„è¿ç§»è„šæœ¬
          // ä¾‹å¦‚ï¼šæ‰§è¡ŒALTER TABLEè¯­å¥ã€æ•°æ®è½¬æ¢ç­‰
          
          // ç¤ºä¾‹ï¼šå¦‚æœéœ€è¦åˆ›å»ºå…ƒæ•°æ®è¡¨ï¼ˆé¦–æ¬¡è¿ç§»æ—¶ï¼‰
          if (version === 1) {
            await db.executeSql(
              'CREATE TABLE IF NOT EXISTS database_meta (' +
              'id INTEGER PRIMARY KEY, ' +
              'version INTEGER NOT NULL, ' +
              'last_updated INTEGER NOT NULL)' +
              '', []
            );
          }
          
          // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å…¶ä»–ç‰ˆæœ¬çš„è¿ç§»é€»è¾‘
        }
      });
      
      Logger.info(TAG, `Database migration completed successfully`);
    } catch (error) {
      Logger.error(TAG, `Database migration failed: ${JSON.stringify(error)}`);
      throw error;
    }
  }
  
  /**
   * è·å–æ•°æ®åº“å®ä¾?   * @returns RdbStoreå®ä¾‹
   */
  public getDatabase(): relationalStore.RdbStore {
    if (!this.database) {
      throw new Error('Database not initialized. Call initDatabase() first.');
    }
    return this.database;
  }
  
  /**
   * æ‰§è¡ŒSQLæŸ¥è¯¢
   * @param sql SQLè¯­å¥
   * @param bindArgs ç»‘å®šå‚æ•°
   */
  public async executeSql(sql: string, bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType> instanceof Error ? bindArgs?: Array<ValueType> : new Error(String(bindArgs?: Array<ValueType>))))))): Promise<void> {
    if (!this.database) {
      throw new Error('Database not initialized');
    }
    
    try {
      Logger.debug(TAG, `Executing SQL: ${sql} with args: ${bindArgs?.toString()}`);
      await this.database.executeSql(sql, bindArgs);
    } catch (error) {
      Logger.error(TAG, `Failed to execute SQL: ${sql}, error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error instanceof Error ? error: ${JSON.stringify(error : new Error(String(error: ${JSON.stringify(error)))))))}`);
      throw error;
    }
  }
  
  /**
   * æ‰§è¡Œäº‹åŠ¡
   * @param transactionFunc äº‹åŠ¡å›è°ƒå‡½æ•°
   */
  public async executeTransaction(transactionFunc: (connection: relationalStore.RdbStore) => Promise<void>): Promise<void> {
    if (!this.database) {
      throw new Error('Database not initialized');
    }
    
    try {
      Logger.debug(TAG, 'Starting database transaction');
      await transactionFunc(this.database);
      Logger.debug(TAG, 'Transaction completed successfully');
    } catch (error) {
      Logger.error(TAG, `Transaction failed: ${JSON.stringify(error)}`);
      throw error;
    }
  }
  
  /**
   * å…³é—­æ•°æ®åº?   */
  public closeDatabase(): void {
    if (this.database) {
      // åœ¨HarmonyOSä¸­ï¼ŒRdbStoreä¼šè‡ªåŠ¨ç®¡ç†è¿æ¥å…³é—?      // è¿™é‡Œä¸»è¦æ˜¯é‡ç½®çŠ¶æ€?      this.database = null;
      this.isInitialized = false;
      Logger.info(TAG, 'Database connection closed' instanceof Error ? 'Database connection closed' : new Error(String('Database connection closed' instanceof Error ? 'Database connection closed' instanceof Error ? 'Database connection closed' : new Error(String('Database connection closed' : new Error(String('Database connection closed' instanceof Error ? 'Database connection closed' : new Error(String('Database connection closed' instanceof Error ? 'Database connection closed' instanceof Error ? 'Database connection closed' : new Error(String('Database connection closed' instanceof Error ? 'Database connection closed' instanceof Error ? 'Database connection closed' : new Error(String('Database connection closed' : new Error(String('Database connection closed' instanceof Error ? 'Database connection closed' : new Error(String('Database connection closed' : new Error(String('Database connection closed' instanceof Error ? 'Database connection closed' : new Error(String('Database connection closed' instanceof Error ? 'Database connection closed' instanceof Error ? 'Database connection closed' : new Error(String('Database connection closed' : new Error(String('Database connection closed' instanceof Error ? 'Database connection closed' : new Error(String('Database connection closed')))))));
    }
  }
  
  /**
   * æ£€æŸ¥æ•°æ®åº“æ˜¯å¦å·²åˆå§‹åŒ–
   * @returns æ˜¯å¦å·²åˆå§‹åŒ–
   */
  public isDatabaseInitialized(): boolean {
    return this.isInitialized && this.database !== null;
  }
  
  /**
   * è·å–æ•°æ®åº“ä¿¡æ?   * @returns æ•°æ®åº“ä¿¡æ?   */
  public getDatabaseInfo(): { name: string; version: number } {
    return {
      name: DATABASE_INFO.NAME,
      version: DATABASE_INFO.VERSION
    };
  }
  
  /**
   * æ¸…ç©ºæ•°æ®åº“ï¼ˆåˆ é™¤æ‰€æœ‰è¡¨å¹¶é‡å»ºï¼‰
   * @param context åº”ç”¨ä¸Šä¸‹æ–?   */
  public async resetDatabase(context: Context): Promise<void> {
    try {
      Logger.warning(TAG, 'Resetting database - this will delete all data!');
      
      // å…³é—­ç°æœ‰è¿æ¥
      this.closeDatabase();
      
      // åˆ é™¤æ•°æ®åº“æ–‡ä»?      await context.deleteDatabase(DATABASE_INFO.NAME);
      Logger.info(TAG, 'Database file deleted');
      
      // é‡æ–°åˆå§‹åŒ?      await this.initDatabase(context);
      Logger.info(TAG, 'Database reset completed successfully');
    } catch (error) {
      Logger.error(TAG, `Failed to reset database: ${JSON.stringify(error)}`);
      throw error;
    }
  }
  
  /**
   * è·å–æ•°æ®åº“å¤§å°ä¿¡æ?   * @returns æ•°æ®åº“å¤§å°ï¼ˆå­—èŠ‚ï¼?   */
  public async getDatabaseSize(): Promise<number> {
    try {
      Logger.debug(TAG, 'Getting database size' instanceof Error ? 'Getting database size' : new Error(String('Getting database size' instanceof Error ? 'Getting database size' instanceof Error ? 'Getting database size' : new Error(String('Getting database size' : new Error(String('Getting database size' instanceof Error ? 'Getting database size' : new Error(String('Getting database size' instanceof Error ? 'Getting database size' instanceof Error ? 'Getting database size' : new Error(String('Getting database size' instanceof Error ? 'Getting database size' instanceof Error ? 'Getting database size' : new Error(String('Getting database size' : new Error(String('Getting database size' instanceof Error ? 'Getting database size' : new Error(String('Getting database size' : new Error(String('Getting database size' instanceof Error ? 'Getting database size' : new Error(String('Getting database size' instanceof Error ? 'Getting database size' instanceof Error ? 'Getting database size' : new Error(String('Getting database size' : new Error(String('Getting database size' instanceof Error ? 'Getting database size' : new Error(String('Getting database size')))))));
      
      // ä½¿ç”¨PRAGMA page_countå’Œpage_sizeæŸ¥è¯¢æ•°æ®åº“å¤§å°?      const pageCountResult = await this.database.querySql('PRAGMA page_count', []);
      let pageCount = 0;
      if (pageCountResult.goToFirstRow()) {
        pageCount = pageCountResult.getLong(0) || 0;
      }
      pageCountResult.close();
      
      const pageSizeResult = await this.database.querySql('PRAGMA page_size', []);
      let pageSize = 0;
      if (pageSizeResult.goToFirstRow()) {
        pageSize = pageSizeResult.getLong(0) || 0;
      }
      pageSizeResult.close();
      
      const databaseSize = pageCount * pageSize;
      Logger.info(TAG, `Database size: ${databaseSize} bytes`);
      
      return databaseSize;
    } catch (error) {
      Logger.error(TAG, `Failed to get database size: ${JSON.stringify(error)}`);
      return 0;
    }
  }
  
  /**
   * ä¼˜åŒ–æ•°æ®åº?   */
  public async optimizeDatabase(): Promise<void> {
    try {
      // åœ¨SQLiteä¸­ï¼ŒVACUUMå‘½ä»¤å¯ä»¥ä¼˜åŒ–æ•°æ®åº?      await this.executeSql('VACUUM');
      Logger.info(TAG, 'Database optimized successfully' instanceof Error ? 'Database optimized successfully' : new Error(String('Database optimized successfully' instanceof Error ? 'Database optimized successfully' instanceof Error ? 'Database optimized successfully' : new Error(String('Database optimized successfully' : new Error(String('Database optimized successfully' instanceof Error ? 'Database optimized successfully' : new Error(String('Database optimized successfully' instanceof Error ? 'Database optimized successfully' instanceof Error ? 'Database optimized successfully' : new Error(String('Database optimized successfully' instanceof Error ? 'Database optimized successfully' instanceof Error ? 'Database optimized successfully' : new Error(String('Database optimized successfully' : new Error(String('Database optimized successfully' instanceof Error ? 'Database optimized successfully' : new Error(String('Database optimized successfully' : new Error(String('Database optimized successfully' instanceof Error ? 'Database optimized successfully' : new Error(String('Database optimized successfully' instanceof Error ? 'Database optimized successfully' instanceof Error ? 'Database optimized successfully' : new Error(String('Database optimized successfully' : new Error(String('Database optimized successfully' instanceof Error ? 'Database optimized successfully' : new Error(String('Database optimized successfully')))))));
    } catch (error) {
      Logger.error(TAG, `Failed to optimize database: ${JSON.stringify(error)}`);
    }
  }
}


