// SQLiteHelper.ets - SQLiteæ•°æ®åº“æ“ä½œè¾…åŠ©ç±»
// æä¾›åŸºæœ¬çš„CRUDæ“ä½œå’ŒSQLæŸ¥è¯¢æ„å»ºåŠŸèƒ½

import RelationalStore from '@ohos.data.relationalStore';
import { DatabaseManager } from './DatabaseManager';
import Logger from '../../common/util/Logger';

const TAG = 'SQLiteHelper';

/**
 * æ•°æ®åº“æ”¯æŒçš„å€¼ç±»å?*/
export type ValueType = string | number | boolean | null;

/**
 * æ•°æ®åº“è®°å½•ç±»å?*/
export type DatabaseRecord = Record<string, ValueType>;

/**
 * SQLiteHelperç±»å®šä¹‰å¼€å§?*/


/**
 * SQLæŸ¥è¯¢æ¡ä»¶æ¥å£
 */
export interface QueryCondition {
  column: string;
  value: ValueType | ValueType[];
  operator?: '=' | '!=' | '>' | '<' | '>=' | '<=' | 'LIKE' | 'IN' | 'NOT IN';
}

/**
 * SQLæ’åºé€‰é¡¹æ¥å£
 */
export interface SortOption {
  column: string;
  order?: 'ASC' | 'DESC';
}

/**
 * æ•°æ®åº“æ“ä½œç»“æœæ¥å?*/
export interface DatabaseResult {
  success: boolean;
  message?: string;
  affectedRows?: number;
  lastInsertRowId?: number;
}

export class SQLiteHelper {
  private static instance: SQLiteHelper;
  private dbManager: DatabaseManager;
  
  /**
   * è·å–å¯¹è±¡çš„é”®æ•°ç»„ï¼ˆArkTSå…¼å®¹æ–¹æ³•ï¼?*/
  private getObjectKeys<T extends DatabaseRecord>(obj: T): string[] {
    const keys: string[] = [];
    for (const key in obj) {
      if (Object.keys(obj).includes(key)) {
        keys.push(key);
      }
    }
    return keys;
  }
  
  /**
   * è·å–å¯¹è±¡çš„å€¼æ•°ç»„ï¼ˆArkTSå…¼å®¹æ–¹æ³•ï¼?*/
  private getObjectValues<T extends DatabaseRecord>(obj: T): ValueType[] {
    const values: ValueType[] = [];
    for (const key in obj) {
      if (Object.keys(obj).includes(key)) {
        values.push(obj[key]);
      }
    }
    return values;
  }
  
  private constructor() {
    this.dbManager = DatabaseManager.getInstance();
  }
  
  /**
   * è·å–SQLiteHelperå•ä¾‹å®ä¾‹
   */
  public static getInstance(): SQLiteHelper {
    if (!SQLiteHelper.instance) {
      SQLiteHelper.instance = new SQLiteHelper();
    }
    return SQLiteHelper.instance;
  }
  
  /**
   * æ’å…¥æ•°æ®
   * @param tableName è¡¨å
   * @param values è¦æ’å…¥çš„æ•°æ®
   * @returns æ’å…¥ç»“æœ
   */
  public async insert(tableName: string, values: Record<string, ValueType>): Promise<DatabaseResult> {
    try {
      Logger.debug(TAG, `Inserting data into ${tableName}`);
      
      const database = this.dbManager.getDatabase();
      
      // æ„å»ºæ’å…¥è¯­å¥
      const columns = this.getObjectKeys(values);
      const placeholders = columns.map(() => '?').join(', ');
      const bindArgs = this.getObjectValues(values);
      
      const sql = `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders})`;
      
      // æ‰§è¡Œæ’å…¥
      await database.executeSql(sql, bindArgs);
      
      // è·å–æœ€åæ’å…¥çš„ID
      const result = await database.querySql(`SELECT last_insert_rowid() as id`);
      // Fix type handling for querySql result
      const idIndex = result.columnNames.indexOf('id');
      const lastInsertRowId = result.firstItem ? (result.firstItem.getLong(idIndex) || 0) : -1;
      
      Logger.info(TAG, `Inserted data into ${tableName}, ID: ${lastInsertRowId}`);
      
      return {
        success: true,
        lastInsertRowId,
        affectedRows: 1
      };
    } catch (error) {
      Logger.error(TAG, `Failed to insert into ${tableName}: ${JSON.stringify(error)}`);
      return {
        success: false,
        message: error instanceof Error ? error.message : JSON.stringify(error)
      };
    }
  }
  
  /**
   * æ‰¹é‡æ’å…¥æ•°æ®
   * @param tableName è¡¨å
   * @param dataList æ•°æ®åˆ—è¡¨
   * @returns æ’å…¥ç»“æœ
   */
  public async batchInsert(tableName: string, dataList: Array<Record<string, ValueType>>): Promise<DatabaseResult> {
    if (!dataList || dataList.length === 0) {
      return { success: true, affectedRows: 0 };
    }
    
    try {
      let affectedRows = 0;
      
      await this.dbManager.executeTransaction(async (db) => {
        for (const values of dataList) {
          const columns = this.getObjectKeys(values);
          const placeholders = columns.map(() => '?').join(', ');
          const bindArgs = this.getObjectValues(values);
          
          const sql = `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders})`;
          await db.executeSql(sql, bindArgs);
          affectedRows++;
        }
      });
      
      Logger.info(TAG, `Batch inserted ${affectedRows} records into ${tableName}`);
      return {
        success: true,
        affectedRows
      };
    } catch (error) {
      Logger.error(TAG, `Failed to batch insert into ${tableName}: ${JSON.stringify(error)}`);
      return {
        success: false,
        message: error instanceof Error ? error.message : JSON.stringify(error)
      };
    }
  }
  
  /**
   * æ›´æ–°æ•°æ®
   * @param tableName è¡¨å
   * @param values è¦æ›´æ–°çš„æ•°æ®
   * @param conditions æ›´æ–°æ¡ä»¶
   * @returns æ›´æ–°ç»“æœ
   */
  public async update(
    tableName: string,
    values: Record<string, ValueType>,
    conditions?: Array<QueryCondition>
  ): Promise<DatabaseResult> {
    try {
      const database = this.dbManager.getDatabase();
      
      // æ„å»ºæ›´æ–°è¯­å¥
      const columns = this.getObjectKeys(values);
      const setClause = columns
        .map(key => `${key} = ?`)
        .join(', ');
      
      let sql = `UPDATE ${tableName} SET ${setClause}`;
      const bindArgs: ValueType[] = this.getObjectValues(values);
      
      // æ·»åŠ æ¡ä»¶
      if (conditions && conditions.length > 0) {
        const whereClause = conditions.map(cond => {
          const operator = cond.operator || '=';
          if (operator === 'IN' || operator === 'NOT IN') {
            const placeholders = Array.isArray(cond.value)
              ? cond.value.map(() => '?').join(', ')
              : '?';
            return `${cond.column} ${operator} (${placeholders})`;
          }
          return `${cond.column} ${operator} ?`;
        }).join(' AND ');
        
        sql += ` WHERE ${whereClause}`;
        
        // å¤„ç†INæ¡ä»¶çš„å‚æ•?        conditions.forEach(cond => {
          if ((cond.operator === 'IN' || cond.operator === 'NOT IN') && Array.isArray(cond.value)) {
            bindArgs.push(...cond.value);
          } else if (cond.operator !== 'IN' && cond.operator !== 'NOT IN') {
            bindArgs.push(cond.value);
          }
        });
      }
      
      // æ‰§è¡Œæ›´æ–°
      await database.executeSql(sql, bindArgs);
      
      // è·å–å½±å“çš„è¡Œæ•?      const result = await database.querySql('SELECT changes() as affected_rows');
      const affectedRows = result.firstItem?.getLong(result.columnNames.indexOf('affected_rows')) || 0;
      
      Logger.info(TAG, `Updated ${affectedRows} records in ${tableName}`);
      
      return {
        success: true,
        affectedRows
      };
    } catch (error) {
      Logger.error(TAG, `Failed to update ${tableName}: ${JSON.stringify(error)}`);
      return {
        success: false,
        message: error instanceof Error ? error.message : JSON.stringify(error)
      };
    }
  }
  
  /**
   * åˆ é™¤æ•°æ®
   * @param tableName è¡¨å
   * @param conditions åˆ é™¤æ¡ä»¶
   * @returns åˆ é™¤ç»“æœ
   */
  public async delete(
    tableName: string,
    conditions?: Array<QueryCondition>
  ): Promise<DatabaseResult> {
    try {
      const database = this.dbManager.getDatabase();
      
      let sql = `DELETE FROM ${tableName}`;
      const bindArgs: ValueType[] = [];
      
      // æ·»åŠ æ¡ä»¶
      if (conditions && conditions.length > 0) {
        const whereClause = conditions.map(cond => {
          const operator = cond.operator || '=';
          if (operator === 'IN' || operator === 'NOT IN') {
            const placeholders = Array.isArray(cond.value)
              ? cond.value.map(() => '?').join(', ')
              : '?';
            return `${cond.column} ${operator} (${placeholders})`;
          }
          return `${cond.column} ${operator} ?`;
        }).join(' AND ');
        
        sql += ` WHERE ${whereClause}`;
        
        // å¤„ç†INæ¡ä»¶çš„å‚æ•?        conditions.forEach(cond => {
          if ((cond.operator === 'IN' || cond.operator === 'NOT IN') && Array.isArray(cond.value)) {
            bindArgs.push(...cond.value);
          } else if (cond.operator !== 'IN' && cond.operator !== 'NOT IN') {
            bindArgs.push(cond.value);
          }
        });
      }
      
      // æ‰§è¡Œåˆ é™¤
      await database.executeSql(sql, bindArgs);
      
      // è·å–å½±å“çš„è¡Œæ•?      const result = await database.querySql('SELECT changes() as affected_rows');
      const affectedRows = result.firstItem?.getLong(result.columnNames.indexOf('affected_rows')) || 0;
      
      Logger.info(TAG, `Deleted ${affectedRows} records from ${tableName}`);
      
      return {
        success: true,
        affectedRows
      };
    } catch (error) {
      Logger.error(TAG, `Failed to delete from ${tableName}: ${JSON.stringify(error)}`);
      return {
        success: false,
        message: error instanceof Error ? error.message : JSON.stringify(error)
      };
    }
  }
  
  /**
   * æŸ¥è¯¢æ•°æ®
   * @param tableName è¡¨å
   * @param columns è¦æŸ¥è¯¢çš„åˆ?   * @param conditions æŸ¥è¯¢æ¡ä»¶
   * @param sortOptions æ’åºé€‰é¡¹
   * @param limit é™åˆ¶æ•°é‡
   * @param offset åç§»é‡?   * @returns æŸ¥è¯¢ç»“æœåˆ—è¡¨
   */
  public async query<T extends DatabaseRecord>(
    tableName: string,
    columns: string[] = ['*'],
    conditions?: Array<QueryCondition>,
    sortOptions?: Array<SortOption>,
    limit?: number,
    offset: number = 0
  ): Promise<T[]> {
    try {
      const database = this.dbManager.getDatabase();
      
      // æ„å»ºæŸ¥è¯¢è¯­å¥
      let sql = `SELECT ${columns.join(', ')} FROM ${tableName}`;
      const bindArgs: ValueType[] = [];
      
      // æ·»åŠ æ¡ä»¶
      if (conditions && conditions.length > 0) {
        const whereClause = conditions.map(cond => {
          const operator = cond.operator || '=';
          if (operator === 'IN' || operator === 'NOT IN') {
            const placeholders = Array.isArray(cond.value)
              ? cond.value.map(() => '?').join(', ')
              : '?';
            return `${cond.column} ${operator} (${placeholders})`;
          }
          return `${cond.column} ${operator} ?`;
        }).join(' AND ');
        
        sql += ` WHERE ${whereClause}`;
        
        // å¤„ç†INæ¡ä»¶çš„å‚æ•?        conditions.forEach(cond => {
          if ((cond.operator === 'IN' || cond.operator === 'NOT IN') && Array.isArray(cond.value)) {
            bindArgs.push(...cond.value);
          } else if (cond.operator !== 'IN' && cond.operator !== 'NOT IN') {
            bindArgs.push(cond.value);
          }
        });
      }
      
      // æ·»åŠ æ’åº
      if (sortOptions && sortOptions.length > 0) {
        const orderByClause = sortOptions
          .map(option => `${option.column} ${option.order || 'ASC'}`)
          .join(', ');
        sql += ` ORDER BY ${orderByClause}`;
      }
      
      // æ·»åŠ åˆ†é¡µ
      if (limit !== undefined) {
        sql += ` LIMIT ? OFFSET ?`;
        bindArgs.push(limit, offset);
      }
      
      Logger.debug(TAG, `Executing query: ${sql}, args: ${JSON.stringify(bindArgs)}`);
      
      // æ‰§è¡ŒæŸ¥è¯¢
      const result = await database.querySql(sql, bindArgs);
      
      // å¤„ç†ç»“æœ
      const records: T[] = [];
      while (result.goToNextRow()) {
        const record: DatabaseRecord = {};
        result.columnNames.forEach((column, index) => {
          // æ ¹æ®æ•°æ®ç±»å‹è·å–å€?          const value = result.getDouble(index);
          if (!isNaN(value)) {
            // å¦‚æœæ˜¯æ•´æ•°ï¼Œè½¬æ¢ä¸ºæ•´æ•?            if (Number.isInteger(value)) {
              record[column] = Math.floor(value);
            } else {
              record[column] = value;
            }
          } else {
            // å°è¯•è·å–å­—ç¬¦ä¸?            record[column] = result.getString(index);
          }
        });
        records.push(record);
      }
      
      Logger.info(TAG, `Retrieved ${records.length} records from ${tableName}`);
      return records;
    } catch (error) {
      Logger.error(TAG, `Failed to query ${tableName}: ${JSON.stringify(error)}`);
      return [];
    }
  }
  
  /**
   * è·å–å•æ¡è®°å½•
   * @param tableName è¡¨å
   * @param columns è¦æŸ¥è¯¢çš„åˆ?   * @param conditions æŸ¥è¯¢æ¡ä»¶
   * @returns å•æ¡è®°å½•æˆ–null
   */
  public async getFirst<T extends DatabaseRecord>(
    tableName: string, 
    columns: string[] = ['*'],
    conditions?: Array<QueryCondition>
  ): Promise<T | null> {
    const results = await this.query<T>(tableName, columns, conditions, undefined, 1);
    return results.length > 0 ? results[0] : null;
  }
  
  /**
   * è·å–è®°å½•æ€»æ•°
   * @param tableName è¡¨å
   * @param conditions æŸ¥è¯¢æ¡ä»¶
   * @returns è®°å½•æ€»æ•°
   */
  public async count(tableName: string, conditions?: Array<QueryCondition>): Promise<number> {
    try {
      const database = this.dbManager.getDatabase();
      
      let sql = `SELECT COUNT(*) as count FROM ${tableName}`;
      const bindArgs: ValueType[] = [];
      
      // æ·»åŠ æ¡ä»¶
      if (conditions && conditions.length > 0) {
        const whereClause = conditions.map(cond => {
          const operator = cond.operator || '=';
          if (operator === 'IN' || operator === 'NOT IN') {
            const placeholders = Array.isArray(cond.value)
              ? cond.value.map(() => '?').join(', ')
              : '?';
            return `${cond.column} ${operator} (${placeholders})`;
          }
          return `${cond.column} ${operator} ?`;
        }).join(' AND ');
        
        sql += ` WHERE ${whereClause}`;
        
        // å¤„ç†INæ¡ä»¶çš„å‚æ•?        conditions.forEach(cond => {
          if ((cond.operator === 'IN' || cond.operator === 'NOT IN') && Array.isArray(cond.value)) {
            bindArgs.push(...cond.value);
          } else if (cond.operator !== 'IN' && cond.operator !== 'NOT IN') {
            bindArgs.push(cond.value);
          }
        });
      }
      
      const result = await database.querySql(sql, bindArgs);
      if (result.firstItem) {
        const count = result.firstItem.getLong(result.columnNames.indexOf('count'));
        return count || 0;
      }
      return 0;
    } catch (error) {
      Logger.error(TAG, `Failed to count ${tableName}: ${JSON.stringify(error)}`);
      return 0;
    }
  }
  
  /**
   * æ£€æŸ¥è®°å½•æ˜¯å¦å­˜åœ?   * @param tableName è¡¨å
   * @param conditions æŸ¥è¯¢æ¡ä»¶
   * @returns æ˜¯å¦å­˜åœ¨
   */
  public async exists(tableName: string, conditions?: Array<QueryCondition>): Promise<boolean> {
    const count = await this.count(tableName, conditions);
    return count > 0;
  }
  
  /**
   * æ‰§è¡Œè‡ªå®šä¹‰SQLæŸ¥è¯¢
   * @param sql SQLè¯­å¥
   * @param bindArgs ç»‘å®šå‚æ•°
   * @returns æŸ¥è¯¢ç»“æœ
   */
  public async executeCustomQuery<T>(sql: string, bindArgs?: ValueType[]): Promise<T[]> {
    try {
      const database = this.dbManager.getDatabase();
      
      Logger.debug(TAG, `Executing custom query: ${sql}, args: ${JSON.stringify(bindArgs)}`);
      
      const result = await database.querySql(sql, bindArgs);
      
      // å¤„ç†ç»“æœ
      const records: T[] = [];
      while (result.goToNextRow()) {
        const record: DatabaseRecord = {};
        result.columnNames.forEach((column, index) => {
          // æ ¹æ®æ•°æ®ç±»å‹è·å–å€?          const value = result.getDouble(index);
          if (!isNaN(value)) {
            // å¦‚æœæ˜¯æ•´æ•°ï¼Œè½¬æ¢ä¸ºæ•´æ•?            if (Number.isInteger(value)) {
              record[column] = Math.floor(value);
            } else {
              record[column] = value;
            }
          } else {
            // å°è¯•è·å–å­—ç¬¦ä¸?            record[column] = result.getString(index);
          }
        });
        records.push(record);
      }
      
      return records;
    } catch (error) {
      Logger.error(TAG, `Failed to execute custom query: ${JSON.stringify(error)}`);
      return [];
    }
  }
}
