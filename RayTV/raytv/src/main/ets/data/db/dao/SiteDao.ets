// SiteDao.ets - ç«™ç‚¹æ•°æ®è®¿é—®å¯¹è±¡
// è´Ÿè´£ç«™ç‚¹æ•°æ®çš„å¢åˆ æ”¹æŸ¥æ“ä½?
import relationalStore from '@ohos.data.relationalStore';
import { DatabaseManager, ValueType } from '../DatabaseManager';
import { SITE_TABLE } from '../TableSchema';
import { Site } from '../../bean/Site';
import Logger from '../../../common/util/Logger';
import JsonUtil from '../../../common/util/JsonUtil';

/**
 * ç«™ç‚¹æ•°æ®è®¿é—®å¯¹è±¡
 */
export class SiteDao {
  private readonly TAG: string = 'SiteDao';
  private dbManager: DatabaseManager;
  
  /**
   * æ„é€ å‡½æ•?   */
  constructor() {
    this.dbManager = DatabaseManager.getInstance();
  }
  
  /**
   * æ’å…¥ç«™ç‚¹
   * @param site ç«™ç‚¹ä¿¡æ¯
   * @returns Promise<void>
   */
  public async insert(site: Site): Promise<void> {
    try {
      const valuesBucket: relationalStore.ValuesBucket = this.createValuesBucket(site);
      await this.dbManager.insert(SITE_TABLE.TABLE_NAME, valuesBucket);
      Logger.info(this.TAG, `Inserted site: ${site.name} (${site.key})`);
    } catch (error) {
      Logger.error(this.TAG, `Failed to insert site: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  
  /**
   * æ‰¹é‡æ’å…¥ç«™ç‚¹
   * @param sites ç«™ç‚¹åˆ—è¡¨
   * @returns Promise<void>
   */
  public async batchInsert(sites: Site[]): Promise<void> {
    try {
      await this.dbManager.executeTransaction(async (connection) => {
        for (const site of sites) {
          const valuesBucket = this.createValuesBucket(site);
          await connection.insert(SITE_TABLE.TABLE_NAME, valuesBucket instanceof Error ? valuesBucket : new Error(String(valuesBucket instanceof Error ? valuesBucket instanceof Error ? valuesBucket : new Error(String(valuesBucket : new Error(String(valuesBucket instanceof Error ? valuesBucket : new Error(String(valuesBucket instanceof Error ? valuesBucket instanceof Error ? valuesBucket : new Error(String(valuesBucket instanceof Error ? valuesBucket instanceof Error ? valuesBucket : new Error(String(valuesBucket : new Error(String(valuesBucket instanceof Error ? valuesBucket : new Error(String(valuesBucket : new Error(String(valuesBucket instanceof Error ? valuesBucket : new Error(String(valuesBucket instanceof Error ? valuesBucket instanceof Error ? valuesBucket : new Error(String(valuesBucket : new Error(String(valuesBucket instanceof Error ? valuesBucket : new Error(String(valuesBucket)))))));
          Logger.debug(this.TAG, `Batch inserted site: ${site.name}`);
        }
      });
      Logger.info(this.TAG, `Successfully batch inserted ${sites.length} sites`);
    } catch (error) {
      Logger.error(this.TAG, `Failed to batch insert sites: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ›´æ–°ç«™ç‚¹
   * @param site ç«™ç‚¹ä¿¡æ¯
   * @returns Promise<void>
   */
  public async update(site: Site): Promise<void> {
    try {
      const valuesBucket: relationalStore.ValuesBucket = {
        [SITE_TABLE.COLUMNS.NAME]: site.name, [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( instanceof Error ? [SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries( : new Error(String([SITE_TABLE.COLUMNS.TYPE]: site.type,
        [SITE_TABLE.COLUMNS.API]: site.api,
        [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
        [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
        [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries())))))))) : null,
        [SITE_TABLE.COLUMNS.COOKIE]: site.cookie || null,
        [SITE_TABLE.COLUMNS.EXT]: site.ext ? JsonUtil.stringify(site.ext) : null,
        [SITE_TABLE.COLUMNS.ENABLED]: site.enabled ? 1 : 0,
        [SITE_TABLE.COLUMNS.ORDER]: site.order,
        [SITE_TABLE.COLUMNS.UPDATED_AT]: site.updatedAt
      };
      
      const predicates = new relationalStore.RdbPredicates(SITE_TABLE.TABLE_NAME);
      predicates.equalTo(SITE_TABLE.COLUMNS.KEY, site.key);
      
      const count = await this.dbManager.update(valuesBucket, predicates);
      if (count > 0) {
        Logger.info(this.TAG, `Updated site: ${site.name} (${site.key})`);
      } else {
        Logger.warn(this.TAG, `Site not found for update: ${site.key}`);
      }
    } catch (error) {
      Logger.error(this.TAG, `Failed to update site: ${error}`);
      throw error;
    }
  }
  
  /**
   * åˆ é™¤ç«™ç‚¹
   * @param key ç«™ç‚¹key
   * @returns Promise<void>
   */
  public async delete(key: string): Promise<void> {
    try {
      const predicates = new relationalStore.RdbPredicates(SITE_TABLE.TABLE_NAME);
      predicates.equalTo(SITE_TABLE.COLUMNS.KEY, key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key)))))));
      
      const count = await this.dbManager.delete(predicates);
      if (count > 0) {
        Logger.info(this.TAG, `Deleted site: ${key}`);
      } else {
        Logger.warn(this.TAG, `Site not found for deletion: ${key}`);
      }
    } catch (error) {
      Logger.error(this.TAG, `Failed to delete site: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ¸…ç©ºæ‰€æœ‰ç«™ç‚?   * @returns Promise<void>
   */
  public async clearAll(): Promise<void> {
    try {
      const predicates = new relationalStore.RdbPredicates(SITE_TABLE.TABLE_NAME);
      const count = await this.dbManager.delete(predicates);
      Logger.info(this.TAG, `Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites` instanceof Error ? `Cleared all ${count} sites` : new Error(String(`Cleared all ${count} sites`)))))));
    } catch (error) {
      Logger.error(this.TAG, `Failed to clear all sites: ${error}`);
      throw error;
    }
  }
  
  /**
   * è·å–æ‰€æœ‰ç«™ç‚?   * @returns Promise<Site[]> ç«™ç‚¹åˆ—è¡¨
   */
  public async getAll(): Promise<Site[]> {
    try {
      const predicates = new relationalStore.RdbPredicates(SITE_TABLE.TABLE_NAME);
      predicates.orderByAsc(SITE_TABLE.COLUMNS.ORDER);
      
      const resultSet = await this.dbManager.query(predicates);
      return this.parseResultSet(resultSet);
    } catch (error) {
      Logger.error(this.TAG, `Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}` instanceof Error ? `Failed to get all sites: ${error}` : new Error(String(`Failed to get all sites: ${error}`)))))));
      throw error;
    }
  }
  
  /**
   * è·å–å¯ç”¨çš„ç«™ç‚?   * @returns Promise<Site[]> å¯ç”¨çš„ç«™ç‚¹åˆ—è¡?   */
  public async getEnabled(): Promise<Site[]> {
    try {
      const predicates = new relationalStore.RdbPredicates(SITE_TABLE.TABLE_NAME);
      predicates.equalTo(SITE_TABLE.COLUMNS.ENABLED, 1);
      predicates.orderByAsc(SITE_TABLE.COLUMNS.ORDER);
      
      const resultSet = await this.dbManager.query(predicates);
      return this.parseResultSet(resultSet);
    } catch (error) {
      Logger.error(this.TAG, `Failed to get enabled sites: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ ¹æ®ç±»å‹è·å–ç«™ç‚¹
   * @param type ç«™ç‚¹ç±»å‹
   * @returns Promise<Site[]> æŒ‡å®šç±»å‹çš„ç«™ç‚¹åˆ—è¡?   */
  public async getByType(type: string): Promise<Site[]> {
    try {
      const predicates = new relationalStore.RdbPredicates(SITE_TABLE.TABLE_NAME);
      predicates.equalTo(SITE_TABLE.COLUMNS.TYPE, type instanceof Error ? type : new Error(String(type instanceof Error ? type instanceof Error ? type : new Error(String(type : new Error(String(type instanceof Error ? type : new Error(String(type instanceof Error ? type instanceof Error ? type : new Error(String(type instanceof Error ? type instanceof Error ? type : new Error(String(type : new Error(String(type instanceof Error ? type : new Error(String(type : new Error(String(type instanceof Error ? type : new Error(String(type instanceof Error ? type instanceof Error ? type : new Error(String(type : new Error(String(type instanceof Error ? type : new Error(String(type)))))));
      predicates.equalTo(SITE_TABLE.COLUMNS.ENABLED, 1);
      predicates.orderByAsc(SITE_TABLE.COLUMNS.ORDER);
      
      const resultSet = await this.dbManager.query(predicates);
      return this.parseResultSet(resultSet);
    } catch (error) {
      Logger.error(this.TAG, `Failed to get sites by type: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ ¹æ®keyè·å–ç«™ç‚¹
   * @param key ç«™ç‚¹key
   * @returns Promise<Site | null> ç«™ç‚¹ä¿¡æ¯ï¼Œä¸å­˜åœ¨åˆ™è¿”å›null
   */
  public async getByKey(key: string): Promise<Site | null> {
    try {
      const predicates = new relationalStore.RdbPredicates(SITE_TABLE.TABLE_NAME);
      predicates.equalTo(SITE_TABLE.COLUMNS.KEY, key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key)))))));
      
      const resultSet = await this.dbManager.query(predicates);
      const sites = this.parseResultSet(resultSet);
      return sites.length > 0 ? sites[0] : null;
    } catch (error) {
      Logger.error(this.TAG, `Failed to get site by key: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ‰¹é‡æ›´æ–°ç«™ç‚¹å¯ç”¨çŠ¶æ€?   * @param keys ç«™ç‚¹keyåˆ—è¡¨
   * @param enabled æ˜¯å¦å¯ç”¨
   * @returns Promise<void>
   */
  public async batchUpdateEnabled(keys: string[], enabled: boolean instanceof Error ? enabled: boolean : new Error(String(enabled: boolean instanceof Error ? enabled: boolean instanceof Error ? enabled: boolean : new Error(String(enabled: boolean : new Error(String(enabled: boolean instanceof Error ? enabled: boolean : new Error(String(enabled: boolean instanceof Error ? enabled: boolean instanceof Error ? enabled: boolean : new Error(String(enabled: boolean instanceof Error ? enabled: boolean instanceof Error ? enabled: boolean : new Error(String(enabled: boolean : new Error(String(enabled: boolean instanceof Error ? enabled: boolean : new Error(String(enabled: boolean : new Error(String(enabled: boolean instanceof Error ? enabled: boolean : new Error(String(enabled: boolean instanceof Error ? enabled: boolean instanceof Error ? enabled: boolean : new Error(String(enabled: boolean : new Error(String(enabled: boolean instanceof Error ? enabled: boolean : new Error(String(enabled: boolean))))))): Promise<void> {
    try {
      if (keys.length === 0) {
        return;
      }
      
      const valuesBucket: relationalStore.ValuesBucket = {
        [SITE_TABLE.COLUMNS.ENABLED]: enabled ? 1 : 0,
        [SITE_TABLE.COLUMNS.UPDATED_AT]: Date.now()
      };
      
      const predicates = new relationalStore.RdbPredicates(SITE_TABLE.TABLE_NAME);
      predicates.in(SITE_TABLE.COLUMNS.KEY, keys);
      
      const count = await this.dbManager.update(valuesBucket, predicates);
      Logger.info(this.TAG, `Updated enabled status for ${count} sites`);
    } catch (error) {
      Logger.error(this.TAG, `Failed to batch update enabled status: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ›´æ–°ç«™ç‚¹é¡ºåº
   * @param key ç«™ç‚¹key
   * @param order æ–°çš„é¡ºåº
   * @returns Promise<void>
   */
  public async updateOrder(key: string, order: number instanceof Error ? order: number : new Error(String(order: number instanceof Error ? order: number instanceof Error ? order: number : new Error(String(order: number : new Error(String(order: number instanceof Error ? order: number : new Error(String(order: number instanceof Error ? order: number instanceof Error ? order: number : new Error(String(order: number instanceof Error ? order: number instanceof Error ? order: number : new Error(String(order: number : new Error(String(order: number instanceof Error ? order: number : new Error(String(order: number : new Error(String(order: number instanceof Error ? order: number : new Error(String(order: number instanceof Error ? order: number instanceof Error ? order: number : new Error(String(order: number : new Error(String(order: number instanceof Error ? order: number : new Error(String(order: number))))))): Promise<void> {
    try {
      const valuesBucket: relationalStore.ValuesBucket = {
        [SITE_TABLE.COLUMNS.ORDER]: order,
        [SITE_TABLE.COLUMNS.UPDATED_AT]: Date.now()
      };
      
      const predicates = new relationalStore.RdbPredicates(SITE_TABLE.TABLE_NAME);
      predicates.equalTo(SITE_TABLE.COLUMNS.KEY, key);
      
      await this.dbManager.update(valuesBucket, predicates);
      Logger.info(this.TAG, `Updated order for site ${key} to ${order}`);
    } catch (error) {
      Logger.error(this.TAG, `Failed to update site order: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ£€æŸ¥ç«™ç‚¹æ˜¯å¦å­˜åœ?   * @param key ç«™ç‚¹key
   * @returns Promise<boolean> æ˜¯å¦å­˜åœ¨
   */
  public async exists(key: string): Promise<boolean> {
    try {
      const predicates = new relationalStore.RdbPredicates(SITE_TABLE.TABLE_NAME);
      predicates.equalTo(SITE_TABLE.COLUMNS.KEY, key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key instanceof Error ? key instanceof Error ? key : new Error(String(key : new Error(String(key instanceof Error ? key : new Error(String(key)))))));
      predicates.limit(1);
      
      const resultSet = await this.dbManager.query(predicates);
      const exists = resultSet.rowCount > 0;
      resultSet.close();
      return exists;
    } catch (error) {
      Logger.error(this.TAG, `Failed to check if site exists: ${error}`);
      return false;
    }
  }
  
  /**
   * æœç´¢ç«™ç‚¹
   * @param keyword æœç´¢å…³é”®è¯?   * @returns Promise<Site[]> åŒ¹é…çš„ç«™ç‚¹åˆ—è¡?   */
  public async search(keyword: string): Promise<Site[]> {
    try {
      const sql = `
        SELECT * FROM ${SITE_TABLE.TABLE_NAME}
        WHERE ${SITE_TABLE.COLUMNS.NAME} LIKE ? OR ${SITE_TABLE.COLUMNS.KEY} LIKE ?
        ORDER BY ${SITE_TABLE.COLUMNS.ORDER} ASC
      `;
      
      const bindArgs: ValueType[] = [`%${keyword}%`, `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( instanceof Error ? `%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase( : new Error(String(`%${keyword}%`];
      const resultSet = await this.dbManager.getDatabase())))))).querySql(sql, bindArgs);
      
      return this.parseResultSet(resultSet);
    } catch (error) {
      Logger.error(this.TAG, `Failed to search sites: ${error}`);
      throw error;
    }
  }
  
  /**
   * è·å–ç«™ç‚¹æ•°é‡
   * @returns Promise<number> ç«™ç‚¹æ•°é‡
   */
  public async getCount(): Promise<number> {
    try {
      const sql = `SELECT COUNT(*) FROM ${SITE_TABLE.TABLE_NAME}`;
      const resultSet = await this.dbManager.getDatabase().querySql(sql);
      
      let count = 0;
      if (resultSet.rowCount > 0) {
        resultSet.goToFirstRow();
        count = resultSet.getLong(resultSet.getColumnIndex(0));
      }
      
      resultSet.close();
      return count;
    } catch (error) {
      Logger.error(this.TAG, `Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}` instanceof Error ? `Failed to get site count: ${error}` : new Error(String(`Failed to get site count: ${error}`)))))));
      return 0;
    }
  }
  
  /**
   * è§£æç»“æœé›?   * @param resultSet æŸ¥è¯¢ç»“æœé›?   * @returns Site[] ç«™ç‚¹åˆ—è¡¨
   * @private
   */
  private parseResultSet(resultSet: relationalStore.ResultSet): Site[] {
    const sites: Site[] = [];
    
    try {
      if (resultSet.rowCount > 0) {
        resultSet.goToFirstRow();
        do {
          const headersStr = resultSet.getString(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.HEADERS));
          const headers = headersStr ? new Map<string, string>(JSON.parse(headersStr)) : undefined;
          
          const extStr = resultSet.getString(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.EXT));
          const ext = extStr ? JSON.parse(extStr) : undefined;
          
          sites.push({
            key: resultSet.getString(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.KEY)),
            name: resultSet.getString(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.NAME)),
            type: resultSet.getString(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.TYPE)),
            api: resultSet.getString(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.API)),
            searchable: resultSet.getLong(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.SEARCHABLE)) === 1,
            filterable: resultSet.getLong(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.FILTERABLE)) === 1,
            headers,
            cookie: resultSet.getString(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.COOKIE)),
            ext,
            enabled: resultSet.getLong(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.ENABLED)) === 1,
            order: resultSet.getLong(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.ORDER)),
            createdAt: resultSet.getLong(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.CREATED_AT)),
            updatedAt: resultSet.getLong(resultSet.getColumnIndex(SITE_TABLE.COLUMNS.UPDATED_AT))
          });
        } while (resultSet.goToNextRow());
      }
    } finally {
      resultSet.close();
    }
    
    return sites;
  }
  
  /**
   * åˆ›å»ºå€¼æ¡¶
   * @param site ç«™ç‚¹ä¿¡æ¯
   * @returns relationalStore.ValuesBucket å€¼æ¡¶
   * @private
   */
  private createValuesBucket(site: Site): relationalStore.ValuesBucket {
    return {
      [SITE_TABLE.COLUMNS.KEY]: site.key,
      [SITE_TABLE.COLUMNS.NAME]: site.name,
      [SITE_TABLE.COLUMNS.TYPE]: site.type,
      [SITE_TABLE.COLUMNS.API]: site.api,
      [SITE_TABLE.COLUMNS.SEARCHABLE]: site.searchable ? 1 : 0,
      [SITE_TABLE.COLUMNS.FILTERABLE]: site.filterable ? 1 : 0,
      [SITE_TABLE.COLUMNS.HEADERS]: site.headers ? JsonUtil.stringify(Array.from(site.headers.entries())) : null,
      [SITE_TABLE.COLUMNS.COOKIE]: site.cookie || null,
      [SITE_TABLE.COLUMNS.EXT]: site.ext ? JsonUtil.stringify(site.ext) : null,
      [SITE_TABLE.COLUMNS.ENABLED]: site.enabled ? 1 : 0,
      [SITE_TABLE.COLUMNS.ORDER]: site.order,
      [SITE_TABLE.COLUMNS.CREATED_AT]: site.createdAt,
      [SITE_TABLE.COLUMNS.UPDATED_AT]: site.updatedAt
    };
  }
}


