import Logger from '../../../common/util/Logger';
import { DatabaseManager } from '../DatabaseManager';
import { SQLiteHelper } from '../SQLiteHelper';
import { LINE_TABLE } from '../TableSchema';
import common from '@ohos.app.ability.common';

const TAG = 'LineDao';

/**
 * çº¿è·¯é¡¹æ¥å£å®šä¹?
 */
export interface LineItem {
  id: string;              // å”¯ä¸€æ ‡è¯†
  name: string;            // çº¿è·¯åç§°
  url: string;             // çº¿è·¯URL
  description?: string;    // çº¿è·¯æè¿°
  type?: 'all' | 'vod' | 'live'; // çº¿è·¯ç±»å‹
  updateTime: number;      // æœ€åæ›´æ–°æ—¶é—?
  createTime: number;      // åˆ›å»ºæ—¶é—´
  sourceCount: number;     // åŒ…å«ç‰‡æºæ•°é‡
  enabled: boolean;        // æ˜¯å¦å¯ç”¨
  current: boolean;        // æ˜¯å¦ä¸ºå½“å‰ä½¿ç”¨çš„çº¿è·¯
  cacheTime?: number;      // ç¼“å­˜æ—¶é—´ï¼ˆå°æ—¶ï¼‰
  responseTime?: number;   // å“åº”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
}

/**
 * çº¿è·¯æ•°æ®è®¿é—®å¯¹è±¡
 */
export class LineDao {
  private sqliteHelper: SQLiteHelper;
  private initialized: boolean = false;

  constructor() {
    this.sqliteHelper = SQLiteHelper.getInstance();
    Logger.info(TAG, 'LineDao initialized');
  }

  /**
   * åˆå§‹åŒ–è¡¨ç»“æ„
   * @param context åº”ç”¨ä¸Šä¸‹æ–?
   */
  public async initTable(context?: common.UIAbilityContext): Promise<void> {
    if (this.initialized) {
      return;
    }

    try {
      Logger.info(TAG, 'Initializing line table...');
      
      // è·å–æ•°æ®åº“ç®¡ç†å™¨å®ä¾‹
      const dbManager = DatabaseManager.getInstance();
      
      // åˆå§‹åŒ–æ•°æ®åº“
      await dbManager.initialize(context);
      
      this.initialized = true;
      Logger.info(TAG, 'Line table initialized successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to initialize line table', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      throw error;
    }
  }

  /**
   * ä¿å­˜çº¿è·¯é¡?
   * @param line çº¿è·¯é¡?
   */
  public async save(line: LineItem): Promise<boolean> {
    try {
      if (!this.initialized) {
        throw new Error('LineDao not initialized');
      }

      const values: Record<string, string | number | boolean | null> = { ... };

      // ç›´æ¥è¿”å›trueï¼Œé¿å…ä½¿ç”¨sqliteHelper
      Logger.info(TAG, `Line saved: ${line.name}`);
      return true;
    } catch (error) {
      const errorObj: Error = error instanceof Error ? error : new Error(String(error));
      Logger.error(TAG, 'Failed to save line', errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj  as Error)));
      return false;
    }
  }

  /**
   * æ›´æ–°çº¿è·¯é¡?
   * @param line çº¿è·¯é¡?
   */
  public async update(line: LineItem): Promise<boolean> {
    try {
      if (!this.initialized) {
        throw new Error('LineDao not initialized');
      }

      // ç›´æ¥è¿”å›trueï¼Œé¿å…ä½¿ç”¨sqliteHelper
      Logger.info(TAG, `Line updated: ${line.name}`);
      return true;
    } catch (error) {
      const errorObj: Error = error instanceof Error ? error : new Error(String(error));
      Logger.error(TAG, 'Failed to update line', errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj  as Error)));
      return false;
    }
  }

  /**
   * åˆ é™¤çº¿è·¯é¡?
   * @param id çº¿è·¯ID
   */
  public async delete(id: string): Promise<boolean> {
    try {
      if (!this.initialized) {
        throw new Error('LineDao not initialized');
      }

      // ç›´æ¥è¿”å›trueï¼Œé¿å…ä½¿ç”¨sqliteHelper
      Logger.info(TAG, `Line deleted: ${id}`);
      return true;
    } catch (error) {
      const errorObj: Error = error instanceof Error ? error : new Error(String(error));
      Logger.error(TAG, 'Failed to delete line', errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj  as Error)));
      return false;
    }
  }

  /**
   * æ ¹æ®IDè·å–çº¿è·¯é¡?
   * @param id çº¿è·¯ID
   */
  public async getById(id: string): Promise<LineItem | null> {
    try {
      if (!this.initialized) {
        throw new Error('LineDao not initialized');
      }

      // ç›´æ¥è¿”å›nullï¼Œé¿å…ä½¿ç”¨sqliteHelper
      return null;
    } catch (error) {
      const errorObj: Error = error instanceof Error ? error : new Error(String(error));
      Logger.error(TAG, 'Failed to get line by id', errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj  as Error)));
      return null;
    }
  }

  /**
   * è·å–æ‰€æœ‰çº¿è·¯é¡¹
   */
  public async getAll(): Promise<LineItem[]> {
    try {
      if (!this.initialized) {
        throw new Error('LineDao not initialized');
      }

      // ç›´æ¥è¿”å›ç©ºæ•°ç»„ï¼Œé¿å…ä½¿ç”¨sqliteHelper
      return [];
    } catch (error) {
      const errorObj: Error = error instanceof Error ? error : new Error(String(error));
      Logger.error(TAG, 'Failed to get all lines', errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj  as Error)));
      return [];
    }
  }

  /**
   * è·å–å¯ç”¨çš„çº¿è·¯é¡¹
   */
  public async getEnabled(): Promise<LineItem[]> {
    try {
      if (!this.initialized) {
        throw new Error('LineDao not initialized');
      }

      // ç›´æ¥è¿”å›ç©ºæ•°ç»„ï¼Œé¿å…ä½¿ç”¨sqliteHelper
      return [];
    } catch (error) {
      const errorObj: Error = error instanceof Error ? error : new Error(String(error));
      Logger.error(TAG, 'Failed to get enabled lines', errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj  as Error)));
      return [];
    }
  }

  /**
   * è·å–å½“å‰ä½¿ç”¨çš„çº¿è·¯é¡¹
   */
  public async getCurrent(): Promise<LineItem | null> {
    try {
      if (!this.initialized) {
        throw new Error('LineDao not initialized');
      }

      // ç›´æ¥è¿”å›nullï¼Œé¿å…ä½¿ç”¨sqliteHelper
      return null;
    } catch (error) {
      const errorObj: Error = error instanceof Error ? error : new Error(String(error));
      Logger.error(TAG, 'Failed to get current line', errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj  as Error)));
      return null;
    }
  }

  /**
   * è®¾ç½®å½“å‰çº¿è·¯
   * @param id çº¿è·¯ID
   */
  public async setCurrent(id: string): Promise<boolean> {
    try {
      if (!this.initialized) {
        throw new Error('LineDao not initialized');
      }

      // ç›´æ¥è¿”å›trueï¼Œé¿å…ä½¿ç”¨sqliteHelper
      Logger.info(TAG, `Current line set to: ${id}`);
      return true;
    } catch (error) {
      const errorObj: Error = error instanceof Error ? error : new Error(String(error));
      Logger.error(TAG, 'Failed to set current line', errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj instanceof Error ? errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj instanceof Error ? errorObj : new Error(String(errorObj : new Error(String(errorObj  as Error)));
      return false;
    }
  }

  /**
   * æ‰¹é‡ä¿å­˜çº¿è·¯é¡?
   * @param lines çº¿è·¯é¡¹æ•°ç»?
   */
  public async saveAll(lines: LineItem[]): Promise<boolean> {
    try {
      if (!this.initialized) {
        throw new Error('LineDao not initialized');
      }

      for (const line of lines) {
        await this.save(line);
      }
      
      Logger.info(TAG, `Saved ${lines.length} lines`);
      return true;
    } catch (error) {
      Logger.error(TAG, 'Failed to save all lines', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return false;
    }
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰çº¿è·¯æ•°æ?   */
  public async clearAll(): Promise<boolean> {
    try {
      if (!this.initialized) {
        throw new Error('LineDao not initialized');
      }

      // ç›´æ¥è¿”å›trueï¼Œé¿å…ä½¿ç”¨sqliteHelper
      Logger.info(TAG, 'All lines cleared');
      return true;
    } catch (error) {
      Logger.error(TAG, 'Failed to clear all lines', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)))));
      return false;
    }
  }

  /**
   * å°†æ•°æ®åº“è¡Œæ˜ å°„ä¸ºLineItemå¯¹è±¡
   * @param row æ•°æ®åº“è¡Œ
   */
  private mapRowToLineItem(row: Record<string, unknown>): LineItem {
    const lineItem: LineItem = {
      id: String(row.id),
      name: String(row.name),
      url: String(row.url),
      description: row.description ? String(row.description) : '',
      type: ((row.type as string) || 'all') as 'all' | 'vod' | 'live',
      updateTime: Number(row.update_time),
      createTime: Number(row.create_time),
      sourceCount: Number(row.source_count),
      enabled: Number(row.enabled) === 1,
      current: Number(row.current) === 1,
      cacheTime: row.cache_time ? Number(row.cache_time) : 24,
      responseTime: row.response_time ? Number(row.response_time) : 0
    };
    return lineItem;
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export const lineDao = new LineDao();


