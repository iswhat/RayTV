// SearchResult - æœç´¢ç»“æœå®ä½“ç±?import Logger from '../../common/util/Logger';
import { VideoType } from './Movie';

const TAG = 'SearchResult';

/**
 * æœç´¢ç»“æœç±»å‹æšä¸¾
 */
export enum ResultType {
  MOVIE,          // ç”µå½±
  TV_SERIES,      // ç”µè§†å‰?  ANIME,          // åŠ¨æ¼«
  DOCUMENTARY,    // çºªå½•ç‰?  VARIETY,        // ç»¼è‰º
  ACTOR,          // æ¼”å‘˜
  DIRECTOR,       // å¯¼æ¼”
  GENRE,          // ç±»å‹
  TAG,            // æ ‡ç­¾
  CHANNEL,        // é¢‘é“
  COLLECTION,     // åˆé›†
  LIVE,           // ç›´æ’­
  OTHER           // å…¶ä»–
}

/**
 * é¢å¤–ä¿¡æ¯ç±»å‹å®šä¹‰
 */
export interface ExtraInfo {
  extraData?: Record<string, string | number | boolean | null | NestedExtraInfo>;
}

/**
 * åµŒå¥—é¢å¤–ä¿¡æ¯ç±»å‹å®šä¹‰
 */
export interface NestedExtraInfo {
  nestedData?: Record<string, string | number | boolean | null>;
}

/**
 * æœç´¢ç»“æœå®ä½“ç±? * å®šä¹‰æœç´¢ç»“æœçš„æ•°æ®ç»“æ„å’Œç›¸å…³æ“ä½œ
 */
export default class SearchResult {
  id: string;              // ç»“æœå”¯ä¸€æ ‡è¯†
  title: string;           // æ ‡é¢˜
  originalTitle?: string;  // åŸå§‹æ ‡é¢˜
  type: ResultType;        // ç»“æœç±»å‹
  coverUrl?: string;       // å°é¢å›¾ç‰‡URL
  backdropUrl?: string;    // èƒŒæ™¯å›¾ç‰‡URL
  description?: string;    // æè¿°/ç®€ä»?  score?: number;          // è¯„åˆ†
  year?: number;           // å¹´ä»½
  releaseDate?: string;    // å‘å¸ƒæ—¥æœŸ
  genres?: string[];       // ç±»å‹æ ‡ç­¾
  tags?: string[];         // æ ‡ç­¾
  duration?: number;       // æ—¶é•¿ï¼ˆç§’ï¼?  totalEpisodes?: number;  // æ€»é›†æ•?  currentSeason?: number;  // å½“å‰å­£æ•°
  actors?: string[];       // æ¼”å‘˜åˆ—è¡¨ï¼ˆé’ˆå¯¹å†…å®¹ç±»å‹ï¼‰
  directors?: string[];    // å¯¼æ¼”åˆ—è¡¨ï¼ˆé’ˆå¯¹å†…å®¹ç±»å‹ï¼‰
  popularity?: number;     // çƒ­åº¦/æµè¡Œåº?  matchScore?: number;     // åŒ¹é…åˆ†æ•°ï¼ˆæœç´¢ç›¸å…³æ€§ï¼‰
  extraInfo?: ExtraInfo; // é¢å¤–ä¿¡æ¯ï¼Œä½¿ç”¨æ›´æ˜ç¡®çš„ç±»å‹å®šä¹?  link?: string;           // å…³è”é“¾æ¥
  sourceId?: string;       // æ¥æºID
  sourceName?: string;     // æ¥æºåç§°

  /**
   * æ„é€ å‡½æ•?   */
  constructor(data: Partial<SearchResult>) {
    this.id = data.id ?? `result_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    this.title = data.title ?? '';
    this.originalTitle = data.originalTitle;
    this.type = data.type ?? ResultType.OTHER;
    this.coverUrl = data.coverUrl;
    this.backdropUrl = data.backdropUrl;
    this.description = data.description;
    this.score = data.score;
    this.year = data.year;
    this.releaseDate = data.releaseDate;
    this.genres = data.genres ?? [];
    this.tags = data.tags ?? [];
    this.duration = data.duration;
    this.totalEpisodes = data.totalEpisodes;
    this.currentSeason = data.currentSeason;
    this.actors = data.actors ?? [];
    this.directors = data.directors ?? [];
    this.popularity = data.popularity;
    this.matchScore = data.matchScore;
    // ç¡®ä¿extraInfoæ˜¯æœ‰æ•ˆçš„å¯¹è±¡ç±»å‹ï¼Œä½¿ç”¨æ˜ç¡®çš„ç±»å‹åˆå§‹åŒ?    if (data.extraInfo && typeof data.extraInfo === 'object' && !Array.isArray(data.extraInfo)) {
      this.extraInfo = data.extraInfo as ExtraInfo;
    } else {
      // ä½¿ç”¨ç©ºå¯¹è±¡å­—é¢é‡ï¼Œæ˜ç¡®ç±»å?      this.extraInfo = this.createEmptyExtraInfo();
    }
    this.link = data.link;
    this.sourceId = data.sourceId;
    this.sourceName = data.sourceName;
  }

  /**
   * åˆ›å»ºç©ºçš„ExtraInfoå¯¹è±¡
   * @returns ç©ºçš„ExtraInfoå¯¹è±¡
   */
  private createEmptyExtraInfo(): ExtraInfo {
    return {
      extraData: undefined
    };
  }

  /**
   * åˆ›å»ºç©ºçš„extraDataè®°å½•
   * @returns ç©ºçš„Recordå¯¹è±¡
   */
  private createEmptyExtraData(): Record<string, string | number | boolean | null | NestedExtraInfo> {
    return {};
  }

  /**
   * è·å–ç±»å‹çš„æ–‡æœ¬æè¿?   * @returns ç±»å‹æè¿°
   */
  public getTypeDescription(): string {
    switch (this.type) {
      case ResultType.MOVIE:
        return 'ç”µå½±';
      case ResultType.TV_SERIES:
        return 'ç”µè§†å‰?;
      case ResultType.ANIME:
        return 'åŠ¨æ¼«';
      case ResultType.DOCUMENTARY:
        return 'çºªå½•ç‰?;
      case ResultType.VARIETY:
        return 'ç»¼è‰º';
      case ResultType.ACTOR:
        return 'æ¼”å‘˜';
      case ResultType.DIRECTOR:
        return 'å¯¼æ¼”';
      case ResultType.GENRE:
        return 'ç±»å‹';
      case ResultType.TAG:
        return 'æ ‡ç­¾';
      case ResultType.CHANNEL:
        return 'é¢‘é“';
      case ResultType.COLLECTION:
        return 'åˆé›†';
      case ResultType.LIVE:
        return 'ç›´æ’­';
      default:
        return 'å…¶ä»–';
    }
  }

  /**
   * è·å–ç±»å‹å¯¹åº”çš„VideoTypeï¼ˆå¦‚æœé€‚ç”¨ï¼?   * @returns VideoTypeæˆ–undefined
   */
  public getVideoType(): VideoType | undefined {
    switch (this.type) {
      case ResultType.MOVIE:
        return VideoType.MOVIE;
      case ResultType.TV_SERIES:
        return VideoType.TV_SERIES;
      case ResultType.ANIME:
        return VideoType.ANIME;
      case ResultType.DOCUMENTARY:
        return VideoType.DOCUMENTARY;
      case ResultType.VARIETY:
        return VideoType.VARIETY;
      case ResultType.LIVE:
        return VideoType.LIVE;
      default:
        return undefined;
    }
  }

  /**
   * è·å–æ ¼å¼åŒ–çš„è¯„åˆ†
   * @returns æ ¼å¼åŒ–çš„è¯„åˆ†å­—ç¬¦ä¸?   */
  public getFormattedScore(): string {
    if (this.score === undefined || this.score === null) {
      return '--';
    }
    return this.score.toFixed(1);
  }

  /**
   * è·å–æ ¼å¼åŒ–çš„å¹´ä»½
   * @returns å¹´ä»½å­—ç¬¦ä¸?   */
  public getFormattedYear(): string {
    if (this.year) {
      return this.year.toString();
    }
    if (this.releaseDate) {
      return this.releaseDate.substring(0, 4);
    }
    return '--';
  }

  /**
   * è·å–æ ¼å¼åŒ–çš„æ—¶é•¿
   * @returns æ—¶é•¿å­—ç¬¦ä¸?   */
  public getFormattedDuration(): string {
    if (!this.duration) {
      return '';
    }
    
    const hours = Math.floor(this.duration / 3600);
    const minutes = Math.floor((this.duration % 3600) / 60);
    
    if (hours > 0) {
      return `${hours}æ—?{minutes > 0 ? `${minutes}åˆ†` : ''}`;
    }
    return `${minutes}åˆ†é’Ÿ`;
  }

  /**
   * è·å–ç±»å‹æ ‡ç­¾å­—ç¬¦ä¸?   * @returns ç±»å‹æ ‡ç­¾å­—ç¬¦ä¸?   */
  public getGenresString(): string {
    return this.genres?.join(' / ') || '';
  }

  /**
   * è·å–æ¼”å‘˜åˆ—è¡¨å­—ç¬¦ä¸?   * @param maxCount æœ€å¤§æ˜¾ç¤ºæ•°é‡?   * @returns æ¼”å‘˜å­—ç¬¦ä¸?   */
  public getActorsString(maxCount: number = 3): string {
    if (!this.actors || this.actors.length === 0) {
      return '';
    }
    
    if (this.actors.length <= maxCount) {
      return this.actors.join('ã€?);
    }
    
    return `${this.actors.slice(0, maxCount).join('ã€?)}...`;
  }

  /**
   * è·å–å¯¼æ¼”åˆ—è¡¨å­—ç¬¦ä¸?   * @param maxCount æœ€å¤§æ˜¾ç¤ºæ•°é‡?   * @returns å¯¼æ¼”å­—ç¬¦ä¸?   */
  public getDirectorsString(maxCount: number = 2): string {
    if (!this.directors || this.directors.length === 0) {
      return '';
    }
    
    if (this.directors.length <= maxCount) {
      return this.directors.join('ã€?);
    }
    
    return `${this.directors.slice(0, maxCount).join('ã€?)}...`;
  }

  /**
   * è·å–ç®€æ´çš„æè¿°ï¼ˆé™åˆ¶é•¿åº¦ï¼‰
   * @param maxLength æœ€å¤§é•¿åº?   * @returns ç®€æ´æè¿?   */
  public getShortDescription(maxLength: number = 100): string {
    if (!this.description) {
      return '';
    }
    
    if (this.description.length <= maxLength) {
      return this.description;
    }
    
    return `${this.description.substring(0, maxLength)}...`;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºåª’ä½“å†…å®¹ç±»å‹ï¼ˆç”µå½±ã€ç”µè§†å‰§ç­‰ï¼‰
   * @returns æ˜¯å¦ä¸ºåª’ä½“å†…å®?   */
  public isMediaContent(): boolean {
    const mediaTypes = [
      ResultType.MOVIE,
      ResultType.TV_SERIES,
      ResultType.ANIME,
      ResultType.DOCUMENTARY,
      ResultType.VARIETY,
      ResultType.LIVE
    ];
    return mediaTypes.includes(this.type);
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºäººç‰©ç±»å‹ï¼ˆæ¼”å‘˜ã€å¯¼æ¼”ï¼‰
   * @returns æ˜¯å¦ä¸ºäººç‰?   */
  public isPersonType(): boolean {
    return this.type === ResultType.ACTOR || this.type === ResultType.DIRECTOR;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºåˆ†ç±»ç±»å‹ï¼ˆç±»å‹ã€æ ‡ç­¾ï¼‰
   * @returns æ˜¯å¦ä¸ºåˆ†ç±?   */
  public isCategoryType(): boolean {
    return this.type === ResultType.GENRE || this.type === ResultType.TAG || this.type === ResultType.CHANNEL;
  }

  /**
   * è·å–æ˜¾ç¤ºä¼˜å…ˆçº§ï¼ˆç”¨äºæœç´¢ç»“æœæ’åºï¼?   * @returns ä¼˜å…ˆçº§æ•°å€?   */
  public getDisplayPriority(): number {
    // å®šä¹‰ç±»å‹ä¼˜å…ˆçº?- ä½¿ç”¨switchè¯­å¥æ›¿ä»£å¯¹è±¡å­—é¢é‡ï¼Œé¿å…éæ ‡è¯†ç¬¦å±æ€§å
    let basePriority = 0;
    switch (this.type) {
      case ResultType.MOVIE:
        basePriority = 10;
        break;
      case ResultType.TV_SERIES:
        basePriority = 9;
        break;
      case ResultType.ANIME:
        basePriority = 8;
        break;
      case ResultType.LIVE:
        basePriority = 7;
        break;
      case ResultType.DOCUMENTARY:
        basePriority = 6;
        break;
      case ResultType.VARIETY:
        basePriority = 5;
        break;
      case ResultType.ACTOR:
        basePriority = 4;
        break;
      case ResultType.DIRECTOR:
        basePriority = 3;
        break;
      case ResultType.COLLECTION:
        basePriority = 2;
        break;
      case ResultType.GENRE:
      case ResultType.TAG:
      case ResultType.CHANNEL:
        basePriority = 1;
        break;
      case ResultType.OTHER:
      default:
        basePriority = 0;
        break;
    }

    // åŸºç¡€ä¼˜å…ˆçº?    let priority = basePriority;
    
    // ç»“åˆåŒ¹é…åˆ†æ•°
    if (this.matchScore) {
      priority += this.matchScore * 0.1;
    }
    
    // ç»“åˆçƒ­åº¦
    if (this.popularity) {
      priority += Math.min(1, this.popularity / 100);
    }
    
    // ç»“åˆè¯„åˆ†
    if (this.score) {
      priority += this.score / 10;
    }
    
    return priority;
  }

// å®šä¹‰SearchResultåºåˆ—åŒ–æ•°æ®æ¥å?export interface SearchResultSerializable {
  id: string;
  title: string;
  originalTitle?: string;
  type: ResultType;
  coverUrl?: string;
  backdropUrl?: string;
  description?: string;
  score?: number;
  year?: number;
  releaseDate?: string;
  genres?: string[];
  tags?: string[];
  duration?: number;
  totalEpisodes?: number;
  currentSeason?: number;
  actors?: string[];
  directors?: string[];
  popularity?: number;
  matchScore?: number;
  extraInfo?: ExtraInfo;
  link?: string;
  sourceId?: string;
  sourceName?: string;
}

  /**
   * åºåˆ—åŒ–å¯¹è±¡ï¼ˆç”¨äºå­˜å‚¨ï¼?   * @returns åºåˆ—åŒ–åçš„å¯¹è±?   */
  public toSerializable(): SearchResultSerializable {
    // åˆ›å»ºä¸€ä¸ªç¬¦åˆSearchResultSerializableæ¥å£çš„å¯¹è±¡ï¼Œé¿å…ä½¿ç”¨å¯¹è±¡å­—é¢é‡?    const result: SearchResultSerializable = {
      id: this.id,
      title: this.title,
      type: this.type
    };
    
    // é€ä¸ªèµ‹å€¼å¯é€‰å±æ€?    if (this.originalTitle !== undefined) {
      result.originalTitle = this.originalTitle;
    }
    if (this.coverUrl !== undefined) {
      result.coverUrl = this.coverUrl;
    }
    if (this.backdropUrl !== undefined) {
      result.backdropUrl = this.backdropUrl;
    }
    if (this.description !== undefined) {
      result.description = this.description;
    }
    if (this.score !== undefined) {
      result.score = this.score;
    }
    if (this.year !== undefined) {
      result.year = this.year;
    }
    if (this.releaseDate !== undefined) {
      result.releaseDate = this.releaseDate;
    }
    if (this.genres !== undefined) {
      result.genres = this.genres;
    }
    if (this.tags !== undefined) {
      result.tags = this.tags;
    }
    if (this.duration !== undefined) {
      result.duration = this.duration;
    }
    if (this.totalEpisodes !== undefined) {
      result.totalEpisodes = this.totalEpisodes;
    }
    if (this.currentSeason !== undefined) {
      result.currentSeason = this.currentSeason;
    }
    if (this.actors !== undefined) {
      result.actors = this.actors;
    }
    if (this.directors !== undefined) {
      result.directors = this.directors;
    }
    if (this.popularity !== undefined) {
      result.popularity = this.popularity;
    }
    if (this.matchScore !== undefined) {
      result.matchScore = this.matchScore;
    }
    if (this.extraInfo !== undefined) {
      result.extraInfo = this.extraInfo;
    }
    if (this.link !== undefined) {
      result.link = this.link;
    }
    if (this.sourceId !== undefined) {
      result.sourceId = this.sourceId;
    }
    if (this.sourceName !== undefined) {
      result.sourceName = this.sourceName;
    }
    
    return result;
  }

  /**
   * ä»åºåˆ—åŒ–å¯¹è±¡åˆ›å»ºSearchResultå®ä¾‹
   * @param data åºåˆ—åŒ–çš„æ•°æ®
   * @returns SearchResultå®ä¾‹
   */
  public static fromSerializable(data: SearchResultSerializable): SearchResult {
    // å‡†å¤‡extraInfo
    let extraInfo: ExtraInfo | undefined;
    if (data.extraInfo && typeof data.extraInfo === 'object' && !Array.isArray(data.extraInfo)) {
      // åˆ›å»ºä¸€ä¸ªæ˜ç¡®çš„ExtraInfoå¯¹è±¡ï¼Œä½¿ç”¨æ¥å£åˆå§‹åŒ–
      extraInfo = {
        extraData: {}
      };
      
      // æ£€æŸ¥extraDataå±æ€?      const extraInfoData = data.extraInfo as Record<string, string | number | boolean | null | Record<string, string | number | boolean | null>>;
      if (extraInfoData.extraData && typeof extraInfoData.extraData === 'object' && !Array.isArray(extraInfoData.extraData)) {
        const extraDataObj = extraInfoData.extraData as Record<string, string | number | boolean | null | Record<string, string | number | boolean | null>>;
        
        // å¤„ç†extraDataçš„æ¯ä¸ªå±æ€?        const extraDataKeys = Object.keys(extraDataObj);
        for (let i = 0; i < extraDataKeys.length; i++) {
          const key = extraDataKeys[i];
          const value = extraDataObj[key];
          
          if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) {
            extraInfo.extraData[key] = value;
          } else if (value && typeof value === 'object' && !Array.isArray(value)) {
            // å¤„ç†åµŒå¥—å¯¹è±¡
            const nestedInfo: NestedExtraInfo = {
              nestedData: {}
            };
            const nestedObj = value as Record<string, string | number | boolean | null>;
            
            const nestedKeys = Object.keys(nestedObj);
            for (let j = 0; j < nestedKeys.length; j++) {
              const nestedKey = nestedKeys[j];
              const nestedValue = nestedObj[nestedKey];
              
              if (typeof nestedValue === 'string' || typeof nestedValue === 'number' || 
                  typeof nestedValue === 'boolean' || nestedValue === null) {
                nestedInfo.nestedData[nestedKey] = nestedValue;
              }
            }
            
            extraInfo.extraData[key] = nestedInfo;
          }
        }
      }
    }
    
    // ç›´æ¥ä½¿ç”¨æ„é€ å‡½æ•°åˆ›å»ºå®ä¾?    const searchResultParams: Partial<SearchResult> = {
      id: typeof data.id === 'string' ? data.id : `result_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
      title: typeof data.title === 'string' ? data.title : '',
      originalTitle: typeof data.originalTitle === 'string' ? data.originalTitle : undefined,
      type: typeof data.type === 'number' ? data.type as ResultType : ResultType.OTHER,
      coverUrl: typeof data.coverUrl === 'string' ? data.coverUrl : undefined,
      backdropUrl: typeof data.backdropUrl === 'string' ? data.backdropUrl : undefined,
      description: typeof data.description === 'string' ? data.description : undefined,
      score: typeof data.score === 'number' ? data.score : undefined,
      year: typeof data.year === 'number' ? data.year : undefined,
      releaseDate: typeof data.releaseDate === 'string' ? data.releaseDate : undefined,
      genres: Array.isArray(data.genres) ? data.genres.filter(item => typeof item === 'string') : undefined,
      tags: Array.isArray(data.tags) ? data.tags.filter(item => typeof item === 'string') : undefined,
      duration: typeof data.duration === 'number' ? data.duration : undefined,
      totalEpisodes: typeof data.totalEpisodes === 'number' ? data.totalEpisodes : undefined,
      currentSeason: typeof data.currentSeason === 'number' ? data.currentSeason : undefined,
      actors: Array.isArray(data.actors) ? data.actors.filter(item => typeof item === 'string') : undefined,
      directors: Array.isArray(data.directors) ? data.directors.filter(item => typeof item === 'string') : undefined,
      popularity: typeof data.popularity === 'number' ? data.popularity : undefined,
      matchScore: typeof data.matchScore === 'number' ? data.matchScore : undefined,
      extraInfo: extraInfo,
      link: typeof data.link === 'string' ? data.link : undefined,
      sourceId: typeof data.sourceId === 'string' ? data.sourceId : undefined,
      sourceName: typeof data.sourceName === 'string' ? data.sourceName : undefined
    };
    
    return new SearchResult(searchResultParams);
  }

  /**
   * å…‹éš†SearchResultå®ä¾‹
   * @returns å…‹éš†åçš„å®ä¾‹
   */
  public clone(): SearchResult {
    // åˆ›å»ºä¸€ä¸ªç¬¦åˆPartial<SearchResult>ç±»å‹çš„å¯¹è±¡ï¼Œé¿å…ç›´æ¥ä½¿ç”¨å¯¹è±¡å­—é¢é‡?    const cloneData: Partial<SearchResult> = {};
    
    // é€ä¸ªèµ‹å€¼å±æ€§ï¼Œç¡®ä¿ç±»å‹å®‰å…¨
    cloneData.id = this.id;
    cloneData.title = this.title;
    cloneData.originalTitle = this.originalTitle;
    cloneData.type = this.type;
    cloneData.coverUrl = this.coverUrl;
    cloneData.backdropUrl = this.backdropUrl;
    cloneData.description = this.description;
    cloneData.score = this.score;
    cloneData.year = this.year;
    cloneData.releaseDate = this.releaseDate;
    cloneData.genres = this.genres ? Array.from(this.genres) : undefined;
    cloneData.tags = this.tags ? Array.from(this.tags) : undefined;
    cloneData.duration = this.duration;
    cloneData.totalEpisodes = this.totalEpisodes;
    cloneData.currentSeason = this.currentSeason;
    cloneData.actors = this.actors ? Array.from(this.actors) : undefined;
    cloneData.directors = this.directors ? Array.from(this.directors) : undefined;
    cloneData.popularity = this.popularity;
    cloneData.matchScore = this.matchScore;
    cloneData.extraInfo = this.extraInfo ? this.cloneExtraInfo(this.extraInfo) : undefined;
    cloneData.link = this.link;
    cloneData.sourceId = this.sourceId;
    cloneData.sourceName = this.sourceName;
    
    return new SearchResult(cloneData);
  }

  /**
   * å…‹éš†ExtraInfoå¯¹è±¡
   * @param extraInfo è¦å…‹éš†çš„ExtraInfoå¯¹è±¡
   * @returns å…‹éš†åçš„ExtraInfoå¯¹è±¡
   */
  private cloneExtraInfo(extraInfo: ExtraInfo): ExtraInfo {
    // åˆ›å»ºExtraInfoå¯¹è±¡ï¼Œæ˜ç¡®åˆå§‹åŒ–extraData
    const cloned: ExtraInfo = {
      extraData: {}
    };
    
    // ç¡®ä¿extraInfo.extraDataå­˜åœ¨
    if (extraInfo.extraData) {
      // æ‰‹åŠ¨å¤åˆ¶extraDataä¸­çš„æ¯ä¸ªå±æ€?      const keys = Object.keys(extraInfo.extraData);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = extraInfo.extraData[key];
        
        if (value && typeof value === 'object' && !Array.isArray(value)) {
          // æ£€æŸ¥æ˜¯å¦ä¸ºNestedExtraInfoç±»å‹
          const potentialNested = value as Record<string, string | number | boolean | null | Record<string, string | number | boolean | null>>;
          if (potentialNested.nestedData && typeof potentialNested.nestedData === 'object' && !Array.isArray(potentialNested.nestedData)) {
            // å…‹éš†NestedExtraInfoå¯¹è±¡
            const nestedCloned: NestedExtraInfo = {
              nestedData: {}
            };
            
            // æ‰‹åŠ¨å¤åˆ¶nestedDataä¸­çš„æ¯ä¸ªå±æ€?            const nestedKeys = Object.keys(potentialNested.nestedData);
            for (let j = 0; j < nestedKeys.length; j++) {
              const nestedKey = nestedKeys[j];
              const nestedValue = potentialNested.nestedData![nestedKey];
              nestedCloned.nestedData[nestedKey] = nestedValue;
            }
            
            cloned.extraData[key] = nestedCloned;
          } else {
            // ç›´æ¥å¤åˆ¶åŸºæœ¬ç±»å‹å€?            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) {
              cloned.extraData[key] = value;
            }
          }
        } else {
          // ç›´æ¥å¤åˆ¶åŸºæœ¬ç±»å‹å€?          cloned.extraData[key] = value;
        }
      }
    }
    
    return cloned;
  }

  /**
   * åˆ›å»ºæœç´¢ç»“æœçš„æ¯”è¾ƒå‡½æ•°ï¼ˆç”¨äºæ’åºï¼?   * @param order æ’åºé¡ºåº 'desc'ï¼ˆé»˜è®¤ï¼‰æˆ?'asc'
   * @returns æ¯”è¾ƒå‡½æ•°
   */
  public static getSortComparator(order: 'desc' | 'asc' = 'desc'): (a: SearchResult, b: SearchResult) => number {
    return (a: SearchResult, b: SearchResult) => {
      const priorityA = a.getDisplayPriority();
      const priorityB = b.getDisplayPriority();
      return order === 'desc' ? priorityB - priorityA : priorityA - priorityB;
    };
  }
}
