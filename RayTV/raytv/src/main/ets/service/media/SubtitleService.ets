// SubtitleService - å­—å¹•æœåŠ¡ç±»
import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import NetworkUtil from '../../common/util/NetworkUtil';
import FileUtil from '../../common/util/FileUtil';
import { SubtitleStyle, DEFAULT_SUBTITLE_STYLE } from '../player/PlayerService';

// å¸¸é‡å®šä¹‰
const TAG = 'SubtitleService';
const SUBTITLE_CACHE_DIR = 'subtitles';
const USER_SUBTITLE_DIR = 'user_subtitles';
const SUBTITLE_HISTORY_KEY = 'subtitle_history';
const SUBTITLE_STYLE_KEY = 'subtitle_style';

// å­—å¹•ç±»å‹æšä¸¾
export enum SubtitleType {
  SRT = 'srt',       // SubRipæ ¼å¼
  VTT = 'vtt',       // WebVTTæ ¼å¼
  ASS = 'ass',       // Advanced SubStation Alphaæ ¼å¼
  SSA = 'ssa',       // SubStation Alphaæ ¼å¼
  TTML = 'ttml',     // Timed Text Markup Languageæ ¼å¼
  DFXP = 'dfxp',     // Distribution Format Exchange Profileæ ¼å¼
  SBV = 'sbv',       // YouTube SBVæ ¼å¼
  LRC = 'lrc',       // æ­Œè¯æ ¼å¼ï¼ˆç”¨äºéŸ³é¢‘ï¼‰
  CAP = 'cap',       // è‡ªå®šä¹‰å­—å¹•æ ¼å¼
  UNKNOWN = 'unknown' // æœªçŸ¥æ ¼å¼
}

// å­—å¹•è¯­è¨€ä¿¡æ¯æ¥å£
export interface SubtitleLanguage {
  code: string;      // è¯­è¨€ä»£ç  (ISO 639-1)
  name: string;      // è¯­è¨€åç§°
  nativeName?: string; // æœ¬åœ°è¯­è¨€åç§°
  flag?: string;     // å›½æ——å›¾æ ‡
  isDefault?: boolean; // æ˜¯å¦é»˜è®¤
}

// å­—å¹•è½¨é“æ¥å£
export interface SubtitleTrack {
  id: string;        // è½¨é“ID
  name: string;      // è½¨é“åç§°
  language: string;  // è¯­è¨€ä»£ç 
  type: SubtitleType; // å­—å¹•ç±»å‹
  url?: string;      // å­—å¹•æ–‡ä»¶URL
  localPath?: string; // æœ¬åœ°æ–‡ä»¶è·¯å¾„
  isExternal: boolean; // æ˜¯å¦å¤–éƒ¨å­—å¹•
  isAuto?: boolean;  // æ˜¯å¦è‡ªåŠ¨ç”Ÿæˆ
  isDefault: boolean; // æ˜¯å¦é»˜è®¤è½¨é“
  isForced?: boolean; // æ˜¯å¦å¼ºåˆ¶å­—å¹•
  encoding?: string; // æ–‡ä»¶ç¼–ç 
  downloadUrl?: string; // ä¸‹è½½é“¾æ¥ï¼ˆå¦‚æœä¸æ’­æ”¾URLä¸åŒï¼‰
  score?: number;    // åŒ¹é…åˆ†æ•°
  source?: string;   // æ¥æº
  size?: number;     // æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
}

// å­—å¹•æ¡ç›®æ¥å£
export interface SubtitleItem {
  startTime: number; // å¼€å§‹æ—¶é—´ï¼ˆç§’ï¼‰
  endTime: number;   // ç»“æŸæ—¶é—´ï¼ˆç§’ï¼‰
  text: string;      // å­—å¹•æ–‡æœ¬
  htmlText?: string; // æ ¼å¼åŒ–åçš„HTMLæ–‡æœ¬
  styles?: Record<string, string>; // æ ·å¼å±æ€§
  speaker?: string;  // è¯´è¯è€…ï¼ˆASS/SSAæ ¼å¼ï¼‰
  index: number;     // å­—å¹•ç´¢å¼•
}

// å­—å¹•æœç´¢å‚æ•°æ¥å£
export interface SubtitleSearchParams {
  movieId?: string;  // ç”µå½±/è§†é¢‘ID
  title: string;     // æ ‡é¢˜
  year?: string;     // å¹´ä»½
  season?: number;   // å­£æ•°ï¼ˆç”µè§†å‰§ï¼‰
  episode?: number;  // é›†æ•°ï¼ˆç”µè§†å‰§ï¼‰
  languages?: string[]; // è¯­è¨€ä»£ç åˆ—è¡¨
  hearingImpaired?: boolean; // æ˜¯å¦åŒ…å«å¬åŠ›éšœç¢æ”¯æŒ
  hash?: string;     // è§†é¢‘æ–‡ä»¶å“ˆå¸Œå€¼
  fileSize?: number; // æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
  limit?: number;    // é™åˆ¶ç»“æœæ•°é‡
  page?: number;     // é¡µç 
  pageSize?: number; // æ¯é¡µæ•°é‡
}

// å­—å¹•æä¾›å•†æšä¸¾
export enum SubtitleProvider {
  OPENSUBTITLES = 'opensubtitles',
  SUBHD = 'subhd',
  ZIMU = 'zimu',
  SHOOTER = 'shooter',
  RENZHI = 'renzhi',
  LOCAL = 'local',
  AUTO = 'auto'
}

// å­—å¹•è¯„åˆ†æ¥å£
export interface SubtitleRating {
  provider: SubtitleProvider;
  rating: number;    // è¯„åˆ†ï¼ˆ0-10ï¼‰
  voteCount: number; // æŠ•ç¥¨æ•°
  downloadCount: number; // ä¸‹è½½æ¬¡æ•°
  uploadDate: number; // ä¸Šä¼ æ—¶é—´
  uploader?: string; // ä¸Šä¼ è€…
}

// å­—å¹•ä¸‹è½½çŠ¶æ€æšä¸¾
export enum SubtitleDownloadStatus {
  IDLE = 'idle',
  DOWNLOADING = 'downloading',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELED = 'canceled'
}

// å­—å¹•ä¸‹è½½ä»»åŠ¡æ¥å£
export interface SubtitleDownloadTask {
  id: string;        // ä»»åŠ¡ID
  track: SubtitleTrack; // å­—å¹•è½¨é“
  status: SubtitleDownloadStatus; // ä¸‹è½½çŠ¶æ€
  progress: number;  // ä¸‹è½½è¿›åº¦ï¼ˆ0-100ï¼‰
  startTime: number; // å¼€å§‹æ—¶é—´
  endTime?: number;  // ç»“æŸæ—¶é—´
  error?: string;    // é”™è¯¯ä¿¡æ¯
  localPath?: string; // ä¸‹è½½åçš„æœ¬åœ°è·¯å¾„
}

// å­—å¹•å†å²è®°å½•æ¥å£
export interface SubtitleHistory {
  contentId: string; // å†…å®¹ID
  subtitleId: string; // å­—å¹•ID
  track: SubtitleTrack; // å­—å¹•è½¨é“
  selectedAt: number; // é€‰æ‹©æ—¶é—´
  duration?: number; // è§‚çœ‹æ—¶é•¿
  language: string; // è¯­è¨€
  type: SubtitleType; // ç±»å‹
}

/**
 * å­—å¹•æœåŠ¡ç±»
 * è´Ÿè´£ç®¡ç†è§†é¢‘å­—å¹•ç›¸å…³åŠŸèƒ½
 */
export default class SubtitleService {
  private static instance: SubtitleService;
  
  private subtitleStyle: SubtitleStyle = { ...DEFAULT_SUBTITLE_STYLE };
  private subtitleHistory: SubtitleHistory[] = [];
  private downloadTasks: Map<string, SubtitleDownloadTask> = new Map();
  private isInitialized: boolean = false;
  
  // å·²åŠ è½½çš„å­—å¹•ç¼“å­˜
  private loadedSubtitles: Map<string, SubtitleItem[]> = new Map();
  
  // æ”¯æŒçš„è¯­è¨€åˆ—è¡¨
  private supportedLanguages: SubtitleLanguage[] = [
    { code: 'zh', name: 'Chinese', nativeName: 'ä¸­æ–‡', flag: 'ğŸ‡¨ğŸ‡³' },
    { code: 'en', name: 'English', nativeName: 'English', flag: 'ğŸ‡¬ğŸ‡§', isDefault: true },
    { code: 'ja', name: 'Japanese', nativeName: 'æ—¥æœ¬èª', flag: 'ğŸ‡¯ğŸ‡µ' },
    { code: 'ko', name: 'Korean', nativeName: 'í•œêµ­ì–´', flag: 'ğŸ‡°ğŸ‡·' },
    { code: 'fr', name: 'French', nativeName: 'FranÃ§ais', flag: 'ğŸ‡«ğŸ‡·' },
    { code: 'de', name: 'German', nativeName: 'Deutsch', flag: 'ğŸ‡©ğŸ‡ª' },
    { code: 'es', name: 'Spanish', nativeName: 'EspaÃ±ol', flag: 'ğŸ‡ªğŸ‡¸' },
    { code: 'ru', name: 'Russian', nativeName: 'Ğ ÑƒÑÑĞºĞ¸Ğ¹', flag: 'ğŸ‡·ğŸ‡º' },
    { code: 'pt', name: 'Portuguese', nativeName: 'PortuguÃªs', flag: 'ğŸ‡µğŸ‡¹' },
    { code: 'it', name: 'Italian', nativeName: 'Italiano', flag: 'ğŸ‡®ğŸ‡¹' },
    { code: 'ar', name: 'Arabic', nativeName: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', flag: 'ğŸ‡¸ğŸ‡¦' },
    { code: 'hi', name: 'Hindi', nativeName: 'à¤¹à¤¿à¤¨à¥à¤¦à¥€', flag: 'ğŸ‡®ğŸ‡³' },
    { code: 'th', name: 'Thai', nativeName: 'à¹„à¸—à¸¢', flag: 'ğŸ‡¹ğŸ‡­' },
    { code: 'vi', name: 'Vietnamese', nativeName: 'Tiáº¿ng Viá»‡t', flag: 'ğŸ‡»ğŸ‡³' },
    { code: 'ms', name: 'Malay', nativeName: 'Bahasa Melayu', flag: 'ğŸ‡²ğŸ‡¾' },
    { code: 'id', name: 'Indonesian', nativeName: 'Bahasa Indonesia', flag: 'ğŸ‡®ğŸ‡©' },
    { code: 'tl', name: 'Tagalog', nativeName: 'Tagalog', flag: 'ğŸ‡µğŸ‡­' }
  ];
  
  // ç›‘å¬å™¨
  private styleListeners: Array<(style: SubtitleStyle) => void> = [];
  private downloadListeners: Map<string, Array<(task: SubtitleDownloadTask) => void>> = new Map();
  private parseListeners: Map<string, Array<(subtitles: SubtitleItem[], error?: string) => void>> = new Map();

  /**
   * æ„é€ å‡½æ•°ï¼ˆç§æœ‰ï¼Œé˜²æ­¢å¤–éƒ¨å®ä¾‹åŒ–ï¼‰
   */
  private constructor() {
    this.initialize();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): SubtitleService {
    if (!SubtitleService.instance) {
      SubtitleService.instance = new SubtitleService();
    }
    return SubtitleService.instance;
  }

  /**
   * åˆå§‹åŒ–å­—å¹•æœåŠ¡
   */
  private async initialize(): Promise<void> {
    try {
      Logger.info(TAG, 'Initializing subtitle service...');
      
      // åˆ›å»ºå­—å¹•ç¼“å­˜ç›®å½•
      await FileUtil.ensureDirectory(SUBTITLE_CACHE_DIR);
      await FileUtil.ensureDirectory(USER_SUBTITLE_DIR);
      
      // åŠ è½½å­—å¹•æ ·å¼è®¾ç½®
      const savedStyle = await StorageUtil.getObject<SubtitleStyle>(SUBTITLE_STYLE_KEY);
      if (savedStyle) {
        this.subtitleStyle = { ...DEFAULT_SUBTITLE_STYLE, ...savedStyle };
      }
      
      // åŠ è½½å­—å¹•å†å²è®°å½•
      const savedHistory = await StorageUtil.getObject<SubtitleHistory[]>(SUBTITLE_HISTORY_KEY);
      if (savedHistory) {
        this.subtitleHistory = savedHistory;
        // åªä¿ç•™æœ€è¿‘100æ¡å†å²è®°å½•
        if (this.subtitleHistory.length > 100) {
          this.subtitleHistory = this.subtitleHistory.slice(-100);
        }
      }
      
      this.isInitialized = true;
      Logger.info(TAG, 'Subtitle service initialized successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to initialize subtitle service', error);
    }
  }

  /**
   * ä¿å­˜å­—å¹•æ ·å¼è®¾ç½®
   */
  private async saveSubtitleStyle(): Promise<void> {
    try {
      await StorageUtil.setObject(SUBTITLE_STYLE_KEY, this.subtitleStyle);
      Logger.debug(TAG, 'Saved subtitle style settings');
    } catch (error) {
      Logger.error(TAG, 'Failed to save subtitle style settings', error);
    }
  }

  /**
   * ä¿å­˜å­—å¹•å†å²è®°å½•
   */
  private async saveSubtitleHistory(): Promise<void> {
    try {
      await StorageUtil.setObject(SUBTITLE_HISTORY_KEY, this.subtitleHistory);
      Logger.debug(TAG, 'Saved subtitle history');
    } catch (error) {
      Logger.error(TAG, 'Failed to save subtitle history', error);
    }
  }

  /**
   * è®¾ç½®å­—å¹•æ ·å¼
   */
  public async setSubtitleStyle(style: Partial<SubtitleStyle>): Promise<SubtitleStyle> {
    try {
      // æ›´æ–°å­—å¹•æ ·å¼
      this.subtitleStyle = {
        ...this.subtitleStyle,
        ...style
      };
      
      // ä¿å­˜æ ·å¼
      await this.saveSubtitleStyle();
      
      // é€šçŸ¥ç›‘å¬å™¨
      this.notifyStyleChanged();
      
      Logger.info(TAG, 'Updated subtitle style');
      return { ...this.subtitleStyle };
    } catch (error) {
      Logger.error(TAG, 'Failed to update subtitle style', error);
      return { ...this.subtitleStyle };
    }
  }

  /**
   * è·å–å­—å¹•æ ·å¼
   */
  public getSubtitleStyle(): SubtitleStyle {
    return { ...this.subtitleStyle };
  }

  /**
   * é‡ç½®å­—å¹•æ ·å¼ä¸ºé»˜è®¤å€¼
   */
  public async resetSubtitleStyle(): Promise<SubtitleStyle> {
    try {
      this.subtitleStyle = { ...DEFAULT_SUBTITLE_STYLE };
      
      // ä¿å­˜æ ·å¼
      await this.saveSubtitleStyle();
      
      // é€šçŸ¥ç›‘å¬å™¨
      this.notifyStyleChanged();
      
      Logger.info(TAG, 'Reset subtitle style to default');
      return { ...this.subtitleStyle };
    } catch (error) {
      Logger.error(TAG, 'Failed to reset subtitle style', error);
      return { ...this.subtitleStyle };
    }
  }

  /**
   * è§£æå­—å¹•æ–‡ä»¶
   */
  public async parseSubtitle(
    track: SubtitleTrack,
    onProgress?: (progress: number) => void
  ): Promise<ApiResponse<SubtitleItem[]>> {
    try {
      // æ£€æŸ¥ç¼“å­˜
      const cacheKey = track.url || track.localPath || track.id;
      if (cacheKey && this.loadedSubtitles.has(cacheKey)) {
        Logger.debug(TAG, `Returning parsed subtitles from cache: ${cacheKey}`);
        return ApiResponse.success(this.loadedSubtitles.get(cacheKey)!, 'å­—å¹•è§£ææˆåŠŸï¼ˆç¼“å­˜ï¼‰');
      }
      
      // é€šçŸ¥è§£æå¼€å§‹
      this.notifyParseStart(track.id);
      
      let subtitleContent: string;
      
      // è·å–å­—å¹•å†…å®¹
      if (track.localPath) {
        // ä»æœ¬åœ°æ–‡ä»¶è¯»å–
        Logger.debug(TAG, `Reading subtitle from local file: ${track.localPath}`);
        subtitleContent = await FileUtil.readFile(track.localPath, track.encoding || 'utf-8');
      } else if (track.url) {
        // ä»URLä¸‹è½½
        Logger.debug(TAG, `Downloading subtitle from URL: ${track.url}`);
        const response = await NetworkUtil.downloadText(track.url, {
          encoding: track.encoding || 'utf-8',
          onProgress: (progress) => {
            if (onProgress) {
              onProgress(progress);
            }
          }
        });
        
        if (!response.success) {
          return ApiResponse.error(ResponseCode.NETWORK_ERROR, `ä¸‹è½½å­—å¹•å¤±è´¥: ${response.error}`);
        }
        
        subtitleContent = response.data;
      } else {
        return ApiResponse.error(ResponseCode.INVALID_PARAMETER, 'å­—å¹•æ–‡ä»¶è·¯å¾„æˆ–URLä¸èƒ½ä¸ºç©º');
      }
      
      // æ ¹æ®å­—å¹•ç±»å‹è§£æ
      let subtitles: SubtitleItem[] = [];
      
      switch (track.type) {
        case SubtitleType.SRT:
          subtitles = this.parseSRT(subtitleContent);
          break;
        case SubtitleType.VTT:
          subtitles = this.parseVTT(subtitleContent);
          break;
        case SubtitleType.ASS:
        case SubtitleType.SSA:
          subtitles = this.parseASS(subtitleContent, track.type);
          break;
        case SubtitleType.TTML:
        case SubtitleType.DFXP:
          subtitles = this.parseTTML(subtitleContent);
          break;
        case SubtitleType.SBV:
          subtitles = this.parseSBV(subtitleContent);
          break;
        case SubtitleType.LRC:
          subtitles = this.parseLRC(subtitleContent);
          break;
        default:
          // å°è¯•è‡ªåŠ¨æ£€æµ‹æ ¼å¼
          if (subtitleContent.includes('WEBVTT')) {
            subtitles = this.parseVTT(subtitleContent);
          } else if (/\d+\s*\r?\n\d{2}:\d{2}:\d{2},\d{3}\s*-->\s*\d{2}:\d{2}:\d{2},\d{3}/.test(subtitleContent)) {
            subtitles = this.parseSRT(subtitleContent);
          } else {
            return ApiResponse.error(ResponseCode.UNSUPPORTED_FORMAT, 'ä¸æ”¯æŒçš„å­—å¹•æ ¼å¼');
          }
      }
      
      // ç¼“å­˜è§£æç»“æœ
      if (cacheKey) {
        this.loadedSubtitles.set(cacheKey, subtitles);
      }
      
      // é€šçŸ¥è§£æå®Œæˆ
      this.notifyParseComplete(track.id, subtitles);
      
      Logger.info(TAG, `Successfully parsed ${subtitles.length} subtitles`);
      return ApiResponse.success(subtitles, 'å­—å¹•è§£ææˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, `Failed to parse subtitle track: ${track.id}`, error);
      
      // é€šçŸ¥è§£æå¤±è´¥
      this.notifyParseError(track.id, String(error));
      
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, `å­—å¹•è§£æå¤±è´¥: ${String(error)}`);
    }
  }

  /**
   * è§£æSRTæ ¼å¼å­—å¹•
   */
  private parseSRT(content: string): SubtitleItem[] {
    const subtitles: SubtitleItem[] = [];
    
    // åˆ†å‰²å­—å¹•å—
    const blocks = content.trim().split(/\r?\n\s*\r?\n/);
    
    blocks.forEach(block => {
      try {
        // åŒ¹é…æ—¶é—´æˆ³å’Œæ–‡æœ¬
        const match = block.match(/(\d+)\s*\r?\n(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*\r?\n([\s\S]*)/);
        
        if (match) {
          // è§£ææ—¶é—´æˆ³
          const startTime = this.parseTime(match[2], match[3], match[4], match[5]);
          const endTime = this.parseTime(match[6], match[7], match[8], match[9]);
          
          // è§£ææ–‡æœ¬ï¼ˆç§»é™¤æ ¼å¼æ ‡ç­¾å¹¶å¤„ç†æ¢è¡Œï¼‰
          let text = match[10].trim();
          // æ›¿æ¢HTMLæ ‡ç­¾ï¼ˆä¿ç•™ç®€å•çš„æ ¼å¼ï¼‰
          text = text.replace(/<\/?[ibu]>/g, '');
          text = text.replace(/<font[^>]*>/g, '');
          text = text.replace(/<\/font>/g, '');
          
          // å¤„ç†å¤šè¡Œæ–‡æœ¬
          text = text.replace(/\r?\n/g, '\n');
          
          // åˆ›å»ºå­—å¹•æ¡ç›®
          subtitles.push({
            startTime,
            endTime,
            text,
            htmlText: text.replace(/\n/g, '<br>'), // è½¬æ¢ä¸ºHTMLæ ¼å¼
            index: parseInt(match[1]) - 1
          });
        }
      } catch (error) {
        Logger.warn(TAG, 'Failed to parse SRT block', error);
      }
    });
    
    // æŒ‰ç´¢å¼•æ’åº
    return subtitles.sort((a, b) => a.index - b.index);
  }

  /**
   * è§£æVTTæ ¼å¼å­—å¹•
   */
  private parseVTT(content: string): SubtitleItem[] {
    const subtitles: SubtitleItem[] = [];
    
    // ç§»é™¤WEBVTTå¤´éƒ¨
    let cleanContent = content.replace(/^WEBVTT[\s\S]*?(?:\r?\n\r?\n|\Z)/, '');
    
    // åˆ†å‰²å­—å¹•å—
    const blocks = cleanContent.trim().split(/\r?\n\s*\r?\n/);
    
    blocks.forEach((block, index) => {
      try {
        // åŒ¹é…æ—¶é—´æˆ³å’Œæ–‡æœ¬
        const match = block.match(/^(?:[^\r\n]*\r?\n)?(\d{2}):(\d{2}):(\d{2})\.(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2})\.(\d{3})(?:[^\r\n]*)\r?\n([\s\S]*)/);
        
        if (match) {
          // è§£ææ—¶é—´æˆ³
          const startTime = this.parseTime(match[1], match[2], match[3], match[4]);
          const endTime = this.parseTime(match[5], match[6], match[7], match[8]);
          
          // è§£ææ–‡æœ¬
          let text = match[9].trim();
          // ç§»é™¤æ³¨é‡Šå’Œæ ¼å¼æ ‡ç­¾
          text = text.replace(/<c[^>]*>/g, '');
          text = text.replace(/<\/c>/g, '');
          text = text.replace(/<\/?[ibu]>/g, '');
          text = text.replace(/<font[^>]*>/g, '');
          text = text.replace(/<\/font>/g, '');
          text = text.replace(/<u[^>]*>/g, '');
          text = text.replace(/<\/u>/g, '');
          text = text.replace(/<[^>]*>/g, ''); // ç§»é™¤å…¶ä»–æ ‡ç­¾
          
          // å¤„ç†å¤šè¡Œæ–‡æœ¬
          text = text.replace(/\r?\n/g, '\n');
          
          // åˆ›å»ºå­—å¹•æ¡ç›®
          subtitles.push({
            startTime,
            endTime,
            text,
            htmlText: text.replace(/\n/g, '<br>'),
            index
          });
        }
      } catch (error) {
        Logger.warn(TAG, 'Failed to parse VTT block', error);
      }
    });
    
    return subtitles;
  }

  /**
   * è§£æASS/SSAæ ¼å¼å­—å¹•
   */
  private parseASS(content: string, type: SubtitleType): SubtitleItem[] {
    const subtitles: SubtitleItem[] = [];
    
    // æå–è„šæœ¬ä¿¡æ¯å’Œæ ·å¼
    const eventsMatch = content.match(/\[Events\][\s\S]*?(?=\[|$)/);
    
    if (eventsMatch) {
      const events = eventsMatch[0];
      // æå–å¯¹è¯è¡Œ
      const dialogueLines = events.match(/^Dialogue:\s*.*/gm) || [];
      
      dialogueLines.forEach((line, index) => {
        try {
          // åˆ†å‰²å¯¹è¯è¡Œ
          const parts = line.split(',');
          
          if (parts.length >= 10) {
            // è§£ææ—¶é—´
            const startTimeText = parts[1];
            const endTimeText = parts[2];
            
            const startTime = this.parseASSTime(startTimeText);
            const endTime = this.parseASSTime(endTimeText);
            
            // è·å–è¯´è¯è€…
            const speaker = parts[3];
            
            // åˆå¹¶æ–‡æœ¬éƒ¨åˆ†ï¼ˆASSæ ¼å¼çš„æ–‡æœ¬å¯èƒ½åŒ…å«é€—å·ï¼‰
            const textParts = parts.slice(9);
            let text = textParts.join(',');
            
            // ç§»é™¤ASSæ ·å¼æ ‡ç­¾
            text = text.replace(/\{[^}]*\}/g, '');
            text = text.replace(/\\[Nn]/g, '\n');
            
            // åˆ›å»ºå­—å¹•æ¡ç›®
            subtitles.push({
              startTime,
              endTime,
              text: text.trim(),
              htmlText: text.trim().replace(/\n/g, '<br>'),
              speaker,
              index
            });
          }
        } catch (error) {
          Logger.warn(TAG, 'Failed to parse ASS/SSA dialogue line', error);
        }
      });
    }
    
    return subtitles;
  }

  /**
   * è§£æTTMLæ ¼å¼å­—å¹•
   */
  private parseTTML(content: string): SubtitleItem[] {
    const subtitles: SubtitleItem[] = [];
    
    try {
      // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–å­—å¹•ä¿¡æ¯
      const textElements = content.match(/<p\s[^>]*begin="([^"]*)"[^>]*end="([^"]*)"[^>]*>([\s\S]*?)<\/p>/g) || [];
      
      textElements.forEach((element, index) => {
        try {
          const beginMatch = element.match(/begin="([^"]*)"/);
          const endMatch = element.match(/end="([^"]*)"/);
          const textMatch = element.match(/<p[^>]*>([\s\S]*?)<\/p>/);
          
          if (beginMatch && endMatch && textMatch) {
            const startTime = this.parseTTMLTime(beginMatch[1]);
            const endTime = this.parseTTMLTime(endMatch[1]);
            
            // æå–æ–‡æœ¬å¹¶ç§»é™¤æ ‡ç­¾
            let text = textMatch[1];
            text = text.replace(/<[^>]*>/g, '');
            text = text.replace(/&lt;/g, '<');
            text = text.replace(/&gt;/g, '>');
            text = text.replace(/&amp;/g, '&');
            text = text.replace(/&quot;/g, '"');
            text = text.replace(/&#39;/g, '\'');
            text = text.replace(/\s+/g, ' ').trim();
            
            if (text) {
              subtitles.push({
                startTime,
                endTime,
                text,
                htmlText: text.replace(/\n/g, '<br>'),
                index
              });
            }
          }
        } catch (error) {
          Logger.warn(TAG, 'Failed to parse TTML element', error);
        }
      });
    } catch (error) {
      Logger.error(TAG, 'Failed to parse TTML content', error);
    }
    
    return subtitles;
  }

  /**
   * è§£æSBVæ ¼å¼å­—å¹•
   */
  private parseSBV(content: string): SubtitleItem[] {
    const subtitles: SubtitleItem[] = [];
    
    // åˆ†å‰²å­—å¹•å—
    const blocks = content.trim().split(/\r?\n\s*\r?\n/);
    
    blocks.forEach((block, index) => {
      try {
        // åŒ¹é…æ—¶é—´æˆ³å’Œæ–‡æœ¬
        const match = block.match(/(\d{2}):(\d{2}):(\d{2})\.(\d{3})\s*,\s*(\d{2}):(\d{2}):(\d{2})\.(\d{3})\s*\r?\n([\s\S]*)/);
        
        if (match) {
          // è§£ææ—¶é—´æˆ³
          const startTime = this.parseTime(match[1], match[2], match[3], match[4]);
          const endTime = this.parseTime(match[5], match[6], match[7], match[8]);
          
          // è§£ææ–‡æœ¬
          let text = match[9].trim();
          text = text.replace(/\r?\n/g, '\n');
          
          // åˆ›å»ºå­—å¹•æ¡ç›®
          subtitles.push({
            startTime,
            endTime,
            text,
            htmlText: text.replace(/\n/g, '<br>'),
            index
          });
        }
      } catch (error) {
        Logger.warn(TAG, 'Failed to parse SBV block', error);
      }
    });
    
    return subtitles;
  }

  /**
   * è§£æLRCæ ¼å¼æ­Œè¯
   */
  private parseLRC(content: string): SubtitleItem[] {
    const subtitles: SubtitleItem[] = [];
    
    // æå–æ—¶é—´æ ‡ç­¾è¡Œ
    const timeLines = content.match(/\[\d{2}:\d{2}\.\d{2}\].*/g) || [];
    
    timeLines.forEach((line, index) => {
      try {
        // æå–æ‰€æœ‰æ—¶é—´æ ‡ç­¾
        const timeTags = line.match(/\[(\d{2}):(\d{2})\.(\d{2})\]/g) || [];
        const text = line.replace(/\[(\d{2}:\d{2}\.\d{2})\]/g, '').trim();
        
        timeTags.forEach(tag => {
          const match = tag.match(/\[(\d{2}):(\d{2})\.(\d{2})\]/);
          if (match) {
            const minutes = parseInt(match[1]);
            const seconds = parseInt(match[2]);
            const milliseconds = parseInt(match[3]) * 10; // LRCé€šå¸¸ä½¿ç”¨10msç²¾åº¦
            
            const startTime = minutes * 60 + seconds + milliseconds / 1000;
            
            // LRCæ²¡æœ‰ç»“æŸæ—¶é—´ï¼Œä¼°ç®—ä¸º2ç§’
            const endTime = startTime + 2;
            
            if (text) {
              subtitles.push({
                startTime,
                endTime,
                text,
                htmlText: text,
                index
              });
            }
          }
        });
      } catch (error) {
        Logger.warn(TAG, 'Failed to parse LRC line', error);
      }
    });
    
    // æŒ‰æ—¶é—´æ’åº
    return subtitles.sort((a, b) => a.startTime - b.startTime);
  }

  /**
   * è§£ææ—¶é—´æ ¼å¼ï¼ˆHH:MM:SS,mmm æˆ– HH:MM:SS.mmmï¼‰
   */
  private parseTime(hours: string, minutes: string, seconds: string, milliseconds: string): number {
    const h = parseInt(hours);
    const m = parseInt(minutes);
    const s = parseInt(seconds);
    const ms = parseInt(milliseconds);
    
    return h * 3600 + m * 60 + s + ms / 1000;
  }

  /**
   * è§£æASS/SSAæ—¶é—´æ ¼å¼ï¼ˆHH:MM:SS.ccï¼‰
   */
  private parseASSTime(timeText: string): number {
    const match = timeText.match(/(\d+):(\d+):(\d+)\.(\d+)/);
    if (match) {
      const h = parseInt(match[1]);
      const m = parseInt(match[2]);
      const s = parseInt(match[3]);
      const cs = parseInt(match[4]); // å˜ç§’
      
      return h * 3600 + m * 60 + s + cs / 100;
    }
    return 0;
  }

  /**
   * è§£æTTMLæ—¶é—´æ ¼å¼
   */
  private parseTTMLTime(timeText: string): number {
    // å¤„ç†å°æ—¶:åˆ†é’Ÿ:ç§’.æ¯«ç§’ æ ¼å¼
    const fullMatch = timeText.match(/^(\d+):(\d+):(\d+(?:\.\d+)?)$/);
    if (fullMatch) {
      const h = parseInt(fullMatch[1]);
      const m = parseInt(fullMatch[2]);
      const s = parseFloat(fullMatch[3]);
      
      return h * 3600 + m * 60 + s;
    }
    
    // å¤„ç†åˆ†é’Ÿ:ç§’.æ¯«ç§’ æ ¼å¼
    const shortMatch = timeText.match(/^(\d+):(\d+(?:\.\d+)?)$/);
    if (shortMatch) {
      const m = parseInt(shortMatch[1]);
      const s = parseFloat(shortMatch[2]);
      
      return m * 60 + s;
    }
    
    return 0;
  }

  /**
   * ä¸‹è½½å­—å¹•æ–‡ä»¶
   */
  public async downloadSubtitle(
    track: SubtitleTrack,
    onProgress?: (task: SubtitleDownloadTask) => void
  ): Promise<ApiResponse<SubtitleDownloadTask>> {
    try {
      if (!track.url && !track.downloadUrl) {
        return ApiResponse.error(ResponseCode.INVALID_PARAMETER, 'å­—å¹•ä¸‹è½½URLä¸èƒ½ä¸ºç©º');
      }
      
      // åˆ›å»ºä¸‹è½½ä»»åŠ¡
      const task: SubtitleDownloadTask = {
        id: `download_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        track,
        status: SubtitleDownloadStatus.IDLE,
        progress: 0,
        startTime: Date.now()
      };
      
      // æ·»åŠ åˆ°ä»»åŠ¡åˆ—è¡¨
      this.downloadTasks.set(task.id, task);
      
      // ç”Ÿæˆä¿å­˜è·¯å¾„
      const fileName = `${track.id}_${Date.now()}.${track.type}`;
      const savePath = `${SUBTITLE_CACHE_DIR}/${fileName}`;
      
      // æ›´æ–°ä»»åŠ¡çŠ¶æ€
      task.status = SubtitleDownloadStatus.DOWNLOADING;
      this.updateDownloadTask(task);
      if (onProgress) {
        onProgress({ ...task });
      }
      
      // ä¸‹è½½æ–‡ä»¶
      const downloadUrl = track.downloadUrl || track.url!;
      const response = await NetworkUtil.downloadFile(downloadUrl, savePath, {
        onProgress: (progress) => {
          task.progress = progress;
          this.updateDownloadTask(task);
          if (onProgress) {
            onProgress({ ...task });
          }
        }
      });
      
      if (response.success) {
        // æ›´æ–°ä»»åŠ¡çŠ¶æ€
        task.status = SubtitleDownloadStatus.COMPLETED;
        task.progress = 100;
        task.endTime = Date.now();
        task.localPath = savePath;
        
        this.updateDownloadTask(task);
        
        // ç§»é™¤ä»»åŠ¡ï¼ˆå¯é€‰ï¼Œä¿ç•™çŸ­æ—¶é—´ä»¥ä¾¿æŸ¥è¯¢ï¼‰
        setTimeout(() => {
          this.downloadTasks.delete(task.id);
        }, 300000); // 5åˆ†é’Ÿåç§»é™¤
        
        Logger.info(TAG, `Successfully downloaded subtitle: ${track.name} to ${savePath}`);
        return ApiResponse.success({ ...task }, 'å­—å¹•ä¸‹è½½æˆåŠŸ');
      } else {
        // æ›´æ–°ä»»åŠ¡çŠ¶æ€
        task.status = SubtitleDownloadStatus.FAILED;
        task.error = response.error;
        task.endTime = Date.now();
        
        this.updateDownloadTask(task);
        
        return ApiResponse.error(ResponseCode.NETWORK_ERROR, `å­—å¹•ä¸‹è½½å¤±è´¥: ${response.error}`);
      }
    } catch (error) {
      Logger.error(TAG, `Failed to download subtitle: ${track.name}`, error);
      
      // å¦‚æœæœ‰ä»»åŠ¡ï¼Œæ›´æ–°çŠ¶æ€
      for (const [, task] of this.downloadTasks) {
        if (task.track.id === track.id && task.status === SubtitleDownloadStatus.DOWNLOADING) {
          task.status = SubtitleDownloadStatus.FAILED;
          task.error = String(error);
          task.endTime = Date.now();
          this.updateDownloadTask(task);
          break;
        }
      }
      
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, `å­—å¹•ä¸‹è½½å¤±è´¥: ${String(error)}`);
    }
  }

  /**
   * å–æ¶ˆå­—å¹•ä¸‹è½½
   */
  public async cancelDownload(taskId: string): Promise<ApiResponse<boolean>> {
    try {
      const task = this.downloadTasks.get(taskId);
      if (!task) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'ä¸‹è½½ä»»åŠ¡ä¸å­˜åœ¨');
      }
      
      if (task.status !== SubtitleDownloadStatus.DOWNLOADING) {
        return ApiResponse.error(ResponseCode.INVALID_OPERATION, 'ä»»åŠ¡ä¸åœ¨ä¸‹è½½ä¸­');
      }
      
      // æ›´æ–°ä»»åŠ¡çŠ¶æ€
      task.status = SubtitleDownloadStatus.CANCELED;
      task.endTime = Date.now();
      
      this.updateDownloadTask(task);
      
      // ç§»é™¤ä»»åŠ¡
      setTimeout(() => {
        this.downloadTasks.delete(taskId);
      }, 5000);
      
      Logger.info(TAG, `Canceled subtitle download task: ${taskId}`);
      return ApiResponse.success(true, 'å–æ¶ˆä¸‹è½½æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, `Failed to cancel download task: ${taskId}`, error);
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'å–æ¶ˆä¸‹è½½å¤±è´¥');
    }
  }

  /**
   * è·å–æ‰€æœ‰ä¸‹è½½ä»»åŠ¡
   */
  public getDownloadTasks(): SubtitleDownloadTask[] {
    return Array.from(this.downloadTasks.values());
  }

  /**
   * è·å–ä¸‹è½½ä»»åŠ¡
   */
  public getDownloadTask(taskId: string): SubtitleDownloadTask | undefined {
    return this.downloadTasks.get(taskId);
  }

  /**
   * æ›´æ–°ä¸‹è½½ä»»åŠ¡çŠ¶æ€
   */
  private updateDownloadTask(task: SubtitleDownloadTask): void {
    this.downloadTasks.set(task.id, { ...task });
    this.notifyDownloadTaskChanged(task);
  }

  /**
   * æœç´¢å­—å¹•
   */
  public async searchSubtitles(
    params: SubtitleSearchParams,
    providers?: SubtitleProvider[]
  ): Promise<ApiResponse<Map<SubtitleProvider, SubtitleTrack[]>>> {
    try {
      const results = new Map<SubtitleProvider, SubtitleTrack[]>();
      
      // è¿™é‡Œåº”è¯¥è°ƒç”¨å„ä¸ªå­—å¹•æä¾›å•†çš„API
      // ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬è¿”å›æ¨¡æ‹Ÿæ•°æ®
      
      // æ¨¡æ‹ŸOpenSubtitlesç»“æœ
      results.set(SubtitleProvider.OPENSUBTITLES, [
        {
          id: 'opensub_1',
          name: 'English (US)',
          language: 'en',
          type: SubtitleType.SRT,
          url: 'https://example.com/subtitles/en.srt',
          isExternal: true,
          isDefault: true
        },
        {
          id: 'opensub_2',
          name: 'ç®€ä½“ä¸­æ–‡',
          language: 'zh',
          type: SubtitleType.SRT,
          url: 'https://example.com/subtitles/zh.srt',
          isExternal: true,
          isDefault: false
        }
      ]);
      
      // æ¨¡æ‹ŸSubHDç»“æœ
      results.set(SubtitleProvider.SUBHD, [
        {
          id: 'subhd_1',
          name: 'ç®€ä½“ä¸­æ–‡å­—å¹•',
          language: 'zh',
          type: SubtitleType.ASS,
          url: 'https://example.com/subtitles/subhd.ass',
          isExternal: true,
          isDefault: false
        }
      ]);
      
      Logger.info(TAG, `Search subtitles completed for: ${params.title}`);
      return ApiResponse.success(results, 'å­—å¹•æœç´¢æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to search subtitles', error);
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'å­—å¹•æœç´¢å¤±è´¥');
    }
  }

  /**
   * æ·»åŠ å­—å¹•åˆ°å†å²è®°å½•
   */
  public async addToHistory(
    contentId: string,
    track: SubtitleTrack,
    duration?: number
  ): Promise<void> {
    try {
      const historyItem: SubtitleHistory = {
        contentId,
        subtitleId: track.id,
        track,
        selectedAt: Date.now(),
        duration,
        language: track.language,
        type: track.type
      };
      
      // æ·»åŠ åˆ°å†å²è®°å½•ï¼ˆç§»é™¤æ—§çš„ç›¸åŒæ¡ç›®ï¼‰
      this.subtitleHistory = this.subtitleHistory.filter(
        item => !(item.contentId === contentId && item.subtitleId === track.id)
      );
      
      // æ·»åŠ åˆ°å¼€å¤´
      this.subtitleHistory.unshift(historyItem);
      
      // é™åˆ¶å†å²è®°å½•æ•°é‡
      if (this.subtitleHistory.length > 100) {
        this.subtitleHistory = this.subtitleHistory.slice(0, 100);
      }
      
      // ä¿å­˜å†å²è®°å½•
      await this.saveSubtitleHistory();
      
      Logger.debug(TAG, `Added subtitle to history: ${track.name}`);
    } catch (error) {
      Logger.error(TAG, 'Failed to add subtitle to history', error);
    }
  }

  /**
   * è·å–å­—å¹•å†å²è®°å½•
   */
  public getHistory(limit: number = 50): SubtitleHistory[] {
    return this.subtitleHistory.slice(0, limit);
  }

  /**
   * è·å–å†…å®¹çš„å­—å¹•å†å²
   */
  public getContentHistory(contentId: string): SubtitleHistory[] {
    return this.subtitleHistory.filter(item => item.contentId === contentId);
  }

  /**
   * æ¸…é™¤å­—å¹•å†å²è®°å½•
   */
  public async clearHistory(): Promise<void> {
    try {
      this.subtitleHistory = [];
      await this.saveSubtitleHistory();
      Logger.info(TAG, 'Cleared subtitle history');
    } catch (error) {
      Logger.error(TAG, 'Failed to clear subtitle history', error);
    }
  }

  /**
   * è·å–æ”¯æŒçš„è¯­è¨€åˆ—è¡¨
   */
  public getSupportedLanguages(): SubtitleLanguage[] {
    return [...this.supportedLanguages];
  }

  /**
   * æ ¹æ®è¯­è¨€ä»£ç è·å–è¯­è¨€ä¿¡æ¯
   */
  public getLanguageByCode(code: string): SubtitleLanguage | undefined {
    return this.supportedLanguages.find(lang => lang.code === code);
  }

  /**
   * åŠ è½½æœ¬åœ°å­—å¹•æ–‡ä»¶
   */
  public async loadLocalSubtitle(filePath: string): Promise<ApiResponse<SubtitleTrack>> {
    try {
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      const exists = await FileUtil.fileExists(filePath);
      if (!exists) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'å­—å¹•æ–‡ä»¶ä¸å­˜åœ¨');
      }
      
      // è·å–æ–‡ä»¶æ‰©å±•å
      const extension = FileUtil.getExtension(filePath).toLowerCase();
      
      // ç¡®å®šå­—å¹•ç±»å‹
      let type: SubtitleType;
      switch (extension) {
        case 'srt':
          type = SubtitleType.SRT;
          break;
        case 'vtt':
          type = SubtitleType.VTT;
          break;
        case 'ass':
          type = SubtitleType.ASS;
          break;
        case 'ssa':
          type = SubtitleType.SSA;
          break;
        case 'ttml':
          type = SubtitleType.TTML;
          break;
        case 'dfxp':
          type = SubtitleType.DFXP;
          break;
        case 'sbv':
          type = SubtitleType.SBV;
          break;
        case 'lrc':
          type = SubtitleType.LRC;
          break;
        default:
          type = SubtitleType.UNKNOWN;
      }
      
      // è·å–æ–‡ä»¶åä½œä¸ºæ ‡é¢˜
      const fileName = FileUtil.getFileName(filePath);
      
      // åˆ›å»ºå­—å¹•è½¨é“
      const track: SubtitleTrack = {
        id: `local_${Date.now()}`,
        name: fileName,
        language: 'unknown',
        type,
        localPath: filePath,
        isExternal: true,
        isDefault: false
      };
      
      // å°è¯•è§£æå­—å¹•ä»¥éªŒè¯
      const parseResult = await this.parseSubtitle(track);
      if (!parseResult.isSuccess()) {
        return ApiResponse.error(parseResult.code, `å­—å¹•æ–‡ä»¶æ ¼å¼æ— æ•ˆ: ${parseResult.message}`);
      }
      
      Logger.info(TAG, `Loaded local subtitle file: ${filePath}`);
      return ApiResponse.success(track, 'åŠ è½½æœ¬åœ°å­—å¹•æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, `Failed to load local subtitle file: ${filePath}`, error);
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, `åŠ è½½æœ¬åœ°å­—å¹•å¤±è´¥: ${String(error)}`);
    }
  }

  /**
   * ç”Ÿæˆå­—å¹•é¢„è§ˆï¼ˆç”¨äºé€‰æ‹©å­—å¹•ï¼‰
   */
  public async generateSubtitlePreview(
    track: SubtitleTrack,
    time: number,
    duration: number = 30
  ): Promise<ApiResponse<string>> {
    try {
      // è§£æå­—å¹•
      const parseResult = await this.parseSubtitle(track);
      if (!parseResult.isSuccess() || !parseResult.data) {
        return ApiResponse.error(parseResult.code, parseResult.message || 'å­—å¹•è§£æå¤±è´¥');
      }
      
      // è·å–æŒ‡å®šæ—¶é—´èŒƒå›´å†…çš„å­—å¹•
      const previewSubtitles = parseResult.data.filter(
        sub => sub.startTime >= time && sub.startTime <= time + duration
      ).slice(0, 10); // æœ€å¤š10æ¡
      
      // ç”Ÿæˆé¢„è§ˆæ–‡æœ¬
      const preview = previewSubtitles.map(sub => {
        const startTimeFormatted = this.formatTime(sub.startTime);
        return `[${startTimeFormatted}] ${sub.text}`;
      }).join('\n\n');
      
      return ApiResponse.success(preview, 'ç”Ÿæˆå­—å¹•é¢„è§ˆæˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, `Failed to generate subtitle preview: ${track.id}`, error);
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'ç”Ÿæˆå­—å¹•é¢„è§ˆå¤±è´¥');
    }
  }

  /**
   * æ ¼å¼åŒ–æ—¶é—´ä¸ºHH:MM:SS,mmmæ ¼å¼
   */
  private formatTime(seconds: number): string {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 1000);
    
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
  }

  /**
   * æ¸…é™¤å­—å¹•ç¼“å­˜
   */
  public async clearCache(): Promise<ApiResponse<boolean>> {
    try {
      // æ¸…é™¤å†…å­˜ç¼“å­˜
      this.loadedSubtitles.clear();
      
      // æ¸…é™¤ä¸‹è½½ä»»åŠ¡
      this.downloadTasks.clear();
      
      // åˆ é™¤ç¼“å­˜æ–‡ä»¶
      await FileUtil.deleteDirectory(SUBTITLE_CACHE_DIR);
      await FileUtil.ensureDirectory(SUBTITLE_CACHE_DIR);
      
      Logger.info(TAG, 'Cleared subtitle cache');
      return ApiResponse.success(true, 'æ¸…é™¤å­—å¹•ç¼“å­˜æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to clear subtitle cache', error);
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ¸…é™¤å­—å¹•ç¼“å­˜å¤±è´¥');
    }
  }

  /**
   * é€šçŸ¥æ ·å¼å˜æ›´
   */
  private notifyStyleChanged(): void {
    for (const listener of this.styleListeners) {
      try {
        listener({ ...this.subtitleStyle });
      } catch (error) {
        Logger.error(TAG, 'Error in style listener', error);
      }
    }
  }

  /**
   * é€šçŸ¥ä¸‹è½½ä»»åŠ¡å˜æ›´
   */
  private notifyDownloadTaskChanged(task: SubtitleDownloadTask): void {
    if (!this.downloadListeners.has(task.id)) return;
    
    const listeners = this.downloadListeners.get(task.id)!;
    for (const listener of listeners) {
      try {
        listener({ ...task });
      } catch (error) {
        Logger.error(TAG, `Error in download listener for task ${task.id}`, error);
      }
    }
  }

  /**
   * é€šçŸ¥è§£æå¼€å§‹
   */
  private notifyParseStart(trackId: string): void {
    if (!this.parseListeners.has(trackId)) return;
    
    const listeners = this.parseListeners.get(trackId)!;
    for (const listener of listeners) {
      try {
        listener([]);
      } catch (error) {
        Logger.error(TAG, `Error in parse listener for track ${trackId}`, error);
      }
    }
  }

  /**
   * é€šçŸ¥è§£æå®Œæˆ
   */
  private notifyParseComplete(trackId: string, subtitles: SubtitleItem[]): void {
    if (!this.parseListeners.has(trackId)) return;
    
    const listeners = this.parseListeners.get(trackId)!;
    for (const listener of listeners) {
      try {
        listener(subtitles);
      } catch (error) {
        Logger.error(TAG, `Error in parse listener for track ${trackId}`, error);
      }
    }
  }

  /**
   * é€šçŸ¥è§£æé”™è¯¯
   */
  private notifyParseError(trackId: string, error: string): void {
    if (!this.parseListeners.has(trackId)) return;
    
    const listeners = this.parseListeners.get(trackId)!;
    for (const listener of listeners) {
      try {
        listener([], error);
      } catch (err) {
        Logger.error(TAG, `Error in parse listener for track ${trackId}`, err);
      }
    }
  }

  /**
   * æ·»åŠ æ ·å¼å˜æ›´ç›‘å¬å™¨
   */
  public addStyleListener(listener: (style: SubtitleStyle) => void): () => void {
    this.styleListeners.push(listener);
    
    // ç«‹å³å›è°ƒå½“å‰æ ·å¼
    listener({ ...this.subtitleStyle });
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.styleListeners.indexOf(listener);
      if (index > -1) {
        this.styleListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ ä¸‹è½½ä»»åŠ¡ç›‘å¬å™¨
   */
  public addDownloadListener(
    taskId: string,
    listener: (task: SubtitleDownloadTask) => void
  ): () => void {
    if (!this.downloadListeners.has(taskId)) {
      this.downloadListeners.set(taskId, []);
    }
    
    const listeners = this.downloadListeners.get(taskId)!;
    listeners.push(listener);
    
    // ç«‹å³å›è°ƒå½“å‰ä»»åŠ¡çŠ¶æ€
    const task = this.downloadTasks.get(taskId);
    if (task) {
      listener({ ...task });
    }
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
      
      // å¦‚æœæ²¡æœ‰ç›‘å¬å™¨äº†ï¼Œæ¸…ç†Map
      if (listeners.length === 0) {
        this.downloadListeners.delete(taskId);
      }
    };
  }

  /**
   * æ·»åŠ è§£æç›‘å¬å™¨
   */
  public addParseListener(
    trackId: string,
    listener: (subtitles: SubtitleItem[], error?: string) => void
  ): () => void {
    if (!this.parseListeners.has(trackId)) {
      this.parseListeners.set(trackId, []);
    }
    
    const listeners = this.parseListeners.get(trackId)!;
    listeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
      
      // å¦‚æœæ²¡æœ‰ç›‘å¬å™¨äº†ï¼Œæ¸…ç†Map
      if (listeners.length === 0) {
        this.parseListeners.delete(trackId);
      }
    };
  }

  /**
   * é”€æ¯å­—å¹•æœåŠ¡
   */
  public async destroy(): Promise<void> {
    try {
      Logger.info(TAG, 'Destroying subtitle service...');
      
      // æ¸…é™¤ç¼“å­˜
      await this.clearCache();
      
      // æ¸…é™¤ç›‘å¬å™¨
      this.styleListeners = [];
      this.downloadListeners.clear();
      this.parseListeners.clear();
      
      // æ¸…é™¤ä»»åŠ¡
      this.downloadTasks.clear();
      this.loadedSubtitles.clear();
      
      Logger.info(TAG, 'Subtitle service destroyed successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to destroy subtitle service', error);
    }
  }
}

// å¯¼å‡ºApiResponseç±»å‹ï¼ˆç”¨äºå…¼å®¹æ€§ï¼‰
class ApiResponse<T> {
  code: number;
  message: string;
  data?: T;
  
  constructor(code: number, message: string, data?: T) {
    this.code = code;
    this.message = message;
    this.data = data;
  }
  
  static success<T>(data: T, message: string = 'Success'): ApiResponse<T> {
    return new ApiResponse(200, message, data);
  }
  
  static error<T>(code: number, message: string): ApiResponse<T> {
    return new ApiResponse(code, message);
  }
  
  isSuccess(): boolean {
    return this.code === 200;
  }
}