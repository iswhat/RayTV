// MediaCacheService.ets - åª’ä½“ç¼“å­˜æœåŠ¡
// è´Ÿè´£ç®¡ç†è§†é¢‘æ–‡ä»¶çš„æœ¬åœ°ç¼“å­˜ï¼ŒåŒ…æ‹¬ç¼“å­˜ç­–ç•¥ã€æ¸…ç†æœºåˆ¶å’Œç¼“å­˜ç»Ÿè®¡

import Logger from '../../common/util/Logger';
import ConfigService from '../../service/config/ConfigService';
import BusinessError from '@ohos.base';

// å¸¸é‡å®šä¹‰
const TAG = 'MediaCacheService';
const DEFAULT_CACHE_DIR = '/cache/media';

// ç¼“å­˜çº§åˆ«æšä¸¾
export enum CacheLevel {
  LOW = 'low',           // ä½ç¼“å­˜ï¼ˆä»…åŸºæœ¬ä¿¡æ¯ï¼‰
  MEDIUM = 'medium',     // ä¸­ç­‰ç¼“å­˜ï¼ˆåŸºæœ¬ä¿¡æ?éƒ¨åˆ†è§†é¢‘ï¼?  HIGH = 'high',         // é«˜ç¼“å­˜ï¼ˆå®Œæ•´è§†é¢‘ç¼“å­˜ï¼?  PREMIUM = 'premium'    // é«˜çº§ç¼“å­˜ï¼ˆå¤šè´¨é‡ç¼“å­˜ï¼?}

// ç¼“å­˜ç­–ç•¥æšä¸¾
export enum CacheStrategy {
  FIRST_IN_FIRST_OUT = 'fifo',      // å…ˆè¿›å…ˆå‡º
  LEAST_RECENTLY_USED = 'lru',      // æœ€è¿‘æœ€å°‘ä½¿ç”?  LEAST_FREQUENTLY_USED = 'lfu',    // æœ€ä¸ç»å¸¸ä½¿ç”?  SIZE_BASED = 'size',              // åŸºäºå¤§å°
  TIME_BASED = 'time'               // åŸºäºæ—¶é—´
}

// ç¼“å­˜çŠ¶æ€æšä¸?export enum CacheStatus {
  NOT_CACHED = 'not_cached',        // æœªç¼“å­?  CACHING = 'caching',              // ç¼“å­˜ä¸?  CACHED = 'cached',                // å·²ç¼“å­?  FAILED = 'failed',                // ç¼“å­˜å¤±è´¥
  PARTIALLY_CACHED = 'partially_cached', // éƒ¨åˆ†ç¼“å­˜
  EXPIRED = 'expired'               // å·²è¿‡æœ?}

// ç¼“å­˜é…ç½®æ¥å£
export interface CacheConfig {
  enabled: boolean;               // æ˜¯å¦å¯ç”¨ç¼“å­˜
  maxCacheSize: number;           // æœ€å¤§ç¼“å­˜å¤§å°ï¼ˆå­—èŠ‚ï¼?  cacheLevel: CacheLevel;         // ç¼“å­˜çº§åˆ«
  cacheStrategy: CacheStrategy;   // ç¼“å­˜ç­–ç•¥
  autoClean: boolean;             // è‡ªåŠ¨æ¸…ç†
  cleanInterval: number;          // æ¸…ç†é—´éš”ï¼ˆç§’ï¼?  cacheExpiryDays: number;        // ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼ˆå¤©ï¼?  wifiOnly: boolean;              // ä»…WiFiç¼“å­˜
  backgroundDownload: boolean;    // åå°ä¸‹è½½
  preloadEnabled: boolean;        // é¢„åŠ è½½å¯ç”?  preloadBufferSize: number;      // é¢„åŠ è½½ç¼“å†²åŒºå¤§å°
  maxConcurrentDownloads: number; // æœ€å¤§å¹¶å‘ä¸‹è½½æ•°
  autoResumeDownloads: boolean;   // è‡ªåŠ¨æ¢å¤ä¸‹è½½
  priorityHighQuality: boolean;   // ä¼˜å…ˆé«˜è´¨é‡?}

// é»˜è®¤ç¼“å­˜é…ç½®
export const DEFAULT_CACHE_CONFIG: CacheConfig = {
  enabled: true,
  maxCacheSize: 1024 * 1024 * 1024 * 5, // 5GB
  cacheLevel: CacheLevel.MEDIUM,
  cacheStrategy: CacheStrategy.LEAST_RECENTLY_USED,
  autoClean: true,
  cleanInterval: 3600, // 1å°æ—¶
  cacheExpiryDays: 7, // 7å¤?  wifiOnly: true,
  backgroundDownload: true,
  preloadEnabled: true,
  preloadBufferSize: 1024 * 1024 * 50, // 50MB
  maxConcurrentDownloads: 3,
  autoResumeDownloads: true,
  priorityHighQuality: false
};

// ç¼“å­˜é¡¹æ¥å?export interface CacheItem {
  id: string;                     // ç¼“å­˜é¡¹ID
  url: string;                    // åª’ä½“URL
  filePath: string;               // æœ¬åœ°æ–‡ä»¶è·¯å¾„
  fileName: string;               // æ–‡ä»¶å?  size: number;                   // æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰
  downloadedSize: number;         // å·²ä¸‹è½½å¤§å°?  duration: number;               // åª’ä½“æ—¶é•¿ï¼ˆç§’ï¼?  format: string;                 // åª’ä½“æ ¼å¼
  quality: string;                // åª’ä½“è´¨é‡
  mimeType: string;               // MIMEç±»å‹
  status: CacheStatus;            // ç¼“å­˜çŠ¶æ€?  lastAccessTime: number;         // æœ€åè®¿é—®æ—¶é—?  creationTime: number;           // åˆ›å»ºæ—¶é—´
  accessCount: number;            // è®¿é—®æ¬¡æ•°
  sourceId: string;               // æºID
  sourceName: string;             // æºåç§?  metadata?: Record<string, string | number | boolean | null>;                 // é¢å¤–å…ƒæ•°æ?  error?: string;                 // é”™è¯¯ä¿¡æ¯
}

// ç¼“å­˜ç»Ÿè®¡æ¥å£
export interface CacheStatistics {
  totalSize: number;              // æ€»ç¼“å­˜å¤§å°?  usedSize: number;               // å·²ä½¿ç”¨å¤§å°?  freeSize: number;               // å¯ç”¨å¤§å°
  itemCount: number;              // ç¼“å­˜é¡¹æ•°é‡?  cachedCount: number;            // å·²ç¼“å­˜æ•°é‡?  cachingCount: number;           // ç¼“å­˜ä¸­æ•°é‡?  failedCount: number;            // å¤±è´¥æ•°é‡
  expiredCount: number;           // è¿‡æœŸæ•°é‡
  cacheHitRate: number;           // ç¼“å­˜å‘½ä¸­ç?  cacheRatio: number;             // ç¼“å­˜å ç”¨æ¯”ä¾‹
  oldestCacheTime: number;        // æœ€æ—§ç¼“å­˜æ—¶é—?  newestCacheTime: number;        // æœ€æ–°ç¼“å­˜æ—¶é—?}

// ä¸‹è½½ä»»åŠ¡æ¥å£
export interface DownloadTask {
  id: string;                     // ä»»åŠ¡ID
  cacheItemId: string;            // ç¼“å­˜é¡¹ID
  url: string;                    // ä¸‹è½½URL
  filePath: string;               // ä¿å­˜è·¯å¾„
  startTime: number;              // å¼€å§‹æ—¶é—?  endTime?: number;               // ç»“æŸæ—¶é—´
  size: number;                   // æ–‡ä»¶å¤§å°
  downloadedSize: number;         // å·²ä¸‹è½½å¤§å°?  progress: number;               // è¿›åº¦ï¼?-100ï¼?  speed: number;                  // ä¸‹è½½é€Ÿåº¦ï¼ˆå­—èŠ?ç§’ï¼‰
  status: 'pending' | 'downloading' | 'paused' | 'completed' | 'failed' | 'canceled'; // çŠ¶æ€?  retries: number;                // é‡è¯•æ¬¡æ•°
  priority: number;               // ä¼˜å…ˆçº§ï¼ˆ1-10ï¼?  headers?: Record<string, string>; // è¯·æ±‚å¤?}

// é¢„åŠ è½½é€‰é¡¹æ¥å£
export interface PreloadOptions {
  url: string;                    // åª’ä½“URL
  priority: number;               // é¢„åŠ è½½ä¼˜å…ˆçº§
  maxSize?: number;               // æœ€å¤§é¢„åŠ è½½å¤§å°
  quality?: string;               // ä¼˜å…ˆè´¨é‡
  metadata?: Record<string, string | number | boolean | null>;                 // å…ƒæ•°æ?}

// ç¼“å­˜æŸ¥è¯¢é€‰é¡¹æ¥å£
export interface CacheQueryOptions {
  status?: CacheStatus;           // æŒ‰çŠ¶æ€æŸ¥è¯?  sourceId?: string;              // æŒ‰æºIDæŸ¥è¯¢
  minSize?: number;               // æœ€å°å¤§å°?  maxSize?: number;               // æœ€å¤§å¤§å°?  startDate?: number;             // å¼€å§‹æ—¥æœ?  endDate?: number;               // ç»“æŸæ—¥æœŸ
  quality?: string;               // åª’ä½“è´¨é‡
  limit?: number;                 // é™åˆ¶æ•°é‡
  offset?: number;                // åç§»é‡?  sortBy?: 'size' | 'time' | 'accessCount'; // æ’åºå­—æ®µ
  sortOrder?: 'asc' | 'desc';     // æ’åºé¡ºåº
}

// ç¼“å­˜æ¸…ç†é€‰é¡¹æ¥å£
export interface CacheCleanOptions {
  olderThanDays?: number;         // æ¸…ç†æŒ‡å®šå¤©æ•°å‰çš„ç¼“å­˜
  maxSize?: number;               // æ¸…ç†åˆ°æœ€å¤§å¤§å°ä»¥ä¸?  status?: CacheStatus;           // æŒ‰çŠ¶æ€æ¸…ç?  sourceId?: string;              // æŒ‰æºIDæ¸…ç†
  quality?: string;               // æŒ‰è´¨é‡æ¸…ç?  exceptIds?: string[];           // æ’é™¤çš„IDåˆ—è¡¨
  dryRun?: boolean;               // æ¨¡æ‹Ÿè¿è¡Œ
}

// ç¼“å­˜ç›‘å¬å™¨å›è°ƒç±»å?type CacheListener = (item: CacheItem) => void;

// ä¸‹è½½ç›‘å¬å™¨å›è°ƒç±»å?type DownloadListener = (task: DownloadTask) => void;

export default class MediaCacheService {
  private static instance: MediaCacheService;
  private configService: ConfigService;
  private config: CacheConfig = DEFAULT_CACHE_CONFIG;
  private cacheDir: string = DEFAULT_CACHE_DIR;
  private cacheItems: Map<string, CacheItem> = new Map();
  private downloadTasks: Map<string, DownloadTask> = new Map();
  private pendingTasks: DownloadTask[] = [];
  private activeTasks: number = 0;
  private cacheStats: CacheStatistics = this.createEmptyCacheStats();
  private cacheListeners: Map<string, CacheListener[]> = new Map();
  private downloadListeners: Map<string, DownloadListener[]> = new Map();
  private cleanTimerId: number | null = null;
  private isInitialized: boolean = false;
  private cacheHitCount: number = 0;
  private cacheMissCount: number = 0;

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): MediaCacheService {
    if (!MediaCacheService.instance) {
      MediaCacheService.instance = new MediaCacheService();
    }
    return MediaCacheService.instance;
  }

  /**
   * æ„é€ å‡½æ•?   */
  private constructor() {
    this.configService = ConfigService.getInstance();
  }

  /**
   * åˆå§‹åŒ–åª’ä½“ç¼“å­˜æœåŠ?   * @param context åº”ç”¨ä¸Šä¸‹æ–?   */
  public async initialize(context: Context): Promise<void> {
    if (this.isInitialized) {
      Logger.info(TAG, 'Media cache service already initialized');
      return;
    }

    try {
      Logger.info(TAG, 'Initializing media cache service...');

      // è®¾ç½®ç¼“å­˜ç›®å½•
      this.cacheDir = this.getCacheDirectory(context);
      await this.ensureCacheDirectory();
      
      // åŠ è½½é…ç½®
      await this.loadConfig();
      
      // åŠ è½½ç¼“å­˜é¡?      await this.loadCacheItems();
      
      // æ›´æ–°ç¼“å­˜ç»Ÿè®¡
      await this.updateCacheStatistics();
      
      // å¦‚æœå¯ç”¨äº†è‡ªåŠ¨æ¸…ç†ï¼Œå¯åŠ¨å®šæ—¶æ¸…ç†
      if (this.config.autoClean && this.config.enabled) {
        this.startAutoCleanup();
      }
      
      // æ¢å¤æœªå®Œæˆçš„ä¸‹è½½
      if (this.config.autoResumeDownloads) {
        this.resumePendingDownloads();
      }
      
      this.isInitialized = true;
      Logger.info(TAG, 'Media cache service initialized successfully');
      Logger.info(TAG, `Cache directory: ${this.cacheDir}, Config: ${JSON.stringify(this.config)}`);
    } catch (error) {
      Logger.error(TAG, `Failed to initialize media cache service: ${JSON.stringify(error)}`);
      throw error;
    }
  }

  /**
   * è·å–ç¼“å­˜ç›®å½•
   */
  private getCacheDirectory(context: Context): string {
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œåº”è¯¥ä½¿ç”¨ç³»ç»ŸAPIè·å–åº”ç”¨ç¼“å­˜ç›®å½•
    // è¿™é‡Œä½¿ç”¨ä¸´æ—¶è·¯å¾„æ¨¡æ‹Ÿ
    return context.cacheDir + DEFAULT_CACHE_DIR;
  }

  /**
   * ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
   */
  private async ensureCacheDirectory(): Promise<void> {
    try {
      // TODO: ä½¿ç”¨æ–‡ä»¶APIåˆ›å»ºç›®å½•
      Logger.debug(TAG, `Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}` instanceof Error ? `Ensuring cache directory exists: ${this.cacheDir}` : new Error(String(`Ensuring cache directory exists: ${this.cacheDir}`)))))));
    } catch (error) {
      Logger.error(TAG, `Failed to create cache directory: ${error}`);
      throw error;
    }
  }

  /**
   * åŠ è½½é…ç½®
   */
  private async loadConfig(): Promise<void> {
    try {
      const savedConfig = await this.configService.getConfig('mediaCacheConfig', DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG instanceof Error ? DEFAULT_CACHE_CONFIG : new Error(String(DEFAULT_CACHE_CONFIG)))))));
      if (savedConfig) {
        this.config = { ...DEFAULT_CACHE_CONFIG, ...savedConfig };
      }
    } catch (error) {
      Logger.error(TAG, `Failed to load media cache config: ${error}`);
    }
  }

  /**
   * ä¿å­˜é…ç½®
   */
  public async saveConfig(config: Partial<CacheConfig>): Promise<void> {
    try {
      this.config = { ...this.config, ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config instanceof Error ? ...config };
      await this.configService.setConfig('mediaCacheConfig', this.config : new Error(String(...config };
      await this.configService.setConfig('mediaCacheConfig', this.config)))))));
      
      // æ ¹æ®é…ç½®è°ƒæ•´è‡ªåŠ¨æ¸…ç†
      if (this.config.autoClean && this.config.enabled) {
        this.startAutoCleanup();
      } else {
        this.stopAutoCleanup();
      }
      
      // å¦‚æœå¯ç”¨äº†ç¼“å­˜ï¼Œæ¸…ç†è¿‡æœŸç¼“å­˜
      if (this.config.enabled) {
        this.cleanExpiredCache();
      }
    } catch (error) {
      Logger.error(TAG, `Failed to save media cache config: ${error}`);
      throw error;
    }
  }

  /**
   * è·å–é…ç½®
   */
  public getConfig(): CacheConfig {
    return { ...this.config };
  }

  /**
   * åŠ è½½ç¼“å­˜é¡?   */
  private async loadCacheItems(): Promise<void> {
    try {
      // ä»é…ç½®ä¸­åŠ è½½ç¼“å­˜é¡¹ä¿¡æ?      const savedItems = await this.configService.getConfig<CacheItem[]>('cacheItems', [] instanceof Error ? [] : new Error(String([] instanceof Error ? [] instanceof Error ? [] : new Error(String([] : new Error(String([] instanceof Error ? [] : new Error(String([] instanceof Error ? [] instanceof Error ? [] : new Error(String([] instanceof Error ? [] instanceof Error ? [] : new Error(String([] : new Error(String([] instanceof Error ? [] : new Error(String([] : new Error(String([] instanceof Error ? [] : new Error(String([] instanceof Error ? [] instanceof Error ? [] : new Error(String([] : new Error(String([] instanceof Error ? [] : new Error(String([])))))));
      
      // éªŒè¯ç¼“å­˜é¡¹çš„å®é™…æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      for (const item of savedItems) {
        const exists = await this.checkFileExists(item.filePath);
        
        if (exists) {
          // æ›´æ–°ç¼“å­˜é¡¹çŠ¶æ€?          item.status = CacheStatus.CACHED;
          this.cacheItems.set(item.id, item);
        } else {
          // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œç§»é™¤ç¼“å­˜é¡?          Logger.warn(TAG, `Cache file not found: ${item.filePath}, removing cache item`);
        }
      }
      
      Logger.info(TAG, `Loaded ${this.cacheItems.size} cache items`);
    } catch (error) {
      Logger.error(TAG, `Failed to load cache items: ${error}`);
    }
  }

  /**
   * ä¿å­˜ç¼“å­˜é¡?   */
  private async saveCacheItems(): Promise<void> {
    try {
      const items = Array.from(this.cacheItems.values());
      await this.configService.setConfig('cacheItems', items instanceof Error ? items : new Error(String(items instanceof Error ? items instanceof Error ? items : new Error(String(items : new Error(String(items instanceof Error ? items : new Error(String(items instanceof Error ? items instanceof Error ? items : new Error(String(items instanceof Error ? items instanceof Error ? items : new Error(String(items : new Error(String(items instanceof Error ? items : new Error(String(items : new Error(String(items instanceof Error ? items : new Error(String(items instanceof Error ? items instanceof Error ? items : new Error(String(items : new Error(String(items instanceof Error ? items : new Error(String(items)))))));
    } catch (error) {
      Logger.error(TAG, `Failed to save cache items: ${error}`);
    }
  }

  /**
   * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ?   */
  private async checkFileExists(filePath: string): Promise<boolean> {
    try {
      // TODO: ä½¿ç”¨æ–‡ä»¶APIæ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ?      Logger.debug(TAG, `Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}` instanceof Error ? `Checking if file exists: ${filePath}` : new Error(String(`Checking if file exists: ${filePath}`)))))));
      return false; // ä¸´æ—¶è¿”å›falseï¼Œå®é™…éœ€è¦å®ç?    } catch (error) {
      Logger.error(TAG, `Failed to check file existence: ${error}`);
      return false;
    }
  }

  /**
   * åˆ›å»ºç©ºçš„ç¼“å­˜ç»Ÿè®¡å¯¹è±¡
   */
  private createEmptyCacheStats(): CacheStatistics {
    return {
      totalSize: this.config.maxCacheSize, usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( instanceof Error ? usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now( : new Error(String(usedSize: 0,
      freeSize: this.config.maxCacheSize,
      itemCount: 0,
      cachedCount: 0,
      cachingCount: 0,
      failedCount: 0,
      expiredCount: 0,
      cacheHitRate: 0,
      cacheRatio: 0,
      oldestCacheTime: Date.now())))))),
      newestCacheTime: Date.now()
    };
  }

  /**
   * æ›´æ–°ç¼“å­˜ç»Ÿè®¡
   */
  private async updateCacheStatistics(): Promise<void> {
    const stats = this.createEmptyCacheStats();
    stats.itemCount = this.cacheItems.size;
    
    let totalUsedSize = 0;
    let cachedCount = 0;
    let cachingCount = 0;
    let failedCount = 0;
    let expiredCount = 0;
    let oldestTime = Date.now();
    let newestTime = 0;
    
    const expiryTime = Date.now() - (this.config.cacheExpiryDays * 24 * 60 * 60 * 1000);
    
    for (const item of this.cacheItems.values()) {
      totalUsedSize += item.size;
      
      switch (item.status) {
        case CacheStatus.CACHED:
          cachedCount++;
          // æ£€æŸ¥æ˜¯å¦è¿‡æœ?          if (item.lastAccessTime < expiryTime) {
            item.status = CacheStatus.EXPIRED;
            expiredCount++;
          }
          break;
        case CacheStatus.CACHING:
          cachingCount++;
          break;
        case CacheStatus.FAILED:
          failedCount++;
          break;
        case CacheStatus.EXPIRED:
          expiredCount++;
          break;
      }
      
      oldestTime = Math.min(oldestTime, item.creationTime);
      newestTime = Math.max(newestTime, item.creationTime);
    }
    
    stats.usedSize = totalUsedSize;
    stats.freeSize = Math.max(0, this.config.maxCacheSize - totalUsedSize);
    stats.cachedCount = cachedCount;
    stats.cachingCount = cachingCount;
    stats.failedCount = failedCount;
    stats.expiredCount = expiredCount;
    stats.cacheRatio = this.config.maxCacheSize > 0 ? (totalUsedSize / this.config.maxCacheSize) * 100 : 0;
    stats.cacheHitRate = this.calculateCacheHitRate();
    stats.oldestCacheTime = oldestTime;
    stats.newestCacheTime = newestTime;
    
    this.cacheStats = stats;
  }

  /**
   * è®¡ç®—ç¼“å­˜å‘½ä¸­ç?   */
  private calculateCacheHitRate(): number {
    const totalRequests = this.cacheHitCount + this.cacheMissCount;
    return totalRequests > 0 ? (this.cacheHitCount / totalRequests) * 100 : 0;
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡
   */
  public getCacheStatistics(): CacheStatistics {
    return { ...this.cacheStats };
  }

  /**
   * å¼€å§‹è‡ªåŠ¨æ¸…ç?   */
  private startAutoCleanup(): void {
    this.stopAutoCleanup();
    
    this.cleanTimerId = setInterval(() => {
      this.performAutoCleanup().catch(error => {
        Logger.error(TAG, `Auto cleanup failed: ${error}`);
      });
    }, this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000 instanceof Error ? this.config.cleanInterval * 1000 : new Error(String(this.config.cleanInterval * 1000)))))));
    
    Logger.info(TAG, `Auto cleanup started with interval: ${this.config.cleanInterval}s`);
  }

  /**
   * åœæ­¢è‡ªåŠ¨æ¸…ç†
   */
  private stopAutoCleanup(): void {
    if (this.cleanTimerId !== null) {
      clearInterval(this.cleanTimerId);
      this.cleanTimerId = null;
      Logger.info(TAG, 'Auto cleanup stopped');
    }
  }

  /**
   * æ‰§è¡Œè‡ªåŠ¨æ¸…ç†
   */
  private async performAutoCleanup(): Promise<void> {
    if (!this.config.enabled) {
      return;
    }

    Logger.info(TAG, 'Performing auto cleanup...');
    
    // æ¸…ç†è¿‡æœŸç¼“å­˜
    await this.cleanExpiredCache();
    
    // å¦‚æœç¼“å­˜å¤§å°è¶…è¿‡é™åˆ¶ï¼Œæ ¹æ®ç­–ç•¥æ¸…ç?    if (this.cacheStats.usedSize > this.config.maxCacheSize) {
      const bytesToClean = this.cacheStats.usedSize - this.config.maxCacheSize;
      await this.cleanCacheByStrategy(bytesToClean);
    }
    
    // æ›´æ–°ç»Ÿè®¡
    await this.updateCacheStatistics();
    Logger.info(TAG, 'Auto cleanup completed');
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   */
  private async cleanExpiredCache(): Promise<void> {
    const expiryTime = Date.now() - (this.config.cacheExpiryDays * 24 * 60 * 60 * 1000);
    const expiredItems = Array.from(this.cacheItems.values()).filter(
      item => item.lastAccessTime < expiryTime && item.status !== CacheStatus.CACHING
    );
    
    if (expiredItems.length > 0) {
      Logger.info(TAG, `Cleaning ${expiredItems.length} expired cache items`);
      await this.removeCacheItems(expiredItems.map(item => item.id));
    }
  }

  /**
   * æ ¹æ®ç­–ç•¥æ¸…ç†ç¼“å­˜
   */
  private async cleanCacheByStrategy(bytesToClean: number): Promise<void> {
    const cacheItems = Array.from(this.cacheItems.values())
      .filter(item => item.status !== CacheStatus.CACHING);
    
    let itemsToRemove: CacheItem[] = [];
    let cleanedBytes = 0;
    
    // æ ¹æ®ç¼“å­˜ç­–ç•¥æ’åº
    let sortedItems: CacheItem[] = [];
    
    switch (this.config.cacheStrategy) {
      case CacheStrategy.FIRST_IN_FIRST_OUT:
        // å…ˆè¿›å…ˆå‡ºï¼šæŒ‰åˆ›å»ºæ—¶é—´æ’åºï¼Œå…ˆåˆ é™¤æœ€æ—§çš„
        sortedItems = [...cacheItems].sort((a, b) => a.creationTime - b.creationTime);
        break;
      case CacheStrategy.LEAST_RECENTLY_USED:
        // æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼šæŒ‰æœ€åè®¿é—®æ—¶é—´æ’åº?        sortedItems = [...cacheItems].sort((a, b) => a.lastAccessTime - b.lastAccessTime);
        break;
      case CacheStrategy.LEAST_FREQUENTLY_USED:
        // æœ€ä¸ç»å¸¸ä½¿ç”¨ï¼šæŒ‰è®¿é—®æ¬¡æ•°æ’åº?        sortedItems = [...cacheItems].sort((a, b) => a.accessCount - b.accessCount);
        break;
      case CacheStrategy.SIZE_BASED:
        // åŸºäºå¤§å°ï¼šæŒ‰æ–‡ä»¶å¤§å°æ’åºï¼Œä¼˜å…ˆåˆ é™¤å¤§æ–‡ä»¶
        sortedItems = [...cacheItems].sort((a, b) => b.size - a.size);
        break;
      case CacheStrategy.TIME_BASED:
        // åŸºäºæ—¶é—´ï¼šæŒ‰æœ€åè®¿é—®æ—¶é—´æ’åº?        sortedItems = [...cacheItems].sort((a, b) => a.lastAccessTime - b.lastAccessTime);
        break;
    }
    
    // é€‰æ‹©è¦åˆ é™¤çš„é¡¹ç›®
    for (const item of sortedItems) {
      if (cleanedBytes >= bytesToClean) {
        break;
      }
      
      itemsToRemove.push(item);
      cleanedBytes += item.size;
    }
    
    if (itemsToRemove.length > 0) {
      Logger.info(TAG, `Cleaning ${itemsToRemove.length} cache items to free ${cleanedBytes} bytes`);
      await this.removeCacheItems(itemsToRemove.map(item => item.id));
    }
  }

  /**
   * æ¢å¤æœªå®Œæˆçš„ä¸‹è½½
   */
  private resumePendingDownloads(): void {
    const pendingTasks = Array.from(this.downloadTasks.values())
      .filter(task => task.status === 'paused' || task.status === 'pending');
    
    Logger.info(TAG, `Resuming ${pendingTasks.length} pending downloads`);
    
    for (const task of pendingTasks) {
      this.startDownloadTask(task).catch(error => {
        Logger.error(TAG, `Failed to resume task ${task.id}: ${error}`);
      });
    }
  }

  /**
   * ç¼“å­˜åª’ä½“æ–‡ä»¶
   */
  public async cacheMedia(options: {
    url: string;
    quality?: string;
    metadata?: Record<string, string | number | boolean | null>;
    priority?: number;
    headers?: Record<string, string>;
  } instanceof Error ? string>;
  } : new Error(String(string>;
  } instanceof Error ? string>;
  } instanceof Error ? string>;
  } : new Error(String(string>;
  } : new Error(String(string>;
  } instanceof Error ? string>;
  } : new Error(String(string>;
  } instanceof Error ? string | number | boolean | null>;
    priority?: number;
    headers?: Record<string, string>;
  } instanceof Error ? string>;
  } : new Error(String(string>;
  } instanceof Error ? string>;
  } instanceof Error ? string>;
  } : new Error(String(string>;
  } : new Error(String(string>;
  } instanceof Error ? string>;
  } : new Error(String(string>;
  } : new Error(String(string | number | boolean | null>;
    priority?: number;
    headers?: Record<string, string>;
  } instanceof Error ? string>;
  } : new Error(String(string>;
  } instanceof Error ? string>;
  } instanceof Error ? string>;
  } : new Error(String(string>;
  } : new Error(String(string>;
  } instanceof Error ? string>;
  } : new Error(String(string>;
  }))))))): Promise<CacheItem> {
    if (!this.config.enabled) {
      throw new Error('Media cache is disabled');
    }

    const url = options.url;
    const quality = options.quality ?? 'auto';
    const metadata = options.metadata ?? {};
    const priority = options.priority ?? 5;
    const headers = options.headers ?? {};
    
    // ç”Ÿæˆç¼“å­˜é¡¹ID
    const cacheId = this.generateCacheId(url, quality);
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    let cacheItem = this.cacheItems.get(cacheId);
    if (cacheItem) {
      // æ›´æ–°è®¿é—®æ—¶é—´å’Œè®¡æ•?      cacheItem.lastAccessTime = Date.now();
      cacheItem.accessCount++;
      cacheItem.metadata = { ...cacheItem.metadata, ...metadata };
      
      // å¦‚æœå·²ç¼“å­˜ï¼Œç›´æ¥è¿”å›
      if (cacheItem.status === CacheStatus.CACHED) {
        this.notifyCacheUpdate(cacheItem);
        await this.saveCacheItems();
        return cacheItem;
      }
      
      // å¦‚æœæ­£åœ¨ç¼“å­˜ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”çš„ä¸‹è½½ä»»åŠ?      const existingTask = Array.from(this.downloadTasks.values())
        .find(task => task.cacheItemId === cacheId);
      
      if (existingTask && existingTask.status === 'downloading') {
        return cacheItem;
      }
    } else {
      // åˆ›å»ºæ–°çš„ç¼“å­˜é¡?      const fileName = this.generateFileName(url, quality);
      const filePath = `${this.cacheDir}/${fileName}`;
      
      cacheItem = {
        id: cacheId,
        url,
        filePath,
        fileName,
        size: 0,
        downloadedSize: 0,
        duration: 0,
        format: this.getFileFormat(url),
        quality,
        mimeType: this.getMimeType(url),
        status: CacheStatus.NOT_CACHED,
        lastAccessTime: Date.now(),
        creationTime: Date.now(),
        accessCount: 1,
        sourceId: metadata.sourceId || '',
        sourceName: metadata.sourceName || '',
        metadata
      };
      
      this.cacheItems.set(cacheId, cacheItem);
    }
    
    // åˆ›å»ºä¸‹è½½ä»»åŠ¡
    const downloadTask: DownloadTask = {
      id: `download_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      cacheItemId: cacheId,
      url,
      filePath: cacheItem.filePath,
      startTime: Date.now(),
      size: cacheItem.size,
      downloadedSize: cacheItem.downloadedSize,
      progress: 0,
      speed: 0,
      status: 'pending',
      retries: 0,
      priority,
      headers
    };
    
    this.downloadTasks.set(downloadTask.id, downloadTask);
    
    // æ›´æ–°ç¼“å­˜é¡¹çŠ¶æ€?    cacheItem.status = CacheStatus.CACHING;
    this.notifyCacheUpdate(cacheItem);
    
    // å¯åŠ¨ä¸‹è½½ä»»åŠ¡
    this.startDownloadTask(downloadTask);
    
    // ä¿å­˜ç¼“å­˜é¡?    await this.saveCacheItems();
    
    return cacheItem;
  }

  /**
   * ç”Ÿæˆç¼“å­˜ID
   */
  private generateCacheId(url: string, quality: string): string {
    // ç®€å•å®ç°ï¼šä½¿ç”¨URLå’Œè´¨é‡çš„å“ˆå¸Œä½œä¸ºID
    // å®é™…åº”ç”¨ä¸­åº”è¯¥ä½¿ç”¨æ›´å®‰å…¨çš„å“ˆå¸Œç®—æ³?    let hash = 0;
    const data = url + quality;
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash |= 0; // è½¬æ¢ä¸?2ä½æ•´æ•?    }
    return `cache_${hash.toString(16)}`;
  }

  /**
   * ç”Ÿæˆæ–‡ä»¶å?   */
  private generateFileName(url: string, quality: string): string {
    const timestamp = Date.now();
    const format = this.getFileFormat(url);
    const safeName = this.sanitizeFileName(url.substring(url.lastIndexOf('/') + 1, url.lastIndexOf('.')));
    return `${safeName}_${quality}_${timestamp}.${format}`;
  }

  /**
   * æ¸…ç†æ–‡ä»¶å?   */
  private sanitizeFileName(name: string): string {
    // ç§»é™¤ä¸å®‰å…¨çš„å­—ç¬¦
    return name.replace(/[<>"/\|?*]/g, '_').substring(0, 50);
  }

  /**
   * è·å–æ–‡ä»¶æ ¼å¼
   */
  private getFileFormat(url: string): string {
    const match = url.match(/\.([^.]+)$/);
    return match ? match[1].toLowerCase() : 'mp4';
  }

  /**
   * è·å–MIMEç±»å‹
   */
  private getMimeType(url: string): string {
    const format = this.getFileFormat(url);
    const mimeTypes: Record<string, string> = {
      mp4: 'video/mp4',
      mkv: 'video/x-matroska',
      avi: 'video/x-msvideo',
      flv: 'video/x-flv',
      webm: 'video/webm',
      mov: 'video/quicktime'
    };
    
    return mimeTypes[format] || 'video/mp4';
  }

  /**
   * å¯åŠ¨ä¸‹è½½ä»»åŠ¡
   */
  private async startDownloadTask(task: DownloadTask): Promise<void> {
    // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§å¹¶å‘ä¸‹è½½æ•°
    if (this.activeTasks >= this.config.maxConcurrentDownloads) {
      // æ·»åŠ åˆ°å¾…å¤„ç†é˜Ÿåˆ—
      this.pendingTasks.push(task);
      Logger.info(TAG, `Task ${task.id} added to pending queue`);
      return;
    }
    
    // æ›´æ–°ä»»åŠ¡çŠ¶æ€?    task.status = 'downloading';
    this.activeTasks++;
    
    // é€šçŸ¥ä»»åŠ¡æ›´æ–°
    this.notifyDownloadUpdate(task);
    
    try {
      // TODO: å®ç°å®é™…çš„ä¸‹è½½é€»è¾‘
      // è¿™é‡Œéœ€è¦ä½¿ç”¨ç½‘ç»œAPIä¸‹è½½æ–‡ä»¶
      Logger.info(TAG, `Starting download task ${task.id}: ${task.url}`);
      
      // æ¨¡æ‹Ÿä¸‹è½½è¿‡ç¨‹
      await this.simulateDownload(task);
      
      // ä¸‹è½½å®Œæˆ
      task.status = 'completed';
      task.endTime = Date.now();
      task.progress = 100;
      
      // æ›´æ–°ç¼“å­˜é¡?      const cacheItem = this.cacheItems.get(task.cacheItemId);
      if (cacheItem) {
        cacheItem.status = CacheStatus.CACHED;
        cacheItem.size = task.size;
        cacheItem.downloadedSize = task.downloadedSize;
        this.notifyCacheUpdate(cacheItem);
        
        // æ›´æ–°ç»Ÿè®¡
        await this.updateCacheStatistics();
        await this.saveCacheItems();
      }
      
    } catch (error) {
      Logger.error(TAG, `Download task ${task.id} failed: ${error}`);
      
      task.status = 'failed';
      task.endTime = Date.now();
      task.retries++;
      
      // æ›´æ–°ç¼“å­˜é¡?      const cacheItem = this.cacheItems.get(task.cacheItemId);
      if (cacheItem) {
        cacheItem.status = CacheStatus.FAILED;
        cacheItem.error = String(error);
        this.notifyCacheUpdate(cacheItem);
      }
      
      // å¦‚æœé‡è¯•æ¬¡æ•°æœªè¾¾åˆ°é™åˆ¶ï¼Œé‡æ–°å°è¯•
      if (task.retries < 3) {
        setTimeout(() => {
          this.retryDownloadTask(task);
        }, 5000 instanceof Error ? 5000 : new Error(String(5000 instanceof Error ? 5000 instanceof Error ? 5000 : new Error(String(5000 : new Error(String(5000 instanceof Error ? 5000 : new Error(String(5000 instanceof Error ? 5000 instanceof Error ? 5000 : new Error(String(5000 instanceof Error ? 5000 instanceof Error ? 5000 : new Error(String(5000 : new Error(String(5000 instanceof Error ? 5000 : new Error(String(5000 : new Error(String(5000 instanceof Error ? 5000 : new Error(String(5000 instanceof Error ? 5000 instanceof Error ? 5000 : new Error(String(5000 : new Error(String(5000 instanceof Error ? 5000 : new Error(String(5000)))))));
      }
    } finally {
      this.activeTasks--;
      this.notifyDownloadUpdate(task);
      
      // å¤„ç†ä¸‹ä¸€ä¸ªå¾…å¤„ç†ä»»åŠ¡
      this.processNextPendingTask();
      
      // å¦‚æœä»»åŠ¡å·²å®Œæˆæˆ–å¤±è´¥ï¼Œä»æ´»åŠ¨ä»»åŠ¡ä¸­ç§»é™?      if (task.status === 'completed' || task.status === 'failed') {
        setTimeout(() => {
          this.downloadTasks.delete(task.id);
        }, 60000); // 1åˆ†é’Ÿåç§»é™?      }
    }
  }

  /**
   * æ¨¡æ‹Ÿä¸‹è½½è¿‡ç¨‹
   */
  private async simulateDownload(task: DownloadTask): Promise<void> {
    // æ¨¡æ‹Ÿéšæœºæ–‡ä»¶å¤§å°ï¼?0MB - 500MBï¼?    const fileSize = Math.floor(Math.random() * 490 * 1024 * 1024) + 10 * 1024 * 1024;
    task.size = fileSize;
    
    let downloaded = task.downloadedSize;
    const chunkSize = 1024 * 1024; // 1MB chunks
    const startTime = Date.now();
    
    while (downloaded < fileSize) {
      // æ¨¡æ‹Ÿä¸‹è½½è¿›åº¦
      const chunkDownloaded = Math.min(chunkSize, fileSize - downloaded);
      downloaded += chunkDownloaded;
      
      // æ›´æ–°ä»»åŠ¡
      task.downloadedSize = downloaded;
      task.progress = Math.round((downloaded / fileSize) * 100);
      
      // è®¡ç®—é€Ÿåº¦
      const elapsed = (Date.now() - startTime) / 1000; // ç§?      task.speed = elapsed > 0 ? (downloaded / elapsed) : 0;
      
      // é€šçŸ¥æ›´æ–°
      this.notifyDownloadUpdate(task);
      
      // çŸ­æš‚å»¶è¿Ÿæ¨¡æ‹Ÿç½‘ç»œä¸‹è½½
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  /**
   * é‡è¯•ä¸‹è½½ä»»åŠ¡
   */
  private retryDownloadTask(task: DownloadTask): void {
    Logger.info(TAG, `Retrying download task ${task.id} (attempt ${task.retries}/3)`);
    this.startDownloadTask(task);
  }

  /**
   * å¤„ç†ä¸‹ä¸€ä¸ªå¾…å¤„ç†ä»»åŠ¡
   */
  private processNextPendingTask(): void {
    if (this.pendingTasks.length === 0 || this.activeTasks >= this.config.maxConcurrentDownloads) {
      return;
    }
    
    // æŒ‰ä¼˜å…ˆçº§æ’åº
    this.pendingTasks.sort((a, b) => b.priority - a.priority);
    
    // å–å‡ºä¸‹ä¸€ä¸ªä»»åŠ?    const nextTask = this.pendingTasks.shift();
    if (nextTask) {
      this.startDownloadTask(nextTask);
    }
  }

  /**
   * æš‚åœä¸‹è½½
   */
  public async pauseDownload(cacheItemId: string): Promise<void> {
    const task = Array.from(this.downloadTasks.values())
      .find(t => t.cacheItemId === cacheItemId && t.status === 'downloading');
    
    if (task) {
      task.status = 'paused';
      this.notifyDownloadUpdate(task);
      
      // ä»æ´»åŠ¨ä»»åŠ¡ä¸­å‡å°‘è®¡æ•°
      this.activeTasks--;
      
      // å¤„ç†ä¸‹ä¸€ä¸ªä»»åŠ?      this.processNextPendingTask();
      
      // æ›´æ–°ç¼“å­˜é¡¹çŠ¶æ€?      const cacheItem = this.cacheItems.get(cacheItemId);
      if (cacheItem) {
        cacheItem.status = CacheStatus.PARTIALLY_CACHED;
        cacheItem.downloadedSize = task.downloadedSize;
        this.notifyCacheUpdate(cacheItem);
        await this.saveCacheItems();
      }
    }
  }

  /**
   * æ¢å¤ä¸‹è½½
   */
  public async resumeDownload(cacheItemId: string): Promise<void> {
    const task = Array.from(this.downloadTasks.values())
      .find(t => t.cacheItemId === cacheItemId && t.status === 'paused');
    
    if (task) {
      this.startDownloadTask(task);
    } else {
      // å¦‚æœä»»åŠ¡ä¸å­˜åœ¨ï¼Œé‡æ–°åˆ›å»º
      const cacheItem = this.cacheItems.get(cacheItemId);
      if (cacheItem) {
        await this.cacheMedia({
          url: cacheItem.url,
          quality: cacheItem.quality,
          metadata: cacheItem.metadata
        });
      }
    }
  }

  /**
   * å–æ¶ˆä¸‹è½½
   */
  public async cancelDownload(cacheItemId: string): Promise<void> {
    const task = Array.from(this.downloadTasks.values())
      .find(t => t.cacheItemId === cacheItemId && 
            (t.status === 'downloading' || t.status === 'paused' || t.status === 'pending'));
    
    if (task) {
      task.status = 'canceled';
      this.notifyDownloadUpdate(task);
      
      // å¦‚æœæ­£åœ¨ä¸‹è½½ï¼Œå‡å°‘æ´»åŠ¨ä»»åŠ¡è®¡æ•?      if (task.status === 'downloading') {
        this.activeTasks--;
        this.processNextPendingTask();
      }
      
      // ä»å¾…å¤„ç†é˜Ÿåˆ—ä¸­ç§»é™?      const pendingIndex = this.pendingTasks.findIndex(t => t.id === task.id);
      if (pendingIndex > -1) {
        this.pendingTasks.splice(pendingIndex, 1);
      }
      
      // æ›´æ–°ç¼“å­˜é¡?      const cacheItem = this.cacheItems.get(cacheItemId);
      if (cacheItem) {
        cacheItem.status = CacheStatus.NOT_CACHED;
        cacheItem.downloadedSize = 0;
        this.notifyCacheUpdate(cacheItem);
        await this.saveCacheItems();
      }
      
      // åˆ é™¤ä¸´æ—¶æ–‡ä»¶
      await this.deleteFile(task.filePath);
    }
  }

  /**
   * åˆ é™¤æ–‡ä»¶
   */
  private async deleteFile(filePath: string): Promise<void> {
    try {
      // TODO: ä½¿ç”¨æ–‡ä»¶APIåˆ é™¤æ–‡ä»¶
      Logger.debug(TAG, `Deleting file: ${filePath}`);
    } catch (error) {
      Logger.error(TAG, `Failed to delete file ${filePath}: ${error}`);
    }
  }

  /**
   * è·å–ç¼“å­˜é¡?   */
  public getCacheItem(cacheItemId: string): CacheItem | null {
    const item = this.cacheItems.get(cacheItemId);
    if (item) {
      // æ›´æ–°è®¿é—®æ—¶é—´å’Œè®¡æ•?      item.lastAccessTime = Date.now();
      item.accessCount++;
      this.notifyCacheUpdate(item);
      this.cacheHitCount++;
      return { ...item };
    }
    
    this.cacheMissCount++;
    return null;
  }

  /**
   * é€šè¿‡URLæŸ¥æ‰¾ç¼“å­˜é¡?   */
  public findCacheItemByUrl(url: string, quality?: string instanceof Error ? quality?: string : new Error(String(quality?: string instanceof Error ? quality?: string instanceof Error ? quality?: string : new Error(String(quality?: string : new Error(String(quality?: string instanceof Error ? quality?: string : new Error(String(quality?: string instanceof Error ? quality?: string instanceof Error ? quality?: string : new Error(String(quality?: string instanceof Error ? quality?: string instanceof Error ? quality?: string : new Error(String(quality?: string : new Error(String(quality?: string instanceof Error ? quality?: string : new Error(String(quality?: string : new Error(String(quality?: string instanceof Error ? quality?: string : new Error(String(quality?: string instanceof Error ? quality?: string instanceof Error ? quality?: string : new Error(String(quality?: string : new Error(String(quality?: string instanceof Error ? quality?: string : new Error(String(quality?: string))))))): CacheItem | null {
    const cacheId = this.generateCacheId(url, quality || 'auto');
    return this.getCacheItem(cacheId);
  }

  /**
   * åˆ—å‡ºç¼“å­˜é¡?   */
  public listCacheItems(options?: CacheQueryOptions): CacheItem[] {
    let items = Array.from(this.cacheItems.values());
    
    // åº”ç”¨è¿‡æ»¤æ¡ä»¶
    if (options) {
      if (options.status) {
        items = items.filter(item => item.status === options.status);
      }
      
      if (options.sourceId) {
        items = items.filter(item => item.sourceId === options.sourceId);
      }
      
      if (options.minSize !== undefined) {
        items = items.filter(item => item.size >= options.minSize!);
      }
      
      if (options.maxSize !== undefined) {
        items = items.filter(item => item.size <= options.maxSize!);
      }
      
      if (options.startDate !== undefined) {
        items = items.filter(item => item.creationTime >= options.startDate!);
      }
      
      if (options.endDate !== undefined) {
        items = items.filter(item => item.creationTime <= options.endDate!);
      }
      
      if (options.quality) {
        items = items.filter(item => item.quality === options.quality);
      }
    }
    
    // åº”ç”¨æ’åº
    if (options?.sortBy) {
      items.sort((a, b) => {
        let aValue: Record<string, string | number | boolean | null>;
  let bValue: Record<string, string | number | boolean | null>;
        
        switch (options.sortBy) {
          case 'size':
            aValue = a.size;
            bValue = b.size;
            break;
          case 'time':
            aValue = a.lastAccessTime;
            bValue = b.lastAccessTime;
            break;
          case 'accessCount':
            aValue = a.accessCount;
            bValue = b.accessCount;
            break;
          default:
            return 0;
        }
        
        return options.sortOrder === 'desc' ? bValue - aValue : aValue - bValue;
      });
    }
    
    // åº”ç”¨åˆ†é¡µ
    if (options?.offset !== undefined) {
      items = items.slice(options.offset);
    }
    
    if (options?.limit !== undefined) {
      items = items.slice(0, options.limit);
    }
    
    return items.map(item => ({ ...item }));
  }

  /**
   * ç§»é™¤ç¼“å­˜é¡?   */
  public async removeCacheItems(cacheItemIds: string[]): Promise<void> {
    for (const id of cacheItemIds) {
      const item = this.cacheItems.get(id);
      if (item) {
        // å–æ¶ˆç›¸å…³ä¸‹è½½ä»»åŠ¡
        await this.cancelDownload(id);
        
        // åˆ é™¤æ–‡ä»¶
        await this.deleteFile(item.filePath);
        
        // ä»ç¼“å­˜é¡¹åˆ—è¡¨ä¸­ç§»é™?        this.cacheItems.delete(id);
        
        Logger.info(TAG, `Removed cache item: ${id}`);
      }
    }
    
    // æ›´æ–°ç»Ÿè®¡
    await this.updateCacheStatistics();
    await this.saveCacheItems();
  }

  /**
   * æ¸…ç†ç¼“å­˜
   */
  public async cleanCache(options?: CacheCleanOptions): Promise<number> {
    if (!this.config.enabled) {
      return 0;
    }
    
    let itemsToRemove: CacheItem[] = [];
    const allItems = Array.from(this.cacheItems.values());
    
    // åº”ç”¨æ¸…ç†é€‰é¡¹
    if (options) {
      if (options.olderThanDays) {
        const cutoffTime = Date.now() - (options.olderThanDays * 24 * 60 * 60 * 1000);
        itemsToRemove = itemsToRemove.concat(
          allItems.filter(item => item.creationTime < cutoffTime)
        );
      }
      
      if (options.status) {
        itemsToRemove = itemsToRemove.concat(
          allItems.filter(item => item.status === options.status)
        );
      }
      
      if (options.sourceId) {
        itemsToRemove = itemsToRemove.concat(
          allItems.filter(item => item.sourceId === options.sourceId)
        );
      }
      
      if (options.quality) {
        itemsToRemove = itemsToRemove.concat(
          allItems.filter(item => item.quality === options.quality)
        );
      }
      
      if (options.maxSize && this.cacheStats.usedSize > options.maxSize) {
        // æ ¹æ®ç¼“å­˜ç­–ç•¥æ¸…ç†åˆ°æŒ‡å®šå¤§å°?        const bytesToClean = this.cacheStats.usedSize - options.maxSize;
        const sortedItems = this.sortItemsByStrategy(allItems);
        
        let cleanedBytes = 0;
        for (const item of sortedItems) {
          if (cleanedBytes >= bytesToClean) {
            break;
          }
          
          if (!itemsToRemove.find(i => i.id === item.id)) {
            itemsToRemove.push(item);
            cleanedBytes += item.size;
          }
        }
      }
    } else {
      // æ¸…ç†æ‰€æœ‰ç¼“å­?      itemsToRemove = allItems;
    }
    
    // æ’é™¤æŒ‡å®šçš„ID
    if (options?.exceptIds) {
      itemsToRemove = itemsToRemove.filter(item => !options.exceptIds!.includes(item.id));
    }
    
    // å»é‡
    const uniqueItems = itemsToRemove.filter((item, index, self) =>
      index === self.findIndex(i => i.id === item.id)
    );
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºæ¨¡æ‹Ÿè¿è¡Œ
    if (options?.dryRun) {
      Logger.info(TAG, `Dry run: would remove ${uniqueItems.length} cache items`);
      return uniqueItems.length;
    }
    
    // æ‰§è¡Œæ¸…ç†
    if (uniqueItems.length > 0) {
      await this.removeCacheItems(uniqueItems.map(item => item.id));
    }
    
    return uniqueItems.length;
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰ç¼“å­?   */
  public async clearAllCache(): Promise<void> {
    await this.cleanCache();
    Logger.info(TAG, 'All cache cleared');
  }

  /**
   * æ ¹æ®ç­–ç•¥æ’åºç¼“å­˜é¡?   */
  private sortItemsByStrategy(items: CacheItem[]): CacheItem[] {
    const sorted = [...items];
    
    switch (this.config.cacheStrategy) {
      case CacheStrategy.FIRST_IN_FIRST_OUT:
        return sorted.sort((a, b) => a.creationTime - b.creationTime);
      case CacheStrategy.LEAST_RECENTLY_USED:
        return sorted.sort((a, b) => a.lastAccessTime - b.lastAccessTime);
      case CacheStrategy.LEAST_FREQUENTLY_USED:
        return sorted.sort((a, b) => a.accessCount - b.accessCount);
      case CacheStrategy.SIZE_BASED:
        return sorted.sort((a, b) => b.size - a.size);
      case CacheStrategy.TIME_BASED:
        return sorted.sort((a, b) => a.lastAccessTime - b.lastAccessTime);
      default:
        return sorted;
    }
  }

  /**
   * é¢„åŠ è½½åª’ä½?   */
  public async preloadMedia(options: PreloadOptions): Promise<void> {
    if (!this.config.enabled || !this.config.preloadEnabled) {
      return;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²ç¼“å­˜
    const existingItem = this.findCacheItemByUrl(options.url, options.quality);
    if (existingItem && existingItem.status === CacheStatus.CACHED) {
      return;
    }
    
    // å¼€å§‹é¢„åŠ è½½
    await this.cacheMedia({
      url: options.url,
      quality: options.quality,
      metadata: options.metadata,
      priority: options.priority
    });
  }

  /**
   * è·å–ä¸‹è½½ä»»åŠ¡
   */
  public getDownloadTask(taskId: string): DownloadTask | null {
    const task = this.downloadTasks.get(taskId);
    return task ? { ...task } : null;
  }

  /**
   * åˆ—å‡ºä¸‹è½½ä»»åŠ¡
   */
  public listDownloadTasks(): DownloadTask[] {
    return Array.from(this.downloadTasks.values()).map(task => ({ ...task }));
  }

  /**
   * é€šçŸ¥ç¼“å­˜æ›´æ–°
   */
  private notifyCacheUpdate(item: CacheItem): void {
    const listeners = this.cacheListeners.get(item.id) || [];
    for (const listener of listeners) {
      try {
        listener({ ...item });
      } catch (error) {
        Logger.error(TAG, `Error in cache listener: ${error}`);
      }
    }
  }

  /**
   * é€šçŸ¥ä¸‹è½½æ›´æ–°
   */
  private notifyDownloadUpdate(task: DownloadTask): void {
    const listeners = this.downloadListeners.get(task.id) || [];
    for (const listener of listeners) {
      try {
        listener({ ...task });
      } catch (error) {
        Logger.error(TAG, `Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}` instanceof Error ? `Error in download listener: ${error}` : new Error(String(`Error in download listener: ${error}`)))))));
      }
    }
  }

  /**
   * æ·»åŠ ç¼“å­˜ç›‘å¬
   */
  public addCacheListener(cacheItemId: string, listener: CacheListener): void {
    if (!this.cacheListeners.has(cacheItemId)) {
      this.cacheListeners.set(cacheItemId, []);
    }
    
    this.cacheListeners.get(cacheItemId)!.push(listener);
  }

  /**
   * ç§»é™¤ç¼“å­˜ç›‘å¬
   */
  public removeCacheListener(cacheItemId: string, listener: CacheListener): void {
    if (this.cacheListeners.has(cacheItemId)) {
      const listeners = this.cacheListeners.get(cacheItemId)!;
      const index = listeners.indexOf(listener);
      
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }

  /**
   * æ·»åŠ ä¸‹è½½ç›‘å¬
   */
  public addDownloadListener(taskId: string, listener: DownloadListener): void {
    if (!this.downloadListeners.has(taskId)) {
      this.downloadListeners.set(taskId, []);
    }
    
    this.downloadListeners.get(taskId)!.push(listener);
  }

  /**
   * ç§»é™¤ä¸‹è½½ç›‘å¬
   */
  public removeDownloadListener(taskId: string, listener: DownloadListener): void {
    if (this.downloadListeners.has(taskId)) {
      const listeners = this.downloadListeners.get(taskId)!;
      const index = listeners.indexOf(listener);
      
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
  }

  /**
   * å…³é—­åª’ä½“ç¼“å­˜æœåŠ¡
   */
  public async close(): Promise<void> {
    if (!this.isInitialized) {
      return;
    }

    // åœæ­¢æ‰€æœ‰ä¸‹è½?    const activeTasks = Array.from(this.downloadTasks.values())
      .filter(task => task.status === 'downloading');
    
    for (const task of activeTasks) {
      task.status = 'paused';
      this.notifyDownloadUpdate(task);
    }
    
    this.activeTasks = 0;
    
    // åœæ­¢è‡ªåŠ¨æ¸…ç†
    this.stopAutoCleanup();
    
    // ä¿å­˜æ•°æ®
    await this.saveCacheItems();

    this.isInitialized = false;
    Logger.info(TAG, 'Media cache service closed');
  }
}


