import Logger from '../../common/util/Logger';
import gesture from '@ohos.multimodalInput.gesture';
import input from '@ohos.multimodalInput.input';
import BusinessError from '@ohos.base';

/**
 * æ‰‹åŠ¿åŸå§‹äº‹ä»¶æ¥å£
 */
export interface GestureRawEvent {
  type: string;
  x?: number;
  y?: number;
  timestamp?: number;
  pointers?: Object;
  deviceId?: number;
  button?: number;
  direction?: string;
  distance?: number;
  velocity?: number;
  scale?: number;
  rotation?: number;
}

/**
 * æ‰‹åŠ¿ç±»å‹æšä¸¾
 */
export enum GestureType {
  TAP = 'tap',
  DOUBLE_TAP = 'doubleTap',
  LONG_PRESS = 'longPress',
  SWIPE = 'swipe',
  PINCH = 'pinch',
  ROTATE = 'rotate',
  PAN = 'pan'
}

/**
 * æ–¹å‘æšä¸¾
 */
export enum Direction {
  UP = 'up',
  DOWN = 'down',
  LEFT = 'left',
  RIGHT = 'right'
}

/**
 * æ‰‹åŠ¿äº‹ä»¶æ¥å£
 */
export interface GestureEvent {
  type: GestureType;
  x: number;
  y: number;
  timestamp: number;
  direction?: Direction;
  distance?: number;
  velocity?: number;
  scale?: number;
  rotation?: number;
}

/**
 * æ‰‹åŠ¿é…ç½®æ¥å£
 */
export interface GestureConfig {
  enableTap?: boolean;
  enableDoubleTap?: boolean;
  enableLongPress?: boolean;
  enableSwipe?: boolean;
  enablePinch?: boolean;
  enableRotate?: boolean;
  enablePan?: boolean;
  swipeThreshold?: number; // æ»‘åŠ¨é˜ˆå€?  longPressDuration?: number; // é•¿æŒ‰æŒç»­æ—¶é—´
}

/**
 * æ‰‹åŠ¿æœåŠ¡æ¥å£
 */
export interface GestureService {
  // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ?  init(config?: GestureConfig): Promise<void>;
  
  // è®¾ç½®æ‰‹åŠ¿ç›‘å¬
  onGesture(callback: (event: GestureEvent) => void): void;
  
  // è®¾ç½®ç‰¹å®šç±»å‹æ‰‹åŠ¿ç›‘å¬
  on(type: GestureType, callback: (event: GestureEvent) => void): void;
  
  // å–æ¶ˆç‰¹å®šç±»å‹æ‰‹åŠ¿ç›‘å¬
  off(type: GestureType): void;
  
  // å–æ¶ˆæ‰€æœ‰æ‰‹åŠ¿ç›‘å?  offAll(): void;
  
  // é”€æ¯æ‰‹åŠ¿æœåŠ?  destroy(): void;
}

/**
 * æ‰‹åŠ¿æœåŠ¡å®ç°ç±? * åŸºäºHarmonyOS @ohos.multimodalInput.gesture APIå®ç°æ‰‹åŠ¿è¯†åˆ«åŠŸèƒ½
 */
export class GestureServiceImpl implements GestureService {
  private readonly TAG: string = 'GestureServiceImpl';
  private isInitialized: boolean = false;
  private gestureManager: gesture.GestureManager | null = null;
  private config: GestureConfig = {};
  private globalCallback?: (event: GestureEvent) => void;
  private gestureCallbacks: Map<GestureType, (event: GestureEvent) => void> = new Map();
  private subscription: number = -1;
  
  /**
   * åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ?   */
  async init(config?: GestureConfig): Promise<void> {
    try {
      if (this.isInitialized) {
        Logger.warn(this.TAG, 'Gesture service already initialized');
        return;
      }
      
      // åˆå¹¶é…ç½®
      this.config = {
        enableTap: true,
        enableDoubleTap: true,
        enableLongPress: true,
        enableSwipe: true,
        enablePinch: true,
        enableRotate: true,
        enablePan: true,
        swipeThreshold: 50,
        longPressDuration: 500,
        ...config
      };
      
      // åˆ›å»ºæ‰‹åŠ¿ç®¡ç†å™?      this.gestureManager = await gesture.createGestureManager();
      
      // è®¢é˜…æ‰‹åŠ¿äº‹ä»¶
      this.subscribeToGestureEvents();
      
      this.isInitialized = true;
      Logger.info(this.TAG, 'Gesture service initialized successfully');
    } catch (error) {
      Logger.error(this.TAG, `Failed to initialize gesture service: ${error}`);
      throw error;
    }
  }
  
  /**
   * è®¾ç½®å…¨å±€æ‰‹åŠ¿ç›‘å¬
   */
  onGesture(callback: (event: GestureEvent) => void): void {
    this.globalCallback = callback;
    Logger.info(this.TAG, 'Global gesture callback set' instanceof Error ? 'Global gesture callback set' : new Error(String('Global gesture callback set' instanceof Error ? 'Global gesture callback set' instanceof Error ? 'Global gesture callback set' : new Error(String('Global gesture callback set' : new Error(String('Global gesture callback set' instanceof Error ? 'Global gesture callback set' : new Error(String('Global gesture callback set' instanceof Error ? 'Global gesture callback set' instanceof Error ? 'Global gesture callback set' : new Error(String('Global gesture callback set' instanceof Error ? 'Global gesture callback set' instanceof Error ? 'Global gesture callback set' : new Error(String('Global gesture callback set' : new Error(String('Global gesture callback set' instanceof Error ? 'Global gesture callback set' : new Error(String('Global gesture callback set' : new Error(String('Global gesture callback set' instanceof Error ? 'Global gesture callback set' : new Error(String('Global gesture callback set' instanceof Error ? 'Global gesture callback set' instanceof Error ? 'Global gesture callback set' : new Error(String('Global gesture callback set' : new Error(String('Global gesture callback set' instanceof Error ? 'Global gesture callback set' : new Error(String('Global gesture callback set')))))));
  }
  
  /**
   * è®¾ç½®ç‰¹å®šç±»å‹æ‰‹åŠ¿ç›‘å¬
   */
  on(type: GestureType, callback: (event: GestureEvent) => void): void {
    this.gestureCallbacks.set(type, callback);
    Logger.info(this.TAG, `Gesture callback set for type: ${type}`);
  }
  
  /**
   * å–æ¶ˆç‰¹å®šç±»å‹æ‰‹åŠ¿ç›‘å¬
   */
  off(type: GestureType): void {
    this.gestureCallbacks.delete(type);
    Logger.info(this.TAG, `Gesture callback removed for type: ${type}`);
  }
  
  /**
   * å–æ¶ˆæ‰€æœ‰æ‰‹åŠ¿ç›‘å?   */
  offAll(): void {
    this.globalCallback = undefined;
    this.gestureCallbacks.clear();
    Logger.info(this.TAG, 'All gesture callbacks removed');
  }
  
  /**
   * é”€æ¯æ‰‹åŠ¿æœåŠ?   */
  destroy(): void {
    try {
      if (this.subscription >= 0) {
        input.off(this.subscription);
        this.subscription = -1;
      }
      
      this.globalCallback = undefined;
      this.gestureCallbacks.clear();
      this.isInitialized = false;
      
      Logger.info(this.TAG, 'Gesture service destroyed');
    } catch (error) {
      Logger.error(this.TAG, `Failed to destroy gesture service: ${error}`);
    }
  }
  
  /**
   * è®¢é˜…æ‰‹åŠ¿äº‹ä»¶
   */
  subscribeToGestureEvents(): void {
    try {
      this.subscription = input.on('multimodalGesture', (event instanceof Error ? (event : new Error(String((event instanceof Error ? (event instanceof Error ? (event : new Error(String((event : new Error(String((event instanceof Error ? (event : new Error(String((event instanceof Error ? (event instanceof Error ? (event : new Error(String((event instanceof Error ? (event instanceof Error ? (event : new Error(String((event : new Error(String((event instanceof Error ? (event : new Error(String((event : new Error(String((event instanceof Error ? (event : new Error(String((event instanceof Error ? (event instanceof Error ? (event : new Error(String((event : new Error(String((event instanceof Error ? (event : new Error(String((event))))))) => {
        this.handleGestureEvent(event);
      });
      
      Logger.info(this.TAG, 'Gesture events subscribed');
    } catch (error) {
      Logger.error(this.TAG, `Failed to subscribe to gesture events: ${error}`);
    }
  }
  
  /**
   * å¤„ç†æ‰‹åŠ¿äº‹ä»¶
   */
  handleGestureEvent(event: GestureRawEvent): void {
    try {
      // æ„å»ºæ ‡å‡†åŒ–çš„æ‰‹åŠ¿äº‹ä»¶
      const gestureEvent: GestureEvent = this.buildGestureEvent(event);
      if (!gestureEvent) return;
      
      // è§¦å‘å…¨å±€å›è°ƒ
      if (this.globalCallback) {
        this.globalCallback(gestureEvent);
      }
      
      // è§¦å‘ç‰¹å®šç±»å‹å›è°ƒ
      const specificCallback = this.gestureCallbacks.get(gestureEvent.type);
      if (specificCallback) {
        specificCallback(gestureEvent);
      }
    } catch (error) {
      Logger.error(this.TAG, `Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}` instanceof Error ? `Failed to handle gesture event: ${error}` : new Error(String(`Failed to handle gesture event: ${error}`)))))));
    }
  }
  
  /**
   * æ„å»ºæ ‡å‡†åŒ–çš„æ‰‹åŠ¿äº‹ä»¶
   */
  buildGestureEvent(event: GestureRawEvent): GestureEvent | null {
    try {
      // æ ¹æ®äº‹ä»¶ç±»å‹è½¬æ¢ä¸ºæ ‡å‡†æ‰‹åŠ¿äº‹ä»?      switch (event.type) {
        case 'tap':
          if (!this.config.enableTap) return null;
          return {
            type: GestureType.TAP,
            x: event.x,
            y: event.y,
            timestamp: event.timestamp
          };
          
        case 'doubleTap':
          if (!this.config.enableDoubleTap) return null;
          return {
            type: GestureType.DOUBLE_TAP,
            x: event.x,
            y: event.y,
            timestamp: event.timestamp
          };
          
        case 'longPress':
          if (!this.config.enableLongPress) return null;
          return {
            type: GestureType.LONG_PRESS,
            x: event.x,
            y: event.y,
            timestamp: event.timestamp,
            duration: event.duration
          };
          
        case 'swipe':
          if (!this.config.enableSwipe) return null;
          // æ£€æŸ¥æ»‘åŠ¨è·ç¦»æ˜¯å¦è¶…è¿‡é˜ˆå€?          if (Math.abs(event.distance) < this.config.swipeThreshold) return null;
          
          let direction: Direction;
          if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {
            direction = event.deltaX > 0 ? Direction.RIGHT : Direction.LEFT;
          } else {
            direction = event.deltaY > 0 ? Direction.DOWN : Direction.UP;
          }
          
          return {
            type: GestureType.SWIPE,
            x: event.x,
            y: event.y,
            timestamp: event.timestamp,
            direction: direction,
            distance: event.distance,
            velocity: event.velocity
          };
          
        case 'pinch':
          if (!this.config.enablePinch) return null;
          return {
            type: GestureType.PINCH,
            x: event.x || 0,
            y: event.y || 0,
            timestamp: event.timestamp || 0,
            scale: event.scale || 1
          };
          
        case 'rotate':
          if (!this.config.enableRotate) return null;
          return {
            type: GestureType.ROTATE,
            x: event.x,
            y: event.y,
            timestamp: event.timestamp,
            rotation: event.rotation
          };
          
        case 'pan':
          if (!this.config.enablePan) return null;
          return {
            type: GestureType.PAN,
            x: event.x,
            y: event.y,
            timestamp: event.timestamp,
            distance: Math.sqrt(event.deltaX * event.deltaX + event.deltaY * event.deltaY)
          };
          
        default:
          return null;
      }
    } catch (error) {
      Logger.error(this.TAG, `Failed to build gesture event: ${error}`);
      return null;
    }
  }
}

/**
 * æ‰‹åŠ¿æœåŠ¡å•ä¾‹
 */
export const GestureServiceInstance: GestureService = new GestureServiceImpl();


