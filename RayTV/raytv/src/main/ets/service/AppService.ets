// AppService - åº”ç”¨æœåŠ¡ç±?import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import JsonUtil from '../../common/util/JsonUtil';
import ConfigService from './config/ConfigService';
import CacheService from './cache/CacheService';
import HttpService from './HttpService';
import AuthService from './user/UserService';
import MovieService from './media/MovieService';
import HistoryService from './media/HistoryService';
import CollectionService from './collection/CollectionService';
import DownloadService from './download/DownloadService';
import PlayerService from './player/PlayerService';
import LiveStreamService from './live/LiveStreamService';
import SubtitleService from './media/SubtitleService';
import FileService from './storage/FileService';
import RepositoryFactory from '../../data/repository/RepositoryFactory';
import { getParserService } from './parser/index';

// å¸¸é‡å®šä¹‰
const TAG = 'AppService';
const APP_STATE_KEY = 'app_state';
const APP_VERSION_KEY = 'app_version';
const INITIALIZATION_TIMEOUT = 30000; // 30ç§?
// åº”ç”¨çŠ¶æ€æšä¸?export enum AppState {
  CREATED = 'created',
  INITIALIZING = 'initializing',
  READY = 'ready',
  BACKGROUND = 'background',
  FOREGROUND = 'foreground',
  SUSPENDED = 'suspended',
  SHUTTING_DOWN = 'shutting_down',
  ERROR = 'error'
}

// åº”ç”¨é”™è¯¯ç±»å‹æšä¸¾
export enum AppErrorType {
  INITIALIZATION_FAILED = 'initialization_failed',
  SERVICE_ERROR = 'service_error',
  NETWORK_ERROR = 'network_error',
  STORAGE_ERROR = 'storage_error',
  PERMISSION_ERROR = 'permission_error',
  UNKNOWN_ERROR = 'unknown_error'
}

// åº”ç”¨ä¿¡æ¯æ¥å£
export interface AppInfo {
  appName: string;
  packageName: string;
  versionName: string;
  versionCode: number;
  buildType: 'debug' | 'release';
  targetSdkVersion: number;
  minSdkVersion: number;
  deviceId: string;
  deviceModel: string;
  deviceManufacturer: string;
  osVersion: string;
  screenWidth: number;
  screenHeight: number;
  isTablet: boolean;
  isTV: boolean;
  countryCode: string;
  languageCode: string;
  isRooted: boolean;
  installTime: number;
  lastUpdateTime: number;
  firstLaunchTime: number;
  launchCount: number;
  totalRunningTime: number;
  lastLaunchTime: number;
}

// åº”ç”¨é…ç½®æ¥å£
export interface AppConfig {
  enableAnalytics: boolean;
  enableCrashReporting: boolean;
  enableAutoUpdate: boolean;
  enableBackgroundSync: boolean;
  enableNotifications: boolean;
  enableNightMode: boolean;
  enableHardwareAcceleration: boolean;
  enableGestureNavigation: boolean;
  enableDataSaver: boolean;
  autoPlayNextVideo: boolean;
  autoResumePlayback: boolean;
  maxVideoQuality: 'low' | 'medium' | 'high' | 'auto';
  defaultSubtitleLanguage: string;
  defaultAudioLanguage: string;
  playbackSpeed: number;
  theme: 'light' | 'dark' | 'system';
  language: string;
  interfaceScale: 'small' | 'medium' | 'large';
  animationEnabled: boolean;
  cacheEnabled: boolean;
  networkTimeout: number;
  retryCount: number;
}

// åº”ç”¨ç»Ÿè®¡æ¥å£
export interface AppStatistics {
  totalLaunches: number;
  totalPlaybackTime: number;
  totalDownloadedSize: number;
  totalUploadedSize: number;
  totalSearchQueries: number;
  totalContentViews: number;
  totalFavorites: number;
  totalHistoryItems: number;
  lastCleanupTime: number;
  lastBackupTime: number;
  lastRestoreTime: number;
  lastUpdateCheckTime: number;
  deviceStorageUsed: number;
  deviceStorageTotal: number;
}

// åº”ç”¨é”™è¯¯æ¥å£
export interface AppError {
  type: AppErrorType;
  code: string;
  message: string;
  stackTrace?: string;
  context?: Record<string, unknown>;
  timestamp: number;
}

// åº”ç”¨äº‹ä»¶ç±»å‹æšä¸¾
export enum AppEventType {
  INITIALIZED = 'initialized',
  READY = 'ready',
  BACKGROUND = 'background',
  FOREGROUND = 'foreground',
  SHUTDOWN = 'shutdown',
  ERROR = 'error',
  UPDATE_AVAILABLE = 'update_available',
  CONFIG_CHANGED = 'config_changed',
  USER_LOGIN = 'user_login',
  USER_LOGOUT = 'user_logout',
  NETWORK_CHANGE = 'network_change',
  STORAGE_WARNING = 'storage_warning',
  CLEANUP_COMPLETED = 'cleanup_completed'
}

// åº”ç”¨äº‹ä»¶æ¥å£
export interface AppEvent<T = any> {
  type: AppEventType;
  data?: T;
  timestamp: number;
}

// åº”ç”¨å¤‡ä»½é€‰é¡¹æ¥å£
export interface AppBackupOptions {
  includeUserData: boolean;
  includeSettings: boolean;
  includeHistory: boolean;
  includeCollections: boolean;
  includeDownloads: boolean;
  includeCache: boolean;
  excludeKeys?: string[];
  password?: string;
  compress: boolean;
}

// åº”ç”¨æ¢å¤é€‰é¡¹æ¥å£
export interface AppRestoreOptions {
  overwriteExisting: boolean;
  includeUserData: boolean;
  includeSettings: boolean;
  includeHistory: boolean;
  includeCollections: boolean;
  includeDownloads: boolean;
  includeCache: boolean;
  password?: string;
  validateOnly: boolean;
}

// åº”ç”¨å¤‡ä»½ä¿¡æ¯æ¥å£
export interface AppBackupInfo {
  version: string;
  timestamp: number;
  size: number;
  description?: string;
  deviceInfo?: string;
  includes: {
    userData: boolean;
    settings: boolean;
    history: boolean;
    collections: boolean;
    downloads: boolean;
    cache: boolean;
  };
  hash?: string;
  encrypted: boolean;
}

// é»˜è®¤åº”ç”¨é…ç½®
const DEFAULT_APP_CONFIG: AppConfig = {
  enableAnalytics: true,
  enableCrashReporting: true,
  enableAutoUpdate: true,
  enableBackgroundSync: true,
  enableNotifications: true,
  enableNightMode: false,
  enableHardwareAcceleration: true,
  enableGestureNavigation: true,
  enableDataSaver: false,
  autoPlayNextVideo: true,
  autoResumePlayback: true,
  maxVideoQuality: 'high',
  defaultSubtitleLanguage: 'auto',
  defaultAudioLanguage: 'auto',
  playbackSpeed: 1.0,
  theme: 'system',
  language: 'auto',
  interfaceScale: 'medium',
  animationEnabled: true,
  cacheEnabled: true,
  networkTimeout: 30000,
  retryCount: 3
};

/**
 * åº”ç”¨æœåŠ¡ç±? * è´Ÿè´£ç®¡ç†åº”ç”¨ç¨‹åºçš„å…¨å±€çŠ¶æ€ã€ç”Ÿå‘½å‘¨æœŸå’Œé€šç”¨åŠŸèƒ½
 */
export default class AppService {
  private static instance: AppService;
  
  private currentState: AppState = AppState.CREATED;
  private appInfo: AppInfo | null = null;
  private appConfig: AppConfig = { ...DEFAULT_APP_CONFIG };
  private appStatistics: AppStatistics = this.createDefaultStatistics();
  private errorHistory: AppError[] = [];
  private eventHistory: AppEvent[] = [];
  
  // æœåŠ¡æ˜ å°„
  private services: Map<string, Object> = new Map();
  
  // åˆå§‹åŒ–çŠ¶æ€?  private initializationPromise: Promise<void> | null = null;
  private initializationStartTime: number = 0;
  private isInitialized: boolean = false;
  
  // ç›‘å¬å™?  private stateListeners: Array<(newState: AppState, oldState: AppState) => void> = [];
  private eventListeners: Array<(event: AppEvent) => void> = [];
  private errorListeners: Array<(error: AppError) => void> = [];
  
  // åº”ç”¨å¯åŠ¨æ—¶é—´
  private startTime: number = Date.now();
  
  // ç‰ˆæœ¬ä¿¡æ¯
  private currentVersion: string = '1.0.0';
  private buildNumber: number = 1;

  /**
   * æ„é€ å‡½æ•°ï¼ˆç§æœ‰ï¼Œé˜²æ­¢å¤–éƒ¨å®ä¾‹åŒ–ï¼?   */
  private constructor() {
    // æ•è·å…¨å±€é”™è¯¯
    this.setupGlobalErrorHandling();
    
    // è®°å½•å¯åŠ¨æ—¶é—´
    this.startTime = Date.now();
    
    Logger.info(TAG, `Application started, version: ${this.currentVersion}, build: ${this.buildNumber}`);
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): AppService {
    if (!AppService.instance) {
      AppService.instance = new AppService();
    }
    return AppService.instance;
  }

  /**
   * åˆ›å»ºé»˜è®¤ç»Ÿè®¡ä¿¡æ¯
   */
  private createDefaultStatistics(): AppStatistics {
    return {
      totalLaunches: 0,
      totalPlaybackTime: 0,
      totalDownloadedSize: 0,
      totalUploadedSize: 0,
      totalSearchQueries: 0,
      totalContentViews: 0,
      totalFavorites: 0,
      totalHistoryItems: 0,
      lastCleanupTime: 0,
      lastBackupTime: 0,
      lastRestoreTime: 0,
      lastUpdateCheckTime: 0,
      deviceStorageUsed: 0,
      deviceStorageTotal: 0
    };
  }

  /**
   * è®¾ç½®å…¨å±€é”™è¯¯å¤„ç†
   */
  private setupGlobalErrorHandling(): void {
    try {
      // æ•è·æœªå¤„ç†çš„Promiseé”™è¯¯
      globalThis.addEventListener('unhandledrejection', (event) => {
        this.handleGlobalError(new Error(`Unhandled Promise rejection: ${String(event.reason)}`), AppErrorType.UNKNOWN_ERROR);
      });
      
      // æ•è·æœªæ•è·çš„å¼‚å¸¸
      globalThis.addEventListener('error', (event) => {
        this.handleGlobalError(new Error(`${event.message || 'Unknown error'}`), AppErrorType.UNKNOWN_ERROR, event.error?.stack);
      });
    } catch (error) {
      Logger.error(TAG, 'Failed to setup global error handling', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * å¤„ç†å…¨å±€é”™è¯¯
   */
  private handleGlobalError(error: Error, type: AppErrorType, stackTrace?: string): void {
    try {
      const appError: AppError = {
        type,
        code: 'GLOBAL_ERROR',
        message: error.message || String(error),
        stackTrace: stackTrace || error.stack,
        timestamp: Date.now(),
        context: { source: 'global' }
      };
      
      this.recordError(appError);
      
      // è®°å½•åˆ°æ—¥å¿?      Logger.error(TAG, 'Global error occurred', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    } catch (logError) {
      // é¿å…é”™è¯¯å¤„ç†è‡ªèº«å‡ºé”™
      console.error('Failed to log global error', logError);
    }
  }

  /**
   * åˆå§‹åŒ–åº”ç”¨æœåŠ?   */
  public async initialize(): Promise<boolean> {
    // é˜²æ­¢é‡å¤åˆå§‹åŒ?    if (this.initializationPromise) {
      return this.initializationPromise.then(() => this.isInitialized);
    }
    
    this.initializationPromise = this.doInitialize();
    return this.initializationPromise.then(() => this.isInitialized);
  }

  /**
   * æ‰§è¡Œåˆå§‹åŒ–è¿‡ç¨?   */
  private async doInitialize(): Promise<void> {
    try {
      // æ›´æ–°çŠ¶æ€?      this.setState(AppState.INITIALIZING);
      this.initializationStartTime = Date.now();
      
      Logger.info(TAG, 'Starting application initialization...');
      
      // 1. åŠ è½½è®¾å¤‡ä¿¡æ¯
      await this.loadAppInfo();
      
      // 2. åŠ è½½åº”ç”¨é…ç½®
      await this.loadAppConfig();
      
      // 3. åŠ è½½åº”ç”¨ç»Ÿè®¡
      await this.loadAppStatistics();
      
      // 4. åˆå§‹åŒ–å­˜å‚¨æœåŠ?      const fileService = FileService.getInstance();
      await fileService.initialize();
      this.services.set('fileService', fileService);
      
      // 5. åˆå§‹åŒ–ä»“åº“å·¥å?      const repositoryFactory = RepositoryFactory.getInstance();
      await repositoryFactory.initialize();
      this.services.set('repositoryFactory', repositoryFactory);
      
      // 6. åˆå§‹åŒ–é…ç½®æœåŠ?      const configService = ConfigService.getInstance();
      await configService.initialize();
      this.services.set('configService', configService);
      
      // 7. åˆå§‹åŒ–ç¼“å­˜æœåŠ?      const cacheService = CacheService.getInstance();
      await cacheService.initialize();
      this.services.set('cacheService', cacheService);
      
      // 8. åˆå§‹åŒ–ç½‘ç»œæœåŠ?      const httpService = HttpService.getInstance();
      await httpService.initialize();
      this.services.set('httpService', httpService);
      
      // 9. åˆå§‹åŒ–è®¤è¯æœåŠ?      const authService = AuthService.getInstance();
      await authService.initialize();
      this.services.set('authService', authService);
      
      // 10. åˆå§‹åŒ–ç”µå½±æœåŠ?      const movieService = MovieService.getInstance();
      await movieService.initialize();
      this.services.set('movieService', movieService);
      
      // 11. åˆå§‹åŒ–å†å²æœåŠ?      const historyService = HistoryService.getInstance();
      await historyService.initialize();
      this.services.set('historyService', historyService);
      
      // 12. åˆå§‹åŒ–æ”¶è—æœåŠ?      const collectionService = CollectionService.getInstance();
      await collectionService.initialize();
      this.services.set('collectionService', collectionService);
      
      // 13. åˆå§‹åŒ–ä¸‹è½½æœåŠ?      const downloadService = DownloadService.getInstance();
      await downloadService.initialize();
      this.services.set('downloadService', downloadService);
      
      // 14. åˆå§‹åŒ–æ’­æ”¾å™¨æœåŠ¡
      const playerService = PlayerService.getInstance();
      await playerService.initialize();
      this.services.set('playerService', playerService);
      
      // 15. åˆå§‹åŒ–ç›´æ’­æµæœåŠ¡
      const liveStreamService = LiveStreamService.getInstance();
      await liveStreamService.initialize();
      this.services.set('liveStreamService', liveStreamService);
      
      // 16. åˆå§‹åŒ–å­—å¹•æœåŠ?      const subtitleService = SubtitleService.getInstance();
      await subtitleService.initialize();
      this.services.set('subtitleService', subtitleService);
      
      // 17. åˆå§‹åŒ–è§£æå™¨æœåŠ¡
      const parserService = getParserService();
      await parserService.initialize();
      this.services.set('parserService', parserService);
      
      // 18. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      await this.updateLaunchStatistics();
      
      // 19. æ‰§è¡Œå¯åŠ¨æ—¶æ¸…ç?      await this.performStartupCleanup();
      
      // 20. æ£€æŸ¥æ›´æ–?      if (this.appConfig.enableAutoUpdate) {
        await this.checkForUpdates();
      }
      
      // 21. å‘é€åˆå§‹åŒ–å®Œæˆäº‹ä»¶
      this.isInitialized = true;
      this.setState(AppState.READY);
      
      const initDuration = Date.now() - this.initializationStartTime;
      Logger.info(TAG, `Application initialized successfully in ${initDuration}ms`);
      
      // å‘å¸ƒåˆå§‹åŒ–å®Œæˆäº‹ä»?      this.publishEvent(AppEventType.INITIALIZED, { duration: initDuration });
      this.publishEvent(AppEventType.READY, { version: this.currentVersion });
    } catch (error) {
      Logger.error(TAG, 'Application initialization failed', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      
      const appError: AppError = {
        type: AppErrorType.INITIALIZATION_FAILED,
        code: 'INITIALIZATION_ERROR',
        message: String(error),
        stackTrace: (error as Error).stack,
        timestamp: Date.now()
      };
      
      this.recordError(appError);
      this.setState(AppState.ERROR);
      
      throw error;
    }
  }

  /**
   * åŠ è½½åº”ç”¨ä¿¡æ¯
   */
  private async loadAppInfo(): Promise<void> {
    try {
      // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œä¼šä»ç³»ç»ŸAPIè·å–çœŸå®çš„è®¾å¤‡å’Œåº”ç”¨ä¿¡æ¯
      // è¿™é‡Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
      this.appInfo = {
        appName: 'RayTV',
        packageName: 'com.example.raytv',
        versionName: this.currentVersion,
        versionCode: this.buildNumber,
        buildType: 'debug',
        targetSdkVersion: 34,
        minSdkVersion: 28,
        deviceId: 'device-123456',
        deviceModel: 'Device Model',
        deviceManufacturer: 'Device Manufacturer',
        osVersion: '13.0',
        screenWidth: 1920,
        screenHeight: 1080,
        isTablet: false,
        isTV: true,
        countryCode: 'CN',
        languageCode: 'zh',
        isRooted: false,
        installTime: Date.now() - 86400000 * 30, // 30å¤©å‰
        lastUpdateTime: Date.now() - 86400000 * 7, // 7å¤©å‰
        firstLaunchTime: await StorageUtil.getNumber('first_launch_time', Date.now()),
        launchCount: await StorageUtil.getNumber('launch_count', 0),
        totalRunningTime: await StorageUtil.getNumber('total_running_time', 0),
        lastLaunchTime: await StorageUtil.getNumber('last_launch_time', 0)
      };
      
      Logger.debug(TAG, `Loaded app info: ${this.appInfo.appName} v${this.appInfo.versionName}`);
    } catch (error) {
      Logger.error(TAG, 'Failed to load app info', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      // ç¡®ä¿æŠ›å‡ºçš„æ€»æ˜¯Errorç±»å‹ï¼Œå¹¶æ·»åŠ æ›´æœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯
      const finalError = error instanceof Error ? error : new Error(String(error));
      finalError.message = `Failed to load app info: ${finalError.message}`;
      throw finalError;
    }
  }

  /**
   * åŠ è½½åº”ç”¨é…ç½®
   */
  private async loadAppConfig(): Promise<void> {
    try {
      const savedConfig = await StorageUtil.getObject<AppConfig>('app_config');
      if (savedConfig) {
        this.appConfig = { ...DEFAULT_APP_CONFIG, ...savedConfig };
      }
      
      Logger.debug(TAG, 'Loaded app configuration');
    } catch (error) {
      Logger.error(TAG, 'Failed to load app config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      // ä½¿ç”¨é»˜è®¤é…ç½®
      this.appConfig = { ...DEFAULT_APP_CONFIG };
    }
  }

  /**
   * ä¿å­˜åº”ç”¨é…ç½®
   */
  private async saveAppConfig(): Promise<void> {
    try {
      await StorageUtil.setObject('app_config', this.appConfig);
      Logger.debug(TAG, 'Saved app configuration');
    } catch (error) {
      Logger.error(TAG, 'Failed to save app config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * åŠ è½½åº”ç”¨ç»Ÿè®¡
   */
  private async loadAppStatistics(): Promise<void> {
    try {
      const savedStats = await StorageUtil.getObject<AppStatistics>('app_statistics');
      if (savedStats) {
        this.appStatistics = { ...this.appStatistics, ...savedStats };
      }
      
      Logger.debug(TAG, 'Loaded app statistics');
    } catch (error) {
      Logger.error(TAG, 'Failed to load app statistics', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      // ä½¿ç”¨é»˜è®¤ç»Ÿè®¡
      this.appStatistics = this.createDefaultStatistics();
    }
  }

  /**
   * ä¿å­˜åº”ç”¨ç»Ÿè®¡
   */
  private async saveAppStatistics(): Promise<void> {
    try {
      await StorageUtil.setObject('app_statistics', this.appStatistics);
      Logger.debug(TAG, 'Saved app statistics');
    } catch (error) {
      Logger.error(TAG, 'Failed to save app statistics', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * æ›´æ–°å¯åŠ¨ç»Ÿè®¡ä¿¡æ¯
   */
  private async updateLaunchStatistics(): Promise<void> {
    try {
      // æ›´æ–°å¯åŠ¨æ¬¡æ•°
      const currentLaunchCount = await StorageUtil.getNumber('launch_count', 0) + 1;
      await StorageUtil.setNumber('launch_count', currentLaunchCount);
      this.appStatistics.totalLaunches = currentLaunchCount;
      
      // æ›´æ–°æœ€åå¯åŠ¨æ—¶é—?      await StorageUtil.setNumber('last_launch_time', Date.now());
      
      // å¦‚æœæ˜¯é¦–æ¬¡å¯åŠ¨ï¼Œè®°å½•é¦–æ¬¡å¯åŠ¨æ—¶é—´
      if (!await StorageUtil.contains('first_launch_time')) {
        await StorageUtil.setNumber('first_launch_time', Date.now());
      }
      
      Logger.info(TAG, `Launch count: ${currentLaunchCount}`);
    } catch (error) {
      Logger.error(TAG, 'Failed to update launch statistics', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * æ‰§è¡Œå¯åŠ¨æ—¶æ¸…ç?   */
  private async performStartupCleanup(): Promise<void> {
    try {
      // æ¸…ç†è¿‡æœŸçš„ç¼“å­?      const cacheService = CacheService.getInstance();
      await cacheService.clear({ expiredOnly: true });
      
      // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      const fileService = FileService.getInstance();
      await fileService.cleanupTempFiles();
      
      // æ›´æ–°å­˜å‚¨ç»Ÿè®¡
      await this.updateStorageStatistics();
      
      Logger.debug(TAG, 'Performed startup cleanup');
    } catch (error) {
      Logger.error(TAG, 'Failed to perform startup cleanup', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * æ›´æ–°å­˜å‚¨ç»Ÿè®¡
   */
  private async updateStorageStatistics(): Promise<void> {
    try {
      const fileService = FileService.getInstance();
      const storageInfo = await fileService.getStorageInfo();
      
      this.appStatistics.deviceStorageUsed = storageInfo.used;
      this.appStatistics.deviceStorageTotal = storageInfo.total;
      
      // æ£€æŸ¥å­˜å‚¨ç©ºé—´è­¦å‘?      if (storageInfo.used > storageInfo.total * 0.9) {
        this.publishEvent(AppEventType.STORAGE_WARNING, {
          used: storageInfo.used,
          total: storageInfo.total,
          percentage: (storageInfo.used / storageInfo.total) * 100
        });
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to update storage statistics', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * æ£€æŸ¥æ›´æ–?   */
  private async checkForUpdates(): Promise<void> {
    try {
      // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œä¼šè°ƒç”¨æ›´æ–°æ£€æŸ¥API
      // è¿™é‡Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
      const hasUpdate = false;
      const latestVersion = this.currentVersion;
      
      if (hasUpdate) {
        this.publishEvent(AppEventType.UPDATE_AVAILABLE, {
          currentVersion: this.currentVersion,
          latestVersion,
          releaseNotes: 'Bug fixes and performance improvements'
        });
      }
      
      // æ›´æ–°æ£€æŸ¥æ—¶é—?      this.appStatistics.lastUpdateCheckTime = Date.now();
      await this.saveAppStatistics();
      
      Logger.debug(TAG, 'Checked for updates');
    } catch (error) {
      Logger.error(TAG, 'Failed to check for updates', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * è®¾ç½®åº”ç”¨çŠ¶æ€?   */
  private setState(newState: AppState): void {
    const oldState = this.currentState;
    this.currentState = newState;
    
    Logger.debug(TAG, `App state changed: ${oldState} -> ${newState}`);
    
    // é€šçŸ¥çŠ¶æ€ç›‘å¬å™¨
    for (const listener of this.stateListeners) {
      try {
        listener(newState, oldState);
      } catch (error) {
        Logger.error(TAG, 'Error in state listener', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      }
    }
  }

  /**
   * å‘å¸ƒåº”ç”¨äº‹ä»¶
   */
  private publishEvent<T>(type: AppEventType, data?: T): void {
    const event: AppEvent = {
      type,
      data,
      timestamp: Date.now()
    };
    
    // æ·»åŠ åˆ°äº‹ä»¶å†å?    this.eventHistory.push(event);
    // é™åˆ¶å†å²è®°å½•å¤§å°
    if (this.eventHistory.length > 1000) {
      this.eventHistory.shift();
    }
    
    Logger.debug(TAG, `Published event: ${type}`);
    
    // é€šçŸ¥äº‹ä»¶ç›‘å¬å™?    for (const listener of this.eventListeners) {
      try {
        listener(event);
      } catch (error) {
        Logger.error(TAG, 'Error in event listener', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      }
    }
  }

  /**
   * è®°å½•é”™è¯¯
   */
  private recordError(error: AppError): void {
    // æ·»åŠ åˆ°é”™è¯¯å†å?    this.errorHistory.push(error);
    // é™åˆ¶å†å²è®°å½•å¤§å°
    if (this.errorHistory.length > 100) {
      this.errorHistory.shift();
    }
    
    // æ›´æ–°é”™è¯¯ç»Ÿè®¡
    this.appStatistics.totalPlaybackTime = this.appStatistics.totalPlaybackTime; // ä¿æŒä¸å˜
    
    Logger.error(TAG, `Recorded error: ${error.type} - ${error.message}`);
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    for (const listener of this.errorListeners) {
      try {
        listener(error);
      } catch (listenerError) {
        Logger.error(TAG, 'Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError : new Error(String('Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError : new Error(String('Error in error listener', listenerError : new Error(String('Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError : new Error(String('Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError : new Error(String('Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError : new Error(String('Error in error listener', listenerError : new Error(String('Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError : new Error(String('Error in error listener', listenerError : new Error(String('Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError : new Error(String('Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError : new Error(String('Error in error listener', listenerError : new Error(String('Error in error listener', listenerError instanceof Error ? 'Error in error listener', listenerError : new Error(String('Error in error listener', listenerError)))))));
      }
    }
  }

  /**
   * è·å–å½“å‰åº”ç”¨çŠ¶æ€?   */
  public getState(): AppState {
    return this.currentState;
  }

  /**
   * è·å–åº”ç”¨ä¿¡æ¯
   */
  public getAppInfo(): AppInfo | null {
    return this.appInfo;
  }

  /**
   * è·å–åº”ç”¨é…ç½®
   */
  public getAppConfig(): AppConfig {
    return { ...this.appConfig };
  }

  /**
   * æ›´æ–°åº”ç”¨é…ç½®
   */
  public async updateAppConfig(config: Partial<AppConfig>): Promise<AppConfig> {
    try {
      // æ›´æ–°é…ç½®
      this.appConfig = {
        ...this.appConfig,
        ...config
      };
      
      // ä¿å­˜é…ç½®
      await this.saveAppConfig();
      
      // å‘å¸ƒé…ç½®å˜æ›´äº‹ä»¶
      this.publishEvent(AppEventType.CONFIG_CHANGED, { ...this.appConfig });
      
      Logger.info(TAG, 'Updated app configuration');
      return { ...this.appConfig };
    } catch (error) {
      Logger.error(TAG, 'Failed to update app config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return { ...this.appConfig };
    }
  }

  /**
   * é‡ç½®åº”ç”¨é…ç½®
   */
  public async resetAppConfig(): Promise<AppConfig> {
    try {
      this.appConfig = { ...DEFAULT_APP_CONFIG };
      
      // ä¿å­˜é…ç½®
      await this.saveAppConfig();
      
      // å‘å¸ƒé…ç½®å˜æ›´äº‹ä»¶
      this.publishEvent(AppEventType.CONFIG_CHANGED, { ...this.appConfig });
      
      Logger.info(TAG, 'Reset app configuration to default');
      return { ...this.appConfig };
    } catch (error) {
      Logger.error(TAG, 'Failed to reset app config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return { ...this.appConfig };
    }
  }

  /**
   * è·å–åº”ç”¨ç»Ÿè®¡ä¿¡æ¯
   */
  public getAppStatistics(): AppStatistics {
    return { ...this.appStatistics };
  }

  /**
   * æ›´æ–°åº”ç”¨ç»Ÿè®¡ä¿¡æ¯
   */
  public async updateAppStatistics(updates: Partial<AppStatistics>): Promise<void> {
    try {
      this.appStatistics = {
        ...this.appStatistics,
        ...updates
      };
      
      await this.saveAppStatistics();
      Logger.debug(TAG, 'Updated app statistics');
    } catch (error) {
      Logger.error(TAG, 'Failed to update app statistics', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * é‡ç½®åº”ç”¨ç»Ÿè®¡
   */
  public async resetAppStatistics(): Promise<void> {
    try {
      this.appStatistics = this.createDefaultStatistics();
      
      await this.saveAppStatistics();
      Logger.info(TAG, 'Reset app statistics');
    } catch (error) {
      Logger.error(TAG, 'Failed to reset app statistics', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * è·å–æœåŠ¡å®ä¾‹
   */
  public getService<T>(serviceName: string): T | null {
    const service = this.services.get(serviceName);
    if (!service) {
      Logger.warn(TAG, `Service not found: ${serviceName}`);
      return null;
    }
    return service as T;
  }

  /**
   * æ³¨å†Œè‡ªå®šä¹‰æœåŠ?   */
  public registerService(serviceName: string, serviceInstance: { initialize?: () => Promise<void>; close?: () => Promise<void> }): boolean {
    try {
      this.services.set(serviceName, serviceInstance);
      Logger.info(TAG, `Registered custom service: ${serviceName}`);
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to register service: ${serviceName}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return false;
    }
  }

  /**
   * æ³¨é”€è‡ªå®šä¹‰æœåŠ?   */
  public unregisterService(serviceName: string): boolean {
    try {
      this.services.delete(serviceName);
      Logger.info(TAG, `Unregistered service: ${serviceName}`);
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to unregister service: ${serviceName}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return false;
    }
  }

  /**
   * æ·»åŠ çŠ¶æ€ç›‘å¬å™¨
   */
  public addStateListener(listener: (newState: AppState, oldState: AppState) => void): () => void {
    this.stateListeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.stateListeners.indexOf(listener);
      if (index > -1) {
        this.stateListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ äº‹ä»¶ç›‘å¬å™?   */
  public addEventListener(listener: (event: AppEvent) => void): () => void {
    this.eventListeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.eventListeners.indexOf(listener);
      if (index > -1) {
        this.eventListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ é”™è¯¯ç›‘å¬å™?   */
  public addErrorListener(listener: (error: AppError) => void): () => void {
    this.errorListeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.errorListeners.indexOf(listener);
      if (index > -1) {
        this.errorListeners.splice(index, 1);
      }
    };
  }

  /**
   * å¤„ç†åº”ç”¨è¿›å…¥å‰å°
   */
  public onAppForeground(): void {
    try {
      if (this.currentState !== AppState.ERROR) {
        this.setState(AppState.FOREGROUND);
        this.publishEvent(AppEventType.FOREGROUND);
        
        // æ¢å¤å¿…è¦çš„æœåŠ?        this.resumeServices();
      }
      
      Logger.info(TAG, 'Application moved to foreground');
    } catch (error) {
      Logger.error(TAG, 'Failed to handle app foreground', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * å¤„ç†åº”ç”¨è¿›å…¥åå°
   */
  public onAppBackground(): void {
    try {
      if (this.currentState !== AppState.ERROR && this.currentState !== AppState.SHUTTING_DOWN) {
        this.setState(AppState.BACKGROUND);
        this.publishEvent(AppEventType.BACKGROUND);
        
        // æš‚åœéå¿…è¦çš„æœåŠ¡
        this.pauseServices();
        
        // ä¿å­˜çŠ¶æ€?        this.saveAppState();
      }
      
      Logger.info(TAG, 'Application moved to background');
    } catch (error) {
      Logger.error(TAG, 'Failed to handle app background', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * æ¢å¤æœåŠ¡
   */
  private async resumeServices(): Promise<void> {
    try {
      // æ¢å¤ç½‘ç»œæœåŠ¡
      const httpService = this.getService<HttpService>('httpService');
    if (httpService) {
      await httpService.resume();
      }
      
      // æ¢å¤ä¸‹è½½æœåŠ¡
      const downloadService = this.getService<DownloadService>('downloadService');
      if (downloadService) {
        await downloadService.resumeAllDownloads();
      }
      
      Logger.debug(TAG, 'Resumed services');
    } catch (error) {
      Logger.error(TAG, 'Failed to resume services', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * æš‚åœæœåŠ¡
   */
  private async pauseServices(): Promise<void> {
    try {
      // æš‚åœä¸‹è½½æœåŠ¡
      const downloadService = this.getService<DownloadService>('downloadService');
      if (downloadService) {
        await downloadService.pauseAllDownloads();
      }
      
      // æš‚åœç½‘ç»œæœåŠ¡çš„éå¿…è¦è¿æ¥
      const httpService = this.getService<HttpService>('httpService');
    if (httpService) {
      await httpService.pause();
      }
      
      Logger.debug(TAG, 'Paused services');
    } catch (error) {
      Logger.error(TAG, 'Failed to pause services', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * ä¿å­˜åº”ç”¨çŠ¶æ€?   */
  private async saveAppState(): Promise<void> {
    try {
      const appState: Record<string, string | number | boolean | null> = { ... };
      
      await StorageUtil.setObject(APP_STATE_KEY, appState);
      
      // æ›´æ–°æ€»è¿è¡Œæ—¶é—?      const currentRunningTime = await StorageUtil.getNumber('total_running_time', 0);
      const thisSessionTime = Date.now() - this.startTime;
      await StorageUtil.setNumber('total_running_time', currentRunningTime + thisSessionTime);
      
      // ä¿å­˜ç»Ÿè®¡ä¿¡æ¯
      await this.saveAppStatistics();
      
      Logger.debug(TAG, 'Saved app state');
    } catch (error) {
      Logger.error(TAG, 'Failed to save app state', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * åŠ è½½åº”ç”¨çŠ¶æ€?   */
  private async loadAppState(): Promise<AppStatistics | null> {
    try {
      const appState = await StorageUtil.getObject(APP_STATE_KEY);
      Logger.debug(TAG, 'Loaded app state');
      return appState;
    } catch (error) {
      Logger.error(TAG, 'Failed to load app state', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return null;
    }
  }

  /**
   * æ‰§è¡Œåº”ç”¨æ¸…ç†
   */
  public async performCleanup(deepClean: boolean = false): Promise<{ deletedCount: number; freedSpace: number }> {
    try {
      let totalDeleted = 0;
      let totalFreed = 0;
      
      // æ¸…ç†ç¼“å­˜
      const cacheService = CacheService.getInstance();
      const cacheResult = await cacheService.clear({
        force: deepClean,
        expiredOnly: !deepClean
      });
      totalDeleted += cacheResult.deletedCount;
      totalFreed += cacheResult.freedSpace;
      
      // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      const fileService = FileService.getInstance();
      const tempResult = await fileService.cleanupTempFiles();
      totalDeleted += tempResult.deletedCount;
      totalFreed += tempResult.freedSpace;
      
      // æ¸…ç†ä¸‹è½½çš„ä¸´æ—¶æ–‡ä»?      const downloadService = DownloadService.getInstance();
      const downloadResult = await downloadService.cleanupFailedDownloads();
      totalDeleted += downloadResult.deletedCount;
      totalFreed += downloadResult.freedSpace;
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.appStatistics.lastCleanupTime = Date.now();
      await this.saveAppStatistics();
      
      // å‘å¸ƒæ¸…ç†å®Œæˆäº‹ä»¶
      this.publishEvent(AppEventType.CLEANUP_COMPLETED, {
        deletedCount: totalDeleted,
        freedSpace: totalFreed
      });
      
      Logger.info(TAG, `Cleanup completed: ${totalDeleted} items deleted, ${this.formatSize(totalFreed)} freed`);
      return { deletedCount: totalDeleted, freedSpace: totalFreed };
    } catch (error) {
      Logger.error(TAG, 'Failed to perform cleanup', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return { deletedCount: 0, freedSpace: 0 };
    }
  }

  /**
   * åˆ›å»ºåº”ç”¨å¤‡ä»½
   */
  public async createBackup(options: AppBackupOptions): Promise<string | null> {
    try {
      const backupTime = Date.now();
      const backupFileName = `raytv_backup_${backupTime}.zip`;
      const backupFilePath = `${this.getService<FileService>('fileService')?.getBackupDir()}/${backupFileName}`;
      
      // åˆ›å»ºå¤‡ä»½ä¿¡æ¯
      const backupInfo: AppBackupInfo = {
        version: this.currentVersion,
        timestamp: backupTime,
        size: 0, // å°†åœ¨å¤‡ä»½å®Œæˆåæ›´æ–?        description: 'RayTV application backup',
        deviceInfo: `${this.appInfo?.deviceManufacturer} ${this.appInfo?.deviceModel}`,
        includes: {
          userData: options.includeUserData,
          settings: options.includeSettings,
          history: options.includeHistory,
          collections: options.includeCollections,
          downloads: options.includeDownloads,
          cache: options.includeCache
        },
        hash: '', // å°†åœ¨å¤‡ä»½å®Œæˆåè®¡ç®?        encrypted: !!options.password
      };
      
      // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œä¼šæ‰§è¡ŒçœŸå®çš„å¤‡ä»½é€»è¾‘
      // è¿™é‡Œåªæ˜¯æ¨¡æ‹Ÿå¤‡ä»½è¿‡ç¨‹
      
      // ä¿å­˜å¤‡ä»½ä¿¡æ¯
      const backupInfoPath = `${backupFilePath}.info`;
      await StorageUtil.setObject(backupInfoPath, backupInfo);
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.appStatistics.lastBackupTime = backupTime;
      await this.saveAppStatistics();
      
      Logger.info(TAG, `Created backup: ${backupFileName}`);
      return backupFilePath;
    } catch (error) {
      Logger.error(TAG, 'Failed to create backup', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return null;
    }
  }

  /**
   * æ¢å¤åº”ç”¨å¤‡ä»½
   */
  public async restoreBackup(backupFilePath: string, options: AppRestoreOptions): Promise<boolean> {
    try {
      // éªŒè¯å¤‡ä»½æ–‡ä»¶
      if (!await this.getService<FileService>('fileService')?.fileExists(backupFilePath)) {
        throw new Error('Backup file not found');
      }
      
      // è¯»å–å¤‡ä»½ä¿¡æ¯
      const backupInfoPath = `${backupFilePath}.info`;
      const backupInfo = await StorageUtil.getObject<AppBackupInfo>(backupInfoPath);
      
      if (!backupInfo) {
        throw new Error('Invalid backup file');
      }
      
      // å¦‚æœåªæ˜¯éªŒè¯
      if (options.validateOnly) {
        Logger.info(TAG, `Validated backup: ${backupFilePath}`);
        return true;
      }
      
      // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œä¼šæ‰§è¡ŒçœŸå®çš„æ¢å¤é€»è¾‘
      // è¿™é‡Œåªæ˜¯æ¨¡æ‹Ÿæ¢å¤è¿‡ç¨‹
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.appStatistics.lastRestoreTime = Date.now();
      await this.saveAppStatistics();
      
      Logger.info(TAG, `Restored backup: ${backupFilePath}`);
      return true;
    } catch (error) {
      Logger.error(TAG, 'Failed to restore backup', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return false;
    }
  }

  /**
   * æ ¼å¼åŒ–å¤§å°æ˜¾ç¤?   */
  private formatSize(bytes: number): string {
    if (bytes < 1024) {
      return `${bytes} B`;
    } else if (bytes < 1024 * 1024) {
      return `${(bytes / 1024).toFixed(2)} KB`;
    } else if (bytes < 1024 * 1024 * 1024) {
      return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    } else {
      return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }
  }

  /**
   * å…³é—­åº”ç”¨æœåŠ¡
   */
  public async shutdown(): Promise<void> {
    try {
      this.setState(AppState.SHUTTING_DOWN);
      Logger.info(TAG, 'Shutting down application...');
      
      // ä¿å­˜çŠ¶æ€?      await this.saveAppState();
      
      // å…³é—­æ‰€æœ‰æœåŠ?      const servicesToShutdown = [...this.services.values()];
      for (const service of servicesToShutdown) {
        try {
          if (typeof service.shutdown === 'function') {
            await service.shutdown();
          }
        } catch (error) {
          Logger.error(TAG, 'Failed to shutdown service', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
        }
      }
      
      // æ¸…ç©ºæœåŠ¡æ˜ å°„
      this.services.clear();
      
      // å‘å¸ƒå…³é—­äº‹ä»¶
      this.publishEvent(AppEventType.SHUTDOWN);
      
      Logger.info(TAG, 'Application shutdown completed');
    } catch (error) {
      Logger.error(TAG, 'Failed to shutdown application', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * è·å–é”™è¯¯å†å²
   */
  public getErrorHistory(limit: number = 10): AppError[] {
    return this.errorHistory.slice(-limit);
  }

  /**
   * è·å–äº‹ä»¶å†å²
   */
  public getEventHistory(limit: number = 100): AppEvent[] {
    return this.eventHistory.slice(-limit);
  }

  /**
   * æ¸…é™¤é”™è¯¯å†å²
   */
  public clearErrorHistory(): void {
    this.errorHistory = [];
    Logger.debug(TAG, 'Cleared error history');
  }

  /**
   * æ¸…é™¤äº‹ä»¶å†å²
   */
  public clearEventHistory(): void {
    this.eventHistory = [];
    Logger.debug(TAG, 'Cleared event history');
  }

  /**
   * æ£€æŸ¥åº”ç”¨æ˜¯å¦å¤„äºå¥åº·çŠ¶æ€?   */
  public isHealthy(): boolean {
    return this.currentState === AppState.READY || 
           this.currentState === AppState.FOREGROUND || 
           this.currentState === AppState.BACKGROUND;
  }

  /**
   * è·å–åº”ç”¨è¿è¡Œæ—¶é—´
   */
  public getUptime(): number {
    return Date.now() - this.startTime;
  }
}


