// CacheService - ç¼“å­˜æœåŠ¡ï¿?import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import FileUtil from '../../common/util/FileUtil';
import JsonUtil from '../../common/util/JsonUtil';
import TypeSafetyHelper from '../../common/util/TypeSafetyHelper';
import ConfigService from '../config/ConfigService';
import FileService, { StorageLocation, FileType, FileConfig } from './FileService';

// å¸¸é‡å®šä¹‰
const TAG = 'CacheService';
const CACHE_CONFIG_KEY = 'cache_config';
const MEMORY_CACHE_EXPIRY = 60000; // 1åˆ†é’Ÿ
const MAX_MEMORY_CACHE_SIZE = 100 * 1024 * 1024; // 100MB
const DEFAULT_DISK_CACHE_SIZE = 256 * 1024 * 1024; // 256MB
const DEFAULT_CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24å°æ—¶

// ç¼“å­˜ç±»å‹æšä¸¾
export enum CacheType {
  MEMORY = 'memory',
  DISK = 'disk',
  MEMORY_DISK = 'memory_disk'
}

// ç¼“å­˜å­˜å‚¨ä½ç½®æšä¸¾
export enum CacheStorageLocation {
  INTERNAL = 'internal',
  EXTERNAL = 'external',
  TEMP = 'temp'
}

// ç¼“å­˜ç­–ç•¥æšä¸¾
export enum CacheStrategy {
  LRU = 'lru', // æœ€è¿‘æœ€å°‘ä½¿ï¿?  LFU = 'lfu', // æœ€å°‘ä½¿ç”¨é¢‘ï¿?  FIFO = 'fifo', // å…ˆè¿›å…ˆå‡º
  FILO = 'filo' // åè¿›å…ˆå‡º
}

// ç¼“å­˜ä¼˜å…ˆçº§æšï¿?export enum CachePriority {
  LOW = 'low',
  NORMAL = 'normal',
  HIGH = 'high',
  CRITICAL = 'critical'
}

// ç¼“å­˜é…ç½®æ¥å£
export interface CacheConfig {
  enableMemoryCache: boolean;
  enableDiskCache: boolean;
  memoryCacheSize: number; // å­—èŠ‚
  diskCacheSize: number; // å­—èŠ‚
  defaultExpiry: number; // æ¯«ç§’
  cacheStrategy: CacheStrategy;
  storageLocation: CacheStorageLocation;
  maxCacheItems: number;
  enableAutoCleanup: boolean;
  cleanupInterval: number; // æ¯«ç§’
  cleanupThreshold: number; // ç™¾åˆ†ï¿?(0-100)
  cacheKeyPrefix: string;
  cacheVersion: string;
  compressCacheItems: boolean;
  encryptCacheItems: boolean;
  enableStatistics: boolean;
  logLevel: 'debug' | 'info' | 'warn' | 'error' | 'none';
  allowedCacheTypes: CacheType[];
  maxItemSize: number; // å•ä¸ªç¼“å­˜é¡¹æœ€å¤§å¤§å°ï¼ˆå­—èŠ‚ï¿?}

// ç¼“å­˜é¡¹å…ƒæ•°æ®æ¥å£
export interface CacheMetadata {
  key: string;
  type: string; // æ•°æ®ç±»å‹
  size: number; // å­—èŠ‚
  createdAt: number;
  modifiedAt: number;
  accessedAt: number;
  expiry: number; // æ¯«ç§’
  priority: CachePriority;
  hits: number;
  tags: string[];
  version?: string;
  checksum?: string;
  compressed: boolean;
  encrypted: boolean;
  source?: string; // ç¼“å­˜æ¥æº
}

// ç¼“å­˜é¡¹æ¥ï¿?export interface CacheItem<T = unknown> {
  data: T;
  metadata: CacheMetadata;
}

// ç¼“å­˜ç»Ÿè®¡æ¥å£
export interface CacheStatistics {
  memoryCacheSize: number;
  memoryCacheItems: number;
  diskCacheSize: number;
  diskCacheItems: number;
  hitCount: number;
  missCount: number;
  evictionCount: number;
  expirationCount: number;
  errorCount: number;
  lastCleanupTime: number;
  totalCleanupTime: number;
  cacheRatio: number; // ç¼“å­˜å‘½ä¸­ï¿?  averageGetTime: number; // å¹³å‡è·å–æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  averageSetTime: number; // å¹³å‡è®¾ç½®æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  largestItemSize: number;
  smallestItemSize: number;
  averageItemSize: number;
}

// ç¼“å­˜æœç´¢å‚æ•°æ¥å£
export interface CacheSearchParams {
  tags?: string[];
  minAge?: number;
  maxAge?: number;
  minSize?: number;
  maxSize?: number;
  priority?: CachePriority[];
  type?: string[];
  keyPattern?: string;
  expired?: boolean;
  limit?: number;
  offset?: number;
}

// ç¼“å­˜æ“ä½œç»“æœæ¥å£
export interface CacheOperationResult {
  success: boolean;
  key?: string;
  error?: string;
  details?: Record<string, unknown>;
}

// ç¼“å­˜æ¸…ç†é€‰é¡¹æ¥å£
export interface CacheCleanupOptions {
  force?: boolean;
  tags?: string[];
  olderThan?: number; // æ¯«ç§’
  priority?: CachePriority;
  sizeLimit?: number; // å­—èŠ‚
  itemLimit?: number;
  expiredOnly?: boolean;
  excludeKeys?: string[];
  includeKeys?: string[];
}

// é»˜è®¤ç¼“å­˜é…ç½®
const DEFAULT_CACHE_CONFIG: CacheConfig = {
  enableMemoryCache: true,
  enableDiskCache: true,
  memoryCacheSize: MAX_MEMORY_CACHE_SIZE,
  diskCacheSize: DEFAULT_DISK_CACHE_SIZE,
  defaultExpiry: DEFAULT_CACHE_EXPIRY,
  cacheStrategy: CacheStrategy.LRU,
  storageLocation: CacheStorageLocation.INTERNAL,
  maxCacheItems: 1000,
  enableAutoCleanup: true,
  cleanupInterval: 3600000, // 1å°æ—¶
  cleanupThreshold: 80, // 80%
  cacheKeyPrefix: 'cache_',
  cacheVersion: '1.0',
  compressCacheItems: false,
  encryptCacheItems: false,
  enableStatistics: true,
  logLevel: 'info',
  allowedCacheTypes: [CacheType.MEMORY, CacheType.DISK, CacheType.MEMORY_DISK],
  maxItemSize: 10 * 1024 * 1024 // 10MB
};

/**
 * ç¼“å­˜æœåŠ¡ï¿? * è´Ÿè´£ç®¡ç†åº”ç”¨ç¨‹åºçš„ç¼“å­˜æœºåˆ¶ï¼Œæä¾›ç¼“å­˜çš„è®¾ç½®ã€è·å–ã€æ¸…é™¤ç­‰åŠŸèƒ½
 */
export default class CacheService {
  private static instance: CacheService;
  
  private cacheConfig: CacheConfig = { ...DEFAULT_CACHE_CONFIG };
  private memoryCache: Map<string, { data: Record<string, string | number | boolean | null>; expiry: number; timestamp: number }> = new Map();
  private cacheIndex: Map<string, CacheMetadata> = new Map();
  private cacheDir: string = '';
  private indexFile: string = '';
  
  // ç»Ÿè®¡ä¿¡æ¯
  private statistics: CacheStatistics = {
    memoryCacheSize: 0,
    memoryCacheItems: 0,
    diskCacheSize: 0,
    diskCacheItems: 0,
    hitCount: 0,
    missCount: 0,
    evictionCount: 0,
    expirationCount: 0,
    errorCount: 0,
    lastCleanupTime: 0,
    totalCleanupTime: 0,
    cacheRatio: 0,
    averageGetTime: 0,
    averageSetTime: 0,
    largestItemSize: 0,
    smallestItemSize: Number.MAX_SAFE_INTEGER,
    averageItemSize: 0
  };
  
  // æ“ä½œæ—¶é—´è®°å½•
  private getTimes: number[] = [];
  private setTimes: number[] = [];
  
  // ç›‘å¬ï¿?  private cleanupListeners: Array<(deletedCount: number, freedSpace: number) => void> = [];
  private evictionListeners: Array<(key: string, metadata: CacheMetadata) => void> = [];
  private errorListeners: Array<(error: Error, operation: string, key?: string) => void> = [];
  
  private cleanupTimer?: number;
  private isInitialized: boolean = false;

  /**
   * æ„é€ å‡½æ•°ï¼ˆç§æœ‰ï¼Œé˜²æ­¢å¤–éƒ¨å®ä¾‹åŒ–ï¿?   */
  private constructor() {
    this.initialize();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): CacheService {
    if (!CacheService.instance) {
      CacheService.instance = new CacheService();
    }
    return CacheService.instance;
  }
  
  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰é”®
   * æ›¿ä»£Object.keysï¼Œå…¼å®¹ArkTSè¯­æ³•
   */
  private getObjectKeys<T extends object>(obj: T): string[] {
    const keys: string[] = [];
    for (const key in obj) {
      if (Object.keys(obj).includes(key)) {
        keys.push(key);
      }
    }
    return keys;
  }

  /**
   * åˆå§‹åŒ–ç¼“å­˜æœï¿?   */
  public async initialize(): Promise<void> {
    try {
      Logger.info(TAG, 'Initializing cache service...');
      
      // åŠ è½½ç¼“å­˜é…ç½®
      const savedConfig = await StorageUtil.getObject<CacheConfig>(CACHE_CONFIG_KEY);
      if (savedConfig) {
        this.cacheConfig = { ...DEFAULT_CACHE_CONFIG, ...savedConfig };
      }
      
      // è®¾ç½®ç¼“å­˜ç›®å½•
      await this.setCacheDirectory();
      
      // åŠ è½½ç¼“å­˜ç´¢å¼•
      await this.loadCacheIndex();
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      await this.updateStatistics();
      
      // å¯åŠ¨è‡ªåŠ¨æ¸…ç†
      if (this.cacheConfig.enableAutoCleanup) {
        this.startAutoCleanup();
      }
      
      // æ‰§è¡Œåˆå§‹æ¸…ç†
      await this.performInitialCleanup();
      
      this.isInitialized = true;
      Logger.info(TAG, 'Cache service initialized successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to initialize cache service', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'initialize');
    }
  }

  /**
   * è®¾ç½®ç¼“å­˜ç›®å½•
   */
  private async setCacheDirectory(): Promise<void> {
    try {
      const fileService = FileService.getInstance();
      const fileConfig = fileService.getFileConfig();
      
      switch (this.cacheConfig.storageLocation) {
        case CacheStorageLocation.INTERNAL:
          this.cacheDir = `${fileConfig.cacheDir}/cache`;
          break;
        case CacheStorageLocation.EXTERNAL:
          this.cacheDir = `${fileConfig.cacheDir}/external_cache`;
          break;
        case CacheStorageLocation.TEMP:
          this.cacheDir = `${fileConfig.tempDir}/temp_cache`;
          break;
      }
      
      // åˆ›å»ºç¼“å­˜ç›®å½•
      await FileUtil.ensureDirectory(this.cacheDir);
      
      // è®¾ç½®ç´¢å¼•æ–‡ä»¶è·¯å¾„
      this.indexFile = `${this.cacheDir}/cache_index.json`;
      
      Logger.debug(TAG, `Cache directory set to: ${this.cacheDir}`);
    } catch (error) {
      Logger.error(TAG, 'Failed to set cache directory', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      throw error;
    }
  }

  /**
   * åŠ è½½ç¼“å­˜ç´¢å¼•
   */
  private async loadCacheIndex(): Promise<void> {
    try {
      // æ£€æŸ¥ç´¢å¼•æ–‡ä»¶æ˜¯å¦å­˜ï¿?      const indexExists = await FileUtil.fileExists(this.indexFile);
      if (!indexExists) {
        return;
      }
      
      // è¯»å–ç´¢å¼•æ–‡ä»¶
      const indexContent = await FileUtil.readFile(this.indexFile, 'utf-8');
      if (!indexContent) {
        return;
      }
      
      // è§£æç´¢å¼•
      const indexData = JsonUtil.parse<Map<string, CacheMetadata>>(indexContent);
      if (!indexData || typeof indexData !== 'object') {
        return;
      }
      
      // æ›´æ–°ç¼“å­˜ç´¢å¼•
      for (const [key, metadata] of Object.entries(indexData)) {
        this.cacheIndex.set(key, metadata as CacheMetadata);
      }
      
      Logger.debug(TAG, `Loaded cache index with ${this.cacheIndex.size} entries`);
    } catch (error) {
      Logger.error(TAG, 'Failed to load cache index', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      // ç´¢å¼•æ–‡ä»¶æŸåï¼Œé‡æ–°åˆ›ï¿?      await FileUtil.writeFile(this.indexFile, '{}', { create: true });
    }
  }

  /**
   * ä¿å­˜ç¼“å­˜ç´¢å¼•
   */
  private async saveCacheIndex(): Promise<void> {
    try {
      const indexData: Record<string, CacheMetadata> = {};
      
      // è¿‡æ»¤æ‰è¿‡æœŸçš„ç¼“å­˜ï¿?      const now = Date.now();
      for (const [key, metadata] of this.cacheIndex.entries()) {
        if (metadata.expiry === 0 || now < metadata.expiry) {
          indexData[key] = metadata;
        }
      }
      
      // å†™å…¥ç´¢å¼•æ–‡ä»¶
      const indexContent = JsonUtil.stringify(indexData);
      await FileUtil.writeFile(this.indexFile, indexContent, { create: true });
      
      Logger.debug(TAG, `Saved cache index with ${this.getObjectKeys(indexData).length} entries`);
    } catch (error) {
      Logger.error(TAG, 'Failed to save cache index', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'saveCacheIndex');
    }
  }

  /**
   * æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
   */
  private async updateStatistics(): Promise<void> {
    try {
      // é‡ç½®ç»Ÿè®¡
      this.statistics.memoryCacheSize = 0;
      this.statistics.memoryCacheItems = 0;
      this.statistics.diskCacheSize = 0;
      this.statistics.diskCacheItems = 0;
      
      // è®¡ç®—å†…å­˜ç¼“å­˜ç»Ÿè®¡
      if (this.cacheConfig.enableMemoryCache) {
        let totalSize: number = 0;
        let itemCount: number = 0;
        let largest: number = 0;
        let smallest: number = Number.MAX_SAFE_INTEGER;
        
        for (const [key, item] of this.memoryCache.entries()) {
          const itemSize = this.calculateObjectSize(item.data);
          totalSize += itemSize;
          itemCount++;
          largest = Math.max(largest, itemSize);
          smallest = Math.min(smallest, itemSize);
        }
        
        this.statistics.memoryCacheSize = totalSize;
        this.statistics.memoryCacheItems = itemCount;
        
        if (itemCount > 0) {
          this.statistics.largestItemSize = largest;
          this.statistics.smallestItemSize = smallest;
          this.statistics.averageItemSize = totalSize / itemCount;
        }
      }
      
      // è®¡ç®—ç£ç›˜ç¼“å­˜ç»Ÿè®¡
      if (this.cacheConfig.enableDiskCache) {
        let totalSize: number = 0;
        let itemCount: number = 0;
        
        for (const [key, metadata] of this.cacheIndex.entries()) {
          totalSize += metadata.size;
          itemCount++;
        }
        
        this.statistics.diskCacheSize = totalSize;
        this.statistics.diskCacheItems = itemCount;
      }
      
      // è®¡ç®—ç¼“å­˜å‘½ä¸­ï¿?      const total = this.statistics.hitCount + this.statistics.missCount;
      if (total > 0) {
        this.statistics.cacheRatio = this.statistics.hitCount / total;
      }
      
      // è®¡ç®—å¹³å‡æ“ä½œæ—¶é—´
      if (this.getTimes.length > 0) {
        const sum = this.getTimes.reduce((a, b) => a + b, 0);
        this.statistics.averageGetTime = sum / this.getTimes.length;
      }
      
      if (this.setTimes.length > 0) {
        const sum = this.setTimes.reduce((a, b) => a + b, 0);
        this.statistics.averageSetTime = sum / this.setTimes.length;
      }
      
      Logger.debug(TAG, 'Updated cache statistics');
    } catch (error) {
      Logger.error(TAG, 'Failed to update statistics', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'updateStatistics');
    }
  }

  /**
   * è®¡ç®—å¯¹è±¡å¤§å°ï¼ˆä¼°ç®—ï¼‰
   */
  private calculateObjectSize(obj: Record<string, string | number | boolean | null>): number {
    try {
      // ç®€å•ä¼°ç®—ï¼Œå®é™…åº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨æ›´ç²¾ç¡®çš„æ–¹ï¿?      const str = typeof obj === 'string' ? obj : JsonUtil.stringify(obj);
      return new Blob([str]).size;
    } catch (error) {
      Logger.error(TAG, 'Failed to calculate object size', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return 0;
    }
  }

  /**
   * è®°å½•é”™è¯¯
   */
  private recordError(error: Error, operation: string, key?: string): void {
    this.statistics.errorCount++;
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬ï¿?    for (const listener of this.errorListeners) {
      try {
        listener(error, operation, key);
      } catch (listenerError) {
        Logger.error(TAG, 'Error in error listener', listenerError instanceof Error ? listenerError : new Error(String(listenerError instanceof Error ? listenerError instanceof Error ? listenerError : new Error(String(listenerError : new Error(String(listenerError instanceof Error ? listenerError : new Error(String(listenerError instanceof Error ? listenerError instanceof Error ? listenerError : new Error(String(listenerError instanceof Error ? listenerError instanceof Error ? listenerError : new Error(String(listenerError : new Error(String(listenerError instanceof Error ? listenerError : new Error(String(listenerError : new Error(String(listenerError  as Error)));
      }
    }
  }

  /**
   * è®¾ç½®ç¼“å­˜é…ç½®
   */
  public async setCacheConfig(config: Partial<CacheConfig>): Promise<CacheConfig> {
    try {
      // æ›´æ–°é…ç½®
      this.cacheConfig = {
        ...this.cacheConfig,
        ...config
      };
      
      // ä¿å­˜é…ç½®
      await StorageUtil.setObject(CACHE_CONFIG_KEY, this.cacheConfig);
      
      // å¦‚æœå­˜å‚¨ä½ç½®å˜æ›´ï¼Œé‡æ–°è®¾ç½®ç¼“å­˜ç›®ï¿?      if (config.storageLocation !== undefined) {
        await this.setCacheDirectory();
      }
      
      // é‡å¯è‡ªåŠ¨æ¸…ç†
      if (config.enableAutoCleanup !== undefined || config.cleanupInterval !== undefined) {
        this.stopAutoCleanup();
        if (this.cacheConfig.enableAutoCleanup) {
          this.startAutoCleanup();
        }
      }
      
      // å¦‚æœå†…å­˜ç¼“å­˜å¤§å°å˜æ›´ï¼Œæ¸…ç†å†…å­˜ç¼“ï¿?      if (config.memoryCacheSize !== undefined && this.cacheConfig.enableMemoryCache) {
        await this.evictMemoryCacheBySize();
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      await this.updateStatistics();
      
      Logger.info(TAG, 'Updated cache config');
      return { ...this.cacheConfig };
    } catch (error) {
      Logger.error(TAG, 'Failed to update cache config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'setCacheConfig');
      return { ...this.cacheConfig };
    }
  }

  /**
   * è·å–ç¼“å­˜é…ç½®
   */
  public getCacheConfig(): CacheConfig {
    return { ...this.cacheConfig };
  }

  /**
   * é‡ç½®ç¼“å­˜é…ç½®ä¸ºé»˜è®¤ï¿½?   */
  public async resetCacheConfig(): Promise<CacheConfig> {
    try {
      this.cacheConfig = { ...DEFAULT_CACHE_CONFIG };
      
      // ä¿å­˜é…ç½®
      await StorageUtil.setObject(CACHE_CONFIG_KEY, this.cacheConfig);
      
      // é‡æ–°è®¾ç½®ç¼“å­˜ç›®å½•
      await this.setCacheDirectory();
      
      // é‡å¯è‡ªåŠ¨æ¸…ç†
      this.stopAutoCleanup();
      if (this.cacheConfig.enableAutoCleanup) {
        this.startAutoCleanup();
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      await this.updateStatistics();
      
      Logger.info(TAG, 'Reset cache config to default');
      return { ...this.cacheConfig };
    } catch (error) {
      Logger.error(TAG, 'Failed to reset cache config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'resetCacheConfig');
      return { ...this.cacheConfig };
    }
  }

  /**
   * å¼€å§‹è‡ªåŠ¨æ¸…ï¿?   */
  private startAutoCleanup(): void {
    try {
      this.stopAutoCleanup();
      
      this.cleanupTimer = setInterval(() => {
        this.performAutoCleanup();
      }, this.cacheConfig.cleanupInterval);
      
      Logger.debug(TAG, `Started auto cleanup, interval: ${this.cacheConfig.cleanupInterval}ms`);
    } catch (error) {
      Logger.error(TAG, 'Failed to start auto cleanup', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'startAutoCleanup');
    }
  }

  /**
   * åœæ­¢è‡ªåŠ¨æ¸…ç†
   */
  private stopAutoCleanup(): void {
    try {
      if (this.cleanupTimer) {
        clearInterval(this.cleanupTimer);
        this.cleanupTimer = undefined;
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to stop auto cleanup', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'stopAutoCleanup');
    }
  }

  /**
   * æ‰§è¡Œåˆå§‹æ¸…ç†
   */
  private async performInitialCleanup(): Promise<void> {
    try {
      // æ¸…ç†è¿‡æœŸçš„ç¼“å­˜é¡¹
      await this.cleanupExpiredItems();
      
      // æ£€æŸ¥ç¼“å­˜å¤§å°æ˜¯å¦è¶…è¿‡é˜ˆï¿?      const cachePercentage = (this.statistics.diskCacheSize / this.cacheConfig.diskCacheSize) * 100;
      if (cachePercentage > this.cacheConfig.cleanupThreshold) {
        await this.cleanupCacheBySize();
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to perform initial cleanup', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'performInitialCleanup');
    }
  }

  /**
   * æ‰§è¡Œè‡ªåŠ¨æ¸…ç†
   */
  private async performAutoCleanup(): Promise<void> {
    try {
      Logger.info(TAG, 'Performing auto cleanup...');
      const startTime = Date.now();
      
      let deletedCount = 0;
      let freedSpace = 0;
      
      // æ¸…ç†è¿‡æœŸçš„ç¼“å­˜é¡¹
      const expiredCleanup = await this.cleanupExpiredItems();
      deletedCount += expiredCleanup.deletedCount;
      freedSpace += expiredCleanup.freedSpace;
      
      // æ£€æŸ¥ç¼“å­˜å¤§å°æ˜¯å¦è¶…è¿‡é˜ˆï¿?      const cachePercentage = (this.statistics.diskCacheSize / this.cacheConfig.diskCacheSize) * 100;
      if (cachePercentage > this.cacheConfig.cleanupThreshold) {
        const sizeCleanup = await this.cleanupCacheBySize();
        deletedCount += sizeCleanup.deletedCount;
        freedSpace += sizeCleanup.freedSpace;
      }
      
      // æ£€æŸ¥ç¼“å­˜é¡¹æ•°é‡æ˜¯å¦è¶…è¿‡é™åˆ¶
      if (this.statistics.diskCacheItems > this.cacheConfig.maxCacheItems) {
        const countCleanup = await this.cleanupCacheByCount();
        deletedCount += countCleanup.deletedCount;
        freedSpace += countCleanup.freedSpace;
      }
      
      // æ¸…ç†å†…å­˜ç¼“å­˜
      if (this.cacheConfig.enableMemoryCache) {
        await this.evictMemoryCacheByTime();
        await this.evictMemoryCacheBySize();
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      await this.updateStatistics();
      
      // è®°å½•æ¸…ç†æ—¶é—´
      const duration = Date.now() - startTime;
      this.statistics.lastCleanupTime = startTime;
      this.statistics.totalCleanupTime += duration;
      
      // é€šçŸ¥æ¸…ç†å®Œæˆ
      if (deletedCount > 0) {
        this.notifyCleanupCompleted(deletedCount, freedSpace);
      }
      
      Logger.info(TAG, `Auto cleanup completed: ${deletedCount} items deleted, ${this.formatSize(freedSpace)} freed, took ${duration}ms`);
    } catch (error) {
      Logger.error(TAG, 'Failed to perform auto cleanup', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'performAutoCleanup');
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸçš„ç¼“å­˜é¡¹
   */
  private async cleanupExpiredItems(): Promise<{ deletedCount: number; freedSpace: number }> {
    try {
      const now = Date.now();
      const expiredKeys: string[] = [];
      let deletedCount = 0;
      let freedSpace = 0;
      
      // æ‰¾å‡ºè¿‡æœŸçš„ç¼“å­˜é¡¹
      for (const [key, metadata] of this.cacheIndex.entries()) {
        if (metadata.expiry > 0 && now > metadata.expiry) {
          expiredKeys.push(key);
          freedSpace += metadata.size;
        }
      }
      
      // åˆ é™¤è¿‡æœŸçš„ç¼“å­˜é¡¹
      for (const key of expiredKeys) {
        await this.removeItemFromDisk(key);
        deletedCount++;
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.statistics.expirationCount += deletedCount;
      
      // ä¿å­˜ç´¢å¼•
      await this.saveCacheIndex();
      
      return { deletedCount, freedSpace };
    } catch (error) {
      Logger.error(TAG, 'Failed to cleanup expired items', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'cleanupExpiredItems');
      return { deletedCount: 0, freedSpace: 0 };
    }
  }

  /**
   * æŒ‰å¤§å°æ¸…ç†ç¼“ï¿?   */
  private async cleanupCacheBySize(): Promise<{ deletedCount: number; freedSpace: number }> {
    try {
      // è®¡ç®—éœ€è¦é‡Šæ”¾çš„ç©ºé—´
      const targetSize = this.cacheConfig.diskCacheSize * (this.cacheConfig.cleanupThreshold / 100);
      const spaceToFree = this.statistics.diskCacheSize - targetSize;
      
      if (spaceToFree <= 0) {
        return { deletedCount: 0, freedSpace: 0 };
      }
      
      // è·å–æ‰€æœ‰ç¼“å­˜é¡¹å¹¶æ ¹æ®ç­–ç•¥æ’ï¿?      const cacheItems = Array.from(this.cacheIndex.entries());
      let sortedItems: [string, CacheMetadata][];
      
      switch (this.cacheConfig.cacheStrategy) {
        case CacheStrategy.LRU:
          // æŒ‰æœ€è¿‘è®¿é—®æ—¶é—´æ’åºï¼ˆæœ€æ—§çš„å…ˆåˆ é™¤ï¼‰
          sortedItems = cacheItems.sort((a, b) => a[1].accessedAt - b[1].accessedAt);
          break;
        case CacheStrategy.LFU:
          // æŒ‰ä½¿ç”¨é¢‘ç‡æ’åºï¼ˆæœ€å°‘ä½¿ç”¨çš„å…ˆåˆ é™¤ï¼‰
          sortedItems = cacheItems.sort((a, b) => a[1].hits - b[1].hits);
          break;
        case CacheStrategy.FIFO:
          // æŒ‰åˆ›å»ºæ—¶é—´æ’åºï¼ˆæœ€æ—©çš„å…ˆåˆ é™¤ï¼‰
          sortedItems = cacheItems.sort((a, b) => a[1].createdAt - b[1].createdAt);
          break;
        case CacheStrategy.FILO:
          // æŒ‰åˆ›å»ºæ—¶é—´æ’åºï¼ˆæœ€æ™šçš„å…ˆåˆ é™¤ï¼‰
          sortedItems = cacheItems.sort((a, b) => b[1].createdAt - a[1].createdAt);
          break;
        default:
          sortedItems = cacheItems.sort((a, b) => a[1].accessedAt - b[1].accessedAt);
      }
      
      // æŒ‰ä¼˜å…ˆçº§æ’åº
      sortedItems.sort((a, b) => {
        const priorityValue = (p: CachePriority) => {
          switch (p) {
            case CachePriority.CRITICAL:
              return 4;
            case CachePriority.HIGH:
              return 3;
            case CachePriority.NORMAL:
              return 2;
            case CachePriority.LOW:
              return 1;
            default:
              return 0;
          }
        };
        return priorityValue(a[1].priority) - priorityValue(b[1].priority);
      });
      
      let deletedCount = 0;
      let freedSpace = 0;
      
      // åˆ é™¤ç¼“å­˜é¡¹ç›´åˆ°é‡Šæ”¾è¶³å¤Ÿçš„ç©ºé—´
      for (const [key, metadata] of sortedItems) {
        await this.removeItemFromDisk(key);
        deletedCount++;
        freedSpace += metadata.size;
        
        if (freedSpace >= spaceToFree) {
          break;
        }
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.statistics.evictionCount += deletedCount;
      
      // ä¿å­˜ç´¢å¼•
      await this.saveCacheIndex();
      
      return { deletedCount, freedSpace };
    } catch (error) {
      Logger.error(TAG, 'Failed to cleanup cache by size', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'cleanupCacheBySize');
      return { deletedCount: 0, freedSpace: 0 };
    }
  }

  /**
   * æŒ‰æ•°é‡æ¸…ç†ç¼“ï¿?   */
  private async cleanupCacheByCount(): Promise<{ deletedCount: number; freedSpace: number }> {
    try {
      // è®¡ç®—éœ€è¦åˆ é™¤çš„é¡¹ç›®ï¿?      const itemsToDelete = this.statistics.diskCacheItems - this.cacheConfig.maxCacheItems;
      
      if (itemsToDelete <= 0) {
        return { deletedCount: 0, freedSpace: 0 };
      }
      
      // è·å–æ‰€æœ‰ç¼“å­˜é¡¹å¹¶æ ¹æ®ç­–ç•¥æ’ï¿?      const cacheItems = Array.from(this.cacheIndex.entries());
      let sortedItems: [string, CacheMetadata][];
      
      switch (this.cacheConfig.cacheStrategy) {
        case CacheStrategy.LRU:
          sortedItems = cacheItems.sort((a, b) => a[1].accessedAt - b[1].accessedAt);
          break;
        case CacheStrategy.LFU:
          sortedItems = cacheItems.sort((a, b) => a[1].hits - b[1].hits);
          break;
        case CacheStrategy.FIFO:
          sortedItems = cacheItems.sort((a, b) => a[1].createdAt - b[1].createdAt);
          break;
        case CacheStrategy.FILO:
          sortedItems = cacheItems.sort((a, b) => b[1].createdAt - a[1].createdAt);
          break;
        default:
          sortedItems = cacheItems.sort((a, b) => a[1].accessedAt - b[1].accessedAt);
      }
      
      // æŒ‰ä¼˜å…ˆçº§æ’åº
      sortedItems.sort((a, b) => {
        const priorityValue = (p: CachePriority) => {
          switch (p) {
            case CachePriority.CRITICAL:
              return 4;
            case CachePriority.HIGH:
              return 3;
            case CachePriority.NORMAL:
              return 2;
            case CachePriority.LOW:
              return 1;
            default:
              return 0;
          }
        };
        return priorityValue(a[1].priority) - priorityValue(b[1].priority);
      });
      
      let deletedCount = 0;
      let freedSpace = 0;
      
      // åˆ é™¤ç¼“å­˜ï¿?      for (const [key, metadata] of sortedItems.slice(0, itemsToDelete)) {
        await this.removeItemFromDisk(key);
        deletedCount++;
        freedSpace += metadata.size;
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.statistics.evictionCount += deletedCount;
      
      // ä¿å­˜ç´¢å¼•
      await this.saveCacheIndex();
      
      return { deletedCount, freedSpace };
    } catch (error) {
      Logger.error(TAG, 'Failed to cleanup cache by count', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'cleanupCacheByCount');
      return { deletedCount: 0, freedSpace: 0 };
    }
  }

  /**
   * æ ¹æ®æ—¶é—´é©±é€å†…å­˜ç¼“ï¿?   */
  private async evictMemoryCacheByTime(): Promise<void> {
    try {
      const now = Date.now();
      const keysToDelete: string[] = [];
      
      for (const [key, item] of this.memoryCache.entries()) {
        if (item.expiry > 0 && now > item.expiry) {
          keysToDelete.push(key);
        }
      }
      
      for (const key of keysToDelete) {
        this.memoryCache.delete(key);
      }
      
      if (keysToDelete.length > 0) {
        Logger.debug(TAG, `Evicted ${keysToDelete.length} items from memory cache due to expiration`);
        await this.updateStatistics();
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to evict memory cache by time', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'evictMemoryCacheByTime');
    }
  }

  /**
   * æ ¹æ®å¤§å°é©±é€å†…å­˜ç¼“ï¿?   */
  private async evictMemoryCacheBySize(): Promise<void> {
    try {
      // è®¡ç®—å½“å‰å†…å­˜ç¼“å­˜å¤§å°
      let currentSize = 0;
      const cacheItems: Array<[string, { data: Record<string, string | number | boolean | null>; expiry: number; timestamp: number }]> = [];
      
      for (const [key, item] of this.memoryCache.entries()) {
        const itemSize = this.calculateObjectSize(item.data);
        currentSize += itemSize;
        cacheItems.push([key, item, itemSize]);
      }
      
      // å¦‚æœå¤§å°åœ¨é™åˆ¶èŒƒå›´å†…ï¼Œä¸éœ€è¦é©±ï¿?      if (currentSize <= this.cacheConfig.memoryCacheSize) {
        return;
      }
      
      // æŒ‰æ—¶é—´æˆ³æ’åºï¼ˆæœ€æ—§çš„å…ˆåˆ é™¤ï¼‰
      cacheItems.sort((a, b) => a[1].timestamp - b[1].timestamp);
      
      // é©±é€é¡¹ç›®ç›´åˆ°å¤§å°åœ¨é™åˆ¶èŒƒå›´ï¿?      let evictedCount = 0;
      
      for (const [key, item, size] of cacheItems) {
        if (currentSize <= this.cacheConfig.memoryCacheSize) {
          break;
        }
        
        this.memoryCache.delete(key);
        currentSize -= size;
        evictedCount++;
      }
      
      if (evictedCount > 0) {
        Logger.debug(TAG, `Evicted ${evictedCount} items from memory cache due to size limit`);
        await this.updateStatistics();
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to evict memory cache by size', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'evictMemoryCacheBySize');
    }
  }

  /**
   * ä»ç£ç›˜åˆ é™¤ç¼“å­˜é¡¹
   */
  private async removeItemFromDisk(key: string): Promise<void> {
    try {
      const metadata = this.cacheIndex.get(key);
      if (!metadata) {
        return;
      }
      
      // åˆ é™¤ç¼“å­˜æ–‡ä»¶
      const filePath = this.getCacheFilePath(key);
      if (await FileUtil.fileExists(filePath)) {
        await FileUtil.deleteFile(filePath);
      }
      
      // ä»ç´¢å¼•ä¸­åˆ é™¤
      this.cacheIndex.delete(key);
      
      // é€šçŸ¥é©±é€ç›‘å¬å™¨
      this.notifyEviction(key, metadata);
      
      Logger.debug(TAG, `Removed cache item from disk: ${key}`);
    } catch (error) {
      Logger.error(TAG, `Failed to remove cache item from disk: ${key}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'removeItemFromDisk', key);
    }
  }

  /**
   * è·å–ç¼“å­˜æ–‡ä»¶è·¯å¾„
   */
  private getCacheFilePath(key: string): string {
    const encodedKey = encodeURIComponent(key);
    return `${this.cacheDir}/${encodedKey}.cache`;
  }

  /**
   * è®¾ç½®ç¼“å­˜ï¿?   */
  public async set<T>(
    key: string,
    data: T,
    options?: {
      expiry?: number;
      priority?: CachePriority;
      tags?: string[];
      type?: CacheType;
      source?: string;
    }
  ): Promise<CacheOperationResult> {
    const startTime = Date.now();
    const fullKey = `${this.cacheConfig.cacheKeyPrefix}${key}`;
    
    try {
      // éªŒè¯ç¼“å­˜ç±»å‹
      const cacheType = options?.type || CacheType.MEMORY_DISK;
      if (!this.cacheConfig.allowedCacheTypes.includes(cacheType)) {
        throw new Error(`Cache type ${cacheType} not allowed`);
      }
      
      // éªŒè¯æ•°æ®å¤§å°
      const dataSize = this.calculateObjectSize(data);
      if (dataSize > this.cacheConfig.maxItemSize) {
        throw new Error(`Data size ${this.formatSize(dataSize)} exceeds maximum allowed size ${this.formatSize(this.cacheConfig.maxItemSize)}`);
      }
      
      // åˆ›å»ºå…ƒæ•°ï¿?      const metadata: CacheMetadata = {
        key: fullKey,
        type: typeof data,
        size: dataSize,
        createdAt: Date.now(),
        modifiedAt: Date.now(),
        accessedAt: Date.now(),
        expiry: options?.expiry || this.cacheConfig.defaultExpiry,
        priority: options?.priority || CachePriority.NORMAL,
        hits: 0,
        tags: options?.tags || [],
        version: this.cacheConfig.cacheVersion,
        compressed: this.cacheConfig.compressCacheItems,
        encrypted: this.cacheConfig.encryptCacheItems,
        source: options?.source
      };
      
      // ä¿å­˜åˆ°å†…å­˜ç¼“ï¿?      if (this.cacheConfig.enableMemoryCache && 
          (cacheType === CacheType.MEMORY || cacheType === CacheType.MEMORY_DISK)) {
        this.memoryCache.set(fullKey, {
          data: TypeSafetyHelper.asObject(data) || {},
          expiry: metadata.expiry,
          timestamp: Date.now()
        });
        
        // æ£€æŸ¥å†…å­˜ç¼“å­˜å¤§å°é™ï¿?        await this.evictMemoryCacheBySize();
      }
      
      // ä¿å­˜åˆ°ç£ç›˜ç¼“ï¿?      if (this.cacheConfig.enableDiskCache && 
          (cacheType === CacheType.DISK || cacheType === CacheType.MEMORY_DISK)) {
        // åºåˆ—åŒ–æ•°ï¿?        let serializedData: string | ArrayBuffer;
        
        try {
          serializedData = typeof data === 'string' ? data : JsonUtil.stringify(data);
        } catch (error) {
          throw new Error('Failed to serialize data for caching');
        }
        
        // å¦‚æœéœ€è¦å‹ç¼©æˆ–åŠ å¯†ï¼Œåœ¨è¿™é‡Œå¤„ç†
        // ...
        
        // å†™å…¥æ–‡ä»¶
        const filePath = this.getCacheFilePath(fullKey);
        await FileUtil.writeFile(filePath, serializedData, { create: true });
        
        // æ›´æ–°ç´¢å¼•
        this.cacheIndex.set(fullKey, metadata);
        await this.saveCacheIndex();
        
        // æ£€æŸ¥ç£ç›˜ç¼“å­˜å¤§å°é™ï¿?        await this.updateStatistics();
        const cachePercentage = (this.statistics.diskCacheSize / this.cacheConfig.diskCacheSize) * 100;
        if (cachePercentage > this.cacheConfig.cleanupThreshold) {
          await this.cleanupCacheBySize();
        }
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      await this.updateStatistics();
      
      // è®°å½•æ“ä½œæ—¶é—´
      const duration = Date.now() - startTime;
      this.setTimes.push(duration);
      if (this.setTimes.length > 1000) {
        this.setTimes.shift();
      }
      
      Logger.debug(TAG, `Set cache item: ${key}, size: ${this.formatSize(dataSize)}, expiry: ${metadata.expiry > 0 ? new Date(metadata.expiry).toISOString() : 'never'}`);
      return {
        success: true,
        key: fullKey,
        details: {
          size: dataSize,
          expiry: metadata.expiry,
          type: cacheType
        }
      };
    } catch (error) {
      Logger.error(TAG, `Failed to set cache item: ${key}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'set', key);
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * è·å–ç¼“å­˜ï¿?   */
  public async get<T>(key: string): Promise<T | null> {
    const startTime = Date.now();
    const fullKey = `${this.cacheConfig.cacheKeyPrefix}${key}`;
    
    try {
      let data: T | null = null;
      
      // é¦–å…ˆå°è¯•ä»å†…å­˜ç¼“å­˜è·ï¿?      if (this.cacheConfig.enableMemoryCache) {
        const cachedItem = this.memoryCache.get(fullKey);
        if (cachedItem) {
          // æ£€æŸ¥æ˜¯å¦è¿‡ï¿?          if (cachedItem.expiry === 0 || Date.now() < cachedItem.expiry) {
            data = cachedItem.data;
            
            // æ›´æ–°è®¿é—®æ—¶é—´
            cachedItem.timestamp = Date.now();
            
            // æ›´æ–°ç´¢å¼•ä¸­çš„è®¿é—®ä¿¡æ¯ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const metadata = this.cacheIndex.get(fullKey);
            if (metadata) {
              metadata.accessedAt = Date.now();
              metadata.hits++;
              this.cacheIndex.set(fullKey, metadata);
              await this.saveCacheIndex();
            }
            
            this.statistics.hitCount++;
            Logger.debug(TAG, `Cache hit (memory): ${key}`);
          } else {
            // è¿‡æœŸï¼Œåˆ ï¿?            this.memoryCache.delete(fullKey);
            Logger.debug(TAG, `Cache expired (memory): ${key}`);
          }
        }
      }
      
      // å¦‚æœå†…å­˜ç¼“å­˜æœªå‘½ä¸­ï¼Œå°è¯•ä»ç£ç›˜è·ï¿?      if (data === null && this.cacheConfig.enableDiskCache) {
        const metadata = this.cacheIndex.get(fullKey);
        if (metadata) {
          // æ£€æŸ¥æ˜¯å¦è¿‡ï¿?          if (metadata.expiry === 0 || Date.now() < metadata.expiry) {
            const filePath = this.getCacheFilePath(fullKey);
            
            // è¯»å–æ–‡ä»¶
            const fileContent = await FileUtil.readFile(filePath, 'utf-8');
            if (fileContent) {
              // å¦‚æœéœ€è¦è§£å¯†æˆ–è§£å‹ç¼©ï¼Œåœ¨è¿™é‡Œå¤„ï¿?              // ...
              
              // ååºåˆ—åŒ–æ•°æ®
              try {
                data = typeof fileContent === 'string' && 
                      (fileContent.startsWith('{') || fileContent.startsWith('[')) 
                  ? JsonUtil.parse<T>(fileContent)
                  : TypeSafetyHelper.asObject<T>(fileContent) as T;
              } catch (parseError) {
                throw new Error('Failed to parse cached data');
              }
              
              // æ›´æ–°è®¿é—®ä¿¡æ¯
              metadata.accessedAt = Date.now();
              metadata.hits++;
              this.cacheIndex.set(fullKey, metadata);
              await this.saveCacheIndex();
              
              // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
              this.statistics.hitCount++;
              Logger.debug(TAG, `Cache hit (disk): ${key}`);
            }
          } else {
            // è¿‡æœŸï¼Œåˆ ï¿?            await this.removeItemFromDisk(fullKey);
            Logger.debug(TAG, `Cache expired (disk): ${key}`);
          }
        }
      }
      
      // å¦‚æœæœªå‘½ä¸­ï¼Œæ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      if (data === null) {
        this.statistics.missCount++;
        Logger.debug(TAG, `Cache miss: ${key}`);
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      await this.updateStatistics();
      
      // è®°å½•æ“ä½œæ—¶é—´
      const duration = Date.now() - startTime;
      this.getTimes.push(duration);
      if (this.getTimes.length > 1000) {
        this.getTimes.shift();
      }
      
      return data;
    } catch (error) {
      Logger.error(TAG, `Failed to get cache item: ${key}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'get', key);
      return null;
    }
  }

  /**
   * æ£€æŸ¥ç¼“å­˜é¡¹æ˜¯å¦å­˜åœ¨
   */
  public async exists(key: string): Promise<boolean> {
    const fullKey = `${this.cacheConfig.cacheKeyPrefix}${key}`;
    
    try {
      // æ£€æŸ¥å†…å­˜ç¼“ï¿?      if (this.cacheConfig.enableMemoryCache) {
        const cachedItem = this.memoryCache.get(fullKey);
        if (cachedItem && (cachedItem.expiry === 0 || Date.now() < cachedItem.expiry)) {
          return true;
        }
      }
      
      // æ£€æŸ¥ç£ç›˜ç¼“ï¿?      if (this.cacheConfig.enableDiskCache) {
        const metadata = this.cacheIndex.get(fullKey);
        if (metadata && (metadata.expiry === 0 || Date.now() < metadata.expiry)) {
          const filePath = this.getCacheFilePath(fullKey);
          return await FileUtil.fileExists(filePath);
        }
      }
      
      return false;
    } catch (error) {
      Logger.error(TAG, `Failed to check cache existence: ${key}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'exists', key);
      return false;
    }
  }

  /**
   * è·å–ç¼“å­˜é¡¹å…ƒæ•°æ®
   */
  public async getMetadata(key: string): Promise<CacheMetadata | null> {
    const fullKey = `${this.cacheConfig.cacheKeyPrefix}${key}`;
    
    try {
      const metadata = this.cacheIndex.get(fullKey);
      if (!metadata) {
        return null;
      }
      
      // æ£€æŸ¥æ˜¯å¦è¿‡ï¿?      if (metadata.expiry > 0 && Date.now() > metadata.expiry) {
        await this.removeItemFromDisk(fullKey);
        return null;
      }
      
      return { ...metadata };
    } catch (error) {
      Logger.error(TAG, `Failed to get cache metadata: ${key}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'getMetadata', key);
      return null;
    }
  }

  /**
   * åˆ é™¤ç¼“å­˜ï¿?   */
  public async remove(key: string): Promise<CacheOperationResult> {
    const fullKey = `${this.cacheConfig.cacheKeyPrefix}${key}`;
    
    try {
      // ä»å†…å­˜ç¼“å­˜åˆ ï¿?      if (this.cacheConfig.enableMemoryCache) {
        this.memoryCache.delete(fullKey);
      }
      
      // ä»ç£ç›˜ç¼“å­˜åˆ ï¿?      if (this.cacheConfig.enableDiskCache) {
        await this.removeItemFromDisk(fullKey);
        await this.saveCacheIndex();
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      await this.updateStatistics();
      
      Logger.debug(TAG, `Removed cache item: ${key}`);
      return {
        success: true,
        key: fullKey
      };
    } catch (error) {
      Logger.error(TAG, `Failed to remove cache item: ${key}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'remove', key);
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * æ‰¹é‡è®¾ç½®ç¼“å­˜ï¿?   */
  public async setMultiple(
    items: Array<{
      key: string;
      data: Record<string, string | number | boolean | null>;
      options?: {
        expiry?: number;
        priority?: CachePriority;
        tags?: string[];
        type?: CacheType;
        source?: string;
      };
    }>
  ): Promise<Array<CacheOperationResult>> {
    const results: Array<CacheOperationResult> = [];
    
    try {
      for (const item of items) {
        const result = await this.set(item.key, item.data, item.options);
        results.push(result);
      }
      
      return results;
    } catch (error) {
      Logger.error(TAG, 'Failed to set multiple cache items', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'setMultiple');
      return results;
    }
  }

  /**
   * æ‰¹é‡è·å–ç¼“å­˜ï¿?   */
  public async getMultiple<T>(keys: string[]): Promise<Map<string, T | null>> {
    const results = new Map<string, T | null>();
    
    try {
      for (const key of keys) {
        const value = await this.get<T>(key);
        results.set(key, value);
      }
      
      return results;
    } catch (error) {
      Logger.error(TAG, 'Failed to get multiple cache items', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'getMultiple');
      return results;
    }
  }

  /**
   * æ‰¹é‡åˆ é™¤ç¼“å­˜ï¿?   */
  public async removeMultiple(keys: string[]): Promise<Array<CacheOperationResult>> {
    const results: Array<CacheOperationResult> = [];
    
    try {
      for (const key of keys) {
        const result = await this.remove(key);
        results.push(result);
      }
      
      return results;
    } catch (error) {
      Logger.error(TAG, 'Failed to remove multiple cache items', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'removeMultiple');
      return results;
    }
  }

  /**
   * æ¸…ç†ç¼“å­˜
   */
  public async clear(options?: CacheCleanupOptions): Promise<{ deletedCount: number; freedSpace: number }> {
    try {
      let deletedCount = 0;
      let freedSpace = 0;
      
      // å¦‚æœå¼ºåˆ¶æ¸…ç†ï¼Œæ¸…ç©ºæ‰€æœ‰ç¼“ï¿?      if (options?.force) {
        // æ¸…ç©ºå†…å­˜ç¼“å­˜
        if (this.cacheConfig.enableMemoryCache) {
          deletedCount += this.memoryCache.size;
          this.memoryCache.clear();
        }
        
        // æ¸…ç©ºç£ç›˜ç¼“å­˜
        if (this.cacheConfig.enableDiskCache) {
          // åˆ é™¤æ‰€æœ‰ç¼“å­˜æ–‡ï¿?          for (const [key, metadata] of this.cacheIndex.entries()) {
            await this.removeItemFromDisk(key);
            deletedCount++;
            freedSpace += metadata.size;
          }
          
          // æ¸…ç©ºç´¢å¼•
          this.cacheIndex.clear();
          await this.saveCacheIndex();
        }
      } else {
        // æ ¹æ®é€‰é¡¹æ¸…ç†
        const keysToDelete: string[] = [];
        const now = Date.now();
        
        // æ”¶é›†éœ€è¦åˆ é™¤çš„ï¿?        for (const [key, metadata] of this.cacheIndex.entries()) {
          // æ£€æŸ¥æ˜¯å¦åŒ…å«åœ¨æ’é™¤åˆ—è¡¨ï¿?          if (options?.excludeKeys?.includes(key)) {
            continue;
          }
          
          // æ£€æŸ¥æ˜¯å¦åŒ…å«åœ¨åŒ…å«åˆ—è¡¨ï¿?          if (options?.includeKeys && !options.includeKeys.includes(key)) {
            continue;
          }
          
          // æ£€æŸ¥æ˜¯å¦åªæ¸…ç†è¿‡æœŸï¿?          if (options?.expiredOnly && (metadata.expiry === 0 || now < metadata.expiry)) {
            continue;
          }
          
          // æ£€æŸ¥æ ‡ï¿?          if (options?.tags && options.tags.length > 0) {
            const hasMatchingTag = options.tags.some(tag => metadata.tags.includes(tag));
            if (!hasMatchingTag) {
              continue;
            }
          }
          
          // æ£€æŸ¥å¹´ï¿?          if (options?.olderThan) {
            const age = now - metadata.createdAt;
            if (age < options.olderThan) {
              continue;
            }
          }
          
          // æ£€æŸ¥ä¼˜å…ˆçº§
          if (options?.priority) {
            const priorityValue = (p: CachePriority) => {
              switch (p) {
                case CachePriority.CRITICAL:
                  return 4;
                case CachePriority.HIGH:
                  return 3;
                case CachePriority.NORMAL:
                  return 2;
                case CachePriority.LOW:
                  return 1;
                default:
                  return 0;
              }
            };
            
            if (priorityValue(metadata.priority) > priorityValue(options.priority)) {
              continue;
            }
          }
          
          keysToDelete.push(key);
          freedSpace += metadata.size;
        }
        
        // é™åˆ¶åˆ é™¤æ•°é‡
        if (options?.itemLimit && keysToDelete.length > options.itemLimit) {
          keysToDelete.length = options.itemLimit;
        }
        
        // é™åˆ¶é‡Šæ”¾ç©ºé—´
        if (options?.sizeLimit) {
          let accumulatedSize = 0;
          const limitedKeys: string[] = [];
          
          for (const key of keysToDelete) {
            const metadata = this.cacheIndex.get(key);
            if (metadata) {
              accumulatedSize += metadata.size;
              limitedKeys.push(key);
              
              if (accumulatedSize >= options.sizeLimit) {
                break;
              }
            }
          }
          
          keysToDelete.length = 0;
          keysToDelete.push(...limitedKeys);
        }
        
        // åˆ é™¤é€‰ä¸­çš„ç¼“å­˜é¡¹
        for (const key of keysToDelete) {
          // ä»å†…å­˜ç¼“å­˜åˆ ï¿?          if (this.cacheConfig.enableMemoryCache) {
            this.memoryCache.delete(key);
          }
          
          // ä»ç£ç›˜ç¼“å­˜åˆ ï¿?          if (this.cacheConfig.enableDiskCache) {
            await this.removeItemFromDisk(key);
          }
          
          deletedCount++;
        }
        
        // ä¿å­˜ç´¢å¼•
        if (this.cacheConfig.enableDiskCache) {
          await this.saveCacheIndex();
        }
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      await this.updateStatistics();
      
      // æ›´æ–°æ¸…ç†ç»Ÿè®¡
      this.statistics.evictionCount += deletedCount;
      
      // é€šçŸ¥æ¸…ç†å®Œæˆ
      if (deletedCount > 0) {
        this.notifyCleanupCompleted(deletedCount, freedSpace);
      }
      
      Logger.info(TAG, `Cleared cache: ${deletedCount} items deleted, ${this.formatSize(freedSpace)} freed`);
      return { deletedCount, freedSpace };
    } catch (error) {
      Logger.error(TAG, 'Failed to clear cache', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'clear');
      return { deletedCount: 0, freedSpace: 0 };
    }
  }

  /**
   * æœç´¢ç¼“å­˜ï¿?   */
  public async search(params: CacheSearchParams): Promise<Array<{ key: string; metadata: CacheMetadata }>> {
    try {
      const results: Array<{ key: string; metadata: CacheMetadata }> = [];
      const now = Date.now();
      
      // éå†æ‰€æœ‰ç¼“å­˜é¡¹
      for (const [key, metadata] of this.cacheIndex.entries()) {
        // æ£€æŸ¥æ˜¯å¦è¿‡ï¿?        const isExpired = metadata.expiry > 0 && now > metadata.expiry;
        if (params.expired !== undefined && params.expired !== isExpired) {
          continue;
        }
        
        // æ£€æŸ¥æ ‡ï¿?        if (params.tags && params.tags.length > 0) {
          const hasMatchingTag = params.tags.some(tag => metadata.tags.includes(tag));
          if (!hasMatchingTag) {
            continue;
          }
        }
        
        // æ£€æŸ¥å¹´ï¿?        const age = now - metadata.createdAt;
        if (params.minAge !== undefined && age < params.minAge) {
          continue;
        }
        if (params.maxAge !== undefined && age > params.maxAge) {
          continue;
        }
        
        // æ£€æŸ¥å¤§ï¿?        if (params.minSize !== undefined && metadata.size < params.minSize) {
          continue;
        }
        if (params.maxSize !== undefined && metadata.size > params.maxSize) {
          continue;
        }
        
        // æ£€æŸ¥ä¼˜å…ˆçº§
        if (params.priority && params.priority.length > 0 && !params.priority.includes(metadata.priority)) {
          continue;
        }
        
        // æ£€æŸ¥ç±»ï¿?        if (params.type && params.type.length > 0 && !params.type.includes(metadata.type)) {
          continue;
        }
        
        // æ£€æŸ¥é”®æ¨¡å¼
        if (params.keyPattern) {
          // ä¸ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ”¹ç”¨å­—ç¬¦ä¸²æ–¹æ³•å®ç°å¤§å°å†™ä¸æ•æ„Ÿçš„åŒ¹ï¿?          const searchPattern = params.keyPattern.toLowerCase();
          if (key.toLowerCase().indexOf(searchPattern) === -1) {
            continue;
          }
        }
        
        results.push({ key, metadata });
      }
      
      // åº”ç”¨åˆ†é¡µ
      if (params.offset !== undefined) {
        results.splice(0, params.offset);
      }
      
      if (params.limit !== undefined) {
        results.length = Math.min(results.length, params.limit);
      }
      
      Logger.debug(TAG, `Search found ${results.length} cache items`);
      return results;
    } catch (error) {
      Logger.error(TAG, 'Failed to search cache items', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'search');
      return [];
    }
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   */
  public getStatistics(): CacheStatistics {
    return { ...this.statistics };
  }

  /**
   * æ¸…é™¤ç»Ÿè®¡ä¿¡æ¯
   */
  public async resetStatistics(): Promise<void> {
    try {
      this.statistics = {
        memoryCacheSize: this.statistics.memoryCacheSize,
        memoryCacheItems: this.statistics.memoryCacheItems,
        diskCacheSize: this.statistics.diskCacheSize,
        diskCacheItems: this.statistics.diskCacheItems,
        hitCount: 0,
        missCount: 0,
        evictionCount: 0,
        expirationCount: 0,
        errorCount: 0,
        lastCleanupTime: this.statistics.lastCleanupTime,
        totalCleanupTime: this.statistics.totalCleanupTime,
        cacheRatio: 0,
        averageGetTime: 0,
        averageSetTime: 0,
        largestItemSize: this.statistics.largestItemSize,
        smallestItemSize: this.statistics.smallestItemSize,
        averageItemSize: this.statistics.averageItemSize
      };
      
      // æ¸…ç©ºæ“ä½œæ—¶é—´è®°å½•
      this.getTimes = [];
      this.setTimes = [];
      
      Logger.debug(TAG, 'Statistics reset');
    } catch (error) {
      Logger.error(TAG, 'Failed to reset statistics', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'resetStatistics');
    }
  }

  /**
   * æ·»åŠ æ¸…ç†ç›‘å¬ï¿?   */
  public addCleanupListener(listener: (deletedCount: number, freedSpace: number) => void): () => void {
    this.cleanupListeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.cleanupListeners.indexOf(listener);
      if (index > -1) {
        this.cleanupListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ é©±é€ç›‘å¬å™¨
   */
  public addEvictionListener(listener: (key: string, metadata: CacheMetadata) => void): () => void {
    this.evictionListeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.evictionListeners.indexOf(listener);
      if (index > -1) {
        this.evictionListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ é”™è¯¯ç›‘å¬ï¿?   */
  public addErrorListener(listener: (error: Error, operation: string, key?: string) => void): () => void {
    this.errorListeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.errorListeners.indexOf(listener);
      if (index > -1) {
        this.errorListeners.splice(index, 1);
      }
    };
  }

  /**
   * é€šçŸ¥æ¸…ç†å®Œæˆ
   */
  private notifyCleanupCompleted(deletedCount: number, freedSpace: number): void {
    for (const listener of this.cleanupListeners) {
      try {
        listener(deletedCount, freedSpace);
      } catch (error) {
        Logger.error(TAG, 'Error in cleanup listener', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      }
    }
  }

  /**
   * é€šçŸ¥ç¼“å­˜é¡¹è¢«é©±ï¿½?   */
  private notifyEviction(key: string, metadata: CacheMetadata): void {
    for (const listener of this.evictionListeners) {
      try {
        listener(key, { ...metadata });
      } catch (error) {
        Logger.error(TAG, 'Error in eviction listener', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      }
    }
  }

  /**
   * æ ¼å¼åŒ–å¤§å°æ˜¾ï¿?   */
  private formatSize(bytes: number): string {
    if (bytes < 1024) {
      return `${bytes} B`;
    } else if (bytes < 1024 * 1024) {
      return `${(bytes / 1024).toFixed(2)} KB`;
    } else if (bytes < 1024 * 1024 * 1024) {
      return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    } else {
      return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }
  }

  /**
   * é”€æ¯ç¼“å­˜æœï¿?   */
  public async destroy(): Promise<void> {
    try {
      Logger.info(TAG, 'Destroying cache service...');
      
      // åœæ­¢è‡ªåŠ¨æ¸…ç†
      this.stopAutoCleanup();
      
      // ä¿å­˜ç´¢å¼•
      if (this.cacheConfig.enableDiskCache) {
        await this.saveCacheIndex();
      }
      
      // æ¸…é™¤å†…å­˜ç¼“å­˜
      this.memoryCache.clear();
      
      // æ¸…é™¤ç›‘å¬ï¿?      this.cleanupListeners = [];
      this.evictionListeners = [];
      this.errorListeners = [];
      
      Logger.info(TAG, 'Cache service destroyed successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to destroy cache service', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      this.recordError(error as Error, 'destroy');
    }
  }
}


