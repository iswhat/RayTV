import Logger from '../../common/util/Logger';
import { configService } from '../config/ConfigService';
import { mediaService } from '../media/MediaService';
import { playerManager } from '../media/PlayerManager';
import { AppNavigator, PageRoute } from '../../navigation/AppNavigator';

/**
 * è¯­éŸ³å‘½ä»¤æ¥å£
 */
export interface VoiceCommand {
  keyword: string;        // å‘½ä»¤å…³é”®è¯?  action: (params?: Record<string, string | number | boolean | null>) => Promise<void>; // æ‰§è¡Œçš„åŠ¨ä½?  description?: string;   // å‘½ä»¤æè¿°
  examples?: string[];    // ç¤ºä¾‹
}

/**
 * è¯­éŸ³è¯†åˆ«ç»“æœæ¥å£
 */
export interface RecognitionResult {
  text: string;           // è¯†åˆ«çš„æ–‡æœ?  confidence: number;     // ç½®ä¿¡åº¦ï¼ˆ0-1ï¼?  timestamp: number;      // è¯†åˆ«æ—¶é—´æˆ?}

/**
 * è¯­éŸ³åŠ©æ‰‹ç®¡ç†å™? */
export class VoiceAssistantManager {
  private static readonly TAG: string = 'VoiceAssistantManager';
  private static instance: VoiceAssistantManager;
  
  private isEnabled: boolean = false;
  private isListening: boolean = false;
  private voiceCommands: Map<string, VoiceCommand> = new Map();
  private recognitionListeners: Array<(result: RecognitionResult) => void> = [];
  private stateListeners: Array<(listening: boolean) => void> = [];
  
  private constructor() {
    // æ³¨å†Œé»˜è®¤è¯­éŸ³å‘½ä»¤
    this.registerDefaultCommands();
  }
  
  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): VoiceAssistantManager {
    if (!VoiceAssistantManager.instance) {
      VoiceAssistantManager.instance = new VoiceAssistantManager();
    }
    return VoiceAssistantManager.instance;
  }
  
  /**
   * åˆå§‹åŒ–è¯­éŸ³åŠ©æ‰?   */
  public async initialize(): Promise<void> {
    try {
      Logger.info(VoiceAssistantManager.TAG, 'Initializing VoiceAssistantManager...');
      
      // åŠ è½½é…ç½®
      this.isEnabled = await configService.getConfig('enableVoiceAssistant', true);
      
      // è¿™é‡Œåº”è¯¥åˆå§‹åŒ–HarmonyOSçš„è¯­éŸ³è¯†åˆ«æœåŠ?      // æš‚æ—¶åªè¿›è¡ŒåŸºæœ¬åˆå§‹åŒ–
      
      Logger.info(VoiceAssistantManager.TAG, 'VoiceAssistantManager initialized successfully');
    } catch (error: Error) {
      Logger.error(VoiceAssistantManager.TAG, `Failed to initialize VoiceAssistantManager: ${error}`);
      throw error;
    }
  }
  
  /**
   * å¼€å§‹è¯­éŸ³è¯†åˆ?   */
  public async startListening(): Promise<void> {
    try {
      if (!this.isEnabled) {
        throw new Error('Voice assistant is disabled');
      }
      
      Logger.info(VoiceAssistantManager.TAG, 'Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' : new Error(String('Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' : new Error(String('Starting voice recognition...' : new Error(String('Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' : new Error(String('Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' : new Error(String('Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' : new Error(String('Starting voice recognition...' : new Error(String('Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' : new Error(String('Starting voice recognition...' : new Error(String('Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' : new Error(String('Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' : new Error(String('Starting voice recognition...' : new Error(String('Starting voice recognition...' instanceof Error ? 'Starting voice recognition...' : new Error(String('Starting voice recognition...')))))));
      
      // æ›´æ–°çŠ¶æ€?      this.isListening = true;
      this.notifyStateChanged();
      
      // è¿™é‡Œåº”è¯¥è°ƒç”¨HarmonyOSçš„è¯­éŸ³è¯†åˆ«API
      // æš‚æ—¶ä½¿ç”¨æ¨¡æ‹Ÿè¯†åˆ«
      await this.simulateVoiceRecognition();
    } catch (error: Error) {
      Logger.error(VoiceAssistantManager.TAG, `Failed to start listening: ${error}`);
      
      // é‡ç½®çŠ¶æ€?      this.isListening = false;
      this.notifyStateChanged();
      
      throw error;
    }
  }
  
  /**
   * åœæ­¢è¯­éŸ³è¯†åˆ«
   */
  public async stopListening(): Promise<void> {
    try {
      if (!this.isListening) {
        return;
      }
      
      Logger.info(VoiceAssistantManager.TAG, 'Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' : new Error(String('Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' : new Error(String('Stopping voice recognition' : new Error(String('Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' : new Error(String('Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' : new Error(String('Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' : new Error(String('Stopping voice recognition' : new Error(String('Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' : new Error(String('Stopping voice recognition' : new Error(String('Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' : new Error(String('Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' : new Error(String('Stopping voice recognition' : new Error(String('Stopping voice recognition' instanceof Error ? 'Stopping voice recognition' : new Error(String('Stopping voice recognition')))))));
      
      // æ›´æ–°çŠ¶æ€?      this.isListening = false;
      this.notifyStateChanged();
      
      // è¿™é‡Œåº”è¯¥åœæ­¢HarmonyOSçš„è¯­éŸ³è¯†åˆ«API
    } catch (error: Error) {
      Logger.error(VoiceAssistantManager.TAG, `Failed to stop listening: ${error}`);
      throw error;
    }
  }
  
  /**
   * å¤„ç†è¯­éŸ³æ–‡æœ¬
   */
  public async processVoiceText(text: string): Promise<void> {
    try {
      Logger.info(VoiceAssistantManager.TAG, `Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}` instanceof Error ? `Processing voice text: ${text}` : new Error(String(`Processing voice text: ${text}`)))))));
      
      // å°†æ–‡æœ¬è½¬æ¢ä¸ºå°å†™ä»¥ä¾¿åŒ¹é…
      const lowercaseText = text.toLowerCase();
      
      // æŸ¥æ‰¾åŒ¹é…çš„å‘½ä»?      let matchedCommand: VoiceCommand | null = null;
      
      // ä¼˜å…ˆç²¾ç¡®åŒ¹é…å…³é”®è¯?      for (const [keyword, command] of this.voiceCommands.entries()) {
        if (lowercaseText.includes(keyword.toLowerCase())) {
          matchedCommand = command;
          break;
        }
      }
      
      // å¦‚æœæ‰¾åˆ°åŒ¹é…çš„å‘½ä»¤ï¼Œæ‰§è¡Œå®?      if (matchedCommand) {
        Logger.info(VoiceAssistantManager.TAG, `Executing command: ${matchedCommand.keyword}`);
        await matchedCommand.action();
        
        // ç”Ÿæˆè¯†åˆ«ç»“æœ
        const result: RecognitionResult = {
          text,
          confidence: 0.9,
          timestamp: Date.now()
        };
        
        this.notifyRecognitionResult(result);
      } else {
        // å¦‚æœæ²¡æœ‰åŒ¹é…çš„å‘½ä»¤ï¼Œå°è¯•æœç´¢å†…å®¹
        await this.handleSearchCommand(lowercaseText);
      }
    } catch (error: Error) {
      Logger.error(VoiceAssistantManager.TAG, `Failed to process voice text: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ³¨å†Œè¯­éŸ³å‘½ä»¤
   */
  public registerCommand(command: VoiceCommand): void {
    this.voiceCommands.set(command.keyword, command instanceof Error ? command : new Error(String(command instanceof Error ? command instanceof Error ? command : new Error(String(command : new Error(String(command instanceof Error ? command : new Error(String(command instanceof Error ? command instanceof Error ? command : new Error(String(command instanceof Error ? command instanceof Error ? command : new Error(String(command : new Error(String(command instanceof Error ? command : new Error(String(command : new Error(String(command instanceof Error ? command : new Error(String(command instanceof Error ? command instanceof Error ? command : new Error(String(command : new Error(String(command instanceof Error ? command : new Error(String(command)))))));
    Logger.info(VoiceAssistantManager.TAG, `Command registered: ${command.keyword}`);
  }
  
  /**
   * æ³¨é”€è¯­éŸ³å‘½ä»¤
   */
  public unregisterCommand(keyword: string): void {
    this.voiceCommands.delete(keyword);
    Logger.info(VoiceAssistantManager.TAG, `Command unregistered: ${keyword}`);
  }
  
  /**
   * è·å–æ‰€æœ‰å¯ç”¨çš„è¯­éŸ³å‘½ä»¤
   */
  public getAvailableCommands(): VoiceCommand[] {
    return Array.from(this.voiceCommands.values());
  }
  
  /**
   * å¯ç”¨/ç¦ç”¨è¯­éŸ³åŠ©æ‰‹
   */
  public async setEnabled(enabled: boolean): Promise<void> {
    try {
      this.isEnabled = enabled;
      await configService.setConfig('enableVoiceAssistant', enabled);
      
      // å¦‚æœç¦ç”¨ï¼Œåœæ­¢ç›‘å?      if (!enabled && this.isListening) {
        await this.stopListening();
      }
      
      Logger.info(VoiceAssistantManager.TAG, `Voice assistant ${enabled ? 'enabled' : 'disabled'}`);
    } catch (error: Error) {
      Logger.error(VoiceAssistantManager.TAG, `Failed to set voice assistant enabled state: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ·»åŠ è¯†åˆ«ç»“æœç›‘å¬å™?   */
  public addRecognitionListener(listener: (result: RecognitionResult) => void): void {
    this.recognitionListeners.push(listener);
  }
  
  /**
   * ç§»é™¤è¯†åˆ«ç»“æœç›‘å¬å™?   */
  public removeRecognitionListener(listener: (result: RecognitionResult) => void): void {
    const index = this.recognitionListeners.indexOf(listener);
    if (index > -1) {
      this.recognitionListeners.splice(index, 1 instanceof Error ? 1 : new Error(String(1 instanceof Error ? 1 instanceof Error ? 1 : new Error(String(1 : new Error(String(1 instanceof Error ? 1 : new Error(String(1 instanceof Error ? 1 instanceof Error ? 1 : new Error(String(1 instanceof Error ? 1 instanceof Error ? 1 : new Error(String(1 : new Error(String(1 instanceof Error ? 1 : new Error(String(1 : new Error(String(1 instanceof Error ? 1 : new Error(String(1 instanceof Error ? 1 instanceof Error ? 1 : new Error(String(1 : new Error(String(1 instanceof Error ? 1 : new Error(String(1)))))));
    }
  }
  
  /**
   * æ·»åŠ çŠ¶æ€ç›‘å¬å™¨
   */
  public addStateListener(listener: (listening: boolean) => void): void {
    this.stateListeners.push(listener);
  }
  
  /**
   * ç§»é™¤çŠ¶æ€ç›‘å¬å™¨
   */
  public removeStateListener(listener: (listening: boolean) => void): void {
    const index = this.stateListeners.indexOf(listener);
    if (index > -1) {
      this.stateListeners.splice(index, 1);
    }
  }
  
  /**
   * æ³¨å†Œé»˜è®¤è¯­éŸ³å‘½ä»¤
   */
  private registerDefaultCommands(): void {
    // æ’­æ”¾æ§åˆ¶å‘½ä»¤
    this.registerCommand({
      keyword: 'æ’­æ”¾',
      action: async () => await playerManager.play(),
      description: 'å¼€å§‹æ’­æ”¾è§†é¢?,
      examples: ['æ’­æ”¾', 'å¼€å§‹æ’­æ”?]
    });
    
    this.registerCommand({
      keyword: 'æš‚åœ',
      action: async () => await playerManager.pause(),
      description: 'æš‚åœæ’­æ”¾',
      examples: ['æš‚åœ', 'åœæ­¢æ’­æ”¾']
    });
    
    this.registerCommand({
      keyword: 'ä¸‹ä¸€é›?,
      action: async () => {
        // è¿™é‡Œåº”è¯¥å®ç°åˆ‡æ¢åˆ°ä¸‹ä¸€é›†çš„é€»è¾‘
        Logger.info(VoiceAssistantManager.TAG, 'Switching to next episode');
      },
      description: 'æ’­æ”¾ä¸‹ä¸€é›?,
      examples: ['ä¸‹ä¸€é›?, 'æ’­æ”¾ä¸‹ä¸€é›?]
    });
    
    this.registerCommand({
      keyword: 'ä¸Šä¸€é›?,
      action: async () => {
        // è¿™é‡Œåº”è¯¥å®ç°åˆ‡æ¢åˆ°ä¸Šä¸€é›†çš„é€»è¾‘
        Logger.info(VoiceAssistantManager.TAG, 'Switching to previous episode');
      },
      description: 'æ’­æ”¾ä¸Šä¸€é›?,
      examples: ['ä¸Šä¸€é›?, 'æ’­æ”¾ä¸Šä¸€é›?]
    });
    
    this.registerCommand({
      keyword: 'å¿«è¿›',
      action: async () => await playerManager.seekBy(30000), // å¿«è¿›30ç§?      description: 'å¿«è¿›30ç§?,
      examples: ['å¿«è¿›', 'å¿«è¿›30ç§?]
    });
    
    this.registerCommand({
      keyword: 'å¿«é€€',
      action: async () => await playerManager.seekBy(-30000), // å¿«é€€30ç§?      description: 'å¿«é€€30ç§?,
      examples: ['å¿«é€€', 'å¿«é€€30ç§?]
    });
    
    // å¯¼èˆªå‘½ä»¤
    this.registerCommand({
      keyword: 'é¦–é¡µ',
      action: async () => AppNavigator.getInstance().navigateToHome(),
      description: 'è¿”å›é¦–é¡µ',
      examples: ['è¿”å›é¦–é¡µ', 'é¦–é¡µ']
    });
    
    this.registerCommand({
      keyword: 'æœç´¢',
      action: async () => AppNavigator.getInstance().navigateToSearch(),
      description: 'æ‰“å¼€æœç´¢é¡µé¢',
      examples: ['æœç´¢', 'æ‰“å¼€æœç´¢']
    });
    
    this.registerCommand({
      keyword: 'å†å²è®°å½•',
      action: async () => AppNavigator.getInstance().navigateToHistory(),
      description: 'æŸ¥çœ‹å†å²è®°å½•',
      examples: ['å†å²è®°å½•', 'æˆ‘çš„å†å²']
    });
    
    this.registerCommand({
      keyword: 'æˆ‘çš„æ”¶è—',
      action: async () => AppNavigator.getInstance().navigateToFavorites(),
      description: 'æŸ¥çœ‹æ”¶è—å†…å®¹',
      examples: ['æˆ‘çš„æ”¶è—', 'æ”¶è—']
    });
  }
  
  /**
   * å¤„ç†æœç´¢å‘½ä»¤
   */
  private async handleSearchCommand(text: string): Promise<void> {
    try {
      // æå–æœç´¢å…³é”®è¯ï¼ˆç§»é™¤å‘½ä»¤å‰ç¼€ï¼?      const searchKeywords = ['æœç´¢', 'æŸ¥æ‰¾', 'æ‰?, 'æ’­æ”¾'];
      let keyword = text;
      
      for (const prefix of searchKeywords) {
        if (keyword.startsWith(prefix)) {
          keyword = keyword.substring(prefix.length).trim();
          break;
        }
      }
      
      if (keyword.length > 0) {
        Logger.info(VoiceAssistantManager.TAG, `Searching for: ${keyword}`);
        
        // å¯¼èˆªåˆ°æœç´¢é¡µé¢å¹¶ä¼ é€’å…³é”®è¯
          AppNavigator.getInstance().navigateToSearch(keyword);
      }
    } catch (error: Error) {
      Logger.error(VoiceAssistantManager.TAG, `Failed to handle search command: ${error}`);
    }
  }
  
  /**
   * æ¨¡æ‹Ÿè¯­éŸ³è¯†åˆ«ï¼ˆç”¨äºæ¼”ç¤ºï¼‰
   */
  private async simulateVoiceRecognition(): Promise<void> {
    // æ¨¡æ‹Ÿè¯†åˆ«å»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 1000 instanceof Error ? 1000 : new Error(String(1000 instanceof Error ? 1000 instanceof Error ? 1000 : new Error(String(1000 : new Error(String(1000 instanceof Error ? 1000 : new Error(String(1000 instanceof Error ? 1000 instanceof Error ? 1000 : new Error(String(1000 instanceof Error ? 1000 instanceof Error ? 1000 : new Error(String(1000 : new Error(String(1000 instanceof Error ? 1000 : new Error(String(1000 : new Error(String(1000 instanceof Error ? 1000 : new Error(String(1000 instanceof Error ? 1000 instanceof Error ? 1000 : new Error(String(1000 : new Error(String(1000 instanceof Error ? 1000 : new Error(String(1000))))))));
    
    // æ¨¡æ‹Ÿè¯†åˆ«ç»“æœ
    const mockResults = [
      'æ’­æ”¾',
      'æš‚åœ',
      'ä¸‹ä¸€é›?,
      'å¿«è¿›',
      'è¿”å›é¦–é¡µ',
      'æœç´¢ç”µå½±'
    ];
    
    // éšæœºé€‰æ‹©ä¸€ä¸ªç»“æ?    const randomIndex = Math.floor(Math.random() * mockResults.length);
    const recognizedText = mockResults[randomIndex];
    
    // å¤„ç†è¯†åˆ«ç»“æœ
    await this.processVoiceText(recognizedText);
    
    // åœæ­¢ç›‘å¬
    this.isListening = false;
    this.notifyStateChanged();
  }
  
  /**
   * é€šçŸ¥è¯†åˆ«ç»“æœ
   */
  private notifyRecognitionResult(result: RecognitionResult): void {
    this.recognitionListeners.forEach(listener => {
      try {
        listener(result);
      } catch (error: Error) {
        Logger.error(VoiceAssistantManager.TAG, `Error in recognition listener: ${error}`);
      }
    });
  }
  
  /**
   * é€šçŸ¥çŠ¶æ€å˜åŒ?   */
  private notifyStateChanged(): void {
    this.stateListeners.forEach(listener => {
      try {
        listener(this.isListening);
      } catch (error) {
        Logger.error(VoiceAssistantManager.TAG, `Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}` instanceof Error ? `Error in state listener: ${error}` : new Error(String(`Error in state listener: ${error}`)))))));
      }
    });
  }
  
  /**
   * è·å–å½“å‰ç›‘å¬çŠ¶æ€?   */
  public isCurrentlyListening(): boolean {
    return this.isListening;
  }
  
  /**
   * è·å–è¯­éŸ³åŠ©æ‰‹å¯ç”¨çŠ¶æ€?   */
  public isAssistantEnabled(): boolean {
    return this.isEnabled;
  }
}

// å¯¼å‡ºå•ä¾‹å®ä¾‹
export function getVoiceAssistantManager(): VoiceAssistantManager {
  return VoiceAssistantManager.getInstance();
}


