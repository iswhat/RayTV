// FileService - æ–‡ä»¶æœåŠ¡ç±?import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import FileUtil, { FileInfo, FileStats } from '../../common/util/FileUtil';
import ConfigService from '../../service/config/ConfigService';
import HttpService from '../http/HttpService';
import { DownloadTask, DownloadStatus } from '../../service/download/DownloadService';

// å¸¸é‡å®šä¹‰
const TAG = 'FileService';
const FILE_CONFIG_KEY = 'file_config';
const MAX_UPLOAD_SIZE = 100 * 1024 * 1024; // 100MB
const TEMP_FILE_EXPIRY = 3600000; // 1å°æ—¶
const THUMBNAIL_CACHE_EXPIRY = 86400000; // 24å°æ—¶

// æ–‡ä»¶ç±»å‹æšä¸¾
export enum FileType {
  VIDEO = 'video',
  AUDIO = 'audio',
  IMAGE = 'image',
  SUBTITLE = 'subtitle',
  DOCUMENT = 'document',
  ARCHIVE = 'archive',
  EXECUTABLE = 'executable',
  OTHER = 'other',
  UNKNOWN = 'unknown'
}

// æ–‡ä»¶æ ¼å¼æšä¸¾
export enum FileFormat {
  // è§†é¢‘æ ¼å¼
  MP4 = 'mp4',
  AVI = 'avi',
  MKV = 'mkv',
  FLV = 'flv',
  WMV = 'wmv',
  MOV = 'mov',
  WEBM = 'webm',
  TS = 'ts',
  MPG = 'mpg',
  MPEG = 'mpeg',
  VOB = 'vob',
  RMVB = 'rmvb',
  M4V = 'm4v',
  
  // éŸ³é¢‘æ ¼å¼
  MP3 = 'mp3',
  WAV = 'wav',
  FLAC = 'flac',
  AAC = 'aac',
  OGG = 'ogg',
  WMA = 'wma',
  OPUS = 'opus',
  M4A = 'm4a',
  
  // å›¾åƒæ ¼å¼
  JPG = 'jpg',
  JPEG = 'jpeg',
  PNG = 'png',
  GIF = 'gif',
  WEBP = 'webp',
  SVG = 'svg',
  BMP = 'bmp',
  TIFF = 'tiff',
  HEIC = 'heic',
  
  // å­—å¹•æ ¼å¼
  SRT = 'srt',
  VTT = 'vtt',
  ASS = 'ass',
  SSA = 'ssa',
  TTML = 'ttml',
  DFXP = 'dfxp',
  SBV = 'sbv',
  LRC = 'lrc',
  
  // æ–‡æ¡£æ ¼å¼
  TXT = 'txt',
  PDF = 'pdf',
  DOC = 'doc',
  DOCX = 'docx',
  XLS = 'xls',
  XLSX = 'xlsx',
  PPT = 'ppt',
  PPTX = 'pptx',
  MD = 'md',
  HTML = 'html',
  XML = 'xml',
  JSON = 'json',
  
  // å‹ç¼©æ ¼å¼
  ZIP = 'zip',
  RAR = 'rar',
  7Z = '7z',
  TAR = 'tar',
  GZIP = 'gzip',
  BZIP2 = 'bzip2',
  ISO = 'iso',
  
  // å…¶ä»–æ ¼å¼
  APK = 'apk',
  EXE = 'exe',
  DLL = 'dll',
  DYLIB = 'dylib',
  SO = 'so',
  
  // æœªçŸ¥æ ¼å¼
  UNKNOWN = 'unknown'
}

// å­˜å‚¨ä½ç½®æšä¸¾
export enum StorageLocation {
  INTERNAL = 'internal',
  EXTERNAL = 'external',
  SD_CARD = 'sd_card',
  NETWORK = 'network',
  CLOUD = 'cloud',
  TEMP = 'temp'
}

// æ–‡ä»¶æƒé™æšä¸¾
export enum FilePermission {
  READ = 'read',
  WRITE = 'write',
  EXECUTE = 'execute',
  DELETE = 'delete',
  ALL = 'all',
  NONE = 'none'
}

// æ–‡ä»¶æ“ä½œæ¨¡å¼æšä¸¾
export enum FileMode {
  READ = 'read',
  WRITE = 'write',
  APPEND = 'append',
  READ_WRITE = 'read_write',
  TRUNCATE = 'truncate'
}

// æ–‡ä»¶æ’åºæ–¹å¼æšä¸¾
export enum FileSortBy {
  NAME = 'name',
  SIZE = 'size',
  DATE = 'date',
  TYPE = 'type',
  EXTENSION = 'extension',
  NONE = 'none'
}

// æ–‡ä»¶æ’åºæ–¹å‘æšä¸¾
export enum FileSortDirection {
  ASCENDING = 'ascending',
  DESCENDING = 'descending'
}

// æ–‡ä»¶é…ç½®æ¥å£
export interface FileConfig {
  defaultStorageLocation: StorageLocation;
  maxCacheSize: number; // å­—èŠ‚
  maxTempFileSize: number; // å­—èŠ‚
  enableAutoCleanup: boolean;
  cleanupInterval: number; // æ¯«ç§’
  thumbnailCacheSize: number; // å­—èŠ‚
  tempDir: string;
  cacheDir: string;
  downloadDir: string;
  uploadDir: string;
  documentDir: string;
  imageDir: string;
  videoDir: string;
  audioDir: string;
  subtitleDir: string;
  enableFileWatcher: boolean;
  fileWatcherInterval: number; // æ¯«ç§’
  supportedFormats: Partial<Record<FileType, FileFormat[]>>;
  chunkSize: number; // åˆ†å—ä¸Šä¼ /ä¸‹è½½çš„å—å¤§å°
  maxConcurrentOperations: number;
  verifyFileIntegrity: boolean;
}

// æ–‡ä»¶å…ƒæ•°æ®æ¥å?export interface FileMetadata {
  metadata?: Record<string, string | number | boolean | null>;
}

// æ–‡ä»¶ä¿¡æ¯æ‰©å±•æ¥å£
export interface ExtendedFileInfo extends FileInfo {
  type: FileType;
  format: FileFormat;
  storageLocation: StorageLocation;
  permissions: FilePermission[];
  metadata?: FileMetadata;
  thumbnailUrl?: string;
  duration?: number; // è§†é¢‘/éŸ³é¢‘æ—¶é•¿
  width?: number; // å›¾åƒ/è§†é¢‘å®½åº¦
  height?: number; // å›¾åƒ/è§†é¢‘é«˜åº¦
  codec?: string; // è§†é¢‘/éŸ³é¢‘ç¼–ç 
  bitrate?: number; // è§†é¢‘/éŸ³é¢‘æ¯”ç‰¹ç?  frameRate?: number; // è§†é¢‘å¸§ç‡
  resolution?: string; // è§†é¢‘åˆ†è¾¨ç?  aspectRatio?: number; // è§†é¢‘å®½é«˜æ¯?  tags?: Record<string, string>; // æ–‡ä»¶æ ‡ç­¾
  checksum?: string; // æ–‡ä»¶æ ¡éªŒå’?  owner?: string; // æ–‡ä»¶æ‰€æœ‰è€?  createdAt: number;
  modifiedAt: number;
  accessedAt: number;
}

// æ–‡ä»¶æœç´¢å‚æ•°æ¥å£
export interface FileSearchParams {
  path: string;
  pattern?: string;
  recursive?: boolean;
  types?: FileType[];
  formats?: FileFormat[];
  minSize?: number;
  maxSize?: number;
  minDate?: number;
  maxDate?: number;
  sortBy?: FileSortBy;
  sortDirection?: FileSortDirection;
  limit?: number;
  offset?: number;
}

// æ–‡ä»¶æ“ä½œç»“æœæ¥å£
export interface FileOperationResult {
  success: boolean;
  path?: string;
  error?: string;
  details?: { source?: string; format?: string; size?: number; duration?: number };
}

// æ–‡ä»¶å¤¹ä¿¡æ¯æ¥å?export interface FolderInfo {
  path: string;
  name: string;
  parentPath?: string;
  storageLocation: StorageLocation;
  fileCount: number;
  folderCount: number;
  totalSize: number;
  createdAt: number;
  modifiedAt: number;
  accessedAt: number;
  permissions: FilePermission[];
}

// å­˜å‚¨è®¾å¤‡ä¿¡æ¯æ¥å£
export interface StorageDeviceInfo {
  id: string;
  name: string;
  path: string;
  type: StorageLocation;
  totalSize: number;
  availableSize: number;
  usedSize: number;
  isRemovable: boolean;
  isReadOnly: boolean;
  mountPoint: string;
  fileSystem: string;
  model?: string;
  serialNumber?: string;
}

// æ–‡ä»¶ä¼ è¾“è¿›åº¦æ¥å£
export interface FileTransferProgress {
  id: string;
  source: string;
  destination: string;
  progress: number; // 0-100
  bytesTransferred: number;
  totalBytes: number;
  speed: number; // å­—èŠ‚/ç§?  elapsedTime: number; // æ¯«ç§’
  remainingTime?: number; // é¢„ä¼°å‰©ä½™æ¯«ç§’
  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'canceled';
  error?: string;
}

// é»˜è®¤æ–‡ä»¶é…ç½®
const DEFAULT_FILE_CONFIG: FileConfig = {
  defaultStorageLocation: StorageLocation.INTERNAL,
  maxCacheSize: 512 * 1024 * 1024, // 512MB
  maxTempFileSize: 100 * 1024 * 1024, // 100MB
  enableAutoCleanup: true,
  cleanupInterval: 3600000, // 1å°æ—¶
  thumbnailCacheSize: 100 * 1024 * 1024, // 100MB
  tempDir: 'temp',
  cacheDir: 'cache',
  downloadDir: 'downloads',
  uploadDir: 'uploads',
  documentDir: 'documents',
  imageDir: 'images',
  videoDir: 'videos',
  audioDir: 'audio',
  subtitleDir: 'subtitles',
  enableFileWatcher: false,
  fileWatcherInterval: 5000,
  supportedFormats: {
    [FileType.VIDEO]: [
      FileFormat.MP4, FileFormat.AVI, FileFormat.MKV, FileFormat.FLV, 
      FileFormat.WMV, FileFormat.MOV, FileFormat.WEBM, FileFormat.TS,
      FileFormat.MPG, FileFormat.MPEG, FileFormat.VOB, FileFormat.RMVB,
      FileFormat.M4V
    ],
    [FileType.AUDIO]: [
      FileFormat.MP3, FileFormat.WAV, FileFormat.FLAC, FileFormat.AAC,
      FileFormat.OGG, FileFormat.WMA, FileFormat.OPUS, FileFormat.M4A
    ],
    [FileType.IMAGE]: [
      FileFormat.JPG, FileFormat.JPEG, FileFormat.PNG, FileFormat.GIF,
      FileFormat.WEBP, FileFormat.SVG, FileFormat.BMP, FileFormat.TIFF,
      FileFormat.HEIC
    ],
    [FileType.SUBTITLE]: [
      FileFormat.SRT, FileFormat.VTT, FileFormat.ASS, FileFormat.SSA,
      FileFormat.TTML, FileFormat.DFXP, FileFormat.SBV, FileFormat.LRC
    ],
    [FileType.DOCUMENT]: [
      FileFormat.TXT, FileFormat.PDF, FileFormat.DOC, FileFormat.DOCX,
      FileFormat.XLS, FileFormat.XLSX, FileFormat.PPT, FileFormat.PPTX,
      FileFormat.MD, FileFormat.HTML, FileFormat.XML, FileFormat.JSON
    ],
    [FileType.ARCHIVE]: [
      FileFormat.ZIP, FileFormat.RAR, FileFormat['7Z'], FileFormat.TAR,
      FileFormat.GZIP, FileFormat.BZIP2, FileFormat.ISO
    ]
  },
  chunkSize: 1024 * 1024, // 1MB
  maxConcurrentOperations: 5,
  verifyFileIntegrity: true
};

/**
 * æ–‡ä»¶æœåŠ¡ç±? * è´Ÿè´£ç®¡ç†æ–‡ä»¶æ“ä½œã€å­˜å‚¨è·¯å¾„ã€æ–‡ä»¶æ ¼å¼è½¬æ¢ç­‰åŠŸèƒ½
 */
export default class FileService {
  private static instance: FileService;
  
  private fileConfig: FileConfig = { ...DEFAULT_FILE_CONFIG };
  private storageDevices: Map<string, StorageDeviceInfo> = new Map();
  private transferTasks: Map<string, FileTransferProgress> = new Map();
  private activeOperations: Set<string> = new Set();
  private fileWatchers: Map<string, number> = new Map();
  
  // ç›‘å¬å™?  private transferListeners: Map<string, Array<(progress: FileTransferProgress) => void>> = new Map();
  private storageListeners: Array<(devices: StorageDeviceInfo[]) => void> = [];
  private cleanupListeners: Array<(deletedCount: number, freedSpace: number) => void> = [];
  
  private cleanupTimer?: number;
  private isInitialized: boolean = false;

  /**
   * æ„é€ å‡½æ•°ï¼ˆç§æœ‰ï¼Œé˜²æ­¢å¤–éƒ¨å®ä¾‹åŒ–ï¼?   */
  private constructor() {
    this.initialize();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): FileService {
    if (!FileService.instance) {
      FileService.instance = new FileService();
    }
    return FileService.instance;
  }
  
  /**
   * æ£€æŸ¥å¯¹è±¡æ˜¯å¦åŒ…å«æŒ‡å®šå±æ€?   * æ›¿ä»£Object.prototype.hasOwnProperty.callï¼Œå…¼å®¹ArkTSè¯­æ³•
   */
  private hasOwnProperty<T extends object>(obj: T, key: string): boolean {
    return Object.getOwnPropertyNames(obj).includes(key);
  }

  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰å€?   * æ›¿ä»£Object.valuesï¼Œå…¼å®¹ArkTSè¯­æ³•
   */
  private getObjectValues<T extends object>(obj: T): T[keyof T][] {
    const values: T[keyof T][] = [];
    for (const key in obj) {
      if (this.hasOwnProperty(obj, key)) {
        values.push(obj[key]);
      }
    }
    return values;
  }

  /**
   * åˆå§‹åŒ–æ–‡ä»¶æœåŠ?   */
  public async initialize(): Promise<void> {
    try {
      Logger.info(TAG, 'Initializing file service...');
      
      // åŠ è½½æ–‡ä»¶é…ç½®
      const savedConfig = await StorageUtil.getObject<FileConfig>(FILE_CONFIG_KEY);
      if (savedConfig) {
        this.fileConfig = { ...DEFAULT_FILE_CONFIG, ...savedConfig };
      }
      
      // åˆ›å»ºå¿…è¦çš„ç›®å½•ç»“æ?      await this.createDirectoryStructure();
      
      // æ‰«æå­˜å‚¨è®¾å¤‡
      await this.scanStorageDevices();
      
      // å¯åŠ¨è‡ªåŠ¨æ¸…ç†
      if (this.fileConfig.enableAutoCleanup) {
        this.startAutoCleanup();
      }
      
      // å¯åŠ¨æ–‡ä»¶ç›‘æ§ï¼ˆå¦‚æœå¯ç”¨ï¼‰
      if (this.fileConfig.enableFileWatcher) {
        this.startFileWatchers();
      }
      
      this.isInitialized = true;
      Logger.info(TAG, 'File service initialized successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to initialize file service', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * åˆ›å»ºç›®å½•ç»“æ„
   */
  private async createDirectoryStructure(): Promise<void> {
    try {
      const dirs = [
        this.fileConfig.tempDir,
        this.fileConfig.cacheDir,
        this.fileConfig.downloadDir,
        this.fileConfig.uploadDir,
        this.fileConfig.documentDir,
        this.fileConfig.imageDir,
        this.fileConfig.videoDir,
        this.fileConfig.audioDir,
        this.fileConfig.subtitleDir
      ];
      
      for (const dir of dirs) {
        await FileUtil.ensureDirectory(dir);
        Logger.debug(TAG, `Created directory: ${dir}`);
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to create directory structure', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * æ‰«æå­˜å‚¨è®¾å¤‡
   */
  private async scanStorageDevices(): Promise<void> {
    try {
      // å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä½¿ç”¨ç³»ç»ŸAPIæ‰«æå­˜å‚¨è®¾å¤‡
      // è¿™é‡Œç®€åŒ–ä¸ºæ¨¡æ‹Ÿå®ç°
      const devices: StorageDeviceInfo[] = [
        {
          id: 'internal',
          name: 'å†…éƒ¨å­˜å‚¨',
          path: '/',
          type: StorageLocation.INTERNAL,
          totalSize: 50 * 1024 * 1024 * 1024, // 50GB
          availableSize: 20 * 1024 * 1024 * 1024, // 20GB
          usedSize: 30 * 1024 * 1024 * 1024, // 30GB
          isRemovable: false,
          isReadOnly: false,
          mountPoint: '/',
          fileSystem: 'ext4',
          model: 'Internal Storage',
          serialNumber: 'N/A'
        }
      ];
      
      // æ¸…ç©ºç°æœ‰è®¾å¤‡
      this.storageDevices.clear();
      
      // æ·»åŠ è®¾å¤‡
      for (const device of devices) {
        this.storageDevices.set(device.id, device);
      }
      
      // é€šçŸ¥ç›‘å¬å™?      this.notifyStorageDevicesChanged();
      
      Logger.info(TAG, `Scanned ${devices.length} storage devices`);
    } catch (error) {
      Logger.error(TAG, 'Failed to scan storage devices', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * ä¿å­˜æ–‡ä»¶é…ç½®
   */
  private async saveFileConfig(): Promise<void> {
    try {
      await StorageUtil.setObject(FILE_CONFIG_KEY, this.fileConfig);
      Logger.debug(TAG, 'Saved file config');
    } catch (error) {
      Logger.error(TAG, 'Failed to save file config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * è®¾ç½®æ–‡ä»¶é…ç½®
   */
  public async setFileConfig(config: Partial<FileConfig>): Promise<FileConfig> {
    try {
      // æ›´æ–°é…ç½®
      this.fileConfig = {
        ...this.fileConfig,
        ...config
      };
      
      // ä¿å­˜é…ç½®
      await this.saveFileConfig();
      
      // é‡æ–°åˆ›å»ºç›®å½•ï¼ˆå¦‚æœç›®å½•é…ç½®å˜æ›´ï¼‰
      if (config.tempDir || config.cacheDir || config.downloadDir || 
          config.uploadDir || config.documentDir || config.imageDir || 
          config.videoDir || config.audioDir || config.subtitleDir) {
        await this.createDirectoryStructure();
      }
      
      // é‡å¯è‡ªåŠ¨æ¸…ç†ï¼ˆå¦‚æœé…ç½®å˜æ›´ï¼‰
      if (config.enableAutoCleanup !== undefined || config.cleanupInterval !== undefined) {
        this.stopAutoCleanup();
        if (this.fileConfig.enableAutoCleanup) {
          this.startAutoCleanup();
        }
      }
      
      // é‡å¯æ–‡ä»¶ç›‘æ§ï¼ˆå¦‚æœé…ç½®å˜æ›´ï¼‰
      if (config.enableFileWatcher !== undefined || config.fileWatcherInterval !== undefined) {
        this.stopFileWatchers();
        if (this.fileConfig.enableFileWatcher) {
          this.startFileWatchers();
        }
      }
      
      Logger.info(TAG, 'Updated file config');
      return { ...this.fileConfig };
    } catch (error) {
      Logger.error(TAG, 'Failed to update file config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return { ...this.fileConfig };
    }
  }

  /**
   * è·å–æ–‡ä»¶é…ç½®
   */
  public getFileConfig(): FileConfig {
    return { ...this.fileConfig };
  }

  /**
   * é‡ç½®æ–‡ä»¶é…ç½®ä¸ºé»˜è®¤å€?   */
  public async resetFileConfig(): Promise<FileConfig> {
    try {
      this.fileConfig = { ...DEFAULT_FILE_CONFIG };
      
      // ä¿å­˜é…ç½®
      await this.saveFileConfig();
      
      // é‡æ–°åˆ›å»ºç›®å½•ç»“æ„
      await this.createDirectoryStructure();
      
      // é‡å¯è‡ªåŠ¨æ¸…ç†
      this.stopAutoCleanup();
      if (this.fileConfig.enableAutoCleanup) {
        this.startAutoCleanup();
      }
      
      // é‡å¯æ–‡ä»¶ç›‘æ§
      this.stopFileWatchers();
      if (this.fileConfig.enableFileWatcher) {
        this.startFileWatchers();
      }
      
      Logger.info(TAG, 'Reset file config to default');
      return { ...this.fileConfig };
    } catch (error) {
      Logger.error(TAG, 'Failed to reset file config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return { ...this.fileConfig };
    }
  }

  /**
   * å¼€å§‹è‡ªåŠ¨æ¸…ç?   */
  private startAutoCleanup(): void {
    try {
      this.stopAutoCleanup();
      
      this.cleanupTimer = setInterval(() => {
        this.performAutoCleanup();
      }, this.fileConfig.cleanupInterval);
      
      Logger.debug(TAG, `Started auto cleanup, interval: ${this.fileConfig.cleanupInterval}ms`);
    } catch (error) {
      Logger.error(TAG, 'Failed to start auto cleanup', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * åœæ­¢è‡ªåŠ¨æ¸…ç†
   */
  private stopAutoCleanup(): void {
    try {
      if (this.cleanupTimer) {
        clearInterval(this.cleanupTimer);
        this.cleanupTimer = undefined;
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to stop auto cleanup', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * æ‰§è¡Œè‡ªåŠ¨æ¸…ç†
   */
  private async performAutoCleanup(): Promise<void> {
    try {
      Logger.info(TAG, 'Performing auto cleanup...');
      
      let deletedCount = 0;
      let freedSpace = 0;
      
      // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      const tempCleanup = await this.cleanupDirectory(
        this.fileConfig.tempDir,
        TEMP_FILE_EXPIRY
      );
      deletedCount += tempCleanup.deletedCount;
      freedSpace += tempCleanup.freedSpace;
      
      // æ¸…ç†ç¼©ç•¥å›¾ç¼“å­?      const thumbCleanup = await this.cleanupDirectory(
        `${this.fileConfig.cacheDir}/thumbnails`,
        THUMBNAIL_CACHE_EXPIRY
      );
      deletedCount += thumbCleanup.deletedCount;
      freedSpace += thumbCleanup.freedSpace;
      
      // æ£€æŸ¥ç¼“å­˜ç›®å½•å¤§å°?      const cacheStats = await FileUtil.getDirectoryStats(this.fileConfig.cacheDir);
      if (cacheStats && cacheStats.totalSize > this.fileConfig.maxCacheSize) {
        const toDelete = cacheStats.totalSize - this.fileConfig.maxCacheSize;
        const cacheCleanup = await this.cleanupDirectoryBySize(
          this.fileConfig.cacheDir,
          toDelete
        );
        deletedCount += cacheCleanup.deletedCount;
        freedSpace += cacheCleanup.freedSpace;
      }
      
      // æ£€æŸ¥ä¸´æ—¶ç›®å½•å¤§å°?      const tempStats = await FileUtil.getDirectoryStats(this.fileConfig.tempDir);
      if (tempStats && tempStats.totalSize > this.fileConfig.maxTempFileSize) {
        const toDelete = tempStats.totalSize - this.fileConfig.maxTempFileSize;
        const tempSizeCleanup = await this.cleanupDirectoryBySize(
          this.fileConfig.tempDir,
          toDelete
        );
        deletedCount += tempSizeCleanup.deletedCount;
        freedSpace += tempSizeCleanup.freedSpace;
      }
      
      // é€šçŸ¥æ¸…ç†å®Œæˆ
      if (deletedCount > 0) {
        this.notifyCleanupCompleted(deletedCount, freedSpace);
      }
      
      Logger.info(TAG, `Auto cleanup completed: ${deletedCount} files deleted, ${this.formatSize(freedSpace)} freed`);
    } catch (error) {
      Logger.error(TAG, 'Failed to perform auto cleanup', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * æ¸…ç†ç›®å½•ä¸­è¿‡æœŸçš„æ–‡ä»¶
   */
  private async cleanupDirectory(
    directory: string,
    expiryTime: number
  ): Promise<{ deletedCount: number; freedSpace: number }> {
    try {
      const now = Date.now();
      const files = await FileUtil.readDirectory(directory, true);
      
      let deletedCount = 0;
      let freedSpace = 0;
      
      for (const file of files) {
        if (!file.isDirectory && file.modifiedAt && (now - file.modifiedAt > expiryTime)) {
          try {
            const stats = await FileUtil.getFileStats(file.path);
            await FileUtil.deleteFile(file.path);
            deletedCount++;
            freedSpace += stats?.size || 0;
          } catch (error) {
            Logger.warn(TAG, `Failed to delete expired file: ${file.path}`, error);
          }
        }
      }
      
      return { deletedCount, freedSpace };
    } catch (error) {
      Logger.error(TAG, `Failed to cleanup directory: ${directory}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return { deletedCount: 0, freedSpace: 0 };
    }
  }

  /**
   * æŒ‰å¤§å°æ¸…ç†ç›®å½?   */
  private async cleanupDirectoryBySize(
    directory: string,
    bytesToDelete: number
  ): Promise<{ deletedCount: number; freedSpace: number }> {
    try {
      // è·å–æ‰€æœ‰æ–‡ä»¶å¹¶æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼ˆæœ€æ—§çš„å…ˆåˆ é™¤ï¼‰
      const files = await FileUtil.readDirectory(directory, true);
      const fileList = files
        .filter(file => !file.isDirectory && file.modifiedAt)
        .sort((a, b) => (a.modifiedAt || 0) - (b.modifiedAt || 0));
      
      let deletedCount = 0;
      let freedSpace = 0;
      
      for (const file of fileList) {
        if (freedSpace >= bytesToDelete) {
          break;
        }
        
        try {
          const stats = await FileUtil.getFileStats(file.path);
          await FileUtil.deleteFile(file.path);
          deletedCount++;
          freedSpace += stats?.size || 0;
        } catch (error) {
          Logger.warn(TAG, `Failed to delete file by size: ${file.path}`, error);
        }
      }
      
      return { deletedCount, freedSpace };
    } catch (error) {
      Logger.error(TAG, `Failed to cleanup directory by size: ${directory}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return { deletedCount: 0, freedSpace: 0 };
    }
  }

  /**
   * å¼€å§‹æ–‡ä»¶ç›‘æ?   */
  private startFileWatchers(): void {
    try {
      // å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä¸ºé‡è¦ç›®å½•æ·»åŠ æ–‡ä»¶ç›‘æ?      Logger.debug(TAG, 'Started file watchers');
    } catch (error) {
      Logger.error(TAG, 'Failed to start file watchers', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * åœæ­¢æ–‡ä»¶ç›‘æ§
   */
  private stopFileWatchers(): void {
    try {
      // æ¸…é™¤æ‰€æœ‰å®šæ—¶å™¨
      for (const [, timer] of this.fileWatchers) {
        clearInterval(timer);
      }
      this.fileWatchers.clear();
    } catch (error) {
      Logger.error(TAG, 'Failed to stop file watchers', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * è·å–å­˜å‚¨è®¾å¤‡ä¿¡æ¯
   */
  public async getStorageDevices(): Promise<StorageDeviceInfo[]> {
    if (!this.isInitialized) {
      await this.initialize();
    }
    
    return Array.from(this.storageDevices.values());
  }

  /**
   * è·å–å­˜å‚¨è®¾å¤‡ä¿¡æ¯
   */
  public async getStorageDevice(deviceId: string): Promise<StorageDeviceInfo | undefined> {
    if (!this.isInitialized) {
      await this.initialize();
    }
    
    return this.storageDevices.get(deviceId);
  }

  /**
   * è·å–æ–‡ä»¶ä¿¡æ¯
   */
  public async getFileInfo(filePath: string): Promise<ExtendedFileInfo | null> {
    try {
      const fileInfo = await FileUtil.getFileInfo(filePath);
      if (!fileInfo) {
        return null;
      }
      
      // æ‰©å±•æ–‡ä»¶ä¿¡æ¯
      const extendedInfo: ExtendedFileInfo = {
        ...fileInfo,
        type: this.getFileType(filePath),
        format: this.getFileFormat(filePath),
        storageLocation: this.getStorageLocation(filePath),
        permissions: await this.getFilePermissions(filePath),
        createdAt: fileInfo.createdAt || Date.now(),
        modifiedAt: fileInfo.modifiedAt || Date.now(),
        accessedAt: fileInfo.accessedAt || Date.now()
      };
      
      // å¯¹äºåª’ä½“æ–‡ä»¶ï¼Œå°è¯•è·å–æ›´å¤šä¿¡æ?      if (extendedInfo.type === FileType.VIDEO || extendedInfo.type === FileType.AUDIO) {
        // å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä½¿ç”¨åª’ä½“è§£æåº“è·å–è¯¦ç»†ä¿¡æ?        // è¿™é‡Œç®€åŒ–ä¸ºæ¨¡æ‹Ÿæ•°æ®
      }
      
      // å¯¹äºå›¾åƒæ–‡ä»¶ï¼Œå°è¯•è·å–å°ºå¯¸ä¿¡æ?      if (extendedInfo.type === FileType.IMAGE) {
        // å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä½¿ç”¨å›¾åƒè§£æåº“è·å–å°ºå¯?        // è¿™é‡Œç®€åŒ–ä¸ºæ¨¡æ‹Ÿæ•°æ®
      }
      
      return extendedInfo;
    } catch (error) {
      Logger.error(TAG, `Failed to get file info: ${filePath}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return null;
    }
  }

  /**
   * è·å–æ–‡ä»¶ç±»å‹
   */
  public getFileType(filePath: string): FileType {
    const extension = FileUtil.getExtension(filePath).toLowerCase();
    
    // è§†é¢‘ç±»å‹
    if ([
      'mp4', 'avi', 'mkv', 'flv', 'wmv', 'mov', 'webm', 'ts',
      'mpg', 'mpeg', 'vob', 'rmvb', 'm4v'
    ].includes(extension)) {
      return FileType.VIDEO;
    }
    
    // éŸ³é¢‘ç±»å‹
    if ([
      'mp3', 'wav', 'flac', 'aac', 'ogg', 'wma', 'opus', 'm4a'
    ].includes(extension)) {
      return FileType.AUDIO;
    }
    
    // å›¾åƒç±»å‹
    if ([
      'jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'bmp', 'tiff', 'heic'
    ].includes(extension)) {
      return FileType.IMAGE;
    }
    
    // å­—å¹•ç±»å‹
    if ([
      'srt', 'vtt', 'ass', 'ssa', 'ttml', 'dfxp', 'sbv', 'lrc'
    ].includes(extension)) {
      return FileType.SUBTITLE;
    }
    
    // æ–‡æ¡£ç±»å‹
    if ([
      'txt', 'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx',
      'md', 'html', 'xml', 'json'
    ].includes(extension)) {
      return FileType.DOCUMENT;
    }
    
    // å‹ç¼©ç±»å‹
    if ([
      'zip', 'rar', '7z', 'tar', 'gzip', 'gz', 'bzip2', 'bz2', 'iso'
    ].includes(extension)) {
      return FileType.ARCHIVE;
    }
    
    // å¯æ‰§è¡Œç±»å?    if ([
      'exe', 'dll', 'so', 'dylib', 'apk'
    ].includes(extension)) {
      return FileType.EXECUTABLE;
    }
    
    return FileType.UNKNOWN;
  }

  /**
   * è·å–æ–‡ä»¶æ ¼å¼
   */
  public getFileFormat(filePath: string): FileFormat {
    const extension = FileUtil.getExtension(filePath).toLowerCase();
    
    // å°è¯•å°†æ‰©å±•åè½¬æ¢ä¸ºæšä¸¾å€?    const format = this.getObjectValues(FileFormat).find(f => f.toLowerCase() === extension);
    return format || FileFormat.UNKNOWN;
  }

  /**
   * è·å–å­˜å‚¨ä½ç½®
   */
  public getStorageLocation(filePath: string): StorageLocation {
    // å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥æ ¹æ®æ–‡ä»¶è·¯å¾„åˆ¤æ–­å­˜å‚¨ä½ç½®
    // è¿™é‡Œç®€åŒ–ä¸ºé»˜è®¤è¿”å›å†…éƒ¨å­˜å‚¨
    return StorageLocation.INTERNAL;
  }

  /**
   * è·å–æ–‡ä»¶æƒé™
   */
  public async getFilePermissions(filePath: string): Promise<FilePermission[]> {
    try {
      // å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä½¿ç”¨ç³»ç»ŸAPIè·å–æ–‡ä»¶æƒé™
      // è¿™é‡Œç®€åŒ–ä¸ºè¿”å›é»˜è®¤æƒé™
      const exists = await FileUtil.fileExists(filePath);
      if (!exists) {
        return [FilePermission.NONE];
      }
      
      const canRead = await FileUtil.canRead(filePath);
      const canWrite = await FileUtil.canWrite(filePath);
      const canExecute = await FileUtil.canExecute(filePath);
      
      const permissions: FilePermission[] = [];
      if (canRead) permissions.push(FilePermission.READ);
      if (canWrite) permissions.push(FilePermission.WRITE);
      if (canExecute) permissions.push(FilePermission.EXECUTE);
      
      if (canRead && canWrite && canExecute) {
        permissions.push(FilePermission.ALL);
      }
      
      return permissions;
    } catch (error) {
      Logger.error(TAG, `Failed to get file permissions: ${filePath}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return [FilePermission.NONE];
    }
  }

  /**
   * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æ”¯æŒ?   */
  public isFileSupported(filePath: string): boolean {
    const type = this.getFileType(filePath);
    const format = this.getFileFormat(filePath);
    
    if (type === FileType.UNKNOWN || format === FileFormat.UNKNOWN) {
      return false;
    }
    
    const supportedFormats = this.fileConfig.supportedFormats[type];
    return supportedFormats ? supportedFormats.includes(format) : false;
  }

  /**
   * æœç´¢æ–‡ä»¶
   */
  public async searchFiles(params: FileSearchParams): Promise<ExtendedFileInfo[]> {
    try {
      // éªŒè¯è·¯å¾„
      const pathExists = await FileUtil.directoryExists(params.path);
      if (!pathExists) {
        Logger.warn(TAG, `Search path does not exist: ${params.path}`);
        return [];
      }
      
      // è¯»å–ç›®å½•
      const files = await FileUtil.readDirectory(params.path, params.recursive || false);
      
      // è¿‡æ»¤æ–‡ä»¶
      let filteredFiles = files.filter(file => !file.isDirectory);
      
      // åº”ç”¨è¿‡æ»¤å™?      if (params.types && params.types.length > 0) {
        filteredFiles = filteredFiles.filter(file => 
          params.types!.includes(this.getFileType(file.path))
        );
      }
      
      if (params.formats && params.formats.length > 0) {
        filteredFiles = filteredFiles.filter(file => {
          const format = this.getFileFormat(file.path);
          return params.formats!.includes(format);
        });
      }
      
      if (params.minSize !== undefined) {
        filteredFiles = filteredFiles.filter(file => 
          (file.size || 0) >= params.minSize!
        );
      }
      
      if (params.maxSize !== undefined) {
        filteredFiles = filteredFiles.filter(file => 
          (file.size || 0) <= params.maxSize!
        );
      }
      
      if (params.minDate !== undefined) {
        filteredFiles = filteredFiles.filter(file => 
          (file.modifiedAt || 0) >= params.minDate!
        );
      }
      
      if (params.maxDate !== undefined) {
        filteredFiles = filteredFiles.filter(file => 
          (file.modifiedAt || 0) <= params.maxDate!
        );
      }
      
      if (params.pattern) {
        // ä¸ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ”¹ç”¨å­—ç¬¦ä¸²æ–¹æ³•å®ç°å¤§å°å†™ä¸æ•æ„Ÿçš„åŒ¹é…?        const searchPattern = params.pattern.toLowerCase();
        filteredFiles = filteredFiles.filter(file => 
          file.name.toLowerCase().indexOf(searchPattern) !== -1
        );
      }
      
      // æ’åº
      if (params.sortBy && params.sortBy !== FileSortBy.NONE) {
        filteredFiles.sort((a, b) => {
          let compareResult = 0;
          
          switch (params.sortBy) {
            case FileSortBy.NAME:
              compareResult = a.name.localeCompare(b.name);
              break;
            case FileSortBy.SIZE:
              compareResult = (a.size || 0) - (b.size || 0);
              break;
            case FileSortBy.DATE:
              compareResult = (a.modifiedAt || 0) - (b.modifiedAt || 0);
              break;
            case FileSortBy.TYPE:
              compareResult = this.getFileType(a.path).localeCompare(this.getFileType(b.path));
              break;
            case FileSortBy.EXTENSION:
              const extA = FileUtil.getExtension(a.path).toLowerCase();
              const extB = FileUtil.getExtension(b.path).toLowerCase();
              compareResult = extA.localeCompare(extB);
              break;
          }
          
          // åº”ç”¨æ’åºæ–¹å‘
          if (params.sortDirection === FileSortDirection.DESCENDING) {
            compareResult = -compareResult;
          }
          
          return compareResult;
        });
      }
      
      // åˆ†é¡µ
      if (params.offset !== undefined) {
        filteredFiles = filteredFiles.slice(params.offset);
      }
      
      if (params.limit !== undefined) {
        filteredFiles = filteredFiles.slice(0, params.limit);
      }
      
      // è½¬æ¢ä¸ºæ‰©å±•ä¿¡æ?      const result: ExtendedFileInfo[] = [];
      for (const file of filteredFiles) {
        const info = await this.getFileInfo(file.path);
        if (info) {
          result.push(info);
        }
      }
      
      Logger.info(TAG, `Found ${result.length} files matching search criteria`);
      return result;
    } catch (error) {
      Logger.error(TAG, 'Failed to search files', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return [];
    }
  }

  /**
   * åˆ›å»ºä¸´æ—¶æ–‡ä»¶
   */
  public async createTempFile(prefix?: string, extension?: string): Promise<string | null> {
    try {
      const tempPath = this.fileConfig.tempDir;
      const fileName = `${prefix || 'temp'}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}${extension ? '.' + extension : ''}`;
      const filePath = `${tempPath}/${fileName}`;
      
      await FileUtil.writeFile(filePath, '', { create: true });
      
      Logger.debug(TAG, `Created temporary file: ${filePath}`);
      return filePath;
    } catch (error) {
      Logger.error(TAG, 'Failed to create temporary file', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return null;
    }
  }

  /**
   * åˆ›å»ºç›®å½•
   */
  public async createDirectory(path: string, recursive: boolean = true): Promise<FileOperationResult> {
    try {
      await FileUtil.ensureDirectory(path);
      
      Logger.debug(TAG, `Created directory: ${path}`);
      return {
        success: true,
        path
      };
    } catch (error) {
      Logger.error(TAG, `Failed to create directory: ${path}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * åˆ é™¤æ–‡ä»¶
   */
  public async deleteFile(filePath: string): Promise<FileOperationResult> {
    try {
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ?      const exists = await FileUtil.fileExists(filePath);
      if (!exists) {
        return {
          success: false,
          error: 'File does not exist'
        };
      }
      
      await FileUtil.deleteFile(filePath);
      
      Logger.debug(TAG, `Deleted file: ${filePath}`);
      return {
        success: true,
        path: filePath
      };
    } catch (error) {
      Logger.error(TAG, `Failed to delete file: ${filePath}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * åˆ é™¤ç›®å½•
   */
  public async deleteDirectory(path: string, recursive: boolean = false): Promise<FileOperationResult> {
    try {
      // æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ?      const exists = await FileUtil.directoryExists(path);
      if (!exists) {
        return {
          success: false,
          error: 'Directory does not exist'
        };
      }
      
      await FileUtil.deleteDirectory(path, recursive);
      
      Logger.debug(TAG, `Deleted directory: ${path}${recursive ? ' (recursive)' : ''}`);
      return {
        success: true,
        path
      };
    } catch (error) {
      Logger.error(TAG, `Failed to delete directory: ${path}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * å¤åˆ¶æ–‡ä»¶
   */
  public async copyFile(source: string, destination: string): Promise<FileOperationResult> {
    try {
      // æ£€æŸ¥æºæ–‡ä»¶æ˜¯å¦å­˜åœ¨
      const sourceExists = await FileUtil.fileExists(source);
      if (!sourceExists) {
        return {
          success: false,
          error: 'Source file does not exist'
        };
      }
      
      // åˆ›å»ºç›®æ ‡ç›®å½•
      const destDir = FileUtil.getDirectory(destination);
      await FileUtil.ensureDirectory(destDir);
      
      // å¤åˆ¶æ–‡ä»¶
      await FileUtil.copyFile(source, destination);
      
      Logger.debug(TAG, `Copied file from ${source} to ${destination}`);
      return {
        success: true,
        path: destination
      };
    } catch (error) {
      Logger.error(TAG, `Failed to copy file from ${source} to ${destination}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * ç§»åŠ¨æ–‡ä»¶
   */
  public async moveFile(source: string, destination: string): Promise<FileOperationResult> {
    try {
      // æ£€æŸ¥æºæ–‡ä»¶æ˜¯å¦å­˜åœ¨
      const sourceExists = await FileUtil.fileExists(source);
      if (!sourceExists) {
        return {
          success: false,
          error: 'Source file does not exist'
        };
      }
      
      // åˆ›å»ºç›®æ ‡ç›®å½•
      const destDir = FileUtil.getDirectory(destination);
      await FileUtil.ensureDirectory(destDir);
      
      // ç§»åŠ¨æ–‡ä»¶
      await FileUtil.moveFile(source, destination);
      
      Logger.debug(TAG, `Moved file from ${source} to ${destination}`);
      return {
        success: true,
        path: destination
      };
    } catch (error) {
      Logger.error(TAG, `Failed to move file from ${source} to ${destination}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * é‡å‘½åæ–‡ä»?   */
  public async renameFile(filePath: string, newName: string): Promise<FileOperationResult> {
    try {
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ?      const exists = await FileUtil.fileExists(filePath);
      if (!exists) {
        return {
          success: false,
          error: 'File does not exist'
        };
      }
      
      // è·å–ç›®å½•è·¯å¾„
      const directory = FileUtil.getDirectory(filePath);
      const newPath = `${directory}/${newName}`;
      
      // é‡å‘½åæ–‡ä»?      await FileUtil.moveFile(filePath, newPath);
      
      Logger.debug(TAG, `Renamed file from ${filePath} to ${newPath}`);
      return {
        success: true,
        path: newPath
      };
    } catch (error) {
      Logger.error(TAG, `Failed to rename file: ${filePath} to ${newName}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * è¯»å–æ–‡ä»¶å†…å®¹
   */
  public async readFile(filePath: string, encoding: string = 'utf-8'): Promise<string | null> {
    try {
      const content = await FileUtil.readFile(filePath, encoding);
      return content;
    } catch (error) {
      Logger.error(TAG, `Failed to read file: ${filePath}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return null;
    }
  }

  /**
   * å†™å…¥æ–‡ä»¶å†…å®¹
   */
  public async writeFile(
    filePath: string,
    content: string | ArrayBuffer,
    options?: { create?: boolean; append?: boolean }
  ): Promise<FileOperationResult> {
    try {
      // åˆ›å»ºç›®å½•ï¼ˆå¦‚æœéœ€è¦ï¼‰
      if (options?.create) {
        const directory = FileUtil.getDirectory(filePath);
        await FileUtil.ensureDirectory(directory);
      }
      
      await FileUtil.writeFile(filePath, content, options);
      
      Logger.debug(TAG, `Wrote to file: ${filePath}`);
      return {
        success: true,
        path: filePath
      };
    } catch (error) {
      Logger.error(TAG, `Failed to write to file: ${filePath}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°æ˜¾ç¤?   */
  private formatSize(bytes: number): string {
    if (bytes < 1024) {
      return `${bytes} B`;
    } else if (bytes < 1024 * 1024) {
      return `${(bytes / 1024).toFixed(2)} KB`;
    } else if (bytes < 1024 * 1024 * 1024) {
      return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    } else {
      return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
    }
  }

  /**
   * è®¡ç®—æ–‡ä»¶æ ¡éªŒå’?   */
  public async calculateChecksum(filePath: string, algorithm: 'md5' | 'sha1' | 'sha256' = 'md5'): Promise<string | null> {
    try {
      // å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥è®¡ç®—æ–‡ä»¶çš„æ ¡éªŒå’Œ
      // è¿™é‡Œç®€åŒ–ä¸ºè¿”å›æ¨¡æ‹Ÿæ•°æ®
      Logger.debug(TAG, `Calculating ${algorithm} checksum for: ${filePath}`);
      return 'mock_checksum_value';
    } catch (error) {
      Logger.error(TAG, `Failed to calculate checksum for: ${filePath}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return null;
    }
  }

  /**
   * å‹ç¼©æ–‡ä»¶/ç›®å½•
   */
  public async compress(
    source: string,
    destination: string,
    format: 'zip' | 'tar' | 'gz' = 'zip'
  ): Promise<FileOperationResult> {
    try {
      // å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥å®ç°æ–‡ä»¶å‹ç¼©åŠŸèƒ½
      Logger.debug(TAG, `Compressing ${source} to ${destination} (format: ${format})`);
      
      // æ¨¡æ‹Ÿå‹ç¼©æ“ä½œ
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      return {
        success: true,
        path: destination,
        details: {
          format,
          source
        }
      };
    } catch (error) {
      Logger.error(TAG, `Failed to compress ${source}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * è§£å‹æ–‡ä»¶
   */
  public async decompress(
    source: string,
    destination: string
  ): Promise<FileOperationResult> {
    try {
      // å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥å®ç°æ–‡ä»¶è§£å‹åŠŸèƒ½
      Logger.debug(TAG, `Decompressing ${source} to ${destination}`);
      
      // æ¨¡æ‹Ÿè§£å‹æ“ä½œ
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      return {
        success: true,
        path: destination,
        details: {
          source
        }
      };
    } catch (error) {
      Logger.error(TAG, `Failed to decompress ${source}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * è·å–ç›®å½•ä¿¡æ¯
   */
  public async getDirectoryInfo(path: string): Promise<FolderInfo | null> {
    try {
      const stats = await FileUtil.getDirectoryStats(path);
      if (!stats) {
        return null;
      }
      
      const folderInfo: FolderInfo = {
        path,
        name: FileUtil.getFileName(path),
        parentPath: FileUtil.getDirectory(path),
        storageLocation: this.getStorageLocation(path),
        fileCount: stats.fileCount,
        folderCount: stats.directoryCount,
        totalSize: stats.totalSize,
        createdAt: Date.now(),
        modifiedAt: stats.modifiedAt || Date.now(),
        accessedAt: Date.now(),
        permissions: await this.getFilePermissions(path)
      };
      
      return folderInfo;
    } catch (error) {
      Logger.error(TAG, `Failed to get directory info: ${path}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return null;
    }
  }

  /**
   * è·å–ç›®å½•å†…å®¹
   */
  public async getDirectoryContent(
    path: string,
    sortBy: FileSortBy = FileSortBy.NAME,
    sortDirection: FileSortDirection = FileSortDirection.ASCENDING
  ): Promise<{ files: ExtendedFileInfo[]; folders: FolderInfo[] }> {
    try {
      const contents = await FileUtil.readDirectory(path, false);
      
      // åˆ†ç¦»æ–‡ä»¶å’Œç›®å½?      const fileList = contents.filter(item => !item.isDirectory);
      const folderList = contents.filter(item => item.isDirectory);
      
      // å¤„ç†æ–‡ä»¶ä¿¡æ¯
      const files: ExtendedFileInfo[] = [];
      for (const file of fileList) {
        const info = await this.getFileInfo(file.path);
        if (info) {
          files.push(info);
        }
      }
      
      // å¤„ç†ç›®å½•ä¿¡æ¯
      const folders: FolderInfo[] = [];
      for (const folder of folderList) {
        const info = await this.getDirectoryInfo(folder.path);
        if (info) {
          folders.push(info);
        }
      }
      
      // æ’åº
      if (sortBy !== FileSortBy.NONE) {
        // æ’åºé€»è¾‘...
      }
      
      Logger.debug(TAG, `Retrieved ${files.length} files and ${folders.length} folders from ${path}`);
      return { files, folders };
    } catch (error) {
      Logger.error(TAG, `Failed to get directory content: ${path}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return { files: [], folders: [] };
    }
  }

  /**
   * æ¸…ç†ä¸´æ—¶æ–‡ä»¶
   */
  public async cleanupTempFiles(): Promise<{ deletedCount: number; freedSpace: number }> {
    return this.cleanupDirectory(this.fileConfig.tempDir, 0);
  }

  /**
   * æ¸…ç†ç¼“å­˜æ–‡ä»¶
   */
  public async cleanupCache(): Promise<{ deletedCount: number; freedSpace: number }> {
    const result = await this.cleanupDirectory(this.fileConfig.cacheDir, 0);
    return result;
  }

  /**
   * æ·»åŠ å­˜å‚¨è®¾å¤‡å˜æ›´ç›‘å¬å™?   */
  public addStorageListener(listener: (devices: StorageDeviceInfo[]) => void): () => void {
    this.storageListeners.push(listener);
    
    // ç«‹å³å›è°ƒå½“å‰è®¾å¤‡åˆ—è¡¨
    listener(Array.from(this.storageDevices.values()));
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.storageListeners.indexOf(listener);
      if (index > -1) {
        this.storageListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ ä¼ è¾“è¿›åº¦ç›‘å¬å™?   */
  public addTransferListener(
    taskId: string,
    listener: (progress: FileTransferProgress) => void
  ): () => void {
    if (!this.transferListeners.has(taskId)) {
      this.transferListeners.set(taskId, []);
    }
    
    const listeners = this.transferListeners.get(taskId)!;
    listeners.push(listener);
    
    // ç«‹å³å›è°ƒå½“å‰è¿›åº¦
    const task = this.transferTasks.get(taskId);
    if (task) {
      listener({ ...task });
    }
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
      
      // å¦‚æœæ²¡æœ‰ç›‘å¬å™¨äº†ï¼Œæ¸…ç†Map
      if (listeners.length === 0) {
        this.transferListeners.delete(taskId);
      }
    };
  }

  /**
   * æ·»åŠ æ¸…ç†ç›‘å¬å™?   */
  public addCleanupListener(listener: (deletedCount: number, freedSpace: number) => void): () => void {
    this.cleanupListeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.cleanupListeners.indexOf(listener);
      if (index > -1) {
        this.cleanupListeners.splice(index, 1);
      }
    };
  }

  /**
   * é€šçŸ¥å­˜å‚¨è®¾å¤‡å˜æ›´
   */
  private notifyStorageDevicesChanged(): void {
    const devices = Array.from(this.storageDevices.values());
    for (const listener of this.storageListeners) {
      try {
        listener(devices);
      } catch (error) {
        Logger.error(TAG, 'Error in storage listener', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      }
    }
  }

  /**
   * é€šçŸ¥ä¼ è¾“è¿›åº¦å˜æ›´
   */
  private notifyTransferProgressChanged(task: FileTransferProgress): void {
    if (!this.transferListeners.has(task.id)) return;
    
    const listeners = this.transferListeners.get(task.id)!;
    for (const listener of listeners) {
      try {
        listener({ ...task });
      } catch (error) {
        Logger.error(TAG, `Error in transfer listener for task ${task.id}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      }
    }
  }

  /**
   * é€šçŸ¥æ¸…ç†å®Œæˆ
   */
  private notifyCleanupCompleted(deletedCount: number, freedSpace: number): void {
    for (const listener of this.cleanupListeners) {
      try {
        listener(deletedCount, freedSpace);
      } catch (error) {
        Logger.error(TAG, 'Error in cleanup listener', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      }
    }
  }

  /**
   * é”€æ¯æ–‡ä»¶æœåŠ?   */
  public async destroy(): Promise<void> {
    try {
      Logger.info(TAG, 'Destroying file service...');
      
      // åœæ­¢è‡ªåŠ¨æ¸…ç†
      this.stopAutoCleanup();
      
      // åœæ­¢æ–‡ä»¶ç›‘æ§
      this.stopFileWatchers();
      
      // æ¸…ç†ä¸´æ—¶æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
      if (this.fileConfig.enableAutoCleanup) {
        await this.cleanupTempFiles();
      }
      
      // æ¸…é™¤ç›‘å¬å™?      this.storageListeners = [];
      this.transferListeners.clear();
      this.cleanupListeners = [];
      
      // æ¸…é™¤ä»»åŠ¡
      this.transferTasks.clear();
      this.activeOperations.clear();
      
      Logger.info(TAG, 'File service destroyed successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to destroy file service', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }
}


