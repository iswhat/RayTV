// ConfigService - é…ç½®æœåŠ¡ç±?
import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import TypeSafetyUtil from '../../common/util/TypeSafetyUtil';
import RepositoryFactory from '../../data/repository/RepositoryFactory';
import DatabaseRepository from '../../data/repository/DatabaseRepository';
import ConfigParser from './ConfigParser';

// å¯¼å…¥æ¨¡å‹å’ŒDTO
import ApiResponse, { ResponseCode } from '../../data/dto/ApiResponse';

// å¸¸é‡å®šä¹‰
const TAG = 'ConfigService';

// é…ç½®é¡¹ç±»å‹å®šä¹?
export type ConfigKey = 
  | 'theme'
  | 'language'
  | 'videoQuality'
  | 'playbackSpeed'
  | 'autoPlay'
  | 'autoNextEpisode'
  | 'subtitleEnabled'
  | 'subtitleSize'
  | 'subtitleColor'
  | 'subtitleDelay'
  | 'interfaceScale'
  | 'cacheEnabled'
  | 'cacheLimit'
  | 'networkTimeout'
  | 'proxyEnabled'
  | 'proxyConfig'
  | 'notificationEnabled'
  | 'updateCheckEnabled'
  | 'crashReportingEnabled'
  | 'analyticsEnabled'
  | 'startupScreen'
  | 'homeLayout'
  | 'favoriteSort'
  | 'historySort'
  | 'searchSort'
  | 'maxConcurrentDownloads'
  | 'downloadNetworkType'
  | 'parentalControlEnabled'
  | 'parentalControlPin'
  | 'recentlyWatchedLimit'
  | 'dataSaverEnabled'
  | 'streamingEnabled'
  | 'localPlaybackEnabled'
  | 'showAdultContent'
  | 'defaultCategory'
  | 'preferredServer'
  | 'videoPlayerSettings'
  | 'uiAnimationEnabled'
  | 'backgroundPlayEnabled'
  | 'customHeaders'
  | 'customCookies';

// é…ç½®å€¼ç±»å‹å®šä¹?
export type ConfigValue = 
  | string
  | number
  | boolean
  | object
  | null;

// æ’­æ”¾å™¨é…ç½®æ¥å?
export interface PlayerConfig {
  defaultPlayer: string;
  autoPlay: boolean;
  rememberPosition: boolean;
  maxBufferSize: number;
  minBufferSize: number;
  preloadSeconds: number;
  enableHardwareDecoding: boolean;
  enableHDR: boolean;
  subtitleSize: number;
  subtitleColor: string;
  subtitleBackgroundColor: string;
  audioTrack: string;
  videoTrack: string;
}

// æ˜¾ç¤ºé…ç½®æ¥å£
export interface DisplayConfig {
  theme: string;
  fontScale: number;
  enableAnimations: boolean;
  enableBlur: boolean;
  autoRotate: boolean;
  resolution: string;
  screenSaverDelay: number;
  idleTimeout: number;
}

// ç½‘ç»œé…ç½®æ¥å£
export interface NetworkConfig {
  timeout: number;
  retryCount: number;
  retryDelay: number;
  enableCache: boolean;
  cacheSize: number;
  autoDetectNetwork: boolean;
  useProxy: boolean;
  proxyConfig: {
    type: string;
    host: string;
    port: number;
  };
}

// å­˜å‚¨é…ç½®æ¥å£
export interface StorageConfig {
  cachePath: string;
  downloadPath: string;
  maxCacheSize: number;
  autoClearCache: boolean;
  clearCacheInterval: number;
  enableBackgroundCleanup: boolean;
}

// é€šç”¨é…ç½®æ¥å£
export interface GeneralConfig {
  language: string;
  region: string;
  timeZone: string;
  enableAnalytics: boolean;
  enableUsageReport: boolean;
  firstLaunch: boolean;
  version: string;
  lastUpdated: number;
}

// å®‰å…¨é…ç½®æ¥å£
export interface SecurityConfig {
  enablePinCode: boolean;
  pinCode: string;
  enableBiometric: boolean;
  allowedApps: string[];
  lockTimeout: number;
  secureContentOnly: boolean;
}

// é€šçŸ¥é…ç½®æ¥å£
export interface NotificationConfig {
  enablePush: boolean;
  enableUpdateNotification: boolean;
  enableContentNotification: boolean;
  enableLiveReminder: boolean;
  notificationSound: string;
  notificationVolume: number;
}

// æ— éšœç¢é…ç½®æ¥å?
export interface AccessibilityConfig {
  enableHighContrast: boolean;
  enableScreenReader: boolean;
  textToSpeechRate: number;
  closedCaptionEnabled: boolean;
  audioDescriptionEnabled: boolean;
  hapticFeedbackEnabled: boolean;
}

// ç›´æ’­é…ç½®æ¥å£
export interface LiveConfig {
  epgEnabled: boolean;
  epgAutoUpdate: boolean;
  epgUpdateInterval: number;
  channelFavoritesEnabled: boolean;
  lastWatchedChannel: string;
  lastWatchedGroup: string;
}

// VODé…ç½®æ¥å£
export interface VodConfig {
  autoPlayNextEpisode: boolean;
  showRecommendedContent: boolean;
  contentRating: string;
  downloadQuality: string;
  streamingQuality: string;
}

// å®Œæ•´é…ç½®æ¥å£
export interface Config {
  player: PlayerConfig;
  display: DisplayConfig;
  network: NetworkConfig;
  storage: StorageConfig;
  general: GeneralConfig;
  security: SecurityConfig;
  notification: NotificationConfig;
  accessibility: AccessibilityConfig;
  live: LiveConfig;
  vod: VodConfig;
}

// é…ç½®é¡¹æ¥å?
export interface ConfigItem {
  key: ConfigKey;
  value: ConfigValue;
  description?: string;
  type: 'string' | 'number' | 'boolean' | 'object' | 'null';
  defaultValue: ConfigValue;
  category: string;
  options?: Array<{ label: string; value: ConfigValue }>;
  validation?: {
    min?: number;
    max?: number;
    pattern?: string;
    required?: boolean;
  };
  updatedAt: number;
  createdAt: number;
}

// å®Œæ•´é»˜è®¤é…ç½®
export const DEFAULT_FULL_CONFIG: Config = {
  player: {
    defaultPlayer: 'system',
    autoPlay: false,
    rememberPosition: true,
    maxBufferSize: 20,
    minBufferSize: 5,
    preloadSeconds: 30,
    enableHardwareDecoding: true,
    enableHDR: false,
    subtitleSize: 18,
    subtitleColor: '#FFFFFF',
    subtitleBackgroundColor: 'rgba(0, 0, 0, 0.5)',
    audioTrack: 'default',
    videoTrack: 'auto'
  },
  display: {
    theme: 'light',
    fontScale: 1.0,
    enableAnimations: true,
    enableBlur: true,
    autoRotate: true,
    resolution: 'auto',
    screenSaverDelay: 300,
    idleTimeout: 0
  },
  network: {
    timeout: 30000,
    retryCount: 3,
    retryDelay: 1000,
    enableCache: true,
    cacheSize: 500,
    autoDetectNetwork: true,
    useProxy: false,
    proxyConfig: {
      type: 'none',
      host: '',
      port: 0
    }
  },
  storage: {
    cachePath: '',
    downloadPath: '',
    maxCacheSize: 1024,
    autoClearCache: true,
    clearCacheInterval: 7,
    enableBackgroundCleanup: true
  },
  general: {
    language: 'zh-CN',
    region: 'CN',
    timeZone: 'Asia/Shanghai',
    enableAnalytics: true,
    enableUsageReport: false,
    firstLaunch: false,
    version: '1.0.0',
    lastUpdated: Date.now()
  },
  security: {
    enablePinCode: false,
    pinCode: '',
    enableBiometric: false,
    allowedApps: [],
    lockTimeout: 300,
    secureContentOnly: false
  },
  notification: {
    enablePush: true,
    enableUpdateNotification: true,
    enableContentNotification: false,
    enableLiveReminder: true,
    notificationSound: 'default',
    notificationVolume: 1.0
  },
  accessibility: {
    enableHighContrast: false,
    enableScreenReader: false,
    textToSpeechRate: 1.0,
    closedCaptionEnabled: true,
    audioDescriptionEnabled: false,
    hapticFeedbackEnabled: true
  },
  live: {
    epgEnabled: true,
    epgAutoUpdate: true,
    epgUpdateInterval: 3600,
    channelFavoritesEnabled: true,
    lastWatchedChannel: '',
    lastWatchedGroup: ''
  },
  vod: {
    autoPlayNextEpisode: true,
    showRecommendedContent: true,
    contentRating: 'all',
    downloadQuality: '720p',
    streamingQuality: 'auto'
  }
};

// é…ç½®é¡¹é»˜è®¤é…ç½?
export const DEFAULT_CONFIG: Record<ConfigKey, ConfigValue> = {
  // ç•Œé¢ç›¸å…³
  theme: 'dark',
  language: 'auto',
  interfaceScale: 100,
  uiAnimationEnabled: true,
  startupScreen: 'home',
  homeLayout: 'default',
  
  // è§†é¢‘æ’­æ”¾ç›¸å…³
  videoQuality: 'high',
  playbackSpeed: 1.0,
  autoPlay: true,
  autoNextEpisode: true,
  backgroundPlayEnabled: false,
  videoPlayerSettings: {},
  
  // å­—å¹•ç›¸å…³
  subtitleEnabled: true,
  subtitleSize: 16,
  subtitleColor: '#FFFFFF',
  subtitleDelay: 0,
  
  // ç¼“å­˜ç›¸å…³
  cacheEnabled: true,
  cacheLimit: 5000, // MB
  
  // ç½‘ç»œç›¸å…³
  networkTimeout: 30, // ç§?
  proxyEnabled: false,
  proxyConfig: null,
  dataSaverEnabled: false,
  customHeaders: {},
  customCookies: {},
  
  // é€šçŸ¥ç›¸å…³
  notificationEnabled: true,
  
  // æ›´æ–°ç›¸å…³
  updateCheckEnabled: true,
  
  // æ•°æ®æ”¶é›†ç›¸å…³
  crashReportingEnabled: false,
  analyticsEnabled: false,
  
  // æ’åºç›¸å…³
  favoriteSort: 'addedAt_desc',
  historySort: 'timestamp_desc',
  searchSort: 'relevance_desc',
  
  // ä¸‹è½½ç›¸å…³
  maxConcurrentDownloads: 3,
  downloadNetworkType: 'all', // all, wifi, cellular
  
  // å®¶é•¿æ§åˆ¶
  parentalControlEnabled: false,
  parentalControlPin: null,
  showAdultContent: false,
  
  // å…¶ä»–
  recentlyWatchedLimit: 20,
  streamingEnabled: true,
  localPlaybackEnabled: true,
  defaultCategory: 'all',
  preferredServer: 'auto'
};

// é…ç½®åˆ†ç±»
export const CONFIG_CATEGORIES: Record<string, string | number | boolean | null> = { ... };

/**
   * é…ç½®æœåŠ¡ç±?
   * è´Ÿè´£ç®¡ç†åº”ç”¨çš„å„ç§é…ç½®è®¾ç½?
   */
export default class ConfigService {
  private static instance: ConfigService;
  private databaseRepo: DatabaseRepository;
  private configCache: Map<ConfigKey, ConfigItem> = new Map();
  private configParser: ConfigParser;
  private fullConfig: Config = { ...DEFAULT_FULL_CONFIG };
  private isInitialized: boolean = false;

  /**
   * æ„é€ å‡½æ•°ï¼ˆç§æœ‰ï¼Œé˜²æ­¢å¤–éƒ¨å®ä¾‹åŒ–ï¼?
   */
  private constructor() {
    this.databaseRepo = RepositoryFactory.getRepository('database') as DatabaseRepository;
    this.configParser = new ConfigParser();
    this.initializeConfig();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): ConfigService {
    if (!ConfigService.instance) {
      ConfigService.instance = new ConfigService();
    }
    return ConfigService.instance;
  }

  /**
   * åˆå§‹åŒ–é…ç½®æœåŠ?
   */
  public async initialize(): Promise<void> {
    try {
      Logger.info(TAG, 'Initializing ConfigService...');
      
      // å¦‚æœå·²ç»åˆå§‹åŒ–ï¼Œç›´æ¥è¿”å›
      if (this.isInitialized) {
        Logger.info(TAG, 'ConfigService already initialized');
        return;
      }
      
      // è°ƒç”¨ç§æœ‰åˆå§‹åŒ–æ–¹æ³?
      await this.initializeConfig();
      
      Logger.info(TAG, 'ConfigService initialized successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to initialize ConfigService', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      throw error;
    }
  }
  
  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰é”®
   * æ›¿ä»£Object.keysï¼Œå…¼å®¹ArkTSè¯­æ³•
   */
  private getObjectKeys<T extends object>(obj: T): string[] {
    const keys: string[] = [];
    for (const key in obj) {
      if (Object.keys(obj).includes(key)) {
        keys.push(key);
      }
    }
    return keys;
  }
  
  /**
   * è·å–å®Œæ•´é…ç½®
   */
  public async getFullConfig(): Promise<Config> {
    if (!this.isInitialized) {
      await this.initializeConfig();
    }
    return { ...this.fullConfig };
  }
  
  /**
   * åˆå¹¶é…ç½®
   */
  private mergeConfig(defaultConfig: Config, customConfig: Partial<Config>): Config {
    // ä½¿ç”¨ArkTSå…¼å®¹çš„å¯¹è±¡åˆå¹¶æ–¹å¼?
    if (!customConfig || typeof customConfig !== 'object') {
      return defaultConfig;
    }
    
    const result: Record<string, string | number | boolean | null> = { ... };
    
    for (const key in customConfig) {
      if (Object.keys(customConfig).includes(key)) {
        const customValue = customConfig[key];
        const defaultValue = defaultConfig[key];
        
        // é€’å½’åˆå¹¶åµŒå¥—å¯¹è±¡
        if (customValue && typeof customValue === 'object' && defaultValue && typeof defaultValue === 'object') {
          (result as Record<string, any>)[key] = this.mergeConfig(defaultValue as Config, customValue as Partial<Config>);
        } else if (customValue !== undefined) {
          (result as Record<string, any>)[key] = customValue;
        }
      }
    }
    
    return result;
  }
  
  /**
   * ç¡®ä¿é»˜è®¤é…ç½®å­˜åœ¨
   */
  private ensureDefaultConfig(): void {
    // æ›´æ–°æœ€åæ›´æ–°æ—¶é—?
    this.fullConfig.general.lastUpdated = Date.now();
    
    // éªŒè¯å¿…è¦çš„é…ç½®é¡¹
    if (!this.fullConfig.player) {
      this.fullConfig.player = DEFAULT_FULL_CONFIG.player;
    }
    if (!this.fullConfig.display) {
      this.fullConfig.display = DEFAULT_FULL_CONFIG.display;
    }
    if (!this.fullConfig.network) {
      this.fullConfig.network = DEFAULT_FULL_CONFIG.network;
    }
  }
  
  /**
   * æ›´æ–°å®Œæ•´é…ç½®
   */
  public async updateFullConfig(customConfig: Partial<Config>): Promise<ApiResponse<Config>> {
    try {
      // åˆå¹¶é…ç½®
      this.fullConfig = this.mergeConfig(this.fullConfig, customConfig);
      this.ensureDefaultConfig();
      
      // ä¿å­˜åˆ°å­˜å‚?
      await StorageUtil.setObject('app_full_config', this.fullConfig);
      
      // é€šçŸ¥ç›‘å¬å™?
      this.configListeners.forEach(listener => listener(this.fullConfig));
      
      return ApiResponse.success(this.fullConfig, 'é…ç½®æ›´æ–°æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to update full config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'é…ç½®æ›´æ–°å¤±è´¥');
    }
  }
  
  /**
   * æ·»åŠ é…ç½®æ›´æ”¹ç›‘å¬å™?
   */
  public addConfigListener(listener: (config: Config) => void): void {
    this.configListeners.push(listener);
  }
  
  /**
   * ç§»é™¤é…ç½®æ›´æ”¹ç›‘å¬å™?
   */
  public removeConfigListener(listener: (config: Config) => void): void {
    const index = this.configListeners.indexOf(listener);
    if (index > -1) {
      this.configListeners.splice(index, 1);
    }
  }

  /**
   * åˆå§‹åŒ–é…ç½?
   */
  private async initializeConfig(): Promise<void> {
    try {
      Logger.info(TAG, 'Initializing configuration...');
      
      // 1. é¦–å…ˆå°è¯•åŠ è½½å®Œæ•´é…ç½®
      await this.loadFullConfig();
      
      // åŠ è½½é…ç½®åˆ°ç¼“å­?
      const allConfig = await this.databaseRepo.getAllConfig();
      
      // åˆå¹¶é»˜è®¤é…ç½®å’Œæ•°æ®åº“é…ç½®
      for (const [key, defaultValue] of Object.entries(DEFAULT_CONFIG)) {
        const configKey = key as ConfigKey;
        const dbConfig = allConfig.find(c => c.key === configKey);
        
        if (dbConfig) {
          this.configCache.set(configKey, dbConfig);
        } else {
          // åˆ›å»ºé»˜è®¤é…ç½®é¡?
          const defaultItem: ConfigItem = {
            key: configKey,
            value: defaultValue,
            type: this.getValueType(defaultValue),
            defaultValue,
            category: this.getConfigCategory(configKey),
            updatedAt: Date.now(),
            createdAt: Date.now()
          };
          
          this.configCache.set(configKey, defaultItem);
          // ä¿å­˜åˆ°æ•°æ®åº“
          await this.databaseRepo.saveConfig(defaultItem);
        }
      }
      
      // ç¡®ä¿é»˜è®¤é…ç½®å®Œæ•´æ€?
      this.ensureDefaultConfig();
      
      this.isInitialized = true;
      Logger.info(TAG, 'Configuration initialized successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to initialize configuration', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      // åˆå§‹åŒ–å¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤é…ç½®
      this.fullConfig = { ...DEFAULT_FULL_CONFIG };
      this.ensureDefaultConfig();
      this.isInitialized = true;
    }
  }
  
  /**
   * åŠ è½½å®Œæ•´é…ç½®
   */
  private async loadFullConfig(): Promise<void> {
    try {
      // å°è¯•ä»æœ¬åœ°å­˜å‚¨åŠ è½½å®Œæ•´é…ç½?
      const storedConfig = await StorageUtil.getObject<Config>('app_full_config');
      
      if (storedConfig) {
        // åˆå¹¶å­˜å‚¨çš„é…ç½®å’Œé»˜è®¤é…ç½®
        this.fullConfig = this.mergeConfig(DEFAULT_FULL_CONFIG, storedConfig);
        Logger.info(TAG, 'Loaded full configuration from storage');
      } else {
        // ä½¿ç”¨é»˜è®¤é…ç½®
        this.fullConfig = { ...DEFAULT_FULL_CONFIG };
        await StorageUtil.setObject('app_full_config', this.fullConfig);
        Logger.info(TAG, 'Using default full configuration');
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to load full configuration', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      // åŠ è½½å¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤é…ç½?
      this.fullConfig = { ...DEFAULT_FULL_CONFIG };
    }
  }

  /**
   * è·å–é…ç½®å€?
   */
  public async getConfig(key: ConfigKey): Promise<ApiResponse<ConfigValue>> {
    try {
      Logger.debug(TAG, `Getting config for key: ${key}`);
      
      // æ£€æŸ¥ç¼“å­?
      if (this.configCache.has(key)) {
        const config = this.configCache.get(key)!;
        return ApiResponse.success(config.value, `è·å–é…ç½®[${key}]æˆåŠŸ`);
      }
      
      // ä»æ•°æ®åº“è·å–
      const config = await this.databaseRepo.getConfig(key);
      
      if (config) {
        this.configCache.set(key, config);
        return ApiResponse.success(config.value, `è·å–é…ç½®[${key}]æˆåŠŸ`);
      }
      
      // è¿”å›é»˜è®¤å€?
      const defaultValue = DEFAULT_CONFIG[key];
      return ApiResponse.success(defaultValue, `é…ç½®[${key}]ä¸å­˜åœ¨ï¼Œè¿”å›é»˜è®¤å€¼`);
    } catch (error) {
      Logger.error(TAG, `Failed to get config for key: ${key}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      // å‘ç”Ÿé”™è¯¯æ—¶è¿”å›é»˜è®¤å€?
      const defaultValue = DEFAULT_CONFIG[key];
      return ApiResponse.success(defaultValue, `è·å–é…ç½®å¤±è´¥ï¼Œè¿”å›é»˜è®¤å€¼`);
    }
  }

  /**
   * è·å–éƒ¨åˆ†é…ç½®
   */
  public async getPartialConfig<K extends keyof Config>(key: K): Promise<Config[K]> {
    if (!this.isInitialized) {
      await this.initializeConfig();
    }
    
    const configSection = this.fullConfig[key];
    if (!configSection) {
      // å¦‚æœé…ç½®éƒ¨åˆ†ä¸å­˜åœ¨ï¼Œä»é»˜è®¤é…ç½®è·å?
      return DEFAULT_FULL_CONFIG[key];
    }
    
    return { ...configSection };
  }
  
  /**
   * æ›´æ–°éƒ¨åˆ†é…ç½®
   */
  public async updatePartialConfig<K extends keyof Config>(key: K, sectionConfig: Partial<Config[K]>): Promise<ApiResponse<Config[K]>> {
    try {
      if (!this.isInitialized) {
        await this.initializeConfig();
      }
      
      // æ›´æ–°éƒ¨åˆ†é…ç½®
      this.fullConfig[key] = {
        ...this.fullConfig[key],
        ...sectionConfig
      };
      
      // æ›´æ–°æœ€åä¿®æ”¹æ—¶é—?
      this.fullConfig.general.lastUpdated = Date.now();
      
      // ä¿å­˜åˆ°å­˜å‚?
      await StorageUtil.setObject('app_full_config', this.fullConfig);
      
      // é€šçŸ¥ç›‘å¬å™?
      this.configListeners.forEach(listener => listener(this.fullConfig));
      
      return ApiResponse.success(this.fullConfig[key], 'é…ç½®æ›´æ–°æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, `Failed to update partial config for key: ${String(key)}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'é…ç½®æ›´æ–°å¤±è´¥');
    }
  }

  /**
   * è·å–é…ç½®é¡¹è¯¦æƒ?
   */
  public async getConfigItem(key: ConfigKey): Promise<ApiResponse<ConfigItem>> {
    try {
      Logger.debug(TAG, `Getting config item for key: ${key}`);
      
      // æ£€æŸ¥ç¼“å­?
      if (this.configCache.has(key)) {
        const config = this.configCache.get(key)!;
        return ApiResponse.success(config, `è·å–é…ç½®é¡¹[${key}]æˆåŠŸ`);
      }
      
      // ä»æ•°æ®åº“è·å–
      const config = await this.databaseRepo.getConfig(key);
      
      if (config) {
        this.configCache.set(key, config);
        return ApiResponse.success(config, `è·å–é…ç½®é¡¹[${key}]æˆåŠŸ`);
      }
      
      // åˆ›å»ºå¹¶è¿”å›é»˜è®¤é…ç½®é¡¹
      const defaultItem: ConfigItem = {
        key,
        value: DEFAULT_CONFIG[key],
        type: this.getValueType(DEFAULT_CONFIG[key]),
        defaultValue: DEFAULT_CONFIG[key],
        category: this.getConfigCategory(key),
        updatedAt: Date.now(),
        createdAt: Date.now()
      };
      
      return ApiResponse.success(defaultItem, `é…ç½®é¡¹[${key}]ä¸å­˜åœ¨ï¼Œè¿”å›é»˜è®¤é…ç½®é¡¹`);
    } catch (error) {
      Logger.error(TAG, `Failed to get config item for key: ${key}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, `è·å–é…ç½®é¡¹å¤±è´¥`);
    }
  }

  /**
   * è®¾ç½®é…ç½®å€?
   */
  public async setConfig(key: ConfigKey, value: ConfigValue): Promise<ApiResponse<ConfigItem>> {
    try {
      Logger.info(TAG, `Setting config: ${key} = ${JSON.stringify(value)}`);
      
      // éªŒè¯é…ç½®å€?
      const validationResult = this.validateConfigValue(key, value);
      if (!validationResult.isValid) {
        return ApiResponse.validationError([
          { field: key, message: validationResult.errorMessage || 'é…ç½®å€¼æ— æ•? }
        ]);
      }
      
      // è·å–æˆ–åˆ›å»ºé…ç½®é¡¹
      let configItem: ConfigItem;
      
      if (this.configCache.has(key)) {
        // æ›´æ–°ç°æœ‰é…ç½®
        configItem = { ...this.configCache.get(key)! };
        configItem.value = value;
        configItem.updatedAt = Date.now();
      } else {
        // åˆ›å»ºæ–°é…ç½?
        configItem = {
          key,
          value,
          type: this.getValueType(value),
          defaultValue: DEFAULT_CONFIG[key],
          category: this.getConfigCategory(key),
          updatedAt: Date.now(),
          createdAt: Date.now()
        };
      }
      
      // ä¿å­˜åˆ°æ•°æ®åº“
      await this.databaseRepo.saveConfig(configItem);
      
      // æ›´æ–°ç¼“å­˜
      this.configCache.set(key, configItem);
      
      // è§¦å‘é…ç½®æ›´æ”¹äº‹ä»¶
      this.notifyConfigChanged(key, value);
      
      Logger.info(TAG, `Config updated successfully: ${key}`);
      return ApiResponse.success(configItem, `è®¾ç½®é…ç½®[${key}]æˆåŠŸ`);
    } catch (error) {
      Logger.error(TAG, `Failed to set config: ${key}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, `è®¾ç½®é…ç½®å¤±è´¥`);
    }
  }

  /**
   * æ‰¹é‡è®¾ç½®é…ç½®
   */
  public async setMultipleConfig(configs: Array<{ key: ConfigKey; value: ConfigValue }>): Promise<ApiResponse<{ updated: number; failed: number }>> {
    try {
      Logger.info(TAG, `Setting multiple configs: ${configs.length} items`);
      
      let updated = 0;
      let failed = 0;
      
      for (const { key, value } of configs) {
        try {
          // éªŒè¯é…ç½®å€?
          const validationResult = this.validateConfigValue(key, value);
          if (!validationResult.isValid) {
            Logger.warn(TAG, `Invalid config value for ${key}: ${validationResult.errorMessage}`);
            failed++;
            continue;
          }
          
          // æ›´æ–°é…ç½®
          await this.setConfig(key, value);
          updated++;
        } catch (error) {
          Logger.warn(TAG, `Failed to update config ${key}`, error);
          failed++;
        }
      }
      
      Logger.info(TAG, `Multiple configs updated: ${updated} success, ${failed} failed`);
      return ApiResponse.success(
        { updated, failed },
        `æ‰¹é‡æ›´æ–°é…ç½®å®Œæˆï¼ŒæˆåŠ?{updated}é¡¹ï¼Œå¤±è´¥${failed}é¡¹`
      );
    } catch (error) {
      Logger.error(TAG, 'Failed to set multiple configs', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ‰¹é‡æ›´æ–°é…ç½®å¤±è´¥');
    }
  }

  /**
   * é‡ç½®é…ç½®ä¸ºé»˜è®¤å€?
   */
  public async resetConfig(key: ConfigKey): Promise<ApiResponse<ConfigItem>> {
    try {
      Logger.info(TAG, `Resetting config to default: ${key}`);
      
      const defaultValue = DEFAULT_CONFIG[key];
      
      // æ›´æ–°é…ç½®é¡?
      const configItem: ConfigItem = {
        key,
        value: defaultValue,
        type: this.getValueType(defaultValue),
        defaultValue,
        category: this.getConfigCategory(key),
        updatedAt: Date.now(),
        createdAt: this.configCache.has(key) ? this.configCache.get(key)!.createdAt : Date.now()
      };
      
      // ä¿å­˜åˆ°æ•°æ®åº“
      await this.databaseRepo.saveConfig(configItem);
      
      // æ›´æ–°ç¼“å­˜
      this.configCache.set(key, configItem);
      
      // è§¦å‘é…ç½®æ›´æ”¹äº‹ä»¶
      this.notifyConfigChanged(key, defaultValue);
      
      Logger.info(TAG, `Config reset successfully: ${key}`);
      return ApiResponse.success(configItem, `é‡ç½®é…ç½®[${key}]æˆåŠŸ`);
    } catch (error) {
      Logger.error(TAG, `Failed to reset config: ${key}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'é‡ç½®é…ç½®å¤±è´¥');
    }
  }

  /**
   * é‡ç½®æ‰€æœ‰é…ç½®ä¸ºé»˜è®¤å€?
   */
  public async resetAllConfig(): Promise<ApiResponse<boolean>> {
    try {
      Logger.info(TAG, 'Resetting all config to default values');
      
      // æ¸…ç©ºæ•°æ®åº“ä¸­çš„é…ç½?
      await this.databaseRepo.clearAllConfig();
      
      // æ¸…ç©ºç¼“å­˜
      this.configCache.clear();
      
      // é‡æ–°åˆå§‹åŒ–é…ç½?
      await this.initializeConfig();
      
      // è§¦å‘é…ç½®é‡ç½®äº‹ä»¶
      this.notifyConfigReset();
      
      Logger.info(TAG, 'All config reset successfully');
      return ApiResponse.success(true, 'é‡ç½®æ‰€æœ‰é…ç½®æˆåŠ?);
    } catch (error) {
      Logger.error(TAG, 'Failed to reset all config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'é‡ç½®æ‰€æœ‰é…ç½®å¤±è´?);
    }
  }

  /**
   * è·å–æ‰€æœ‰é…ç½?
   */
  public async getAllConfig(category?: string): Promise<ApiResponse<ConfigItem[]>> {
    try {
      Logger.info(TAG, `Getting all configs${category ? ` for category: ${category}` : ''}`);
      
      let allConfigs: ConfigItem[];
      
      if (category) {
        // æŒ‰åˆ†ç±»è·å?
        allConfigs = Array.from(this.configCache.values())
          .filter(item => item.category === category);
      } else {
        // è·å–æ‰€æœ?
        allConfigs = Array.from(this.configCache.values());
      }
      
      return ApiResponse.success(allConfigs, `è·å–é…ç½®åˆ—è¡¨æˆåŠŸï¼Œå…±${allConfigs.length}é¡¹`);
    } catch (error) {
      Logger.error(TAG, 'Failed to get all configs', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–é…ç½®åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * éªŒè¯é…ç½®å€?
   */
  private validateConfigValue(key: ConfigKey, value: ConfigValue): { isValid: boolean; errorMessage?: string } {
    // è·å–é»˜è®¤å€¼ç±»å?
    const defaultValue = DEFAULT_CONFIG[key];
    if (defaultValue === undefined) {
      return { isValid: false, errorMessage: `æœªçŸ¥çš„é…ç½®é¡¹: ${key}` };
    }
    
    // æ£€æŸ¥ç±»å?
    const expectedType = this.getValueType(defaultValue);
    const actualType = this.getValueType(value);
    
    if (expectedType !== actualType) {
      return { 
        isValid: false, 
        errorMessage: `é…ç½®ç±»å‹é”™è¯¯ï¼ŒæœŸæœ?{expectedType}ï¼Œå®é™?{actualType}` 
      };
    }
    
    // å¯¹ç‰¹å®šé…ç½®è¿›è¡Œé¢å¤–éªŒè¯?
    switch (key) {
      case 'cacheLimit':
        if (typeof value === 'number' && (value < 0 || value > 50000)) {
          return { isValid: false, errorMessage: 'ç¼“å­˜é™åˆ¶å¿…é¡»åœ?-50000MBä¹‹é—´' };
        }
        break;
        
      case 'networkTimeout':
        if (typeof value === 'number' && (value < 5 || value > 300)) {
          return { isValid: false, errorMessage: 'ç½‘ç»œè¶…æ—¶å¿…é¡»åœ?-300ç§’ä¹‹é—? };
        }
        break;
        
      case 'subtitleSize':
        if (typeof value === 'number' && (value < 10 || value > 48)) {
          return { isValid: false, errorMessage: 'å­—å¹•å¤§å°å¿…é¡»åœ?0-48ä¹‹é—´' };
        }
        break;
        
      case 'maxConcurrentDownloads':
        if (typeof value === 'number' && (value < 1 || value > 10)) {
          return { isValid: false, errorMessage: 'æœ€å¤§å¹¶å‘ä¸‹è½½æ•°å¿…é¡»åœ?-10ä¹‹é—´' };
        }
        break;
        
      case 'interfaceScale':
        if (typeof value === 'number' && (value < 50 || value > 200)) {
          return { isValid: false, errorMessage: 'ç•Œé¢ç¼©æ”¾å¿…é¡»åœ?0%-200%ä¹‹é—´' };
        }
        break;
        
      case 'parentalControlPin':
        if (value && typeof value === 'string' && !/^\d{4,6}$/.test(value)) {
          return { isValid: false, errorMessage: 'å®¶é•¿æ§åˆ¶PINç å¿…é¡»æ˜¯4-6ä½æ•°å­? };
        }
        break;
    }
    
    return { isValid: true };
  }

  /**
   * è·å–å€¼çš„ç±»å‹
   */
  private getValueType(value: ConfigValue): 'string' | 'number' | 'boolean' | 'object' | 'null' {
    if (value === null) return 'null';
    if (Array.isArray(value)) return 'object';
    return typeof value as 'string' | 'number' | 'boolean' | 'object';
  }

  /**
   * è·å–é…ç½®åˆ†ç±»
   */
  private getConfigCategory(key: ConfigKey): string {
    const categoryMap: Record<ConfigKey, string> = {
      // ç•Œé¢ç›¸å…³
      theme: CONFIG_CATEGORIES.UI,
      language: CONFIG_CATEGORIES.UI,
      interfaceScale: CONFIG_CATEGORIES.UI,
      uiAnimationEnabled: CONFIG_CATEGORIES.UI,
      startupScreen: CONFIG_CATEGORIES.UI,
      homeLayout: CONFIG_CATEGORIES.UI,
      
      // è§†é¢‘æ’­æ”¾ç›¸å…³
      videoQuality: CONFIG_CATEGORIES.VIDEO,
      playbackSpeed: CONFIG_CATEGORIES.VIDEO,
      autoPlay: CONFIG_CATEGORIES.VIDEO,
      autoNextEpisode: CONFIG_CATEGORIES.VIDEO,
      backgroundPlayEnabled: CONFIG_CATEGORIES.VIDEO,
      videoPlayerSettings: CONFIG_CATEGORIES.VIDEO,
      
      // å­—å¹•ç›¸å…³
      subtitleEnabled: CONFIG_CATEGORIES.SUBTITLE,
      subtitleSize: CONFIG_CATEGORIES.SUBTITLE,
      subtitleColor: CONFIG_CATEGORIES.SUBTITLE,
      subtitleDelay: CONFIG_CATEGORIES.SUBTITLE,
      
      // ç¼“å­˜ç›¸å…³
      cacheEnabled: CONFIG_CATEGORIES.CACHE,
      cacheLimit: CONFIG_CATEGORIES.CACHE,
      
      // ç½‘ç»œç›¸å…³
      networkTimeout: CONFIG_CATEGORIES.NETWORK,
      proxyEnabled: CONFIG_CATEGORIES.NETWORK,
      proxyConfig: CONFIG_CATEGORIES.NETWORK,
      dataSaverEnabled: CONFIG_CATEGORIES.NETWORK,
      customHeaders: CONFIG_CATEGORIES.NETWORK,
      customCookies: CONFIG_CATEGORIES.NETWORK,
      
      // é€šçŸ¥ç›¸å…³
      notificationEnabled: CONFIG_CATEGORIES.NOTIFICATION,
      
      // éšç§ç›¸å…³
      updateCheckEnabled: CONFIG_CATEGORIES.PRIVACY,
      crashReportingEnabled: CONFIG_CATEGORIES.PRIVACY,
      analyticsEnabled: CONFIG_CATEGORIES.PRIVACY,
      
      // æ’åºç›¸å…³
      favoriteSort: CONFIG_CATEGORIES.SORTING,
      historySort: CONFIG_CATEGORIES.SORTING,
      searchSort: CONFIG_CATEGORIES.SORTING,
      
      // ä¸‹è½½ç›¸å…³
      maxConcurrentDownloads: CONFIG_CATEGORIES.DOWNLOAD,
      downloadNetworkType: CONFIG_CATEGORIES.DOWNLOAD,
      
      // å®¶é•¿æ§åˆ¶
      parentalControlEnabled: CONFIG_CATEGORIES.PARENTAL,
      parentalControlPin: CONFIG_CATEGORIES.PARENTAL,
      showAdultContent: CONFIG_CATEGORIES.PARENTAL,
      
      // å…¶ä»–
      recentlyWatchedLimit: CONFIG_CATEGORIES.OTHER,
      streamingEnabled: CONFIG_CATEGORIES.OTHER,
      localPlaybackEnabled: CONFIG_CATEGORIES.OTHER,
      defaultCategory: CONFIG_CATEGORIES.OTHER,
      preferredServer: CONFIG_CATEGORIES.OTHER
    };
    
    return categoryMap[key] || CONFIG_CATEGORIES.OTHER;
  }

  // ========== äº‹ä»¶é€šçŸ¥æœºåˆ¶ ==========
  
  private configListeners: Map<string, Array<(value: ConfigValue) => void>> = new Map();
  private globalListeners: Array<(key: ConfigKey, value: ConfigValue) => void> = [];
  private resetListeners: Array<() => void> = [];

  /**
   * ç›‘å¬é…ç½®æ›´æ”¹
   */
  public addConfigListener(key: ConfigKey, listener: (value: ConfigValue) => void): () => void {
    const keyStr = key as string;
    if (!this.configListeners.has(keyStr)) {
      this.configListeners.set(keyStr, []);
    }
    
    const listeners = this.configListeners.get(keyStr)!;
    listeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ å…¨å±€é…ç½®ç›‘å¬
   */
  public addGlobalConfigListener(listener: (key: ConfigKey, value: ConfigValue) => void): () => void {
    this.globalListeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.globalListeners.indexOf(listener);
      if (index > -1) {
        this.globalListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ é…ç½®é‡ç½®ç›‘å¬
   */
  public addConfigResetListener(listener: () => void): () => void {
    this.resetListeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.resetListeners.indexOf(listener);
      if (index > -1) {
        this.resetListeners.splice(index, 1);
      }
    };
  }

  /**
   * é€šçŸ¥é…ç½®æ›´æ”¹
   */
  private notifyConfigChanged(key: ConfigKey, value: ConfigValue): void {
    // é€šçŸ¥ç‰¹å®šé…ç½®çš„ç›‘å¬å™¨
    const keyStr = key as string;
    if (this.configListeners.has(keyStr)) {
      const listeners = this.configListeners.get(keyStr)!;
      for (const listener of listeners) {
        try {
          listener(value);
        } catch (error) {
          Logger.error(TAG, `Error in config listener for ${key}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
        }
      }
    }
    
    // é€šçŸ¥å…¨å±€ç›‘å¬å™?
    for (const listener of this.globalListeners) {
      try {
        listener(key, value);
      } catch (error) {
        Logger.error(TAG, `Error in global config listener`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      }
    }
  }

  /**
   * é€šçŸ¥é…ç½®é‡ç½®
   */
  private notifyConfigReset(): void {
    for (const listener of this.resetListeners) {
      try {
        listener();
      } catch (error) {
        Logger.error(TAG, `Error in config reset listener`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      }
    }
  }

  // ========== é…ç½®å¯¼å‡º/å¯¼å…¥ ==========

  /**
   * å¯¼å‡ºé…ç½®
   */
  public async exportConfig(): Promise<ApiResponse<string>> {
    try {
      Logger.info(TAG, 'Exporting configuration...');
      
      const allConfigs = await this.getAllConfig();
      
      if (!allConfigs.isSuccess() || !allConfigs.data) {
        return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–é…ç½®å¤±è´¥ï¼Œæ— æ³•å¯¼å‡?);
      }
      
      const exportData = {
        exportDate: new Date().toISOString(),
        version: '1.0',
        configs: allConfigs.data.map(item => ({
          key: item.key,
          value: item.value,
          updatedAt: item.updatedAt
        }))
      };
      
      // ä½¿ç”¨ConfigParseræ ¼å¼åŒ–å¯¼å‡ºæ•°æ?
      const jsonStr = this.configParser.formatExportConfig(exportData);
      return ApiResponse.success(jsonStr, 'å¯¼å‡ºé…ç½®æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to export config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'å¯¼å‡ºé…ç½®å¤±è´¥');
    }
  }

  /**
   * å¯¼å…¥é…ç½®
   */
  public async importConfig(jsonData: string, merge: boolean = true): Promise<ApiResponse<{
    imported: number;
    skipped: number;
    invalid: number;
  }>> {
    try {
      Logger.info(TAG, 'Importing configuration...', { merge });
      
      // ä½¿ç”¨ConfigParserè§£æé…ç½®æ•°æ®
      const importData = this.configParser.parseImportConfig(jsonData);
      const configs = importData.configs || [];
      
      let imported = 0;
      let skipped = 0;
      let invalid = 0;
      
      for (const configData of configs) {
        const { key, value } = configData;
        
        // éªŒè¯é…ç½®é”?
        if (!key || !DEFAULT_CONFIG.hasOwnProperty(key)) {
          invalid++;
          continue;
        }
        
        const configKey = key as ConfigKey;
        
        // éªŒè¯é…ç½®å€?
        const validationResult = this.validateConfigValue(configKey, value);
        if (!validationResult.isValid) {
          invalid++;
          continue;
        }
        
        // å¦‚æœä¸åˆå¹¶ä¸”é…ç½®å·²å­˜åœ¨ï¼Œè·³è¿‡
        if (!merge && this.configCache.has(configKey)) {
          skipped++;
          continue;
        }
        
        // å¯¼å…¥é…ç½®
        await this.setConfig(configKey, value);
        imported++;
      }
      
      Logger.info(TAG, 'Configuration import completed', { imported, skipped, invalid });
      return ApiResponse.success(
        { imported, skipped, invalid },
        `å¯¼å…¥é…ç½®å®Œæˆï¼ŒæˆåŠ?{imported}é¡¹ï¼Œè·³è¿‡${skipped}é¡¹ï¼Œæ— æ•ˆ${invalid}é¡¹`
      );
    } catch (error) {
      Logger.error(TAG, 'Failed to import config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'å¯¼å…¥é…ç½®å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®æ ¼å¼?);
    }
  }
}


