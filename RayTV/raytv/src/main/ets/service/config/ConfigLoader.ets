// ConfigLoader - é…ç½®åŠ è½½å™?import Logger from '../../common/util/Logger';
import http from '@ohos.net.http';
import HttpMethod from '@ohos.net.http';
import fs from '@ohos.file.fs';
import { Site } from '../../data/bean/Site';
import { AppConfig } from '../../data/bean/Config';

/**
 * é…ç½®å¯¹è±¡æ¥å£ï¼Œç”¨äºè§„èŒƒåŒ–å¤„ç†å„ç§é…ç½®æ ¼å¼
 */
interface ConfigObject {
  sites?: Site[];
  data?: Site[];
  appConfig?: AppConfig;
  // ç§»é™¤äº†anyç±»å‹çš„ç´¢å¼•ç­¾åï¼Œä½¿ç”¨æ›´å…·ä½“çš„å±æ€§å®šä¹?}

const TAG = 'ConfigLoader';

/**
 * é…ç½®åŠ è½½å™¨ï¼Œæä¾›å¤šæºé…ç½®åŠ è½½èƒ½åŠ›
 */
export class ConfigLoader {
  private static instance: ConfigLoader;
  private cachePath: string;
  
  private constructor() {
    // åˆå§‹åŒ–ç¼“å­˜è·¯å¾?    this.cachePath = this.getCachePath();
  }
  
  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): ConfigLoader {
    if (!ConfigLoader.instance) {
      ConfigLoader.instance = new ConfigLoader();
    }
    return ConfigLoader.instance;
  }
  
  /**
   * ä»URLåŠ è½½é…ç½®
   * @param url é…ç½®URL
   * @param cacheHours ç¼“å­˜æ—¶é—´ï¼ˆå°æ—¶ï¼‰ï¼Œé»˜è®¤ä½¿ç”¨é»˜è®¤å€?   * @param forceRefresh æ˜¯å¦å¼ºåˆ¶åˆ·æ–°ï¼ˆå¿½ç•¥ç¼“å­˜ï¼‰
   */
  public async loadFromUrl(url: string, cacheHours?: number, forceRefresh: boolean = false): Promise<string> {
    try {
      Logger.info(TAG, `Loading config from URL: ${url}`);
      
      // éªŒè¯ç¼“å­˜æ—¶é—´
      const normalizedCacheHours = this.normalizeCacheTime(cacheHours);
      
      // å¦‚æœä¸æ˜¯å¼ºåˆ¶åˆ·æ–°ï¼Œå…ˆå°è¯•ä»ç¼“å­˜åŠ è½?      if (!forceRefresh) {
        try {
          const cachedContent = await this.loadFromCache(url, normalizedCacheHours);
          if (cachedContent) {
            Logger.info(TAG, `Using cached config (${normalizedCacheHours}h)`);
            return cachedContent;
          }
        } catch (cacheError) {
          Logger.error(TAG, `Failed to load cached config: ${cacheError}`);
        }
      } else {
        Logger.info(TAG, `Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache` instanceof Error ? `Force refresh enabled, bypassing cache` : new Error(String(`Force refresh enabled, bypassing cache`)))))));
      }
      
      // åˆ›å»ºHTTPè¯·æ±‚
      const request = http.createHttp();
      const response = await request.request(url, {
        method: HttpMethod.GET,
        header: {
          'Content-Type': 'application/json',
          'User-Agent': 'RayTV-HarmonyOS'
        },
        readTimeout: 15000,
        connectTimeout: 10000
      });
      
      if (response.responseCode === 200) {
        const configContent = response.result as string;
        Logger.info(TAG, `Successfully loaded config from URL`);
        
        // ç¼“å­˜é…ç½®
        await this.cacheConfig(url, configContent);
        
        return configContent;
      } else {
        throw new Error(`Failed to load config, status code: ${response.responseCode}`);
      }
    } catch (error) {
      Logger.error(TAG, `Failed to load config from URL: ${error}`);
      
      // å°è¯•ä»ç¼“å­˜åŠ è½?      try {
        const cachedContent = await this.loadFromCache(url);
        if (cachedContent) {
          Logger.warn(TAG, `Using cached config since network failed` instanceof Error ? `Using cached config since network failed` : new Error(String(`Using cached config since network failed` instanceof Error ? `Using cached config since network failed` instanceof Error ? `Using cached config since network failed` : new Error(String(`Using cached config since network failed` : new Error(String(`Using cached config since network failed` instanceof Error ? `Using cached config since network failed` : new Error(String(`Using cached config since network failed` instanceof Error ? `Using cached config since network failed` instanceof Error ? `Using cached config since network failed` : new Error(String(`Using cached config since network failed` instanceof Error ? `Using cached config since network failed` instanceof Error ? `Using cached config since network failed` : new Error(String(`Using cached config since network failed` : new Error(String(`Using cached config since network failed` instanceof Error ? `Using cached config since network failed` : new Error(String(`Using cached config since network failed` : new Error(String(`Using cached config since network failed` instanceof Error ? `Using cached config since network failed` : new Error(String(`Using cached config since network failed` instanceof Error ? `Using cached config since network failed` instanceof Error ? `Using cached config since network failed` : new Error(String(`Using cached config since network failed` : new Error(String(`Using cached config since network failed` instanceof Error ? `Using cached config since network failed` : new Error(String(`Using cached config since network failed`)))))));
          return cachedContent;
        }
      } catch (cacheError) {
        Logger.error(TAG, `Failed to load cached config: ${cacheError}`);
      }
      
      throw error;
    }
  }
  
  /**
   * ä»æœ¬åœ°æ–‡ä»¶åŠ è½½é…ç½?   * @param filePath æ–‡ä»¶è·¯å¾„
   */
  public async loadFromFile(filePath: string): Promise<string> {
    try {
      Logger.info(TAG, `Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}` instanceof Error ? `Loading config from file: ${filePath}` : new Error(String(`Loading config from file: ${filePath}`)))))));
      
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ?      const fileInfo = await fs.getFileStat(filePath);
      if (!fileInfo.isFile) {
        throw new Error('Path is not a file');
      }
      
      // è¯»å–æ–‡ä»¶å†…å®¹
      const file = await fs.open(filePath, fs.OpenMode.READ_ONLY);
      const fileContent = await fs.readText(file.fd);
      await fs.close(file.fd);
      
      Logger.info(TAG, `Successfully loaded config from file`);
      return fileContent;
    } catch (error) {
      Logger.error(TAG, `Failed to load config from file: ${error}`);
      throw error;
    }
  }
  
  /**
   * è§£æé…ç½®å†…å®¹
   * @param content é…ç½®å†…å®¹
   */
  public parseConfig(content: string): { sites: Site[]; appConfig?: AppConfig } {
    try {
      Logger.info(TAG, 'Parsing config content' instanceof Error ? 'Parsing config content' : new Error(String('Parsing config content' instanceof Error ? 'Parsing config content' instanceof Error ? 'Parsing config content' : new Error(String('Parsing config content' : new Error(String('Parsing config content' instanceof Error ? 'Parsing config content' : new Error(String('Parsing config content' instanceof Error ? 'Parsing config content' instanceof Error ? 'Parsing config content' : new Error(String('Parsing config content' instanceof Error ? 'Parsing config content' instanceof Error ? 'Parsing config content' : new Error(String('Parsing config content' : new Error(String('Parsing config content' instanceof Error ? 'Parsing config content' : new Error(String('Parsing config content' : new Error(String('Parsing config content' instanceof Error ? 'Parsing config content' : new Error(String('Parsing config content' instanceof Error ? 'Parsing config content' instanceof Error ? 'Parsing config content' : new Error(String('Parsing config content' : new Error(String('Parsing config content' instanceof Error ? 'Parsing config content' : new Error(String('Parsing config content')))))));
      
      // å°è¯•è§£æä¸ºçº¯JSON
      try {
        const config = JSON.parse(content) as ConfigObject | Site[];
        return this.processConfigObject(config);
      } catch (jsonError) {
        // å¦‚æœä¸æ˜¯çº¯JSONï¼Œå°è¯•è§£æä¸ºJavaScriptæ ¼å¼
        Logger.info(TAG, 'Not pure JSON, trying to parse as JavaScript');
        return this.parseJavaScriptConfig(content);
      }
    } catch (error) {
      Logger.error(TAG, `Failed to parse config: ${error}`);
      throw new Error('Invalid config format');
    }
  }
  
  /**
   * å¤„ç†é…ç½®å¯¹è±¡
   * @param config é…ç½®å¯¹è±¡
   */
  private processConfigObject(config: ConfigObject | Site[]): { sites: Site[]; appConfig?: AppConfig } {
    const sites: Site[] = [];
    let appConfig: AppConfig | undefined;
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºSiteæ•°ç»„
    if (Array.isArray(config)) {
      // ç›´æ¥æ˜¯ç«™ç‚¹æ•°ç»?      sites.push(...config);
    } else {
      // å¤„ç†ç«™ç‚¹é…ç½®
      if (config.sites && Array.isArray(config.sites)) {
        sites.push(...config.sites);
      } else if (config.data && Array.isArray(config.data)) {
        // å…¼å®¹æ—§ç‰ˆé…ç½®æ ¼å¼
        sites.push(...config.data);
      }
      
      // å¤„ç†åº”ç”¨é…ç½®
      if (config.appConfig) {
        appConfig = config.appConfig;
      }
    }
    
    Logger.info(TAG, `Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites` instanceof Error ? `Processed ${sites.length} sites` : new Error(String(`Processed ${sites.length} sites`)))))));
    return { sites, appConfig };
  }
  
  /**
   * è§£æJavaScriptæ ¼å¼é…ç½®
   * @param content JavaScripté…ç½®å†…å®¹
   */
  private parseJavaScriptConfig(content: string): { sites: Site[]; appConfig?: AppConfig } {
    try {
      // å°è¯•æå–configå˜é‡
      const configMatch = content.match(/var\s+config\s*=\s*([\s\S]*?);/);
      if (configMatch && configMatch[1]) {
        const configObj = JSON.parse(configMatch[1]) as ConfigObject | Site[];
        return this.processConfigObject(configObj);
      }
      
      // å°è¯•æå–dataå˜é‡
      const dataMatch = content.match(/var\s+data\s*=\s*([\s\S]*?);/);
      if (dataMatch && dataMatch[1]) {
        const dataObj = JSON.parse(dataMatch[1]) as ConfigObject | Site[];
        return this.processConfigObject(dataObj);
      }
      
      throw new Error('Could not find valid JavaScript config');
    } catch (error) {
      Logger.error(TAG, `Failed to parse JavaScript config: ${error}`);
      throw new Error('Invalid JavaScript config format');
    }
  }
  
  /**
   * ç¼“å­˜é…ç½®
   * @param url é…ç½®URL
   * @param content é…ç½®å†…å®¹
   */
  private async cacheConfig(url: string, content: string instanceof Error ? content: string : new Error(String(content: string instanceof Error ? content: string instanceof Error ? content: string : new Error(String(content: string : new Error(String(content: string instanceof Error ? content: string : new Error(String(content: string instanceof Error ? content: string instanceof Error ? content: string : new Error(String(content: string instanceof Error ? content: string instanceof Error ? content: string : new Error(String(content: string : new Error(String(content: string instanceof Error ? content: string : new Error(String(content: string : new Error(String(content: string instanceof Error ? content: string : new Error(String(content: string instanceof Error ? content: string instanceof Error ? content: string : new Error(String(content: string : new Error(String(content: string instanceof Error ? content: string : new Error(String(content: string))))))): Promise<void> {
    try {
      // ç”Ÿæˆç¼“å­˜æ–‡ä»¶å?      const cacheFileName = this.getCacheFileName(url);
      const cacheFilePath = `${this.cachePath}/${cacheFileName}`;
      
      // ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
      await this.ensureCacheDir();
      
      // å†™å…¥ç¼“å­˜æ–‡ä»¶
      const file = await fs.open(cacheFilePath, fs.OpenMode.CREATE | fs.OpenMode.WRITE_ONLY | fs.OpenMode.TRUNCATE);
      await fs.writeText(file.fd, content);
      await fs.close(file.fd);
      
      Logger.debug(TAG, `Config cached to ${cacheFilePath}`);
    } catch (error) {
      Logger.warn(TAG, `Failed to cache config: ${error}`);
      // ç¼“å­˜å¤±è´¥ä¸å½±å“ä¸»è¦åŠŸèƒ?    }
  }
  
  // ç¼“å­˜è¿‡æœŸæ—¶é—´é…ç½®ï¼ˆå°æ—¶ï¼‰
  private minCacheHours: number = 24;     // æœ€å°?4å°æ—¶
  private maxCacheHours: number = 72;     // æœ€å¤?2å°æ—¶
  private defaultCacheHours: number = 24; // é»˜è®¤24å°æ—¶

  /**
   * ä»ç¼“å­˜åŠ è½½é…ç½?   * @param url é…ç½®URL
   * @param cacheHours ç¼“å­˜æ—¶é—´ï¼ˆå°æ—¶ï¼‰
   */
  private async loadFromCache(url: string, cacheHours: number = this.defaultCacheHours): Promise<string | null> {
    try {
      const cacheFileName = this.getCacheFileName(url);
      const cacheFilePath = `${this.cachePath}/${cacheFileName}`;
      
      // æ£€æŸ¥ç¼“å­˜æ–‡ä»¶æ˜¯å¦å­˜åœ?      try {
        await fs.getFileStat(cacheFilePath);
      } catch {
        return null;
      }
      
      // è¯»å–ç¼“å­˜æ–‡ä»¶
      const file = await fs.open(cacheFilePath, fs.OpenMode.READ_ONLY);
      const content = await fs.readText(file.fd);
      await fs.close(file.fd);
      
      // æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœ?      const cacheInfo = await fs.getFileStat(cacheFilePath);
      const cacheTime = cacheInfo.mtimeMs || cacheInfo.ctimeMs || Date.now();
      const now = Date.now();
      const cacheExpiry = this.normalizeCacheTime(cacheHours) * 60 * 60 * 1000; // è½¬æ¢ä¸ºæ¯«ç§?      
      if (now - cacheTime > cacheExpiry) {
        Logger.debug(TAG, `Cache expired, ignoring`);
        return null;
      }
      
      Logger.debug(TAG, `Loaded config from cache`);
      return content;
    } catch (error) {
      Logger.warn(TAG, `Failed to load from cache: ${error}`);
      return null;
    }
  }
  
  /**
   * ä¿å­˜ç«™ç‚¹é…ç½®ä¸ºæ–‡ä»?   * @param sites ç«™ç‚¹é…ç½®
   * @param filePath ä¿å­˜è·¯å¾„
   */
  public async saveConfigToFile(sites: Site[], filePath: string): Promise<void> {
    try {
      Logger.info(TAG, `Saving config to file: ${filePath}`);
      
      // åˆ›å»ºé…ç½®å¯¹è±¡
      const config: Record<string, string | number | boolean | null> = { ... };
      
      // è½¬æ¢ä¸ºJSON
      const configJson = JSON.stringify(config, null, 2);
      
      // å†™å…¥æ–‡ä»¶
      const file = await fs.open(filePath, fs.OpenMode.CREATE | fs.OpenMode.WRITE_ONLY | fs.OpenMode.TRUNCATE);
      await fs.writeText(file.fd, configJson);
      await fs.close(file.fd);
      
      Logger.info(TAG, `Successfully saved config to file`);
    } catch (error) {
      Logger.error(TAG, `Failed to save config to file: ${error}`);
      throw error;
    }
  }
  
  /**
   * è·å–ç¼“å­˜è·¯å¾„
   */
  private getCachePath(): string {
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥ä½¿ç”¨åº”ç”¨çš„ç¼“å­˜ç›®å½•
    // è¿™é‡Œç®€åŒ–å¤„ç?    return '/data/storage/el2/base/cache/raytv/config';
  }
  
  /**
   * ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
   */
  private async ensureCacheDir(): Promise<void> {
    try {
      // æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ?      try {
        const dirInfo = await fs.getFileStat(this.cachePath);
        if (!dirInfo.isDir) {
          await fs.unlink(this.cachePath);
        }
      } catch {
        // ç›®å½•ä¸å­˜åœ¨ï¼Œåˆ›å»ºç›®å½•
        await fs.mkdir(this.cachePath, true instanceof Error ? true : new Error(String(true instanceof Error ? true instanceof Error ? true : new Error(String(true : new Error(String(true instanceof Error ? true : new Error(String(true instanceof Error ? true instanceof Error ? true : new Error(String(true instanceof Error ? true instanceof Error ? true : new Error(String(true : new Error(String(true instanceof Error ? true : new Error(String(true : new Error(String(true instanceof Error ? true : new Error(String(true instanceof Error ? true instanceof Error ? true : new Error(String(true : new Error(String(true instanceof Error ? true : new Error(String(true)))))));
      }
    } catch (error) {
      Logger.error(TAG, `Failed to ensure cache directory: ${error}`);
      throw error;
    }
  }
  
  /**
   * ç”Ÿæˆç¼“å­˜æ–‡ä»¶å?   * @param url URL
   */
  private getCacheFileName(url: string): string {
    // ç®€å•çš„URLå“ˆå¸Œä½œä¸ºç¼“å­˜æ–‡ä»¶å?    const hash = this.simpleHash(url);
    return `config_${hash}.json`;
  }
  
  /**
   * ç®€å•çš„å­—ç¬¦ä¸²å“ˆå¸Œå‡½æ•?   * @param str è¾“å…¥å­—ç¬¦ä¸?   */
  private simpleHash(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }
  
  /**
   * æ¸…é™¤é…ç½®ç¼“å­˜
   */
  public async clearCache(): Promise<void> {
    try {
      Logger.info(TAG, 'Clearing config cache' instanceof Error ? 'Clearing config cache' : new Error(String('Clearing config cache' instanceof Error ? 'Clearing config cache' instanceof Error ? 'Clearing config cache' : new Error(String('Clearing config cache' : new Error(String('Clearing config cache' instanceof Error ? 'Clearing config cache' : new Error(String('Clearing config cache' instanceof Error ? 'Clearing config cache' instanceof Error ? 'Clearing config cache' : new Error(String('Clearing config cache' instanceof Error ? 'Clearing config cache' instanceof Error ? 'Clearing config cache' : new Error(String('Clearing config cache' : new Error(String('Clearing config cache' instanceof Error ? 'Clearing config cache' : new Error(String('Clearing config cache' : new Error(String('Clearing config cache' instanceof Error ? 'Clearing config cache' : new Error(String('Clearing config cache' instanceof Error ? 'Clearing config cache' instanceof Error ? 'Clearing config cache' : new Error(String('Clearing config cache' : new Error(String('Clearing config cache' instanceof Error ? 'Clearing config cache' : new Error(String('Clearing config cache')))))));
      
      // è¯»å–ç¼“å­˜ç›®å½•
      const files = await fs.listFile(this.cachePath);
      
      // åˆ é™¤æ‰€æœ‰ç¼“å­˜æ–‡ä»?      for (const file of files) {
        if (file.name.startsWith('config_') && file.name.endsWith('.json')) {
          const filePath = `${this.cachePath}/${file.name}`;
          await fs.unlink(filePath);
          Logger.debug(TAG, `Deleted cache file: ${file.name}`);
        }
      }
      
      Logger.info(TAG, 'Cache cleared successfully');
    } catch (error) {
      Logger.error(TAG, `Failed to clear cache: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜
   * @param cacheHours ä½¿ç”¨çš„ç¼“å­˜æ—¶é—´é˜ˆå€¼ï¼ˆå°æ—¶ï¼‰ï¼Œé»˜è®¤ä½¿ç”¨æœ€å°ç¼“å­˜æ—¶é—?   */
  public async cleanExpiredCache(cacheHours: number = this.minCacheHours): Promise<void> {
    try {
      Logger.info(TAG, `Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h instanceof Error ? `Cleaning expired cache (threshold: ${cacheHours}h : new Error(String(`Cleaning expired cache (threshold: ${cacheHours}h)))))))`);
      
      // è¯»å–ç¼“å­˜ç›®å½•
      const files = await fs.listFile(this.cachePath);
      const now = Date.now();
      const cacheExpiry = this.normalizeCacheTime(cacheHours) * 60 * 60 * 1000;
      
      // åˆ é™¤è¿‡æœŸç¼“å­˜æ–‡ä»¶
      for (const file of files) {
        if (file.name.startsWith('config_') && file.name.endsWith('.json')) {
          const filePath = `${this.cachePath}/${file.name}`;
          try {
            const fileInfo = await fs.getFileStat(filePath);
            const cacheTime = fileInfo.mtimeMs || fileInfo.ctimeMs || Date.now();
            
            if (now - cacheTime > cacheExpiry) {
              await fs.unlink(filePath);
              Logger.debug(TAG, `Deleted expired cache file: ${file.name}`);
            }
          } catch (fileError) {
            Logger.error(TAG, `Failed to check/delete cache file ${file.name}`, fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError)))))))));
          }
        }
      }
      
      Logger.info(TAG, 'Expired cache cleaned successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to clean expired cache', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))))));
    }
  }
  
  /**
   * è·å–ç¼“å­˜ä¿¡æ¯
   */
  public async getCacheInfo(): Promise<{
    cacheSize: number;
    cacheFiles: number;
    lastCacheTime: number;
  }> {
    try {
      const files = await fs.listFile(this.cachePath);
      const configFiles = files.filter(file => 
        file.name.startsWith('config_') && file.name.endsWith('.json')
      );
      
      let totalSize = 0;
      let lastTime = 0;
      
      for (const file of configFiles) {
        const fileInfo = await fs.getFileStat(`${this.cachePath}/${file.name}`);
        totalSize += fileInfo.size || 0;
        const fileTime = fileInfo.mtimeMs || fileInfo.ctimeMs || 0;
        if (fileTime > lastTime) {
          lastTime = fileTime;
        }
      }
      
      return {
        cacheSize: totalSize,
        cacheFiles: configFiles.length,
        lastCacheTime: lastTime
      };
    } catch (error) {
      Logger.error(TAG, 'Failed to get cache info', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))))));
      return {
        cacheSize: 0,
        cacheFiles: 0,
        lastCacheTime: 0
      };
    }
  }
  
  /**
   * è§„èŒƒåŒ–ç¼“å­˜æ—¶é—?   * @param hours ç¼“å­˜æ—¶é—´ï¼ˆå°æ—¶ï¼‰
   */
  private normalizeCacheTime(hours?: number): number {
    if (hours === undefined) {
      return this.defaultCacheHours;
    }
    return Math.max(this.minCacheHours, Math.min(this.maxCacheHours, Math.floor(hours)));
  }
  
  /**
   * è®¾ç½®ç¼“å­˜æ—¶é—´èŒƒå›´
   * @param minHours æœ€å°ç¼“å­˜æ—¶é—´ï¼ˆå°æ—¶ï¼?   * @param maxHours æœ€å¤§ç¼“å­˜æ—¶é—´ï¼ˆå°æ—¶ï¼?   */
  public setCacheTimeRange(minHours: number, maxHours: number): void {
    this.minCacheHours = Math.max(24, minHours);
    this.maxCacheHours = Math.min(72, Math.max(this.minCacheHours, maxHours));
    this.defaultCacheHours = this.minCacheHours; // é»˜è®¤ä½¿ç”¨æœ€å°ç¼“å­˜æ—¶é—?    Logger.info(TAG, `Cache time range set to ${this.minCacheHours}-${this.maxCacheHours} hours`);
  }
}


