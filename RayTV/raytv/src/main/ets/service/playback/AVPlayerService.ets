// AVPlayerService.ets - AVæ’­æ”¾å™¨æœåŠ?// å®ç°åŸºäºHarmonyOS AVPlayerçš„åª’ä½“æ’­æ”¾åŠŸèƒ?
import media from '@ohos.multimedia.media';
import Logger from '../../common/util/Logger';
import { EventEmitter } from '../../common/util/EventEmitter';

// æ’­æ”¾çŠ¶æ€æšä¸?export enum PlaybackStatus {
  IDLE = 'idle',
  INITIALIZED = 'initialized',
  PREPARING = 'preparing',
  PREPARED = 'prepared',
  PLAYING = 'playing',
  PAUSED = 'paused',
  SEEKING = 'seeking',
  ENDED = 'ended',
  ERROR = 'error'
}

/**
 * AVæ’­æ”¾å™¨æœåŠ¡ç±»
 * æä¾›åª’ä½“æ’­æ”¾çš„æ ¸å¿ƒåŠŸèƒ? */
export class AVPlayerService extends EventEmitter {
  private static instance: AVPlayerService;
  private avPlayer: media.AVPlayer | null = null;
  private status: PlaybackStatus = PlaybackStatus.IDLE;
  private sourceUrl: string = '';
  private isInitialized: boolean = false;
  private TAG: string = 'AVPlayerService';

  private constructor() {
    super();
  }

  /**
   * è·å–æ’­æ”¾å™¨æœåŠ¡å•ä¾‹å®ä¾?   */
  public static getInstance(): AVPlayerService {
    if (!AVPlayerService.instance) {
      AVPlayerService.instance = new AVPlayerService();
    }
    return AVPlayerService.instance;
  }

  /**
   * åˆå§‹åŒ–æ’­æ”¾å™¨
   */
  private async initializePlayer(): Promise<void> {
    try {
      if (this.avPlayer) {
        await this.release();
      }

      this.avPlayer = await media.createAVPlayer();
      this.isInitialized = true;
      this.updateStatus(PlaybackStatus.IDLE);

      // çŠ¶æ€å˜åŒ–å›è°?      this.avPlayer.on('stateChange', (state, reason) => {
        Logger.info(this.TAG, `Player state changed: ${state}, reason: ${reason}`);
        this.updateStatus(this.mapAVPlayerState(state));
        this.emit('stateChange', this.status, reason);
      });

      // é”™è¯¯å›è°ƒ
      this.avPlayer.on('error', (error: media.AVPlayerError) => {
        Logger.error(this.TAG, `Player error: ${error.code}, message: ${error.message}`);
        this.updateStatus(PlaybackStatus.ERROR);
        this.emit('error', error.code, error.message);
      });

      // ç¼“å†²æ›´æ–°å›è°ƒ
      this.avPlayer.on('bufferingUpdate', (info: media.BufferingInfo) => {
        Logger.info(this.TAG, `Buffering update: ${info.bufferingPercentage}%`);
        this.emit('bufferingChange', info.bufferingPercentage);
      });

      // æ’­æ”¾å®Œæˆå›è°ƒ
      this.avPlayer.on('playbackComplete', () => {
        Logger.info(this.TAG, 'Playback completed');
        this.updateStatus(PlaybackStatus.ENDED);
        this.emit('playbackComplete');
      });
    } catch (error) {
      Logger.error(this.TAG, `Failed to initialize player: ${JSON.stringify(error)}`);
      this.updateStatus(PlaybackStatus.ERROR);
      throw error;
    }
  }

  /**
   * æ˜ å°„AVPlayerçŠ¶æ€åˆ°è‡ªå®šä¹‰çŠ¶æ€?   */
  private mapAVPlayerState(state: number): PlaybackStatus {
    switch (state) {
      case media.AVPlayerState.IDLE:
        return PlaybackStatus.IDLE;
      case media.AVPlayerState.INITIALIZED:
        return PlaybackStatus.INITIALIZED;
      case media.AVPlayerState.PREPARING:
        return PlaybackStatus.PREPARING;
      case media.AVPlayerState.PREPARED:
        return PlaybackStatus.PREPARED;
      case media.AVPlayerState.PLAYING:
        return PlaybackStatus.PLAYING;
      case media.AVPlayerState.PAUSED:
        return PlaybackStatus.PAUSED;
      case media.AVPlayerState.SEEKING:
        return PlaybackStatus.SEEKING;
      case media.AVPlayerState.COMPLETED:
        return PlaybackStatus.ENDED;
      case media.AVPlayerState.ERROR:
        return PlaybackStatus.ERROR;
      default:
        return PlaybackStatus.IDLE;
    }
  }

  /**
   * æ›´æ–°æ’­æ”¾çŠ¶æ€?   */
  private updateStatus(newStatus: PlaybackStatus): void {
    if (this.status !== newStatus) {
      this.status = newStatus;
      this.emit('statusChange', newStatus);
    }
  }

  /**
   * è®¾ç½®æ’­æ”¾æº?   * @param source æ’­æ”¾æºURL
   */
  public async setSource(source: string): Promise<void> {
    try {
      if (!this.avPlayer) {
        await this.initializePlayer();
      }
      
      this.sourceUrl = source;
      await this.avPlayer.setSource(source);
      this.updateStatus(PlaybackStatus.INITIALIZED);
      Logger.info(this.TAG, `Source set: ${source}`);
    } catch (error) {
      Logger.error(this.TAG, `Failed to set source: ${JSON.stringify(error)}`);
      this.updateStatus(PlaybackStatus.ERROR);
      throw error;
    }
  }

  /**
   * å‡†å¤‡æ’­æ”¾
   */
  public async prepare(): Promise<void> {
    try {
      if (!this.avPlayer) {
        throw new Error('Player not initialized');
      }
      
      this.updateStatus(PlaybackStatus.PREPARING);
      await this.avPlayer.prepare();
      this.updateStatus(PlaybackStatus.PREPARED);
    } catch (error) {
      Logger.error(this.TAG, `Failed to prepare: ${JSON.stringify(error)}`);
      this.updateStatus(PlaybackStatus.ERROR);
      throw error;
    }
  }

  /**
   * å¼€å§‹æ’­æ”?   */
  public async play(): Promise<void> {
    try {
      if (!this.avPlayer) {
        throw new Error('Player not initialized');
      }
      
      await this.avPlayer.play();
      this.updateStatus(PlaybackStatus.PLAYING);
    } catch (error) {
      Logger.error(this.TAG, `Failed to play: ${JSON.stringify(error)}`);
      this.updateStatus(PlaybackStatus.ERROR);
      throw error;
    }
  }

  /**
   * æš‚åœæ’­æ”¾
   */
  public async pause(): Promise<void> {
    try {
      if (!this.avPlayer) {
        throw new Error('Player not initialized');
      }
      
      await this.avPlayer.pause();
      this.updateStatus(PlaybackStatus.PAUSED);
    } catch (error) {
      Logger.error(this.TAG, `Failed to pause: ${JSON.stringify(error)}`);
      this.updateStatus(PlaybackStatus.ERROR);
      throw error;
    }
  }

  /**
   * åœæ­¢æ’­æ”¾
   */
  public async stop(): Promise<void> {
    try {
      if (!this.avPlayer) {
        throw new Error('Player not initialized');
      }
      
      await this.avPlayer.stop();
      this.updateStatus(PlaybackStatus.IDLE);
    } catch (error) {
      Logger.error(this.TAG, `Failed to stop: ${JSON.stringify(error)}`);
      this.updateStatus(PlaybackStatus.ERROR);
      throw error;
    }
  }

  /**
   * è·³è½¬åˆ°æŒ‡å®šä½ç½?   * @param position ä½ç½®ï¼ˆæ¯«ç§’ï¼‰
   */
  public async seekTo(position: number): Promise<void> {
    try {
      if (!this.avPlayer) {
        throw new Error('Player not initialized');
      }
      
      this.updateStatus(PlaybackStatus.SEEKING);
      await this.avPlayer.seek(position);
      // çŠ¶æ€ä¼šåœ¨seekå®Œæˆåé€šè¿‡stateChangeå›è°ƒæ›´æ–°
    } catch (error) {
      Logger.error(this.TAG, `Failed to seek: ${JSON.stringify(error)}`);
      this.updateStatus(PlaybackStatus.ERROR);
      throw error;
    }
  }

  /**
   * è®¾ç½®æ’­æ”¾é€Ÿåº¦
   * @param speed æ’­æ”¾é€Ÿåº¦ï¼?.0ä¸ºæ­£å¸¸é€Ÿåº¦ï¼?   */
  public async setSpeed(speed: number): Promise<void> {
    try {
      if (!this.avPlayer) {
        throw new Error('Player not initialized');
      }
      
      await this.avPlayer.setSpeed(speed);
      Logger.info(this.TAG, `Speed set to: ${speed}`);
    } catch (error) {
      Logger.error(this.TAG, `Failed to set speed: ${JSON.stringify(error)}`);
      throw error;
    }
  }

  /**
   * è®¾ç½®éŸ³é‡
   * @param volume éŸ³é‡å€¼ï¼ˆ0.0-1.0ï¼?   */
  public async setVolume(volume: number): Promise<void> {
    try {
      if (!this.avPlayer) {
        throw new Error('Player not initialized');
      }
      
      await this.avPlayer.setVolume(volume);
      Logger.info(this.TAG, `Volume set to: ${volume}`);
    } catch (error) {
      Logger.error(this.TAG, `Failed to set volume: ${JSON.stringify(error)}`);
      throw error;
    }
  }

  /**
   * è·å–å½“å‰æ’­æ”¾ä½ç½®
   * @returns å½“å‰ä½ç½®ï¼ˆæ¯«ç§’ï¼‰
   */
  public async getCurrentPosition(): Promise<number> {
    try {
      if (!this.avPlayer) {
        throw new Error('Player not initialized');
      }
      
      return await this.avPlayer.getCurrentTime();
    } catch (error) {
      Logger.error(this.TAG, `Failed to get current position: ${JSON.stringify(error)}`);
      return 0;
    }
  }

  /**
   * è·å–åª’ä½“æ€»æ—¶é•?   * @returns æ€»æ—¶é•¿ï¼ˆæ¯«ç§’ï¼?   */
  public async getDuration(): Promise<number> {
    try {
      if (!this.avPlayer) {
        throw new Error('Player not initialized');
      }
      
      return await this.avPlayer.getDuration();
    } catch (error) {
      Logger.error(this.TAG, `Failed to get duration: ${JSON.stringify(error)}`);
      return 0;
    }
  }

  /**
   * è·å–å½“å‰æ’­æ”¾çŠ¶æ€?   * @returns æ’­æ”¾çŠ¶æ€?   */
  public getStatus(): PlaybackStatus {
    return this.status;
  }

  /**
   * è·å–å½“å‰æ’­æ”¾æºURL
   * @returns æ’­æ”¾æºURL
   */
  public getSourceUrl(): string {
    return this.sourceUrl;
  }

  /**
   * é‡Šæ”¾æ’­æ”¾å™¨èµ„æº?   */
  public async release(): Promise<void> {
    try {
      if (this.avPlayer) {
        await this.avPlayer.release();
        this.avPlayer = null;
        this.isInitialized = false;
        this.sourceUrl = '';
        this.updateStatus(PlaybackStatus.IDLE);
        Logger.info(this.TAG, 'Player released');
      }
    } catch (error) {
      Logger.error(this.TAG, `Failed to release player: ${JSON.stringify(error)}`);
      // é‡Šæ”¾å¤±è´¥ä¸å½±å“å…¶ä»–æ“ä½?    }
  }

  /**
   * é‡ç½®æ’­æ”¾å™?   */
  public async reset(): Promise<void> {
    try {
      if (!this.avPlayer) {
        throw new Error('Player not initialized');
      }
      
      await this.avPlayer.reset();
      this.updateStatus(PlaybackStatus.IDLE);
      Logger.info(this.TAG, 'Player reset');
    } catch (error) {
      Logger.error(this.TAG, `Failed to reset player: ${JSON.stringify(error)}`);
      this.updateStatus(PlaybackStatus.ERROR);
      throw error;
    }
  }

  /**
   * æ£€æŸ¥æ’­æ”¾å™¨æ˜¯å¦å·²åˆå§‹åŒ–
   * @returns æ˜¯å¦å·²åˆå§‹åŒ–
   */
  public isPlayerInitialized(): boolean {
    return this.isInitialized && this.avPlayer !== null;
  }

  /**
   * è·å–æ’­æ”¾å™¨å®ä¾?   * @returns AVPlayerå®ä¾‹
   */
  public getPlayer(): media.AVPlayer | null {
    return this.avPlayer;
  }
}
