// PlaybackService.ets - æ’­æ”¾æœåŠ¡
// è´Ÿè´£è§†é¢‘æ’­æ”¾æ§åˆ¶ã€æ’­æ”¾çŠ¶æ€ç®¡ç†å’Œæ’­æ”¾é˜Ÿåˆ—ç®¡ç†

import Logger from '../../common/util/Logger';
import ConfigService from '../config/ConfigService';
import HistoryManager from './HistoryManager';
import AVPlay from '@ohos.multimedia.media';
import AudioManager from '@ohos.multimedia.audio';
import AudioRendererInfo from '@ohos.multimedia.audio';
import BusinessError from '@ohos.base';
import { DeviceInfoRepository } from '../../data/repository/DeviceInfoRepository';

// å¸¸é‡å®šä¹‰
const TAG = 'PlaybackService';
const MAX_PLAYBACK_QUEUE_SIZE = 100;
const PLAYBACK_BUFFER_SIZE = 8 * 1024 * 1024; // 8MB
const MIN_RETRY_INTERVAL = 3000; // æœ€å°é‡è¯•é—´éš?const MAX_RETRY_COUNT = 3; // æœ€å¤§é‡è¯•æ¬¡æ•?
// æ’­æ”¾çŠ¶æ€æšä¸?export enum PlaybackState {
  IDLE = 0,           // ç©ºé—²çŠ¶æ€?  INITIALIZING = 1,   // åˆå§‹åŒ–ä¸­
  PREPARING = 2,      // å‡†å¤‡ä¸?  READY = 3,          // å‡†å¤‡å°±ç»ª
  PLAYING = 4,        // æ’­æ”¾ä¸?  PAUSED = 5,         // æš‚åœ
  SEEKING = 6,        // è·³è½¬ä¸?  BUFFERING = 7,      // ç¼“å†²ä¸?  COMPLETED = 8,      // æ’­æ”¾å®Œæˆ
  ERROR = 9           // é”™è¯¯çŠ¶æ€?}

// æ’­æ”¾é”™è¯¯ç±»å‹æšä¸¾
export enum PlaybackErrorType {
  NETWORK = 0,        // ç½‘ç»œé”™è¯¯
  DECODE = 1,         // è§£ç é”™è¯¯
  PERMISSION = 2,     // æƒé™é”™è¯¯
  RESOURCE = 3,       // èµ„æºé”™è¯¯
  TIMEOUT = 4,        // è¶…æ—¶é”™è¯¯
  DRM = 5,            // DRMé”™è¯¯
  UNKNOWN = 6         // æœªçŸ¥é”™è¯¯
}

// éŸ³é¢‘è·¯ç”±ç±»å‹æšä¸¾
export enum AudioRoute {
  SPEAKER = 0,        // æ‰¬å£°å™?  EARPIECE = 1,       // å¬ç­’
  WIRED_HEADSET = 2,  // æœ‰çº¿è€³æœº
  BLUETOOTH = 3       // è“ç‰™è€³æœº
}

// æ’­æ”¾é€Ÿåº¦æšä¸¾
export enum PlaybackSpeed {
  SPEED_0_5X = 0.5,
  SPEED_0_75X = 0.75,
  SPEED_1_0X = 1.0,
  SPEED_1_25X = 1.25,
  SPEED_1_5X = 1.5,
  SPEED_2_0X = 2.0
}

// å­—å¹•é£æ ¼æ¥å£
export interface SubtitleStyle {
  fontSize: number;      // å­—ä½“å¤§å°
  fontColor: string;     // å­—ä½“é¢œè‰²
  backgroundColor: string; // èƒŒæ™¯é¢œè‰²
  edgeType: 'none' | 'dropShadow' | 'raised' | 'depressed' | 'uniform'; // è¾¹ç¼˜ç±»å‹
  edgeColor: string;     // è¾¹ç¼˜é¢œè‰²
  fontFamily: string;    // å­—ä½“
  bold: boolean;         // æ˜¯å¦ç²—ä½“
  italic: boolean;       // æ˜¯å¦æ–œä½“
  opacity: number;       // é€æ˜åº?  position: 'bottom' | 'top' | 'custom'; // ä½ç½®
  customPosition?: number; // è‡ªå®šä¹‰ä½ç½®ç™¾åˆ†æ¯”
}

// é»˜è®¤å­—å¹•é£æ ¼
export const DEFAULT_SUBTITLE_STYLE: SubtitleStyle = {
  fontSize: 20,
  fontColor: '#FFFFFF',
  backgroundColor: 'rgba(0, 0, 0, 0.5)',
  edgeType: 'dropShadow',
  edgeColor: '#000000',
  fontFamily: 'default',
  bold: false,
  italic: false,
  opacity: 1.0,
  position: 'bottom'
};

// è§†é¢‘å…ƒæ•°æ®æ¥å?export interface VideoMetadata {
  // åŸºç¡€ä¿¡æ¯
  width?: number;           // è§†é¢‘å®½åº¦
  height?: number;          // è§†é¢‘é«˜åº¦
  aspectRatio?: number;     // å®½é«˜æ¯?  resolution?: string;      // åˆ†è¾¨ç‡æè¿°ï¼ˆå¦?080p, 4Kï¼?  
  // ç¼–ç ä¿¡æ¯
  videoCodec?: string;      // è§†é¢‘ç¼–ç æ ¼å¼
  audioCodec?: string;      // éŸ³é¢‘ç¼–ç æ ¼å¼
  bitrate?: number;         // æ¯”ç‰¹ç?  
  // å†…å®¹ä¿¡æ¯
  author?: string;          // ä½œè€?ä¸Šä¼ è€?  channelName?: string;     // é¢‘é“åç§°
  publishDate?: string;     // å‘å¸ƒæ—¥æœŸ
  description?: string;     // æè¿°
  
  // åˆ†ç±»ä¿¡æ¯
  category?: string;        // åˆ†ç±»
  tags?: string[];          // æ ‡ç­¾
  
  // ç»Ÿè®¡ä¿¡æ¯
  viewCount?: number;       // è§‚çœ‹æ¬¡æ•°
  likeCount?: number;       // ç‚¹èµæ•?  commentCount?: number;    // è¯„è®ºæ•?  
  // å…¶ä»–è‡ªå®šä¹‰å­—æ®?  customData?: Record<string, string | number | boolean>; // å…¶ä»–è‡ªå®šä¹‰æ•°æ?}

// æ’­æ”¾é¡¹æ¥å?export interface PlaybackItem {
  id: string;               // æ’­æ”¾é¡¹ID
  title: string;            // æ ‡é¢˜
  subtitle?: string;        // å‰¯æ ‡é¢?  url: string;              // æ’­æ”¾åœ°å€
  type: 'video' | 'audio' | 'live'; // ç±»å‹
  duration: number;         // æ€»æ—¶é•¿ï¼ˆæ¯«ç§’ï¼?  position?: number;        // å½“å‰æ’­æ”¾ä½ç½®ï¼ˆæ¯«ç§’ï¼‰
  coverUrl?: string;        // å°é¢å›¾ç‰‡
  posterUrl?: string;       // æµ·æŠ¥å›¾ç‰‡
  metadata?: VideoMetadata; // é¢å¤–å…ƒæ•°æ?  subtitles?: SubtitleItem[]; // å­—å¹•åˆ—è¡¨
  currentSubtitleIndex?: number; // å½“å‰å­—å¹•ç´¢å¼•
}

// å­—å¹•é¡¹æ¥å?export interface SubtitleItem {
  id: string;               // å­—å¹•ID
  title: string;            // å­—å¹•æ ‡é¢˜
  language: string;         // è¯­è¨€ä»£ç 
  url: string;              // å­—å¹•æ–‡ä»¶URL
  format: 'srt' | 'vtt' | 'ass' | 'ssa'; // å­—å¹•æ ¼å¼
  isDefault?: boolean;      // æ˜¯å¦é»˜è®¤å­—å¹•
  isExternal?: boolean;     // æ˜¯å¦å¤–éƒ¨å­—å¹•
  encoding?: string;        // ç¼–ç æ ¼å¼
}

// æ’­æ”¾é…ç½®æ¥å£
export interface PlaybackConfig {
  autoPlay: boolean;        // è‡ªåŠ¨æ’­æ”¾
  rememberPosition: boolean; // è®°ä½æ’­æ”¾ä½ç½®
  defaultPlaybackSpeed: number; // é»˜è®¤æ’­æ”¾é€Ÿåº¦
  enableHardwareDecoding: boolean; // å¯ç”¨ç¡¬ä»¶è§£ç 
  enableBackgroundPlayback: boolean; // å¯ç”¨åå°æ’­æ”¾
  enableAutoPause: boolean; // å¯ç”¨è‡ªåŠ¨æš‚åœ
  autoPauseOnCall: boolean; // é€šè¯æ—¶è‡ªåŠ¨æš‚å?  enableAudioFocus: boolean; // å¯ç”¨éŸ³é¢‘ç„¦ç‚¹
  audioRoute: AudioRoute;   // éŸ³é¢‘è·¯ç”±
  bufferSize: number;       // ç¼“å†²åŒºå¤§å°?  bufferTime: number;       // ç¼“å†²æ—¶é—´
  maxRetryCount: number;    // æœ€å¤§é‡è¯•æ¬¡æ•?  subtitleStyle: SubtitleStyle; // å­—å¹•æ ·å¼
  volume: number;           // éŸ³é‡
  mute: boolean;            // æ˜¯å¦é™éŸ³
}

// é»˜è®¤æ’­æ”¾é…ç½®
export const DEFAULT_PLAYBACK_CONFIG: PlaybackConfig = {
  autoPlay: true,
  rememberPosition: true,
  defaultPlaybackSpeed: 1.0,
  enableHardwareDecoding: true,
  enableBackgroundPlayback: true,
  enableAutoPause: true,
  autoPauseOnCall: true,
  enableAudioFocus: true,
  audioRoute: AudioRoute.SPEAKER,
  bufferSize: PLAYBACK_BUFFER_SIZE,
  bufferTime: 5000,
  maxRetryCount: MAX_RETRY_COUNT,
  subtitleStyle: DEFAULT_SUBTITLE_STYLE,
  volume: 1.0,
  mute: false
};

// æ’­æ”¾é”™è¯¯æ¥å£
export interface PlaybackError {
  code: number;             // é”™è¯¯ç ?  message: string;          // é”™è¯¯ä¿¡æ¯
  type: PlaybackErrorType;  // é”™è¯¯ç±»å‹
  details?: Record<string, string | number | boolean | null>;            // é”™è¯¯è¯¦æƒ…
}

// ç¼“å†²ä¿¡æ¯æ¥å£
export interface BufferingInfo {
  percent: number;          // ç¼“å†²ç™¾åˆ†æ¯?  currentRange: { start: number; end: number }; // å½“å‰ç¼“å†²èŒƒå›´
  loadedRanges: Array<{ start: number; end: number }>; // å·²åŠ è½½ç¼“å†²èŒƒå›?  totalBytesLoaded: number; // å·²åŠ è½½å­—èŠ‚æ•°
  totalBytes: number;       // æ€»å­—èŠ‚æ•°
}

// æ’­æ”¾çŠ¶æ€å˜åŒ–ç›‘å¬å™¨ç±»å‹
type PlaybackStateListener = (state: PlaybackState) => void;

// æ’­æ”¾é”™è¯¯ç›‘å¬å™¨ç±»å?type PlaybackErrorListener = (error: PlaybackError) => void;

// æ’­æ”¾è¿›åº¦ç›‘å¬å™¨ç±»å?type PlaybackProgressListener = (position: number, duration: number, percent: number) => void;

// ç¼“å†²çŠ¶æ€ç›‘å¬å™¨ç±»å‹
type BufferingStateListener = (info: BufferingInfo) => void;

// æ’­æ”¾é˜Ÿåˆ—å˜åŒ–ç›‘å¬å™¨ç±»å?type PlaybackQueueListener = (queue: PlaybackItem[], currentIndex: number) => void;

export default class PlaybackService {
  private static instance: PlaybackService;
  private configService: ConfigService;
  private historyManager: HistoryManager;
  private deviceInfoRepository: DeviceInfoRepository;
  private config: PlaybackConfig = DEFAULT_PLAYBACK_CONFIG;
  private retryCount: number = 0; // é”™è¯¯é‡è¯•è®¡æ•°
  private avPlayInstance: AVPlay | null = null;
  private currentPlaybackItem: PlaybackItem | null = null;
  private playbackQueue: PlaybackItem[] = [];
  private currentQueueIndex: number = -1;
  private currentState: PlaybackState = PlaybackState.IDLE;
  private playbackSpeed: number = 1.0;
  private volume: number = 1.0;
  private isMuted: boolean = false;
  private subtitleVisible: boolean = true;
  private retryCount: number = 0;
  private lastRetryTime: number = 0;
  private isInitialized: boolean = false;
  private audioManager: AudioManager | null = null;
  private isBackgroundPlaybackEnabled: boolean = false;
  private lastPosition: number = 0;
  private lastPositionUpdateTime: number = 0;
  private positionUpdateTimerId: number | null = null;
  
  // ç›‘å¬å™¨åˆ—è¡?  private stateListeners: PlaybackStateListener[] = [];
  private errorListeners: PlaybackErrorListener[] = [];
  private progressListeners: PlaybackProgressListener[] = [];
  private bufferingListeners: BufferingStateListener[] = [];
  private queueListeners: PlaybackQueueListener[] = [];

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): PlaybackService {
    if (!PlaybackService.instance) {
      PlaybackService.instance = new PlaybackService();
    }
    return PlaybackService.instance;
  }

  /**
   * æ„é€ å‡½æ•?   */
  private constructor() {
    this.configService = ConfigService.getInstance();
    this.historyManager = HistoryManager.getInstance();
    this.deviceInfoRepository = DeviceInfoRepository.getInstance();
  }

  /**
   * åˆå§‹åŒ–æ’­æ”¾æœåŠ?   * @param context åº”ç”¨ä¸Šä¸‹æ–?   */
  public async initialize(context: Context): Promise<void> {
    if (this.isInitialized) {
      Logger.info(TAG, 'Playback service already initialized');
      return;
    }

    try {
      Logger.info(TAG, 'Initializing playback service...');

      // åŠ è½½é…ç½®
      await this.loadConfig();
      
      // åˆå§‹åŒ–éŸ³é¢‘ç®¡ç†å™¨
      this.audioManager = AudioManager.getInstance(context);
      
      // è®¾ç½®é»˜è®¤éŸ³é‡
      this.volume = this.config.volume;
      this.isMuted = this.config.mute;
      
      // è®¾ç½®æ’­æ”¾é€Ÿåº¦
      this.playbackSpeed = this.config.defaultPlaybackSpeed;
      
      this.isInitialized = true;
      Logger.info(TAG, 'Playback service initialized successfully');
    } catch (error) {
      Logger.error(TAG, `Failed to initialize playback service: ${JSON.stringify(error)}`);
      throw error;
    }
  }

  /**
   * åŠ è½½é…ç½®
   */
  private async loadConfig(): Promise<void> {
    try {
      const savedConfig = await this.configService.getConfig('playbackConfig', DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG instanceof Error ? DEFAULT_PLAYBACK_CONFIG : new Error(String(DEFAULT_PLAYBACK_CONFIG)))))));
      if (savedConfig) {
        this.config = { ...DEFAULT_PLAYBACK_CONFIG, ...savedConfig };
      }
    } catch (error) {
      Logger.error(TAG, `Failed to load playback config: ${error}`);
    }
  }

  /**
   * ä¿å­˜é…ç½®
   */
  public async saveConfig(config: Partial<PlaybackConfig>): Promise<void> {
    try {
      this.config = { ...this.config, ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined instanceof Error ? ...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined : new Error(String(...config };
      
      // æ›´æ–°è¿è¡Œæ—¶é…ç½?      if (config.volume !== undefined))))))) {
        this.volume = config.volume;
        if (this.avPlayInstance) {
          this.avPlayInstance.setVolume(this.volume);
        }
      }
      
      if (config.mute !== undefined) {
        this.isMuted = config.mute;
        if (this.avPlayInstance) {
          this.avPlayInstance.setMute(this.isMuted);
        }
      }
      
      if (config.audioRoute !== undefined) {
        await this.setAudioRoute(config.audioRoute);
      }
      
      await this.configService.setConfig('playbackConfig', this.config);
    } catch (error) {
      Logger.error(TAG, `Failed to save playback config: ${error}`);
      throw error;
    }
  }

  /**
   * è·å–é…ç½®
   */
  public getConfig(): PlaybackConfig {
    return { ...this.config };
  }

  /**
   * åˆ›å»ºAVPlayå®ä¾‹
   */
  private async createAVPlayInstance(): Promise<void> {
    try {
      // å¦‚æœå·²æœ‰å®ä¾‹ï¼Œå…ˆé‡Šæ”¾
      if (this.avPlayInstance) {
        await this.releaseAVPlayInstance();
      }

      // åˆ›å»ºæ–°å®ä¾?      this.avPlayInstance = await AVPlay.create();
      
      // è®¾ç½®æ’­æ”¾æ¨¡å¼
      await this.avPlayInstance.setAutoPlay(this.config.autoPlay);
      await this.avPlayInstance.setLoop(false);
      
      // æ ¹æ®è®¾å¤‡èƒ½åŠ›è®¾ç½®æœ€ä½³è§£ç æ¨¡å¼?      await this.setupOptimalDecodingMode();
      
      // è®¾ç½®ç¼“å†²å¤§å°
      await this.avPlayInstance.setParameter('cacheSize', this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString( instanceof Error ? this.config.bufferSize.toString( : new Error(String(this.config.bufferSize.toString())))))));
      
      // è®¾ç½®éŸ³é‡å’Œé™éŸ?      await this.avPlayInstance.setVolume(this.isMuted ? 0 : this.volume);
      await this.avPlayInstance.setMute(this.isMuted);
      
      // è®¾ç½®æ’­æ”¾é€Ÿåº¦
      await this.avPlayInstance.setSpeed(this.playbackSpeed);
      
      // æ³¨å†Œäº‹ä»¶ç›‘å¬
      this.setupEventListeners();
      
      Logger.info(TAG, 'AVPlay instance created successfully');
    } catch (error) {
      Logger.error(TAG, `Failed to create AVPlay instance: ${error}`);
      throw error;
    }
  }
  
  /**
   * æ ¹æ®è®¾å¤‡èƒ½åŠ›è®¾ç½®æœ€ä½³è§£ç æ¨¡å¼?   */
  private async setupOptimalDecodingMode(): Promise<void> {
    if (!this.avPlayInstance) return;
    
    try {
      // æ£€æŸ¥è®¾å¤‡æ˜¯å¦æ”¯æŒç¡¬ä»¶è§£ç ?      if (this.config.enableHardwareDecoding) {
        try {
          // å…ˆå°è¯•ç¡¬ä»¶è§£ç ?          await this.avPlayInstance.setParameter('videoDecodingMode', 'hardware' instanceof Error ? 'hardware' : new Error(String('hardware' instanceof Error ? 'hardware' instanceof Error ? 'hardware' : new Error(String('hardware' : new Error(String('hardware' instanceof Error ? 'hardware' : new Error(String('hardware' instanceof Error ? 'hardware' instanceof Error ? 'hardware' : new Error(String('hardware' instanceof Error ? 'hardware' instanceof Error ? 'hardware' : new Error(String('hardware' : new Error(String('hardware' instanceof Error ? 'hardware' : new Error(String('hardware' : new Error(String('hardware' instanceof Error ? 'hardware' : new Error(String('hardware' instanceof Error ? 'hardware' instanceof Error ? 'hardware' : new Error(String('hardware' : new Error(String('hardware' instanceof Error ? 'hardware' : new Error(String('hardware')))))));
          Logger.info(TAG, 'Hardware decoding enabled');
        } catch (error) {
          // ç¡¬ä»¶è§£ç å¤±è´¥ï¼Œå›é€€åˆ°è½¯ä»¶è§£ç ?          Logger.warn(TAG, 'Hardware decoding not supported, falling back to software decoding');
          await this.avPlayInstance.setParameter('videoDecodingMode', 'software');
          // æ›´æ–°é…ç½®ï¼Œé¿å…ä¸‹æ¬¡å†æ¬¡å°è¯•å¤±è´¥çš„è§£ç æ¨¡å¼
          this.config.enableHardwareDecoding = false;
        }
      } else {
        // ç›´æ¥ä½¿ç”¨è½¯ä»¶è§£ç 
        await this.avPlayInstance.setParameter('videoDecodingMode', 'software');
        Logger.info(TAG, 'Software decoding enabled');
      }
    } catch (error) {
      Logger.error(TAG, `Failed to setup decoding mode: ${error}`);
      // ç¡®ä¿è‡³å°‘è®¾ç½®ä¸ºè½¯ä»¶è§£ç ?      try {
        await this.avPlayInstance.setParameter('videoDecodingMode', 'software' instanceof Error ? 'software' : new Error(String('software' instanceof Error ? 'software' instanceof Error ? 'software' : new Error(String('software' : new Error(String('software' instanceof Error ? 'software' : new Error(String('software' instanceof Error ? 'software' instanceof Error ? 'software' : new Error(String('software' instanceof Error ? 'software' instanceof Error ? 'software' : new Error(String('software' : new Error(String('software' instanceof Error ? 'software' : new Error(String('software' : new Error(String('software' instanceof Error ? 'software' : new Error(String('software' instanceof Error ? 'software' instanceof Error ? 'software' : new Error(String('software' : new Error(String('software' instanceof Error ? 'software' : new Error(String('software')))))));
      } catch (fallbackError) {
        Logger.error(TAG, `Failed to fallback to software decoding: ${fallbackError}`);
      }
    }
  }

  /**
   * è®¾ç½®äº‹ä»¶ç›‘å¬å™?   */
  private setupEventListeners(): void {
    if (!this.avPlayInstance) {
      return;
    }

    // çŠ¶æ€å˜åŒ–äº‹ä»?    this.avPlayInstance.on('stateChange', (state: number, reason: number instanceof Error ? (state: number, reason: number : new Error(String((state: number, reason: number instanceof Error ? (state: number, reason: number instanceof Error ? (state: number, reason: number : new Error(String((state: number, reason: number : new Error(String((state: number, reason: number instanceof Error ? (state: number, reason: number : new Error(String((state: number, reason: number instanceof Error ? (state: number, reason: number instanceof Error ? (state: number, reason: number : new Error(String((state: number, reason: number instanceof Error ? (state: number, reason: number instanceof Error ? (state: number, reason: number : new Error(String((state: number, reason: number : new Error(String((state: number, reason: number instanceof Error ? (state: number, reason: number : new Error(String((state: number, reason: number : new Error(String((state: number, reason: number instanceof Error ? (state: number, reason: number : new Error(String((state: number, reason: number instanceof Error ? (state: number, reason: number instanceof Error ? (state: number, reason: number : new Error(String((state: number, reason: number : new Error(String((state: number, reason: number instanceof Error ? (state: number, reason: number : new Error(String((state: number, reason: number))))))) => {
      this.handleStateChange(state, reason);
    });

    // é”™è¯¯äº‹ä»¶
    this.avPlayInstance.on('error', async (error: BusinessError) => {
      await this.handlePlaybackError(error);
    });

    // ç¼“å†²è¿›åº¦äº‹ä»¶
    this.avPlayInstance.on('bufferingChange', (bufferingStatus: number, startBufferBytes: number, bufferingBytes: number, totalBytes: number) => {
      this.handleBufferingChange(bufferingStatus, startBufferBytes, bufferingBytes, totalBytes);
    });

    // æ’­æ”¾å®Œæˆäº‹ä»¶
    this.avPlayInstance.on('playbackComplete', () => {
      this.handlePlaybackComplete();
    });
  }

  /**
   * å¤„ç†çŠ¶æ€å˜åŒ?   */
  private handleStateChange(state: number, reason: number): void {
    let newState: PlaybackState;
    
    switch (state) {
      case 0: // AVPlayState.IDLE
        newState = PlaybackState.IDLE;
        break;
      case 1: // AVPlayState.INITIALIZED
        newState = PlaybackState.INITIALIZING;
        break;
      case 2: // AVPlayState.PREPARED
        newState = PlaybackState.READY;
        break;
      case 3: // AVPlayState.PLAYING
        newState = PlaybackState.PLAYING;
        this.startPositionUpdates();
        break;
      case 4: // AVPlayState.PAUSED
        newState = PlaybackState.PAUSED;
        this.stopPositionUpdates();
        break;
      case 5: // AVPlayState.COMPLETED
        newState = PlaybackState.COMPLETED;
        this.stopPositionUpdates();
        break;
      case 6: // AVPlayState.STOPPED
        newState = PlaybackState.IDLE;
        this.stopPositionUpdates();
        break;
      default:
        newState = PlaybackState.UNKNOWN;
        break;
    }
    
    this.updatePlaybackState(newState);
    Logger.info(TAG, `Playback state changed to: ${newState}, reason: ${reason}`);
  }

  /**
   * å¤„ç†æ’­æ”¾é”™è¯¯
   */
  private async handlePlaybackError(error: BusinessError): Promise<void> {
    Logger.error(TAG, `Playback error occurred: ${JSON.stringify(error)}`);
    
    // è¯†åˆ«é”™è¯¯ç±»å‹
    const errorType = this.determineErrorType(error);
    
    const playbackError: PlaybackError = {
      code: error.code || -1, message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError instanceof Error ? message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError : new Error(String(message: error.message || 'Unknown error',
      type: errorType,
      details: error
    };
    
    // é€šçŸ¥é”™è¯¯ç›‘å¬å™?    this.notifyErrorListeners(playbackError)))))));
    
    // æ›´æ–°æ’­æ”¾çŠ¶æ€?    this.updatePlaybackState(PlaybackState.ERROR);
    
    // å°è¯•è‡ªåŠ¨æ¢å¤
    if (await this.attemptErrorRecovery(errorType)) {
      Logger.info(TAG, 'Successfully recovered from playback error');
    } else {
      Logger.warn(TAG, 'Failed to recover from playback error, giving up');
      // ä¿å­˜æ’­æ”¾ä½ç½®ä»¥ä¾¿åç»­æ¢å¤
      await this.savePlaybackPosition();
    }
  }
  
  /**
   * ç¡®å®šé”™è¯¯ç±»å‹
   */
  private determineErrorType(error: BusinessError): PlaybackErrorType {
    const errorCode = error.code || 0;
    const errorMessage = (error.message || '').toLowerCase();
    
    // åŸºäºé”™è¯¯ç å’Œé”™è¯¯ä¿¡æ¯ç¡®å®šé”™è¯¯ç±»å‹
    if (errorMessage.includes('network') || errorMessage.includes('connect') || errorMessage.includes('timeout')) {
      return PlaybackErrorType.NETWORK;
    } else if (errorMessage.includes('decode') || errorMessage.includes('codec') || errorMessage.includes('format')) {
      return PlaybackErrorType.DECODE;
    } else if (errorMessage.includes('permission') || errorMessage.includes('denied')) {
      return PlaybackErrorType.PERMISSION;
    } else if (errorMessage.includes('resource') || errorMessage.includes('not found')) {
      return PlaybackErrorType.RESOURCE;
    } else if (errorMessage.includes('timeout')) {
      return PlaybackErrorType.TIMEOUT;
    } else if (errorMessage.includes('drm')) {
      return PlaybackErrorType.DRM;
    } else {
      return PlaybackErrorType.UNKNOWN;
    }
  }
  
  /**
   * å°è¯•é”™è¯¯æ¢å¤
   */
  private async attemptErrorRecovery(errorType: PlaybackErrorType): Promise<boolean> {
    // æ£€æŸ¥é‡è¯•æ¬¡æ•°æ˜¯å¦è¶…é™?    if (this.retryCount >= MAX_RETRY_COUNT) {
      Logger.warn(TAG, `Max retry count (${MAX_RETRY_COUNT}) reached`);
      return false;
    }
    
    // å¢åŠ é‡è¯•è®¡æ•°
    this.retryCount++;
    Logger.info(TAG, `Attempting to recover from error, retry ${this.retryCount}/${MAX_RETRY_COUNT}`);
    
    try {
      // ç­‰å¾…ä¸€æ®µæ—¶é—´å†é‡è¯•
      await new Promise(resolve => setTimeout(resolve, MIN_RETRY_INTERVAL * this.retryCount));
      
      switch (errorType) {
        case PlaybackErrorType.NETWORK:
          // ç½‘ç»œé”™è¯¯ï¼šé‡æ–°åŠ è½½åª’ä½?          return await this.recoverFromNetworkError();
          
        case PlaybackErrorType.DECODE:
          // è§£ç é”™è¯¯ï¼šåˆ‡æ¢è§£ç æ¨¡å¼åé‡æ–°åŠ è½½
          return await this.recoverFromDecodeError();
          
        case PlaybackErrorType.TIMEOUT:
          // è¶…æ—¶é”™è¯¯ï¼šé‡æ–°è¿æ?          return await this.recoverFromTimeoutError();
          
        default:
          // å…¶ä»–é”™è¯¯ï¼šå°è¯•é‡æ–°åŠ è½?          return await this.recoverFromGenericError();
      }
    } catch (error) {
      Logger.error(TAG, `Recovery attempt failed: ${error}`);
      return false;
    }
  }
  
  /**
   * ä»ç½‘ç»œé”™è¯¯æ¢å¤?   */
  private async recoverFromNetworkError(): Promise<boolean> {
    if (!this.currentPlaybackItem) return false;
    
    try {
      Logger.info(TAG, 'Recovering from network error' instanceof Error ? 'Recovering from network error' : new Error(String('Recovering from network error' instanceof Error ? 'Recovering from network error' instanceof Error ? 'Recovering from network error' : new Error(String('Recovering from network error' : new Error(String('Recovering from network error' instanceof Error ? 'Recovering from network error' : new Error(String('Recovering from network error' instanceof Error ? 'Recovering from network error' instanceof Error ? 'Recovering from network error' : new Error(String('Recovering from network error' instanceof Error ? 'Recovering from network error' instanceof Error ? 'Recovering from network error' : new Error(String('Recovering from network error' : new Error(String('Recovering from network error' instanceof Error ? 'Recovering from network error' : new Error(String('Recovering from network error' : new Error(String('Recovering from network error' instanceof Error ? 'Recovering from network error' : new Error(String('Recovering from network error' instanceof Error ? 'Recovering from network error' instanceof Error ? 'Recovering from network error' : new Error(String('Recovering from network error' : new Error(String('Recovering from network error' instanceof Error ? 'Recovering from network error' : new Error(String('Recovering from network error')))))));
      // é‡æ–°åˆ›å»ºæ’­æ”¾å®ä¾‹
      await this.createAVPlayInstance();
      if (!this.avPlayInstance) return false;
      
      // é‡æ–°è®¾ç½®æ•°æ®æº?      await this.avPlayInstance.setSource(this.currentPlaybackItem.url);
      await this.avPlayInstance.prepare();
      
      // æ¢å¤åˆ°ä¸Šæ¬¡æ’­æ”¾ä½ç½?      if (this.lastPosition > 0) {
        await this.avPlayInstance.seekTo(this.lastPosition);
      }
      
      // æ¢å¤æ’­æ”¾
      if (this.config.autoPlay) {
        await this.avPlayInstance.play();
        this.updatePlaybackState(PlaybackState.PLAYING);
      }
      
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to recover from network error: ${error}`);
      return false;
    }
  }
  
  /**
   * ä»è§£ç é”™è¯¯æ¢å¤?   */
  private async recoverFromDecodeError(): Promise<boolean> {
    if (!this.currentPlaybackItem) return false;
    
    try {
      Logger.info(TAG, 'Recovering from decode error' instanceof Error ? 'Recovering from decode error' : new Error(String('Recovering from decode error' instanceof Error ? 'Recovering from decode error' instanceof Error ? 'Recovering from decode error' : new Error(String('Recovering from decode error' : new Error(String('Recovering from decode error' instanceof Error ? 'Recovering from decode error' : new Error(String('Recovering from decode error' instanceof Error ? 'Recovering from decode error' instanceof Error ? 'Recovering from decode error' : new Error(String('Recovering from decode error' instanceof Error ? 'Recovering from decode error' instanceof Error ? 'Recovering from decode error' : new Error(String('Recovering from decode error' : new Error(String('Recovering from decode error' instanceof Error ? 'Recovering from decode error' : new Error(String('Recovering from decode error' : new Error(String('Recovering from decode error' instanceof Error ? 'Recovering from decode error' : new Error(String('Recovering from decode error' instanceof Error ? 'Recovering from decode error' instanceof Error ? 'Recovering from decode error' : new Error(String('Recovering from decode error' : new Error(String('Recovering from decode error' instanceof Error ? 'Recovering from decode error' : new Error(String('Recovering from decode error')))))));
      
      // å¦‚æœå½“å‰ä½¿ç”¨ç¡¬ä»¶è§£ç ï¼Œå°è¯•åˆ‡æ¢åˆ°è½¯ä»¶è§£ç 
      if (this.config.enableHardwareDecoding) {
        Logger.info(TAG, 'Switching from hardware to software decoding');
        this.config.enableHardwareDecoding = false;
        
        // é‡æ–°åˆ›å»ºæ’­æ”¾å®ä¾‹
        await this.createAVPlayInstance();
        if (!this.avPlayInstance) return false;
        
        // é‡æ–°è®¾ç½®æ•°æ®æº?        await this.avPlayInstance.setSource(this.currentPlaybackItem.url);
        await this.avPlayInstance.prepare();
        
        // æ¢å¤åˆ°ä¸Šæ¬¡æ’­æ”¾ä½ç½?        if (this.lastPosition > 0) {
          await this.avPlayInstance.seekTo(this.lastPosition);
        }
        
        // æ¢å¤æ’­æ”¾
        if (this.config.autoPlay) {
          await this.avPlayInstance.play();
          this.updatePlaybackState(PlaybackState.PLAYING);
        }
        
        return true;
      }
      
      return false;
    } catch (error) {
      Logger.error(TAG, `Failed to recover from decode error: ${error}`);
      return false;
    }
  }
  
  /**
   * ä»è¶…æ—¶é”™è¯¯æ¢å¤?   */
  private async recoverFromTimeoutError(): Promise<boolean> {
    // è¶…æ—¶é”™è¯¯å¤„ç†ï¼Œç±»ä¼¼äºç½‘ç»œé”™è¯¯
    return await this.recoverFromNetworkError();
  }
  
  /**
   * ä»ä¸€èˆ¬é”™è¯¯æ¢å¤?   */
  private async recoverFromGenericError(): Promise<boolean> {
    if (!this.currentPlaybackItem) return false;
    
    try {
      Logger.info(TAG, 'Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' : new Error(String('Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' : new Error(String('Attempting generic error recovery' : new Error(String('Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' : new Error(String('Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' : new Error(String('Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' : new Error(String('Attempting generic error recovery' : new Error(String('Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' : new Error(String('Attempting generic error recovery' : new Error(String('Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' : new Error(String('Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' : new Error(String('Attempting generic error recovery' : new Error(String('Attempting generic error recovery' instanceof Error ? 'Attempting generic error recovery' : new Error(String('Attempting generic error recovery')))))));
      // é‡Šæ”¾å¹¶é‡æ–°åˆ›å»ºæ’­æ”¾å®ä¾?      await this.releaseAVPlayInstance();
      await this.createAVPlayInstance();
      
      if (!this.avPlayInstance) return false;
      
      // é‡æ–°åŠ è½½å½“å‰æ’­æ”¾é¡?      await this.load(this.currentPlaybackItem, this.lastPosition);
      return true;
    } catch (error) {
      Logger.error(TAG, `Generic error recovery failed: ${error}`);
      return false;
    }
  }
  
  /**
   * ä¼˜åŒ–æ’­æ”¾è´¨é‡
   */
  public async optimizePlaybackQuality(): Promise<void> {
    try {
      // è·å–è®¾å¤‡èƒ½åŠ›
      const capabilities = await this.deviceInfoRepository.getDeviceCapabilities();
      
      if (!capabilities || !this.avPlayInstance) return;
      
      // æ ¹æ®è®¾å¤‡èƒ½åŠ›è°ƒæ•´æ’­æ”¾å‚æ•°
      Logger.info(TAG, 'Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities' instanceof Error ? 'Optimizing playback quality based on device capabilities' : new Error(String('Optimizing playback quality based on device capabilities')))))));
      
      // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šçš„è´¨é‡ä¼˜åŒ–é€»è¾‘
      // ä¾‹å¦‚æ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´ç¼“å†²å¤§å°
      // æ ¹æ®è®¾å¤‡æ€§èƒ½è°ƒæ•´è§£ç å‚æ•°ç­?    } catch (error) {
      Logger.error(TAG, `Failed to optimize playback quality: ${error}`);
    }
  }
  
  /**
   * ä¿å­˜æ’­æ”¾ä½ç½®
   */
  private async savePlaybackPosition(): Promise<void> {
    try {
      if (!this.currentPlaybackItem || !this.avPlayInstance) return;
      
      // è·å–å½“å‰æ’­æ”¾ä½ç½®
      const position = await this.avPlayInstance.getCurrentTime();
      this.lastPosition = position;
      
      // æ›´æ–°å½“å‰æ’­æ”¾é¡¹çš„ä½ç½®
      this.currentPlaybackItem.position = position;
      
      // ä¿å­˜åˆ°å†å²è®°å½?      if (this.historyManager) {
        await this.historyManager.savePlaybackHistory({
          id: this.currentPlaybackItem.id, title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( instanceof Error ? title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date( : new Error(String(title: this.currentPlaybackItem.title,
          url: this.currentPlaybackItem.url,
          duration: this.currentPlaybackItem.duration,
          position: position,
          lastPlayed: new Date())))))).getTime()
        });
        Logger.info(TAG, `Saved playback position for ${this.currentPlaybackItem.id}: ${position}ms`);
      }
    } catch (error) {
      Logger.error(TAG, `Failed to save playback position: ${error}`);
    }
  }

  /**
   * å¤„ç†ç¼“å†²å˜åŒ–
   */
  private handleBufferingChange(bufferingStatus: number, startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number instanceof Error ? startBufferBytes: number, bufferingBytes: number, totalBytes: number : new Error(String(startBufferBytes: number, bufferingBytes: number, totalBytes: number))))))): void {
    const percent = totalBytes > 0 ? Math.round((bufferingBytes / totalBytes) * 100) : 0;
    
    const bufferingInfo: BufferingInfo = {
      percent,
      currentRange: { start: startBufferBytes, end: startBufferBytes + bufferingBytes },
      loadedRanges: [{ start: startBufferBytes, end: startBufferBytes + bufferingBytes }],
      totalBytesLoaded: bufferingBytes,
      totalBytes
    };
    
    this.notifyBufferingListeners(bufferingInfo);
    
    // æ›´æ–°çŠ¶æ€?    if (bufferingStatus === 1) { // ç¼“å†²ä¸?      this.updatePlaybackState(PlaybackState.BUFFERING);
    } else if (bufferingStatus === 2 && this.currentState === PlaybackState.BUFFERING) { // ç¼“å†²å®Œæˆ
      this.updatePlaybackState(PlaybackState.PLAYING);
    }
  }

  /**
   * å¤„ç†æ’­æ”¾å®Œæˆ
   */
  private async handlePlaybackComplete(): Promise<void> {
    Logger.info(TAG, 'Playback completed');
    
    if (this.currentPlaybackItem) {
      // æ›´æ–°å†å²è®°å½•
      await this.savePlaybackHistory(this.currentPlaybackItem.id, this.currentPlaybackItem.duration, true);
      
      // å°è¯•æ’­æ”¾ä¸‹ä¸€ä¸?      if (this.playbackQueue.length > 0 && this.currentQueueIndex < this.playbackQueue.length - 1) {
        await this.playNext();
        return;
      }
    }
    
    this.updatePlaybackState(PlaybackState.COMPLETED);
  }

  /**
   * ç¡®å®šé”™è¯¯ç±»å‹
   */
  private determineErrorType(errorCode: number): PlaybackErrorType {
    // æ ¹æ®é”™è¯¯ç åˆ¤æ–­é”™è¯¯ç±»å?    switch (errorCode) {
      case -2147483648: // ç½‘ç»œé”™è¯¯
        return PlaybackErrorType.NETWORK;
      case -2147483647: // è§£ç é”™è¯¯
        return PlaybackErrorType.DECODE;
      case -2147483646: // æƒé™é”™è¯¯
        return PlaybackErrorType.PERMISSION;
      case -2147483645: // èµ„æºé”™è¯¯
        return PlaybackErrorType.RESOURCE;
      case -2147483644: // è¶…æ—¶é”™è¯¯
        return PlaybackErrorType.TIMEOUT;
      case -2147483643: // DRMé”™è¯¯
        return PlaybackErrorType.DRM;
      default:
        return PlaybackErrorType.UNKNOWN;
    }
  }

  /**
   * å¤„ç†æ’­æ”¾é‡è¯•
   */
  private async handlePlaybackRetry(error: PlaybackError): Promise<void> {
    const now = Date.now();
    
    // æ£€æŸ¥æ˜¯å¦æ»¡è¶³é‡è¯•æ¡ä»?    if (
      this.retryCount < this.config.maxRetryCount && 
      (now - this.lastRetryTime > MIN_RETRY_INTERVAL) &&
      (error.type === PlaybackErrorType.NETWORK || error.type === PlaybackErrorType.TIMEOUT)
    ) {
      this.retryCount++;
      this.lastRetryTime = now;
      
      Logger.info(TAG, `Retrying playback, attempt ${this.retryCount} of ${this.config.maxRetryCount}`);
      
      try {
        // é‡æ–°åŠ è½½å½“å‰æ’­æ”¾é¡?        await this.load(this.currentPlaybackItem!, this.lastPosition);
      } catch (retryError) {
        Logger.error(TAG, `Playback retry failed: ${retryError}`);
      }
    } else {
      Logger.error(TAG, `Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type` instanceof Error ? `Maximum retry attempts reached or retry not allowed for error type` : new Error(String(`Maximum retry attempts reached or retry not allowed for error type`)))))));
    }
  }

  /**
   * å¼€å§‹æ’­æ”¾ä½ç½®æ›´æ–?   */
  private startPositionUpdates(): void {
    // åœæ­¢ä¹‹å‰çš„å®šæ—¶å™¨
    this.stopPositionUpdates();
    
    // è®¾ç½®æ–°çš„å®šæ—¶å™¨ï¼Œæ¯ç§’æ›´æ–°ä¸€æ¬¡è¿›åº?    this.positionUpdateTimerId = setInterval(async () => {
      await this.updatePlaybackProgress();
    }, 1000);
  }

  /**
   * åœæ­¢æ’­æ”¾ä½ç½®æ›´æ–°
   */
  private stopPositionUpdates(): void {
    if (this.positionUpdateTimerId !== null) {
      clearInterval(this.positionUpdateTimerId);
      this.positionUpdateTimerId = null;
    }
  }

  /**
   * æ›´æ–°æ’­æ”¾è¿›åº¦
   */
  private async updatePlaybackProgress(): Promise<void> {
    if (!this.avPlayInstance || !this.currentPlaybackItem) {
      return;
    }

    try {
      const position = await this.avPlayInstance.getCurrentTime();
      const duration = this.currentPlaybackItem.duration;
      const percent = duration > 0 ? Math.round((position / duration) * 100) : 0;
      
      this.lastPosition = position;
      this.lastPositionUpdateTime = Date.now();
      
      this.notifyProgressListeners(position, duration, percent);
      
      // å®šæœŸä¿å­˜æ’­æ”¾ä½ç½®
      if (this.config.rememberPosition && (Date.now() - this.lastPositionUpdateTime > 10000)) { // æ¯?0ç§’ä¿å­˜ä¸€æ¬?        await this.savePlaybackPosition();
      }
    } catch (error) {
      Logger.error(TAG, `Failed to update playback progress: ${error}`);
    }
  }

  /**
   * åŠ è½½æ’­æ”¾é¡?   */
  public async load(playbackItem: PlaybackItem, position: number = 0 instanceof Error ? position: number = 0 : new Error(String(position: number = 0 instanceof Error ? position: number = 0 instanceof Error ? position: number = 0 : new Error(String(position: number = 0 : new Error(String(position: number = 0 instanceof Error ? position: number = 0 : new Error(String(position: number = 0 instanceof Error ? position: number = 0 instanceof Error ? position: number = 0 : new Error(String(position: number = 0 instanceof Error ? position: number = 0 instanceof Error ? position: number = 0 : new Error(String(position: number = 0 : new Error(String(position: number = 0 instanceof Error ? position: number = 0 : new Error(String(position: number = 0 : new Error(String(position: number = 0 instanceof Error ? position: number = 0 : new Error(String(position: number = 0 instanceof Error ? position: number = 0 instanceof Error ? position: number = 0 : new Error(String(position: number = 0 : new Error(String(position: number = 0 instanceof Error ? position: number = 0 : new Error(String(position: number = 0))))))): Promise<void> {
    if (!this.isInitialized) {
      throw new Error('Playback service not initialized');
    }

    try {
      // é‡ç½®çŠ¶æ€?      this.retryCount = 0;
      this.updatePlaybackState(PlaybackState.INITIALIZING);
      
      // ä¿å­˜å½“å‰æ’­æ”¾é¡?      this.currentPlaybackItem = { ...playbackItem };
      this.lastPosition = position;
      
      // åˆ›å»ºæˆ–é‡ç½®æ’­æ”¾å®ä¾?      await this.createAVPlayInstance();
      
      if (!this.avPlayInstance) {
        throw new Error('Failed to create AVPlay instance');
      }
      
      // åˆå§‹åŒ–æ’­æ”¾å™¨
      await this.avPlayInstance.init();
      
      // è®¾ç½®æ•°æ®æº?      await this.avPlayInstance.setSource(playbackItem.url);
      
      // å‡†å¤‡æ’­æ”¾
      await this.avPlayInstance.prepare();
      
      // æ¢å¤æ’­æ”¾ä½ç½®
      if (position > 0 && this.config.rememberPosition) {
        await this.avPlayInstance.seekTo(position);
      }
      
      // è‡ªåŠ¨æ’­æ”¾
      if (this.config.autoPlay) {
        await this.play();
      }
      
    } catch (error) {
      Logger.error(TAG, `Failed to load playback item: ${error}`);
      this.updatePlaybackState(PlaybackState.ERROR);
      throw error;
    }
  }

  /**
   * æ’­æ”¾
   */
  public async play(): Promise<void> {
    if (!this.avPlayInstance || !this.currentPlaybackItem) {
      throw new Error('No playback item loaded');
    }

    try {
      await this.avPlayInstance.play();
      this.updatePlaybackState(PlaybackState.PLAYING);
    } catch (error) {
      Logger.error(TAG, `Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` : new Error(String(`Failed to play: ${error}` instanceof Error ? `Failed to play: ${error}` : new Error(String(`Failed to play: ${error}`)))))));
      this.updatePlaybackState(PlaybackState.ERROR);
      throw error;
    }
  }

  /**
   * æš‚åœ
   */
  public async pause(): Promise<void> {
    if (!this.avPlayInstance) {
      throw new Error('No playback item loaded');
    }

    try {
      await this.avPlayInstance.pause();
      this.updatePlaybackState(PlaybackState.PAUSED);
      
      // ä¿å­˜æ’­æ”¾ä½ç½®
      await this.savePlaybackPosition();
    } catch (error) {
      Logger.error(TAG, `Failed to pause: ${error}`);
      throw error;
    }
  }

  /**
   * åœæ­¢
   */
  public async stop(): Promise<void> {
    if (!this.avPlayInstance) {
      return;
    }

    try {
      // ä¿å­˜æ’­æ”¾ä½ç½®
      await this.savePlaybackPosition();
      
      await this.avPlayInstance.stop();
      await this.avPlayInstance.release();
      
      this.avPlayInstance = null;
      this.updatePlaybackState(PlaybackState.IDLE);
      
      // æ¸…é™¤é˜Ÿåˆ—ç´¢å¼•
      this.currentQueueIndex = -1;
    } catch (error) {
      Logger.error(TAG, `Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}` instanceof Error ? `Failed to stop: ${error}` : new Error(String(`Failed to stop: ${error}`)))))));
      throw error;
    }
  }

  /**
   * è·³è½¬
   */
  public async seekTo(position: number): Promise<void> {
    if (!this.avPlayInstance || !this.currentPlaybackItem) {
      throw new Error('No playback item loaded');
    }

    try {
      // éªŒè¯ä½ç½®
      const validPosition = Math.max(0, Math.min(position, this.currentPlaybackItem.duration));
      
      this.updatePlaybackState(PlaybackState.SEEKING);
      await this.avPlayInstance.seekTo(validPosition);
      
      this.lastPosition = validPosition;
      
      // æ¢å¤ä¹‹å‰çš„çŠ¶æ€?      if (this.currentState === PlaybackState.PLAYING) {
        this.updatePlaybackState(PlaybackState.PLAYING);
      } else {
        this.updatePlaybackState(PlaybackState.PAUSED);
      }
    } catch (error) {
      Logger.error(TAG, `Failed to seek to position ${position}: ${error}`);
      throw error;
    }
  }

  /**
   * å¿«è¿›
   */
  public async fastForward(seconds: number = 10): Promise<void> {
    if (!this.avPlayInstance || !this.currentPlaybackItem) {
      throw new Error('No playback item loaded');
    }

    try {
      const currentPosition = await this.avPlayInstance.getCurrentTime();
      const newPosition = Math.min(currentPosition + (seconds * 1000), this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration instanceof Error ? this.currentPlaybackItem.duration : new Error(String(this.currentPlaybackItem.duration)))))));
      await this.seekTo(newPosition);
    } catch (error) {
      Logger.error(TAG, `Failed to fast forward: ${error}`);
      throw error;
    }
  }

  /**
   * å¿«é€€
   */
  public async fastRewind(seconds: number = 10): Promise<void> {
    if (!this.avPlayInstance || !this.currentPlaybackItem) {
      throw new Error('No playback item loaded');
    }

    try {
      const currentPosition = await this.avPlayInstance.getCurrentTime();
      const newPosition = Math.max(0, currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000 instanceof Error ? currentPosition - (seconds * 1000 : new Error(String(currentPosition - (seconds * 1000))))))));
      await this.seekTo(newPosition);
    } catch (error) {
      Logger.error(TAG, `Failed to fast rewind: ${error}`);
      throw error;
    }
  }

  /**
   * è®¾ç½®æ’­æ”¾é€Ÿåº¦
   */
  public async setPlaybackSpeed(speed: PlaybackSpeed | number): Promise<void> {
    if (!this.avPlayInstance) {
      throw new Error('No playback item loaded');
    }

    try {
      this.playbackSpeed = speed;
      await this.avPlayInstance.setSpeed(speed);
      Logger.info(TAG, `Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x` instanceof Error ? `Playback speed set to: ${speed}x` : new Error(String(`Playback speed set to: ${speed}x`)))))));
    } catch (error) {
      Logger.error(TAG, `Failed to set playback speed: ${error}`);
      throw error;
    }
  }

  /**
   * è®¾ç½®éŸ³é‡
   */
  public async setVolume(volume: number): Promise<void> {
    // éªŒè¯éŸ³é‡èŒƒå›´
    const validVolume = Math.max(0, Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 : new Error(String(Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 : new Error(String(Math.min(volume, 1 : new Error(String(Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 : new Error(String(Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 : new Error(String(Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 : new Error(String(Math.min(volume, 1 : new Error(String(Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 : new Error(String(Math.min(volume, 1 : new Error(String(Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 : new Error(String(Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 : new Error(String(Math.min(volume, 1 : new Error(String(Math.min(volume, 1 instanceof Error ? Math.min(volume, 1 : new Error(String(Math.min(volume, 1))))))));
    this.volume = validVolume;
    
    if (this.avPlayInstance) {
      try {
        await this.avPlayInstance.setVolume(this.isMuted ? 0 : validVolume);
      } catch (error) {
        Logger.error(TAG, `Failed to set volume: ${error}`);
      }
    }
    
    // ä¿å­˜é…ç½®
    await this.saveConfig({ volume: validVolume });
  }

  /**
   * è®¾ç½®é™éŸ³
   */
  public async setMute(mute: boolean): Promise<void> {
    this.isMuted = mute;
    
    if (this.avPlayInstance) {
      try {
        await this.avPlayInstance.setMute(mute);
        if (!mute) {
          await this.avPlayInstance.setVolume(this.volume);
        }
      } catch (error) {
        Logger.error(TAG, `Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}` instanceof Error ? `Failed to set mute: ${error}` : new Error(String(`Failed to set mute: ${error}`)))))));
      }
    }
    
    // ä¿å­˜é…ç½®
    await this.saveConfig({ mute });
  }

  /**
   * è®¾ç½®éŸ³é¢‘è·¯ç”±
   */
  public async setAudioRoute(route: AudioRoute): Promise<void> {
    if (!this.audioManager) {
      return;
    }

    try {
      // æ ¹æ®è·¯ç”±ç±»å‹è®¾ç½®éŸ³é¢‘æ¨¡å¼
      switch (route) {
        case AudioRoute.SPEAKER:
          await this.audioManager.setAudioScene(AudioManager.AudioSceneType.MEDIA);
          break;
        case AudioRoute.EARPIECE:
          await this.audioManager.setAudioScene(AudioManager.AudioSceneType.CALL);
          break;
        case AudioRoute.WIRED_HEADSET:
          // æœ‰çº¿è€³æœºè·¯ç”±é€šå¸¸ç”±ç³»ç»Ÿè‡ªåŠ¨å¤„ç?          await this.audioManager.setAudioScene(AudioManager.AudioSceneType.MEDIA);
          break;
        case AudioRoute.BLUETOOTH:
          // è“ç‰™è€³æœºè·¯ç”±é€šå¸¸ç”±ç³»ç»Ÿè‡ªåŠ¨å¤„ç?          await this.audioManager.setAudioScene(AudioManager.AudioSceneType.MEDIA);
          break;
      }
      
      this.config.audioRoute = route;
      Logger.info(TAG, `Audio route set to: ${route}`);
    } catch (error) {
      Logger.error(TAG, `Failed to set audio route: ${error}`);
    }
  }

  /**
   * ä¿å­˜æ’­æ”¾ä½ç½®
   */
  private async savePlaybackPosition(): Promise<void> {
    if (!this.currentPlaybackItem || !this.config.rememberPosition) {
      return;
    }

    try {
      if (this.avPlayInstance) {
        const currentTime = await this.avPlayInstance.getCurrentTime();
        this.lastPosition = currentTime;
      }
      
      // åªä¿å­˜éå®ŒæˆçŠ¶æ€çš„æ’­æ”¾ä½ç½®
      const isCompleted = this.lastPosition >= this.currentPlaybackItem.duration - 5000;
      if (!isCompleted) {
        await this.historyManager.savePlaybackPosition(
          this.currentPlaybackItem.id, this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
         instanceof Error ? this.lastPosition,
          this.currentPlaybackItem.duration
         : new Error(String(this.lastPosition,
          this.currentPlaybackItem.duration
        )))))));
      }
    } catch (error) {
      Logger.error(TAG, `Failed to save playback position: ${error}`);
    }
  }

  /**
   * ä¿å­˜æ’­æ”¾å†å²
   */
  private async savePlaybackHistory(id: string, position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean instanceof Error ? position: number, isCompleted: boolean : new Error(String(position: number, isCompleted: boolean))))))): Promise<void> {
    if (!this.currentPlaybackItem) {
      return;
    }

    try {
      await this.historyManager.addToHistory({
        id,
        title: this.currentPlaybackItem.title,
        subtitle: this.currentPlaybackItem.subtitle,
        coverUrl: this.currentPlaybackItem.coverUrl,
        duration: this.currentPlaybackItem.duration,
        position,
        isCompleted,
        timestamp: Date.now(),
        type: this.currentPlaybackItem.type,
        metadata: this.currentPlaybackItem.metadata
      });
    } catch (error) {
      Logger.error(TAG, `Failed to save playback history: ${error}`);
    }
  }

  /**
   * è®¾ç½®æ’­æ”¾é˜Ÿåˆ—
   */
  public setPlaybackQueue(queue: PlaybackItem[], startIndex: number = 0 instanceof Error ? startIndex: number = 0 : new Error(String(startIndex: number = 0 instanceof Error ? startIndex: number = 0 instanceof Error ? startIndex: number = 0 : new Error(String(startIndex: number = 0 : new Error(String(startIndex: number = 0 instanceof Error ? startIndex: number = 0 : new Error(String(startIndex: number = 0 instanceof Error ? startIndex: number = 0 instanceof Error ? startIndex: number = 0 : new Error(String(startIndex: number = 0 instanceof Error ? startIndex: number = 0 instanceof Error ? startIndex: number = 0 : new Error(String(startIndex: number = 0 : new Error(String(startIndex: number = 0 instanceof Error ? startIndex: number = 0 : new Error(String(startIndex: number = 0 : new Error(String(startIndex: number = 0 instanceof Error ? startIndex: number = 0 : new Error(String(startIndex: number = 0 instanceof Error ? startIndex: number = 0 instanceof Error ? startIndex: number = 0 : new Error(String(startIndex: number = 0 : new Error(String(startIndex: number = 0 instanceof Error ? startIndex: number = 0 : new Error(String(startIndex: number = 0))))))): void {
    // éªŒè¯é˜Ÿåˆ—
    if (!Array.isArray(queue) || queue.length === 0) {
      throw new Error('Invalid playback queue');
    }
    
    // é™åˆ¶é˜Ÿåˆ—å¤§å°
    this.playbackQueue = queue.slice(0, MAX_PLAYBACK_QUEUE_SIZE);
    
    // éªŒè¯èµ·å§‹ç´¢å¼•
    this.currentQueueIndex = Math.max(0, Math.min(startIndex, this.playbackQueue.length - 1));
    
    this.notifyQueueListeners();
    Logger.info(TAG, `Playback queue set with ${this.playbackQueue.length} items, current index: ${this.currentQueueIndex}`);
  }

  /**
   * æ·»åŠ åˆ°æ’­æ”¾é˜Ÿåˆ?   */
  public addToPlaybackQueue(item: PlaybackItem): void {
    if (this.playbackQueue.length >= MAX_PLAYBACK_QUEUE_SIZE) {
      throw new Error('Playback queue is full');
    }
    
    this.playbackQueue.push(item);
    this.notifyQueueListeners();
  }

  /**
   * ä»æ’­æ”¾é˜Ÿåˆ—ç§»é™?   */
  public removeFromPlaybackQueue(index: number): void {
    if (index < 0 || index >= this.playbackQueue.length) {
      throw new Error('Invalid queue index');
    }
    
    this.playbackQueue.splice(index, 1);
    
    // æ›´æ–°å½“å‰ç´¢å¼•
    if (index === this.currentQueueIndex) {
      if (this.currentQueueIndex >= this.playbackQueue.length) {
        this.currentQueueIndex = this.playbackQueue.length - 1;
      }
    } else if (index < this.currentQueueIndex) {
      this.currentQueueIndex--;
    }
    
    this.notifyQueueListeners();
  }

  /**
   * æ’­æ”¾ä¸Šä¸€ä¸?   */
  public async playPrevious(): Promise<void> {
    if (this.playbackQueue.length === 0) {
      throw new Error('Playback queue is empty');
    }
    
    const newIndex = this.currentQueueIndex > 0 ? this.currentQueueIndex - 1 : this.playbackQueue.length - 1;
    await this.playQueueItem(newIndex);
  }

  /**
   * æ’­æ”¾ä¸‹ä¸€ä¸?   */
  public async playNext(): Promise<void> {
    if (this.playbackQueue.length === 0) {
      throw new Error('Playback queue is empty');
    }
    
    const newIndex = this.currentQueueIndex < this.playbackQueue.length - 1 ? this.currentQueueIndex + 1 : 0;
    await this.playQueueItem(newIndex);
  }

  /**
   * æ’­æ”¾é˜Ÿåˆ—ä¸­çš„æŒ‡å®šé¡?   */
  public async playQueueItem(index: number): Promise<void> {
    if (index < 0 || index >= this.playbackQueue.length) {
      throw new Error('Invalid queue index');
    }
    
    const item = this.playbackQueue[index];
    
    // ä¿å­˜å½“å‰æ’­æ”¾ä½ç½®
    await this.savePlaybackPosition();
    
    // æ›´æ–°é˜Ÿåˆ—ç´¢å¼•
    this.currentQueueIndex = index;
    
    // åŠ è½½å¹¶æ’­æ”¾æ–°é¡?    await this.load(item);
    
    this.notifyQueueListeners();
  }

  /**
   * åˆ‡æ¢å­—å¹•æ˜¾ç¤º
   */
  public toggleSubtitleVisibility(): boolean {
    this.subtitleVisible = !this.subtitleVisible;
    // TODO: å®ç°å­—å¹•æ˜¾ç¤ºæ§åˆ¶
    Logger.info(TAG, `Subtitle visibility toggled to: ${this.subtitleVisible}`);
    return this.subtitleVisible;
  }

  /**
   * è®¾ç½®å­—å¹•æ ·å¼
   */
  public async setSubtitleStyle(style: Partial<SubtitleStyle>): Promise<void> {
    this.config.subtitleStyle = { ...this.config.subtitleStyle, ...style };
    // TODO: å®ç°å­—å¹•æ ·å¼è®¾ç½®
    
    // ä¿å­˜é…ç½®
    await this.saveConfig({ subtitleStyle: this.config.subtitleStyle });
  }

  /**
   * é€‰æ‹©å­—å¹•
   */
  public async selectSubtitle(index: number): Promise<void> {
    if (!this.currentPlaybackItem || !this.currentPlaybackItem.subtitles) {
      throw new Error('No subtitles available');
    }
    
    if (index < -1 || index >= this.currentPlaybackItem.subtitles.length) {
      throw new Error('Invalid subtitle index');
    }
    
    this.currentPlaybackItem.currentSubtitleIndex = index;
    // TODO: å®ç°å­—å¹•é€‰æ‹©é€»è¾‘
    
    Logger.info(TAG, `Subtitle selected: ${index === -1 ? 'none' : this.currentPlaybackItem.subtitles[index]?.title}`);
  }

  /**
   * å¯ç”¨åå°æ’­æ”¾
   */
  public setBackgroundPlaybackEnabled(enabled: boolean): void {
    this.isBackgroundPlaybackEnabled = enabled;
    // TODO: å®ç°åå°æ’­æ”¾é€»è¾‘
    Logger.info(TAG, `Background playback ${enabled ? 'enabled' : 'disabled'}`);
  }

  /**
   * æ›´æ–°æ’­æ”¾çŠ¶æ€?   */
  private updatePlaybackState(state: PlaybackState): void {
    this.currentState = state;
    this.notifyStateListeners(state);
  }

  /**
   * é€šçŸ¥çŠ¶æ€ç›‘å¬å™¨
   */
  private notifyStateListeners(state: PlaybackState): void {
    for (const listener of this.stateListeners) {
      try {
        listener(state);
      } catch (error) {
        Logger.error(TAG, `Error in state listener: ${error}`);
      }
    }
  }

  /**
   * é€šçŸ¥é”™è¯¯ç›‘å¬å™?   */
  private notifyErrorListeners(error: PlaybackError): void {
    for (const listener of this.errorListeners) {
      try {
        listener(error);
      } catch (error) {
        Logger.error(TAG, `Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}` instanceof Error ? `Error in error listener: ${error}` : new Error(String(`Error in error listener: ${error}`)))))));
      }
    }
  }

  /**
   * é€šçŸ¥è¿›åº¦ç›‘å¬å™?   */
  private notifyProgressListeners(position: number, duration: number, percent: number): void {
    for (const listener of this.progressListeners) {
      try {
        listener(position, duration, percent);
      } catch (error) {
        Logger.error(TAG, `Error in progress listener: ${error}`);
      }
    }
  }

  /**
   * é€šçŸ¥ç¼“å†²ç›‘å¬å™?   */
  private notifyBufferingListeners(info: BufferingInfo): void {
    for (const listener of this.bufferingListeners) {
      try {
        listener(info);
      } catch (error) {
        Logger.error(TAG, `Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}` instanceof Error ? `Error in buffering listener: ${error}` : new Error(String(`Error in buffering listener: ${error}`)))))));
      }
    }
  }

  /**
   * é€šçŸ¥é˜Ÿåˆ—ç›‘å¬å™?   */
  private notifyQueueListeners(): void {
    for (const listener of this.queueListeners) {
      try {
        listener([...this.playbackQueue], this.currentQueueIndex);
      } catch (error) {
        Logger.error(TAG, `Error in queue listener: ${error}`);
      }
    }
  }

  /**
   * æ·»åŠ çŠ¶æ€ç›‘å¬å™¨
   */
  public addStateListener(listener: PlaybackStateListener): void {
    this.stateListeners.push(listener);
  }

  /**
   * ç§»é™¤çŠ¶æ€ç›‘å¬å™¨
   */
  public removeStateListener(listener: PlaybackStateListener): void {
    const index = this.stateListeners.indexOf(listener);
    if (index > -1) {
      this.stateListeners.splice(index, 1 instanceof Error ? 1 : new Error(String(1 instanceof Error ? 1 instanceof Error ? 1 : new Error(String(1 : new Error(String(1 instanceof Error ? 1 : new Error(String(1 instanceof Error ? 1 instanceof Error ? 1 : new Error(String(1 instanceof Error ? 1 instanceof Error ? 1 : new Error(String(1 : new Error(String(1 instanceof Error ? 1 : new Error(String(1 : new Error(String(1 instanceof Error ? 1 : new Error(String(1 instanceof Error ? 1 instanceof Error ? 1 : new Error(String(1 : new Error(String(1 instanceof Error ? 1 : new Error(String(1)))))));
    }
  }

  /**
   * æ·»åŠ é”™è¯¯ç›‘å¬å™?   */
  public addErrorListener(listener: PlaybackErrorListener): void {
    this.errorListeners.push(listener);
  }

  /**
   * ç§»é™¤é”™è¯¯ç›‘å¬å™?   */
  public removeErrorListener(listener: PlaybackErrorListener): void {
    const index = this.errorListeners.indexOf(listener);
    if (index > -1) {
      this.errorListeners.splice(index, 1);
    }
  }

  /**
   * æ·»åŠ è¿›åº¦ç›‘å¬å™?   */
  public addProgressListener(listener: PlaybackProgressListener): void {
    this.progressListeners.push(listener);
  }

  /**
   * ç§»é™¤è¿›åº¦ç›‘å¬å™?   */
  public removeProgressListener(listener: PlaybackProgressListener): void {
    const index = this.progressListeners.indexOf(listener);
    if (index > -1) {
      this.progressListeners.splice(index, 1);
    }
  }

  /**
   * æ·»åŠ ç¼“å†²ç›‘å¬å™?   */
  public addBufferingListener(listener: BufferingStateListener): void {
    this.bufferingListeners.push(listener);
  }

  /**
   * ç§»é™¤ç¼“å†²ç›‘å¬å™?   */
  public removeBufferingListener(listener: BufferingStateListener): void {
    const index = this.bufferingListeners.indexOf(listener);
    if (index > -1) {
      this.bufferingListeners.splice(index, 1);
    }
  }

  /**
   * æ·»åŠ é˜Ÿåˆ—ç›‘å¬å™?   */
  public addQueueListener(listener: PlaybackQueueListener): void {
    this.queueListeners.push(listener);
  }

  /**
   * ç§»é™¤é˜Ÿåˆ—ç›‘å¬å™?   */
  public removeQueueListener(listener: PlaybackQueueListener): void {
    const index = this.queueListeners.indexOf(listener);
    if (index > -1) {
      this.queueListeners.splice(index, 1);
    }
  }

  /**
   * è·å–å½“å‰æ’­æ”¾çŠ¶æ€?   */
  public getPlaybackState(): PlaybackState {
    return this.currentState;
  }

  /**
   * è·å–å½“å‰æ’­æ”¾é¡?   */
  public getCurrentPlaybackItem(): PlaybackItem | null {
    return this.currentPlaybackItem ? { ...this.currentPlaybackItem } : null;
  }

  /**
   * è·å–æ’­æ”¾é˜Ÿåˆ—
   */
  public getPlaybackQueue(): PlaybackItem[] {
    return [...this.playbackQueue];
  }

  /**
   * è·å–å½“å‰é˜Ÿåˆ—ç´¢å¼•
   */
  public getCurrentQueueIndex(): number {
    return this.currentQueueIndex;
  }

  /**
   * è·å–æ’­æ”¾é€Ÿåº¦
   */
  public getPlaybackSpeed(): number {
    return this.playbackSpeed;
  }

  /**
   * è·å–éŸ³é‡
   */
  public getVolume(): number {
    return this.volume;
  }

  /**
   * è·å–é™éŸ³çŠ¶æ€?   */
  public isMuted(): boolean {
    return this.isMuted;
  }

  /**
   * è·å–å­—å¹•å¯è§çŠ¶æ€?   */
  public isSubtitleVisible(): boolean {
    return this.subtitleVisible;
  }

  /**
   * è·å–åå°æ’­æ”¾çŠ¶æ€?   */
  public isBackgroundPlaybackEnabled(): boolean {
    return this.isBackgroundPlaybackEnabled;
  }

  /**
   * é‡Šæ”¾AVPlayå®ä¾‹
   */
  private async releaseAVPlayInstance(): Promise<void> {
    if (!this.avPlayInstance) {
      return;
    }

    try {
      // ç§»é™¤äº‹ä»¶ç›‘å¬
      this.avPlayInstance.off('stateChange');
      this.avPlayInstance.off('error');
      this.avPlayInstance.off('bufferingChange');
      this.avPlayInstance.off('playbackComplete');
      
      // åœæ­¢å’Œé‡Šæ”?      await this.avPlayInstance.stop();
      await this.avPlayInstance.release();
      
      this.avPlayInstance = null;
    } catch (error) {
      Logger.error(TAG, `Failed to release AVPlay instance: ${error}`);
    }
  }

  /**
   * å…³é—­æ’­æ”¾æœåŠ¡
   */
  public async close(): Promise<void> {
    if (!this.isInitialized) {
      return;
    }

    try {
      // ä¿å­˜æ’­æ”¾ä½ç½®
      await this.savePlaybackPosition();
      
      // ä¿å­˜æ’­æ”¾å†å²
      if (this.currentPlaybackItem) {
        await this.savePlaybackHistory(
          this.currentPlaybackItem.id, this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         instanceof Error ? this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
         : new Error(String(this.lastPosition,
          this.currentState === PlaybackState.COMPLETED
        )))))));
      }
      
      // é‡Šæ”¾æ’­æ”¾å®ä¾‹
      await this.releaseAVPlayInstance();
      
      // åœæ­¢å®šæ—¶å™?      this.stopPositionUpdates();
      
      // é‡ç½®çŠ¶æ€?      this.currentState = PlaybackState.IDLE;
      this.currentPlaybackItem = null;
      this.playbackQueue = [];
      this.currentQueueIndex = -1;
      
      this.isInitialized = false;
      Logger.info(TAG, 'Playback service closed');
    } catch (error) {
      Logger.error(TAG, `Error closing playback service: ${error}`);
    }
  }
}


