// HistoryManager.ets - å†å²è®°å½•ç®¡ç†å™?// è´Ÿè´£ç®¡ç†è§†é¢‘æ’­æ”¾å†å²è®°å½•

import Logger from '../../common/util/Logger';
import HistoryDao from '../../data/db/dao/HistoryDao';
import ConfigService from '../config/ConfigService';

// å¸¸é‡å®šä¹‰
const TAG = 'HistoryManager';
const DEFAULT_MAX_HISTORY_COUNT = 100; // é»˜è®¤æœ€å¤§å†å²è®°å½•æ•°é‡?
// å†å²è®°å½•é¡¹æ¥å?export interface HistoryItem {
  id: string;           // å”¯ä¸€æ ‡è¯†
  title: string;        // æ ‡é¢˜
  subtitle?: string;    // å‰¯æ ‡é¢?  url: string;          // æ’­æ”¾åœ°å€
  coverUrl?: string;    // å°é¢å›¾ç‰‡
  position: number;     // æ’­æ”¾ä½ç½®ï¼ˆæ¯«ç§’ï¼‰
  duration: number;     // æ€»æ—¶é•¿ï¼ˆæ¯«ç§’ï¼?  progress: number;     // æ’­æ”¾è¿›åº¦ï¼?-1ï¼?  lastPlayed: number;   // æœ€åæ’­æ”¾æ—¶é—´æˆ³
  siteKey?: string;     // ç«™ç‚¹æ ‡è¯†
  videoId?: string;     // è§†é¢‘ID
  metadata?: Record<string, unknown>; // é¢å¤–å…ƒæ•°æ?}

export default class HistoryManager {
  private static instance: HistoryManager;
  private historyDao: HistoryDao;
  private configService: ConfigService;
  private maxHistoryCount: number = DEFAULT_MAX_HISTORY_COUNT;
  private isInitialized: boolean = false;

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): HistoryManager {
    if (!HistoryManager.instance) {
      HistoryManager.instance = new HistoryManager();
    }
    return HistoryManager.instance;
  }

  /**
   * æ„é€ å‡½æ•?   */
  private constructor() {
    this.historyDao = new HistoryDao();
    this.configService = ConfigService.getInstance();
  }

  /**
   * åˆå§‹åŒ–å†å²è®°å½•ç®¡ç†å™¨
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      Logger.info(TAG, 'History manager already initialized');
      return;
    }

    try {
      // åŠ è½½é…ç½®
      await this.loadConfig();
      
      // ç¡®ä¿æ•°æ®åº“è¡¨åˆ›å»º
      await this.historyDao.createTable();
      
      this.isInitialized = true;
      Logger.info(TAG, 'History manager initialized successfully');
    } catch (error) {
      Logger.error(TAG, `Failed to initialize history manager: ${error}`);
      throw error;
    }
  }

  /**
   * åŠ è½½é…ç½®
   */
  private async loadConfig(): Promise<void> {
    try {
      const maxCount = await this.configService.getConfig('maxHistoryCount');
      if (typeof maxCount === 'number' && maxCount > 0) {
        this.maxHistoryCount = maxCount;
      }
    } catch (error) {
      Logger.error(TAG, `Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}` instanceof Error ? `Failed to load history config: ${error}` : new Error(String(`Failed to load history config: ${error}`)))))));
    }
  }

  /**
   * ä¿å­˜æˆ–æ›´æ–°å†å²è®°å½?   * @param historyItem å†å²è®°å½•é¡?   */
  public async saveHistory(historyItem: HistoryItem): Promise<void> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      // ç”Ÿæˆå”¯ä¸€IDï¼ˆå¦‚æœæ²¡æœ‰ï¼‰
      if (!historyItem.id) {
        historyItem.id = `${historyItem.siteKey || 'default'}:${historyItem.videoId || this.generateId()}`;
      }

      // æ›´æ–°æœ€åæ’­æ”¾æ—¶é—´å’Œè¿›åº¦
      historyItem.lastPlayed = Date.now();
      historyItem.progress = historyItem.duration > 0 ? 
        Math.min(1, Math.max(0, historyItem.position / historyItem.duration)) : 0;

      // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥è®°å½?      const existingItem = await this.historyDao.getById(historyItem.id);
      
      if (existingItem) {
        // æ›´æ–°ç°æœ‰è®°å½•
        await this.historyDao.update({
          ...existingItem,
          ...historyItem,
          lastPlayed: historyItem.lastPlayed,
          position: historyItem.position,
          duration: historyItem.duration,
          progress: historyItem.progress
        });
        Logger.debug(TAG, `Updated history: ${historyItem.title}`);
      } else {
        // æ’å…¥æ–°è®°å½?        await this.historyDao.insert(historyItem);
        Logger.debug(TAG, `Added history: ${historyItem.title}`);
      }

      // æ£€æŸ¥å¹¶æ¸…ç†è¶…å‡ºé™åˆ¶çš„å†å²è®°å½?      await this.cleanupExcessHistory();
    } catch (error) {
      Logger.error(TAG, `Failed to save history: ${error}`);
      throw error;
    }
  }

  /**
   * è·å–å†å²è®°å½•åˆ—è¡¨
   * @param limit é™åˆ¶æ•°é‡
   * @param offset åç§»é‡?   */
  public async getHistoryList(limit: number = 50, offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0 : new Error(String(offset: number = 0 instanceof Error ? offset: number = 0 : new Error(String(offset: number = 0))))))): Promise<HistoryItem[]> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      const historyList = await this.historyDao.query({
        orderBy: 'lastPlayed DESC',
        limit,
        offset
      });
      return historyList;
    } catch (error) {
      Logger.error(TAG, `Failed to get history list: ${error}`);
      return [];
    }
  }

  /**
   * æ ¹æ®IDè·å–å†å²è®°å½•
   * @param id å†å²è®°å½•ID
   */
  public async getHistoryById(id: string): Promise<HistoryItem | null> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      return await this.historyDao.getById(id);
    } catch (error) {
      Logger.error(TAG, `Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}` instanceof Error ? `Failed to get history by id: ${error}` : new Error(String(`Failed to get history by id: ${error}`)))))));
      return null;
    }
  }

  /**
   * æ ¹æ®ç«™ç‚¹å’Œè§†é¢‘IDè·å–å†å²è®°å½•
   * @param siteKey ç«™ç‚¹æ ‡è¯†
   * @param videoId è§†é¢‘ID
   */
  public async getHistoryByVideo(siteKey: string, videoId: string): Promise<HistoryItem | null> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      return await this.historyDao.queryOne({
        conditions: `siteKey = ? AND videoId = ?`,
        params: [siteKey, videoId]
      });
    } catch (error) {
      Logger.error(TAG, `Failed to get history by video: ${error}`);
      return null;
    }
  }

  /**
   * åˆ é™¤å†å²è®°å½•
   * @param id å†å²è®°å½•ID
   */
  public async deleteHistory(id: string): Promise<void> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      await this.historyDao.delete(id);
      Logger.debug(TAG, `Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` : new Error(String(`Deleted history: ${id}` instanceof Error ? `Deleted history: ${id}` : new Error(String(`Deleted history: ${id}`)))))));
    } catch (error) {
      Logger.error(TAG, `Failed to delete history: ${error}`);
      throw error;
    }
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰å†å²è®°å½?   */
  public async clearAllHistory(): Promise<void> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      await this.historyDao.clear();
      Logger.info(TAG, 'Cleared all history records' instanceof Error ? 'Cleared all history records' : new Error(String('Cleared all history records' instanceof Error ? 'Cleared all history records' instanceof Error ? 'Cleared all history records' : new Error(String('Cleared all history records' : new Error(String('Cleared all history records' instanceof Error ? 'Cleared all history records' : new Error(String('Cleared all history records' instanceof Error ? 'Cleared all history records' instanceof Error ? 'Cleared all history records' : new Error(String('Cleared all history records' instanceof Error ? 'Cleared all history records' instanceof Error ? 'Cleared all history records' : new Error(String('Cleared all history records' : new Error(String('Cleared all history records' instanceof Error ? 'Cleared all history records' : new Error(String('Cleared all history records' : new Error(String('Cleared all history records' instanceof Error ? 'Cleared all history records' : new Error(String('Cleared all history records' instanceof Error ? 'Cleared all history records' instanceof Error ? 'Cleared all history records' : new Error(String('Cleared all history records' : new Error(String('Cleared all history records' instanceof Error ? 'Cleared all history records' : new Error(String('Cleared all history records')))))));
    } catch (error) {
      Logger.error(TAG, `Failed to clear history: ${error}`);
      throw error;
    }
  }

  /**
   * æ¸…ç†è¶…å‡ºé™åˆ¶çš„å†å²è®°å½?   */
  private async cleanupExcessHistory(): Promise<void> {
    try {
      const count = await this.historyDao.count();
      if (count > this.maxHistoryCount) {
        const excessCount = count - this.maxHistoryCount;
        await this.historyDao.deleteOldest(excessCount);
        Logger.info(TAG, `Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records` instanceof Error ? `Cleaned up ${excessCount} excess history records` : new Error(String(`Cleaned up ${excessCount} excess history records`)))))));
      }
    } catch (error) {
      Logger.error(TAG, `Failed to cleanup excess history: ${error}`);
    }
  }

  /**
   * ç”Ÿæˆå”¯ä¸€ID
   */
  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
}


