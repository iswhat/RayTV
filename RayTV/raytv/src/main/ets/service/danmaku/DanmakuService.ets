// å¼¹å¹•æœåŠ¡
// æä¾›å¼¹å¹•çš„æ˜¾ç¤ºã€å‘é€ã€è¿‡æ»¤å’Œå†å²ç®¡ç†åŠŸèƒ½

import { StorageUtil } from '../../common/util/StorageUtil';
import { HttpService } from '../HttpService';

export class DanmakuService {
  static instance: DanmakuService;
  storageUtil: StorageUtil;
  httpService: HttpService;
  danmakuConfig: DanmakuConfig;
  danmakuHistory: DanmakuHistoryItem[] = [];
  customDanmakus: DanmakuItem[] = [];
  listeners: DanmakuListener[] = [];

  constructor() {
    this.storageUtil = StorageUtil.getInstance();
    this.httpService = HttpService.getInstance();
    this.initialize();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): DanmakuService {
    if (!DanmakuService.instance) {
      DanmakuService.instance = new DanmakuService();
    }
    return DanmakuService.instance;
  }

  /**
   * åˆå§‹åŒ–å¼¹å¹•æœåŠ?   */
  async initialize(): Promise<void> {
    // åŠ è½½é…ç½®
    this.danmakuConfig = await this.storageUtil.get<DanmakuConfig>('danmakuConfig', {
      enabled: true,
      opacity: 0.8,
      fontSize: 16,
      speed: 100,
      showTop: true,
      showBottom: true,
      showScroll: true,
      filterKeywords: [],
      maxDisplayCount: 50
    });

    // åŠ è½½è‡ªå®šä¹‰å¼¹å¹?    this.customDanmakus = await this.storageUtil.get<DanmakuItem[]>('customDanmakus', []);
  }

  /**
   * è®¾ç½®å¼¹å¹•é…ç½®
   * @param config å¼¹å¹•é…ç½®
   */
  async setConfig(config: Partial<DanmakuConfig>): Promise<void> {
    this.danmakuConfig = { ...this.danmakuConfig, ...config };
    await this.storageUtil.save('danmakuConfig', this.danmakuConfig);
    this.notifyConfigChanged();
  }

  /**
   * è·å–å¼¹å¹•é…ç½®
   */
  getConfig(): DanmakuConfig {
    return { ...this.danmakuConfig };
  }

  /**
   * åŠ è½½è§†é¢‘å¼¹å¹•
   * @param videoId è§†é¢‘ID
   * @param siteKey ç«™ç‚¹é”?   * @param episodeIndex å‰§é›†ç´¢å¼•
   */
  async loadDanmakus(videoId: string, siteKey: string, episodeIndex?: number): Promise<DanmakuItem[]> {
    try {
      // é¦–å…ˆä»æœ¬åœ°å†å²åŠ è½?      const cacheKey = this.getCacheKey(videoId, siteKey, episodeIndex);
      const cachedDanmakus = await this.storageUtil.get<DanmakuItem[]>(cacheKey, []);
      
      // è¿™é‡Œå¯ä»¥æ·»åŠ ä»è¿œç¨‹æœåŠ¡å™¨åŠ è½½å¼¹å¹•çš„é€»è¾‘
      // const remoteDanmakus = await this.fetchRemoteDanmakus(videoId, siteKey, episodeIndex);
      
      // åˆå¹¶æœ¬åœ°å’Œè¿œç¨‹å¼¹å¹?      const allDanmakus = [...cachedDanmakus];
      
      // åº”ç”¨è¿‡æ»¤è§„åˆ™
      const filteredDanmakus = this.applyFilters(allDanmakus);
      
      // æŒ‰æ—¶é—´æ’åº?      filteredDanmakus.sort((a, b) => a.time - b.time);
      
      return filteredDanmakus;
    } catch (error) {
      console.error('Failed to load danmakus:', error);
      return [];
    }
  }

  /**
   * å‘é€å¼¹å¹?   * @param danmaku å¼¹å¹•å†…å®¹
   */
  async sendDanmaku(danmaku: Omit<DanmakuItem, 'id' | 'timestamp'>): Promise<boolean> {
    try {
      const newDanmaku: DanmakuItem = {
        ...danmaku,
        id: this.generateId(),
        timestamp: Date.now()
      };

      // ä¿å­˜åˆ°è‡ªå®šä¹‰å¼¹å¹•åˆ—è¡¨
      this.customDanmakus.push(newDanmaku);
      await this.storageUtil.save('customDanmakus', this.customDanmakus);

      // è¿™é‡Œå¯ä»¥æ·»åŠ å‘é€åˆ°è¿œç¨‹æœåŠ¡å™¨çš„é€»è¾‘
      // await this.sendToRemoteServer(newDanmaku);

      // é€šçŸ¥ç›‘å¬å™?      this.notifyDanmakuAdded(newDanmaku);

      return true;
    } catch (error) {
      console.error('Failed to send danmaku:', error);
      return false;
    }
  }

  /**
   * ä¿å­˜å¼¹å¹•åˆ°å†å²è®°å½?   * @param videoId è§†é¢‘ID
   * @param siteKey ç«™ç‚¹é”?   * @param danmakus å¼¹å¹•åˆ—è¡¨
   * @param episodeIndex å‰§é›†ç´¢å¼•
   */
  async saveDanmakusToHistory(videoId: string, siteKey: string, danmakus: DanmakuItem[], episodeIndex?: number): Promise<void> {
    try {
      const cacheKey = this.getCacheKey(videoId, siteKey, episodeIndex);
      
      // åˆå¹¶å¹¶å»é‡?      const existingDanmakus = await this.storageUtil.get<DanmakuItem[]>(cacheKey, []);
      const mergedDanmakus = this.mergeDanmakus(existingDanmakus, danmakus);
      
      await this.storageUtil.save(cacheKey, mergedDanmakus);
      
      // æ›´æ–°å†å²è®°å½•
      const historyItem: DanmakuHistoryItem = {
        videoId,
        siteKey,
        episodeIndex,
        danmakuCount: mergedDanmakus.length,
        lastUpdated: Date.now()
      };
      
      this.updateHistoryItem(historyItem);
    } catch (error) {
      console.error('Failed to save danmakus to history:', error);
    }
  }

  /**
   * æ·»åŠ å¼¹å¹•è¿‡æ»¤å…³é”®è¯?   * @param keyword å…³é”®è¯?   */
  async addFilterKeyword(keyword: string): Promise<void> {
    if (!this.danmakuConfig.filterKeywords.includes(keyword)) {
      this.danmakuConfig.filterKeywords.push(keyword);
      await this.setConfig(this.danmakuConfig);
    }
  }

  /**
   * ç§»é™¤å¼¹å¹•è¿‡æ»¤å…³é”®è¯?   * @param keyword å…³é”®è¯?   */
  async removeFilterKeyword(keyword: string): Promise<void> {
    this.danmakuConfig.filterKeywords = this.danmakuConfig.filterKeywords.filter(k => k !== keyword);
    await this.setConfig(this.danmakuConfig);
  }

  /**
   * æ·»åŠ å¼¹å¹•ç›‘å¬å™?   * @param listener ç›‘å¬å™?   */
  addListener(listener: DanmakuListener): void {
    if (!this.listeners.includes(listener)) {
      this.listeners.push(listener);
    }
  }

  /**
   * ç§»é™¤å¼¹å¹•ç›‘å¬å™?   * @param listener ç›‘å¬å™?   */
  removeListener(listener: DanmakuListener): void {
    this.listeners = this.listeners.filter(l => l !== listener);
  }

  /**
   * è·å–å¼¹å¹•å†å²è®°å½•
   */
  public async getDanmakuHistory(): Promise<DanmakuHistoryItem[]> {
    await this.loadHistory();
    return [...this.danmakuHistory];
  }

  /**
   * æ¸…ç©ºå¼¹å¹•å†å²
   */
  public async clearDanmakuHistory(): Promise<void> {
    this.danmakuHistory = [];
    await this.storageUtil.save('danmakuHistory', this.danmakuHistory);
  }

  /**
   * åº”ç”¨å¼¹å¹•è¿‡æ»¤è§„åˆ™
   * @param danmakus å¼¹å¹•åˆ—è¡¨
   */
  private applyFilters(danmakus: DanmakuItem[]): DanmakuItem[] {
    return danmakus.filter(danmaku => {
      // æ£€æŸ¥ç±»å‹è¿‡æ»?      switch (danmaku.type) {
        case DanmakuType.TOP:
          if (!this.danmakuConfig.showTop) return false;
          break;
        case DanmakuType.BOTTOM:
          if (!this.danmakuConfig.showBottom) return false;
          break;
        case DanmakuType.SCROLL:
          if (!this.danmakuConfig.showScroll) return false;
          break;
      }

      // æ£€æŸ¥å…³é”®è¯è¿‡æ»¤
      const content = danmaku.content.toLowerCase();
      return !this.danmakuConfig.filterKeywords.some(keyword => 
        content.includes(keyword.toLowerCase())
      );
    });
  }

  /**
   * åˆå¹¶å¼¹å¹•åˆ—è¡¨å¹¶å»é‡?   * @param existingDanmakus å·²å­˜åœ¨çš„å¼¹å¹•
   * @param newDanmakus æ–°å¼¹å¹?   */
  private mergeDanmakus(existingDanmakus: DanmakuItem[], newDanmakus: DanmakuItem[]): DanmakuItem[] {
    const idSet = new Set(existingDanmakus.map(d => d.id));
    const merged = [...existingDanmakus];
    
    for (const danmaku of newDanmakus) {
      if (!idSet.has(danmaku.id)) {
        merged.push(danmaku);
        idSet.add(danmaku.id);
      }
    }
    
    return merged;
  }

  /**
   * æ›´æ–°å†å²è®°å½•é¡?   * @param item å†å²è®°å½•é¡?   */
  private updateHistoryItem(item: DanmakuHistoryItem): void {
    const index = this.danmakuHistory.findIndex(
      h => h.videoId === item.videoId && h.siteKey === item.siteKey && h.episodeIndex === item.episodeIndex
    );
    
    if (index >= 0) {
      this.danmakuHistory[index] = item;
    } else {
      this.danmakuHistory.push(item);
    }
    
    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (this.danmakuHistory.length > 100) {
      this.danmakuHistory = this.danmakuHistory.slice(-100);
    }
    
    this.saveHistory();
  }

  /**
   * åŠ è½½å†å²è®°å½•
   */
  private async loadHistory(): Promise<void> {
    try {
      const history = await this.storageUtil.get<DanmakuHistoryItem[]>('danmakuHistory', []);
      this.danmakuHistory = history || [];
    } catch (error) {
      console.error('Failed to load danmaku history:', error);
      this.danmakuHistory = [];
    }
  }

  /**
   * ä¿å­˜å†å²è®°å½•
   */
  private async saveHistory(): Promise<void> {
    try {
      await this.storageUtil.save('danmakuHistory', this.danmakuHistory);
    } catch (error) {
      console.error('Failed to save danmaku history:', error);
    }
  }

  /**
   * ç”Ÿæˆç¼“å­˜é”?   */
  private getCacheKey(videoId: string, siteKey: string, episodeIndex?: number): string {
    return `danmaku_${siteKey}_${videoId}${episodeIndex !== undefined ? `_${episodeIndex}` : ''}`;
  }

  /**
   * ç”Ÿæˆå”¯ä¸€ID
   */
  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  /**
   * é€šçŸ¥å¼¹å¹•æ·»åŠ 
   */
  private notifyDanmakuAdded(danmaku: DanmakuItem): void {
    for (const listener of this.listeners) {
      listener.onDanmakuAdded?.(danmaku);
    }
  }

  /**
   * é€šçŸ¥é…ç½®å˜æ›´
   */
  private notifyConfigChanged(): void {
    for (const listener of this.listeners) {
      listener.onConfigChanged?.(this.danmakuConfig);
    }
  }
}

/**
 * å¼¹å¹•ç±»å‹æšä¸¾
 */
export enum DanmakuType {
  SCROLL = 0, // æ»šåŠ¨å¼¹å¹•
  TOP = 1,    // é¡¶éƒ¨å¼¹å¹•
  BOTTOM = 4  // åº•éƒ¨å¼¹å¹•
}

/**
 * å¼¹å¹•é…ç½®
 */
export interface DanmakuConfig {
  enabled: boolean;
  opacity: number;
  fontSize: number;
  speed: number;
  showTop: boolean;
  showBottom: boolean;
  showScroll: boolean;
  filterKeywords: string[];
  maxDisplayCount: number;
}

/**
 * å¼¹å¹•é¡? */
export interface DanmakuItem {
  id: string;
  content: string;
  time: number; // æ—¶é—´ï¼ˆç§’ï¼?  type: DanmakuType;
  color?: string;
  fontSize?: number;
  timestamp: number; // åˆ›å»ºæ—¶é—´æˆ?  user?: string;
}

/**
 * å¼¹å¹•å†å²è®°å½•é¡? */
export interface DanmakuHistoryItem {
  videoId: string;
  siteKey: string;
  episodeIndex?: number;
  danmakuCount: number;
  lastUpdated: number;
}

/**
 * å¼¹å¹•ç›‘å¬å™? */
export interface DanmakuListener {
  onDanmakuAdded?: (danmaku: DanmakuItem) => void;
  onConfigChanged?: (config: DanmakuConfig) => void;
}
