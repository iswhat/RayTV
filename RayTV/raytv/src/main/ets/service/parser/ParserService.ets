import Logger from '../../common/util/Logger';
import { ParserInfo } from '../../data/repository/NetworkRepository';
import { NetworkResult, VideoSourceInfo } from '../../data/bean/NetworkResult';
import { configService } from '../config/ConfigService';
import HttpService from '../HttpService';

/**
 * è§£æå™¨é…ç½®æ¥å? */
interface ParserConfig {
  enabled?: boolean;
  timeout?: number;
  retryCount?: number;
}

/**
 * è§£æå™¨æ‰§è¡Œä¸Šä¸‹æ–‡
 */
interface ParserContext {
  parserId: string;
  sourceUrl: string;
  config: ParserConfig;
}

/**
 * è§£æå™¨æœåŠ? * è´Ÿè´£ç®¡ç†å’Œæ‰§è¡Œè§†é¢‘æºè§£æåŠŸèƒ½
 */
/**
 * è‡ªå®šä¹‰è§£æå™¨æ¥å£
 */
interface CustomParser extends ParserInfo {
  // å¯èƒ½çš„é¢å¤–å±æ€?  version?: string;
  priority?: number;
}

export class ParserService {
  private static readonly TAG: string = 'ParserService';
  // ä½¿ç”¨é™æ€ç§æœ‰æˆå‘˜å˜é‡å­˜å‚¨å•ä¾‹å®ä¾?  private static instance: ParserService | null = null;
  
  private parsers: Map<string, ParserInfo> = new Map();
  private defaultConfig: ParserConfig = {
    enabled: true,
    timeout: 30000,
    retryCount: 2
  };
  
  /**
   * æ„é€ å‡½æ•?   */
  private constructor() {
    // åˆå§‹åŒ–é»˜è®¤è§£æå™¨
    this.initializeDefaultParsers();
  }
  
  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): ParserService {
    if (!ParserService.instance) {
      // åˆ›å»ºæ–°å®ä¾‹å¹¶å­˜å‚¨åˆ°é™æ€å˜é‡?      ParserService.instance = new ParserService();
    }
    // ç¡®ä¿è¿”å›å®ä¾‹ä¸ä¸ºnull
    return ParserService.instance!;
  }
  
  /**
   * åˆå§‹åŒ–æœåŠ?   */
  public async initialize(): Promise<void> {
    try {
      Logger.info(ParserService.TAG, 'Initializing ParserService...');
      
      // åŠ è½½è§£æå™¨é…ç½?      await this.loadParserConfig();
      
      // åŠ è½½è‡ªå®šä¹‰è§£æå™¨
      await this.loadCustomParsers();
      
      Logger.info(ParserService.TAG, `ParserService initialized with ${this.parsers.size} parsers`);
    } catch (error) {
      Logger.error(ParserService.TAG, `Failed to initialize ParserService: ${error}`);
      throw error instanceof Error ? error : new Error(String(error));
    }
  }
  
  /**
   * è·å–è§†é¢‘æºåˆ—è¡?   * @param contentId å†…å®¹ID
   * @param contentType å†…å®¹ç±»å‹
   * @returns Promise<NetworkResult<VideoSourceInfo[]>>
   */
  public async getVideoSources(contentId: string, contentType: string instanceof Error ? contentType: string : new Error(String(contentType: string instanceof Error ? contentType: string instanceof Error ? contentType: string : new Error(String(contentType: string : new Error(String(contentType: string instanceof Error ? contentType: string : new Error(String(contentType: string instanceof Error ? contentType: string instanceof Error ? contentType: string : new Error(String(contentType: string instanceof Error ? contentType: string instanceof Error ? contentType: string : new Error(String(contentType: string : new Error(String(contentType: string instanceof Error ? contentType: string : new Error(String(contentType: string : new Error(String(contentType: string instanceof Error ? contentType: string : new Error(String(contentType: string instanceof Error ? contentType: string instanceof Error ? contentType: string : new Error(String(contentType: string : new Error(String(contentType: string instanceof Error ? contentType: string : new Error(String(contentType: string))))))): Promise<NetworkResult<VideoSourceInfo[]>> {
    try {
      Logger.info(ParserService.TAG, `Getting video sources for contentId: ${contentId}, contentType: ${contentType}`);
      
      // è¿™é‡Œå¯ä»¥æ ¹æ®contentIdå’ŒcontentTypeè·å–è§†é¢‘æºåˆ—è¡?      // ç›®å‰è¿”å›ä¸€ä¸ªæ¨¡æ‹Ÿçš„ç©ºåˆ—è¡¨ï¼Œå¯ä»¥æ ¹æ®å®é™…éœ€æ±‚å®ç?      return { success: true, data: [] };
    } catch (error) {
      Logger.error(ParserService.TAG, `Failed to get video sources: ${error}`);
      return { 
        success: false, error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error instanceof Error ? error: error instanceof Error ? error : new Error(String(error : new Error(String(error: error instanceof Error ? error : new Error(String(error)))))))),
        message: 'Failed to get video sources' 
      };
    }
  }

  /**
   * è§£æè§†é¢‘æº?   * @param sourceUrl åŸå§‹è§†é¢‘æºURL
   * @param parserId è§£æå™¨IDï¼ˆå¯é€‰ï¼‰
   * @returns Promise<NetworkResult<VideoSourceInfo>>
   */
  public async parseVideoSource(sourceUrl: string, parserId?: string): Promise<NetworkResult<VideoSourceInfo>> {
    try {
      Logger.info(ParserService.TAG, `Parsing video source: ${sourceUrl}, parserId: ${parserId}`);
      
      // éªŒè¯URL
      if (!sourceUrl || typeof sourceUrl !== 'string') {
        return { success: false, message: 'Invalid source URL' };
      }
      
      // è·å–è§£æå™?      const parser = this.getParser(parserId);
      if (!parser) {
        return { success: false, message: 'No suitable parser found' };
      }
      
      // æ‰§è¡Œè§£æ
      // æ‰‹åŠ¨åˆå¹¶é…ç½®ï¼Œé¿å…å¯¹è±¡å±•å¼€æ“ä½œ
      const config: ParserConfig = {
        enabled: this.defaultConfig.enabled,
        timeout: this.defaultConfig.timeout,
        retryCount: this.defaultConfig.retryCount
      };
      
      const context: ParserContext = {
        parserId: parser.id,
        sourceUrl,
        config: config
      };
      
      const result = await this.executeParser(context);
      
      // è®°å½•è§£æç»“æœ
      Logger.info(ParserService.TAG, `Parse result for ${sourceUrl}: ${result.success ? 'success' : 'failed'}`);
      
      return result;
    } catch (error) {
      Logger.error(ParserService.TAG, `Failed to parse video source: ${error}`);
      return { success: false, message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error instanceof Error ? message: `Parse failed: ${error instanceof Error ? error.message : String(error : new Error(String(message: `Parse failed: ${error instanceof Error ? error.message : String(error)))))))}` };
    }
  }
  
  /**
   * è·å–æ‰€æœ‰å¯ç”¨è§£æå™¨
   * @returns Promise<NetworkResult<ParserInfo[]>>
   */
  public async getParsers(): Promise<NetworkResult<ParserInfo[]>> {
    try {
      const parserList = Array.from(this.parsers.values()).filter(p => p.enabled !== false);
      return { success: true, data: parserList };
    } catch (error) {
      Logger.error(ParserService.TAG, `Failed to get parsers: ${error}`);
      return { success: false, message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string instanceof Error ? message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string : new Error(String(message: `Get parsers failed: ${error}` };
    }
  }
  
  /**
   * æ£€æŸ¥è§£æå™¨æ˜¯å¦å¯ç”¨
   * @param parserId è§£æå™¨ID
   * @returns Promise<NetworkResult<boolean>>
   */
  public async checkParserAvailability(parserId: string))))))): Promise<NetworkResult<boolean>> {
    try {
      const parser = this.parsers.get(parserId);
      const available = !!parser && parser.enabled !== false;
      return { success: true, data: available };
    } catch (error) {
      Logger.error(ParserService.TAG, `Failed to check parser availability: ${error}`);
      return { success: false, message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo instanceof Error ? message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo : new Error(String(message: `Check availability failed: ${error}` };
    }
  }
  
  /**
   * æ·»åŠ è‡ªå®šä¹‰è§£æå™¨
   * @param parser è§£æå™¨ä¿¡æ?   */
  public addParser(parser: ParserInfo))))))): void {
    if (parser && parser.id) {
      this.parsers.set(parser.id, parser);
      Logger.info(ParserService.TAG, `Added custom parser: ${parser.name} (${parser.id})`);
    }
  }
  
  /**
   * ç§»é™¤è§£æå™?   * @param parserId è§£æå™¨ID
   */
  public removeParser(parserId: string): void {
    if (this.parsers.delete(parserId)) {
      Logger.info(ParserService.TAG, `Removed parser: ${parserId}`);
    }
  }
  
  /**
   * æ›´æ–°è§£æå™¨é…ç½?   * @param parserId è§£æå™¨ID
   * @param config æ–°é…ç½?   */
  public updateParserConfig(parserId: string, config: Partial<ParserInfo>): void {
    const parser = this.parsers.get(parserId);
    if (parser) {
      // æ‰‹åŠ¨åˆå¹¶è§£æå™¨é…ç½®ï¼Œé¿å…å¯¹è±¡å±•å¼€æ“ä½œ
      const updatedParser: ParserInfo = {
        id: parser.id,
        name: parser.name,
        description: config.description !== undefined ? config.description : parser.description,
        supports: config.supports !== undefined ? config.supports : parser.supports,
        version: config.version !== undefined ? config.version : parser.version,
        isEnabled: config.isEnabled !== undefined ? config.isEnabled : parser.isEnabled,
        config: config.config !== undefined ? config.config : parser.config
      };
      
      this.parsers.set(parserId, updatedParser);
      Logger.info(ParserService.TAG, 'Updated parser config', updatedParser as Error);
    }
  }
  
  /**
   * åˆå§‹åŒ–é»˜è®¤è§£æå™¨
   */
  private initializeDefaultParsers(): void {
    // æ·»åŠ é»˜è®¤è§£æå™?    const defaultParsers: ParserInfo[] = [
      {
        id: 'direct',
        name: 'ç›´é“¾è§£æ',
        description: 'ç›´æ¥ä½¿ç”¨åŸå§‹URLï¼Œé€‚ç”¨äºHTTP/HTTPSè§†é¢‘æµ?,
        supports: ['http', 'https'],
        version: '1.0',
        isEnabled: true
      },
      {
        id: 'hls',
        name: 'HLSè§£æ',
        description: 'è§£æHLSæµ?m3u8æ ¼å¼)',
        supports: ['m3u8', 'hls'],
        version: '1.0',
        isEnabled: true
      },
      {
        id: 'dash',
        name: 'DASHè§£æ',
        description: 'è§£æDASHæµ?mpdæ ¼å¼)',
        supports: ['mpd', 'dash'],
        version: '1.0',
        isEnabled: true
      },
      {
        id: 'mp4',
        name: 'MP4è§£æ',
        description: 'MP4æ–‡ä»¶ç›´æ¥æ’­æ”¾è§£æ',
        supports: ['mp4'],
        version: '1.0',
        isEnabled: true
      },
      {
        id: 'flv',
        name: 'FLVè§£æ',
        description: 'FLVæ–‡ä»¶ç›´æ¥æ’­æ”¾è§£æ',
        supports: ['flv'],
        version: '1.0',
        isEnabled: true
      }
    ];
    
    // æ³¨å†Œé»˜è®¤è§£æå™?    defaultParsers.forEach(parser => {
      this.parsers.set(parser.id, parser);
    });
  }
  
  /**
   * åŠ è½½è§£æå™¨é…ç½?   */
  private async loadParserConfig(): Promise<void> {
    try {
      // ä»é…ç½®æœåŠ¡åŠ è½½è§£æå™¨é…ç½®
      const parserConfig = await configService.getConfig<Record<string, boolean | number>>('parserConfig', {});
      
      if (parserConfig && typeof parserConfig === 'object') {
        // æ‰‹åŠ¨åˆå¹¶é»˜è®¤é…ç½®ï¼Œé¿å…å¯¹è±¡å±•å¼€æ“ä½œ
        if (parserConfig.enabled !== undefined) {
          this.defaultConfig.enabled = parserConfig.enabled as boolean;
        }
        if (parserConfig.timeout !== undefined) {
          this.defaultConfig.timeout = parserConfig.timeout as number;
        }
        if (parserConfig.retryCount !== undefined) {
          this.defaultConfig.retryCount = parserConfig.retryCount as number;
        }
      }
    } catch (error) {
      Logger.warn(ParserService.TAG, `Failed to load parser config: ${error}`);
    }
  }
  
  /**
   * åŠ è½½è‡ªå®šä¹‰è§£æå™¨
   */
  private async loadCustomParsers(): Promise<void> {
    try {
      // ä»é…ç½®æœåŠ¡åŠ è½½è‡ªå®šä¹‰è§£æå™?      const customParsers: CustomParser[] = await configService.getConfig<CustomParser[]>('customParsers', []);
      
      if (Array.isArray(customParsers)) {
        for (let i = 0; i < customParsers.length; i++) {
          const parser = customParsers[i];
          try {
            if (parser && typeof parser === 'object' && parser.id && parser.name) {
              this.addParser({
                id: parser.id,
                name: parser.name,
                description: parser.description,
                type: parser.type,
                url: parser.url,
                enabled: parser.enabled !== undefined ? parser.enabled : true
              } as ParserInfo);
            }
          } catch (error) {
            Logger.warn(ParserService.TAG, `Failed to add custom parser: ${error}`);
          }
        }
      }
    } catch (error) {
      Logger.warn(ParserService.TAG, `Failed to load custom parsers: ${error}`);
    }
  }
  
  /**
   * è·å–é€‚åˆçš„è§£æå™¨
   */
  private getParser(parserId?: string): ParserInfo | undefined {
    // å¦‚æœæŒ‡å®šäº†è§£æå™¨IDï¼Œä¼˜å…ˆä½¿ç”?    if (parserId) {
      return this.parsers.get(parserId);
    }
    
    // è¿”å›é»˜è®¤è§£æå™?    return this.parsers.get('direct');
  }
  
  /**
   * æ‰§è¡Œè§£æå™?   */
  private async executeParser(context: ParserContext): Promise<NetworkResult<VideoSourceInfo>> {
    let attempts = 0;
    
    while (attempts <= context.config.retryCount!) {
      attempts++;
      
      try {
        // æ ¹æ®è§£æå™¨ç±»å‹æ‰§è¡Œä¸åŒçš„è§£æé€»è¾‘
        let result: VideoSourceInfo;
        
        switch (context.parserId) {
          case 'direct':
            result = await this.directParse(context.sourceUrl);
            break;
          case 'hls':
            result = await this.hlsParse(context.sourceUrl);
            break;
          case 'dash':
            result = await this.dashParse(context.sourceUrl);
            break;
          case 'mp4':
          case 'flv':
            result = await this.directParse(context.sourceUrl);
            break;
          default:
            // å¯¹äºè‡ªå®šä¹‰è§£æå™¨ï¼Œè¿™é‡Œå¯ä»¥æ‰©å±•ä¸ºè°ƒç”¨å¤–éƒ¨APIæˆ–å…¶ä»–è§£æé€»è¾‘
            result = await this.directParse(context.sourceUrl);
        }
        
        return { success: true, data: result };
      } catch (error) {
        Logger.warn(ParserService.TAG, `Parse attempt ${attempts} failed: ${error instanceof Error ? error.message : String(error)}`);
        
        if (attempts > context.config.retryCount!) {
          throw error instanceof Error ? error : new Error(String(error));
        }
        
        // æŒ‡æ•°é€€é¿é‡è¯?        const backoffTime = Math.pow(2, attempts - 1) * 1000 + Math.random() * 500;
        // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
        await new Promise(resolve => setTimeout(resolve, backoffTime));
      }
    }
    
    throw new Error('All parse attempts failed');
  }
  
  /**
   * ç›´æ¥è§£æï¼ˆä¸åšå¤„ç†ï¼‰
   */
  private async directParse(url: string): Promise<VideoSourceInfo> {
    // ç®€å•æ£€æµ‹è§†é¢‘ç±»å?    let format = 'unknown';
    let mimeType = 'video/mp4'; // é»˜è®¤
    
    if (url.includes('.m3u8')) {
      format = 'hls';
      mimeType = 'application/x-mpegURL';
    } else if (url.includes('.mpd')) {
      format = 'dash';
      mimeType = 'application/dash+xml';
    } else if (url.includes('.mp4')) {
      format = 'mp4';
      mimeType = 'video/mp4';
    } else if (url.includes('.flv')) {
      format = 'flv';
      mimeType = 'video/x-flv';
    } else if (url.includes('.mkv')) {
      format = 'mkv';
      mimeType = 'video/x-matroska';
    }
    
    return {
      id: `source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: `Direct Source (${format})`,
      url,
      format,
      mimeType,
      quality: 'unknown',
      headers: {},
      duration: 0
    };
  }
  
  /**
   * HLSæµè§£æ?   */
  private async hlsParse(url: string): Promise<VideoSourceInfo> {
    try {
      // éªŒè¯URLæ˜¯å¦ä¸ºm3u8æ ¼å¼
      let m3u8Url = url;
      if (!url.includes('.m3u8')) {
        // å°è¯•è·å–é‡å®šå‘åçš„URL
        try {
          const response = await HttpService.getInstance().head(url, { timeout: 10000 });
          if (response.headers) {
            const contentType = response.headers['content-type'] || response.headers['Content-Type'];
            if (contentType && contentType.includes('application/x-mpegURL')) {
              m3u8Url = url;
            }
          }
        } catch (headError) {
          // HEADè¯·æ±‚å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨åŸå§‹URL
          Logger.debug(ParserService.TAG, `HEAD request failed: ${headError instanceof Error ? headError.message : String(headError)}`);
        }
      }
      
      return {
        id: `source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: `HLS Source`,
        url: m3u8Url,
        format: 'hls',
        mimeType: 'application/x-mpegURL',
        quality: this.detectQuality(m3u8Url),
        headers: {},
        duration: 0
      };
    } catch (error) {
      Logger.warn(ParserService.TAG, `Failed to parse HLS stream: ${error instanceof Error ? error.message : String(error)}`);
      // é™çº§ä¸ºç›´æ¥è§£æ?      return this.directParse(url);
    }
  }
  
  /**
   * DASHæµè§£æ?   */
  private async dashParse(url: string): Promise<VideoSourceInfo> {
    try {
      // éªŒè¯URLæ˜¯å¦ä¸ºmpdæ ¼å¼
      let mpdUrl = url;
      if (!url.includes('.mpd')) {
        // å°è¯•è·å–é‡å®šå‘åçš„URL
        try {
          const response = await HttpService.getInstance().head(url, { timeout: 10000 });
          if (response.headers) {
            const contentType = response.headers['content-type'] || response.headers['Content-Type'];
            if (contentType && contentType.includes('application/dash+xml')) {
              mpdUrl = url;
            }
          }
        } catch (headError) {
          // HEADè¯·æ±‚å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨åŸå§‹URL
          Logger.debug(ParserService.TAG, `HEAD request failed: ${headError instanceof Error ? headError.message : String(headError)}`);
        }
      }
      
      return {
        id: `source_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: `DASH Source`,
        url: mpdUrl,
        format: 'dash',
        mimeType: 'application/dash+xml',
        quality: this.detectQuality(mpdUrl),
        headers: {},
        duration: 0
      };
    } catch (error) {
      Logger.warn(ParserService.TAG, `Failed to parse DASH stream: ${error instanceof Error ? error.message : String(error)}`);
      // é™çº§ä¸ºç›´æ¥è§£æ?      return this.directParse(url);
    }
  }
  
  /**
   * ä»URLæ£€æµ‹è§†é¢‘è´¨é‡?   */
  private detectQuality(url: string): string {
    const lowercaseUrl = url.toLowerCase();
    
    if (lowercaseUrl.includes('4k') || lowercaseUrl.includes('2160')) {
      return '4K';
    } else if (lowercaseUrl.includes('1080') || lowercaseUrl.includes('fhd')) {
      return '1080P';
    } else if (lowercaseUrl.includes('720') || lowercaseUrl.includes('hd')) {
      return '720P';
    } else if (lowercaseUrl.includes('480') || lowercaseUrl.includes('sd')) {
      return '480P';
    } else if (lowercaseUrl.includes('360')) {
      return '360P';
    }
    
    return 'unknown';
  }
  
  /**
   * æ¸…ç†èµ„æº
   */
  public destroy(): void {
    try {
      this.parsers.clear();
      Logger.info(ParserService.TAG, 'ParserService destroyed');
      // é‡ç½®å•ä¾‹å®ä¾‹
      ParserService.instance = null;
    } catch (error) {
      Logger.error(ParserService.TAG, `Failed to destroy ParserService: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

// å¯¼å‡ºå•ä¾‹å®ä¾‹ - ä½¿ç”¨å‡½æ•°è°ƒç”¨æ–¹å¼
export function getParserService(): ParserService {
  return ParserService.getInstance();
}


