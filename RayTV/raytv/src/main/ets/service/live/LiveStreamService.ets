// LiveStreamService - ç›´æ’­æµæœåŠ¡ç±»
import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import DateUtil from '../../common/util/DateUtil';
import RepositoryFactory from '../../data/repository/RepositoryFactory';
import DatabaseRepository from '../../data/repository/DatabaseRepository';
import NetworkRepository from '../../data/repository/NetworkRepository';

// å¯¼å…¥æ¨¡å‹å’ŒDTO
import ApiResponse, { ResponseCode } from '../dto/ApiResponse';
import Movie, { VideoSource, VideoType, VideoQuality } from '../model/Movie';

// å¸¸é‡å®šä¹‰
const TAG = 'LiveStreamService';
const LIVE_FAVORITES_KEY = 'live_favorites';
const LIVE_CATEGORY_CACHE_KEY = 'live_categories';
const LIVE_CHANNEL_CACHE_KEY = 'live_channels';
const CACHE_EXPIRY_TIME = 30 * 60 * 1000; // 30åˆ†é’Ÿç¼“å­˜æœ‰æ•ˆæœ?
// ç›´æ’­çŠ¶æ€æšä¸?export enum LiveStatus {
  OFFLINE = 'offline',    // ç¦»çº¿
  LIVE = 'live',         // ç›´æ’­ä¸?  UPCOMING = 'upcoming',  // å³å°†å¼€å§?  ENDING = 'ending',      // å³å°†ç»“æŸ
  ERROR = 'error'         // é”™è¯¯
}

// ç›´æ’­è´¨é‡æšä¸¾
export enum LiveQuality {
  AUTO = 'auto',         // è‡ªåŠ¨
  LOW = 'low',          // ä½æ¸…æ™°åº¦
  SD = 'sd',           // æ ‡æ¸…
  HD = 'hd',           // é«˜æ¸…
  FHD = 'fhd',         // å…¨é«˜æ¸?  UHD = 'uhd'          // è¶…é«˜æ¸?}

// ç›´æ’­åˆ†ç±»æ¥å£
export interface LiveCategory {
  id: string;           // åˆ†ç±»ID
  name: string;         // åˆ†ç±»åç§°
  icon?: string;        // åˆ†ç±»å›¾æ ‡
  order: number;        // æ’åº
  channelCount: number; // é¢‘é“æ•°é‡
}

// ç›´æ’­é¢‘é“æ¥å£
export interface LiveChannel {
  id: string;          // é¢‘é“ID
  name: string;        // é¢‘é“åç§°
  logo?: string;       // é¢‘é“logo
  description?: string; // é¢‘é“æè¿°
  categoryId: string;  // åˆ†ç±»ID
  categoryName: string; // åˆ†ç±»åç§°
  status: LiveStatus;  // ç›´æ’­çŠ¶æ€?  url?: string;        // ç›´æ’­æºURL
  qualities?: LiveQuality[]; // å¯ç”¨æ¸…æ™°åº?  currentProgram?: LiveProgram; // å½“å‰èŠ‚ç›®
  nextProgram?: LiveProgram;   // ä¸‹ä¸€ä¸ªèŠ‚ç›?  tags?: string[];     // æ ‡ç­¾
  isFavorite: boolean; // æ˜¯å¦æ”¶è—
  viewCount?: number;  // è§‚çœ‹äººæ•°
  country?: string;    // å›½å®¶/åœ°åŒº
  language?: string;   // è¯­è¨€
  isLocked?: boolean;  // æ˜¯å¦é”å®š
}

// ç›´æ’­èŠ‚ç›®æ¥å£
export interface LiveProgram {
  id: string;          // èŠ‚ç›®ID
  title: string;       // èŠ‚ç›®æ ‡é¢˜
  startTime: number;   // å¼€å§‹æ—¶é—´ï¼ˆæ—¶é—´æˆ³ï¼‰
  endTime: number;     // ç»“æŸæ—¶é—´ï¼ˆæ—¶é—´æˆ³ï¼?  description?: string; // èŠ‚ç›®æè¿°
  cover?: string;      // èŠ‚ç›®å°é¢
  genre?: string[];    // èŠ‚ç›®ç±»å‹
  actors?: string[];   // æ¼”å‘˜
  director?: string;   // å¯¼æ¼”
}

// ç›´æ’­äº‹ä»¶æ¥å£
export interface LiveEvent {
  id: string;          // äº‹ä»¶ID
  title: string;       // äº‹ä»¶æ ‡é¢˜
  description: string; // äº‹ä»¶æè¿°
  startTime: number;   // å¼€å§‹æ—¶é—?  endTime: number;     // ç»“æŸæ—¶é—´
  coverImage?: string; // å°é¢å›?  channelId: string;   // æ‰€å±é¢‘é“ID
  channelName: string; // æ‰€å±é¢‘é“åç§?  status: LiveStatus;  // ç›´æ’­çŠ¶æ€?  isHighlight?: boolean; // æ˜¯å¦é«˜äº®
}

// ç›´æ’­æºä¿¡æ¯æ¥å?export interface LiveSource {
  id: string;          // æºID
  url: string;         // æºURL
  quality: LiveQuality; // æ¸…æ™°åº?  isDefault: boolean;  // æ˜¯å¦é»˜è®¤
  bitrate?: number;    // æ¯”ç‰¹ç?  codec?: string;      // ç¼–ç æ ¼å¼
  protocol?: string;   // åè®®ç±»å‹
  resolution?: string; // åˆ†è¾¨ç?}

// ç›´æ’­ç­›é€‰æ¡ä»¶æ¥å?export interface LiveFilter {
  categories?: string[]; // åˆ†ç±»IDåˆ—è¡¨
  search?: string;       // æœç´¢å…³é”®è¯?  status?: LiveStatus[]; // ç›´æ’­çŠ¶æ€?  countries?: string[];  // å›½å®¶/åœ°åŒº
  languages?: string[];  // è¯­è¨€
  favoritesOnly?: boolean; // ä»…æ˜¾ç¤ºæ”¶è—?}

// ç›´æ’­æ’åºç±»å‹æšä¸¾
export enum LiveSortType {
  DEFAULT = 'default',     // é»˜è®¤æ’åº
  NAME_ASC = 'name_asc',    // åç§°å‡åº
  NAME_DESC = 'name_desc',  // åç§°é™åº
  VIEW_COUNT = 'view_count', // è§‚çœ‹äººæ•°
  STATUS = 'status'        // çŠ¶æ€?}

// é¢‘é“ç»„æ¥å?export interface ChannelGroup {
  id: string;          // ç»„ID
  name: string;        // ç»„åç§?  channelIds: string[]; // é¢‘é“IDåˆ—è¡¨
  order: number;       // æ’åº
  isDefault?: boolean;  // æ˜¯å¦é»˜è®¤ç»?}

// ç›´æ’­ç»Ÿè®¡ä¿¡æ¯æ¥å£
export interface LiveStatistics {
  totalChannels: number;  // æ€»é¢‘é“æ•°
  liveChannels: number;   // ç›´æ’­ä¸­é¢‘é“æ•°
  offlineChannels: number; // ç¦»çº¿é¢‘é“æ•?  totalCategories: number; // æ€»åˆ†ç±»æ•°
  favoriteChannels: number; // æ”¶è—é¢‘é“æ•?  recentViews: number;    // æœ€è¿‘è§‚çœ‹æ•°
}

/**
 * ç›´æ’­æµæœåŠ¡ç±»
 * è´Ÿè´£ç®¡ç†ç›´æ’­ç›¸å…³åŠŸèƒ½
 */
export default class LiveStreamService {
  private static instance: LiveStreamService;
  private databaseRepo: DatabaseRepository;
  private networkRepo: NetworkRepository;
  
  private favoriteChannels: Set<string> = new Set();
  private channelGroups: Map<string, ChannelGroup> = new Map();
  private isInitialized: boolean = false;
  
  // ç¼“å­˜æ•°æ®
  private cachedCategories: {
    data: LiveCategory[];
    timestamp: number;
  } | null = null;
  
  private cachedChannels: Map<string, {
    data: LiveChannel[];
    timestamp: number;
  }> = new Map();
  
  // ç›‘å¬å™?  private favoriteListeners: Array<(channelId: string, isFavorite: boolean) => void> = [];
  private channelGroupListeners: Array<(groups: ChannelGroup[]) => void> = [];
  private statusListeners: Map<string, Array<(status: LiveStatus) => void>> = new Map();

  /**
   * æ„é€ å‡½æ•°ï¼ˆç§æœ‰ï¼Œé˜²æ­¢å¤–éƒ¨å®ä¾‹åŒ–ï¼?   */
  private constructor() {
    this.databaseRepo = RepositoryFactory.getRepository('database') as DatabaseRepository;
    this.networkRepo = RepositoryFactory.getRepository('network') as NetworkRepository;
    this.initialize();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): LiveStreamService {
    if (!LiveStreamService.instance) {
      LiveStreamService.instance = new LiveStreamService();
    }
    return LiveStreamService.instance;
  }

  /**
   * åˆå§‹åŒ–ç›´æ’­æœåŠ?   */
  public async initialize(): Promise<void> {
    try {
      Logger.info(TAG, 'Initializing live stream service...');
      
      // åŠ è½½æ”¶è—é¢‘é“
      await this.loadFavoriteChannels();
      
      // åŠ è½½é¢‘é“ç»?      await this.loadChannelGroups();
      
      // åŠ è½½ç¼“å­˜æ•°æ®
      await this.loadCachedData();
      
      this.isInitialized = true;
      Logger.info(TAG, 'Live stream service initialized successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to initialize live stream service', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * åŠ è½½æ”¶è—é¢‘é“
   */
  private async loadFavoriteChannels(): Promise<void> {
    try {
      // ä»å­˜å‚¨ä¸­åŠ è½½æ”¶è—åˆ—è¡¨
      const favoritesJson = await StorageUtil.getString(LIVE_FAVORITES_KEY);
      if (favoritesJson) {
        const favorites = JSON.parse(favoritesJson) as string[];
        favorites.forEach(channelId => this.favoriteChannels.add(channelId));
      }
      
      Logger.info(TAG, `Loaded ${this.favoriteChannels.size} favorite channels`);
    } catch (error) {
      Logger.error(TAG, 'Failed to load favorite channels', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      this.favoriteChannels = new Set();
    }
  }

  /**
   * ä¿å­˜æ”¶è—é¢‘é“
   */
  private async saveFavoriteChannels(): Promise<void> {
    try {
      const favoritesJson = JSON.stringify(Array.from(this.favoriteChannels));
      await StorageUtil.setString(LIVE_FAVORITES_KEY, favoritesJson);
      Logger.debug(TAG, 'Saved favorite channels');
    } catch (error) {
      Logger.error(TAG, 'Failed to save favorite channels', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * åŠ è½½é¢‘é“ç»?   */
  private async loadChannelGroups(): Promise<void> {
    try {
      // ä»æ•°æ®åº“åŠ è½½é¢‘é“ç»?      const result = await this.databaseRepo.getLiveChannelGroups();
      if (result.isSuccess() && result.data) {
        result.data.forEach(group => {
          this.channelGroups.set(group.id, group);
        });
      }
      
      Logger.info(TAG, `Loaded ${this.channelGroups.size} channel groups`);
    } catch (error) {
      Logger.error(TAG, 'Failed to load channel groups', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * åŠ è½½ç¼“å­˜æ•°æ®
   */
  private async loadCachedData(): Promise<void> {
    try {
      // åŠ è½½åˆ†ç±»ç¼“å­˜
      const categoryCacheJson = await StorageUtil.getString(LIVE_CATEGORY_CACHE_KEY);
      if (categoryCacheJson) {
        const cacheData = JSON.parse(categoryCacheJson);
        this.cachedCategories = cacheData;
      }
      
      // åŠ è½½é¢‘é“ç¼“å­˜
      const channelCacheJson = await StorageUtil.getString(LIVE_CHANNEL_CACHE_KEY);
      if (channelCacheJson) {
        const cacheData = JSON.parse(channelCacheJson);
        Object.entries(cacheData).forEach(([key, value]) => {
          this.cachedChannels.set(key, value);
        });
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to load cached data', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * ä¿å­˜ç¼“å­˜æ•°æ®
   */
  private async saveCachedData(): Promise<void> {
    try {
      // ä¿å­˜åˆ†ç±»ç¼“å­˜
      if (this.cachedCategories) {
        await StorageUtil.setString(
          LIVE_CATEGORY_CACHE_KEY,
          JSON.stringify(this.cachedCategories)
        );
      }
      
      // ä¿å­˜é¢‘é“ç¼“å­˜
      const channelsCache = Object.fromEntries(this.cachedChannels.entries());
      await StorageUtil.setString(
        LIVE_CHANNEL_CACHE_KEY,
        JSON.stringify(channelsCache)
      );
    } catch (error) {
      Logger.error(TAG, 'Failed to save cached data', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }

  /**
   * æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•?   */
  private isCacheValid(timestamp: number): boolean {
    return Date.now() - timestamp < CACHE_EXPIRY_TIME;
  }

  /**
   * è·å–æ‰€æœ‰ç›´æ’­åˆ†ç±?   */
  public async getCategories(): Promise<ApiResponse<LiveCategory[]>> {
    try {
      // æ£€æŸ¥ç¼“å­?      if (this.cachedCategories && this.isCacheValid(this.cachedCategories.timestamp)) {
        Logger.debug(TAG, 'Returning categories from cache');
        return ApiResponse.success(this.cachedCategories.data, 'è·å–åˆ†ç±»æˆåŠŸï¼ˆç¼“å­˜ï¼‰');
      }
      
      // ä»ç½‘ç»œè·å–åˆ†ç±?      Logger.debug(TAG, 'Fetching categories from network');
      const result = await this.networkRepo.getLiveCategories();
      
      if (result.isSuccess() && result.data) {
        // æ›´æ–°ç¼“å­˜
        this.cachedCategories = {
          data: result.data,
          timestamp: Date.now()
        };
        
        // ä¿å­˜ç¼“å­˜åˆ°æœ¬åœ?        await this.saveCachedData();
        
        return ApiResponse.success(result.data, 'è·å–åˆ†ç±»æˆåŠŸ');
      } else {
        // å¦‚æœç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ç¼“å­˜æ•°æ?        if (this.cachedCategories) {
          Logger.warn(TAG, 'Network failed, using cached categories');
          return ApiResponse.success(this.cachedCategories.data, 'è·å–åˆ†ç±»æˆåŠŸï¼ˆç¼“å­˜ï¼‰');
        }
        
        return ApiResponse.error(result.code, result.message || 'è·å–åˆ†ç±»å¤±è´¥');
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to get categories', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      
      // å¦‚æœå‘ç”Ÿå¼‚å¸¸ï¼Œå°è¯•ä½¿ç”¨ç¼“å­˜æ•°æ?      if (this.cachedCategories) {
        Logger.warn(TAG, 'Error occurred, using cached categories');
        return ApiResponse.success(this.cachedCategories.data, 'è·å–åˆ†ç±»æˆåŠŸï¼ˆç¼“å­˜ï¼‰');
      }
      
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–åˆ†ç±»å¤±è´¥');
    }
  }

  /**
   * æ ¹æ®åˆ†ç±»è·å–é¢‘é“åˆ—è¡¨
   */
  public async getChannelsByCategory(categoryId: string): Promise<ApiResponse<LiveChannel[]>> {
    try {
      // æ£€æŸ¥ç¼“å­?      const cacheKey = `category_${categoryId}`;
      const cached = this.cachedChannels.get(cacheKey);
      if (cached && this.isCacheValid(cached.timestamp)) {
        Logger.debug(TAG, `Returning channels for category ${categoryId} from cache`);
        const channelsWithFavoriteStatus = cached.data.map(channel => ({
          ...channel,
          isFavorite: this.favoriteChannels.has(channel.id)
        }));
        return ApiResponse.success(channelsWithFavoriteStatus, 'è·å–é¢‘é“æˆåŠŸï¼ˆç¼“å­˜ï¼‰');
      }
      
      // ä»ç½‘ç»œè·å–é¢‘é?      Logger.debug(TAG, `Fetching channels for category ${categoryId} from network`);
      const result = await this.networkRepo.getLiveChannelsByCategory(categoryId);
      
      if (result.isSuccess() && result.data) {
        // æ›´æ–°æ”¶è—çŠ¶æ€?        const channelsWithFavoriteStatus = result.data.map(channel => ({
          ...channel,
          isFavorite: this.favoriteChannels.has(channel.id)
        }));
        
        // æ›´æ–°ç¼“å­˜
        this.cachedChannels.set(cacheKey, {
          data: channelsWithFavoriteStatus,
          timestamp: Date.now()
        });
        
        // ä¿å­˜ç¼“å­˜åˆ°æœ¬åœ?        await this.saveCachedData();
        
        return ApiResponse.success(channelsWithFavoriteStatus, 'è·å–é¢‘é“æˆåŠŸ');
      } else {
        // å¦‚æœç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ç¼“å­˜æ•°æ?        if (cached) {
          Logger.warn(TAG, `Network failed, using cached channels for category ${categoryId}`);
          const channelsWithFavoriteStatus = cached.data.map(channel => ({
            ...channel,
            isFavorite: this.favoriteChannels.has(channel.id)
          }));
          return ApiResponse.success(channelsWithFavoriteStatus, 'è·å–é¢‘é“æˆåŠŸï¼ˆç¼“å­˜ï¼‰');
        }
        
        return ApiResponse.error(result.code, result.message || 'è·å–é¢‘é“å¤±è´¥');
      }
    } catch (error) {
      Logger.error(TAG, `Failed to get channels for category ${categoryId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      
      // å¦‚æœå‘ç”Ÿå¼‚å¸¸ï¼Œå°è¯•ä½¿ç”¨ç¼“å­˜æ•°æ?      const cacheKey = `category_${categoryId}`;
      const cached = this.cachedChannels.get(cacheKey);
      if (cached) {
        Logger.warn(TAG, `Error occurred, using cached channels for category ${categoryId}`);
        const channelsWithFavoriteStatus = cached.data.map(channel => ({
          ...channel,
          isFavorite: this.favoriteChannels.has(channel.id)
        }));
        return ApiResponse.success(channelsWithFavoriteStatus, 'è·å–é¢‘é“æˆåŠŸï¼ˆç¼“å­˜ï¼‰');
      }
      
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–é¢‘é“å¤±è´¥');
    }
  }

  /**
   * è·å–æ‰€æœ‰ç›´æ’­é¢‘é“ï¼ˆåˆ†é¡µï¼?   */
  public async getAllChannels(
    page: number = 1,
    pageSize: number = 50
  ): Promise<ApiResponse<{ channels: LiveChannel[], total: number }>> {
    try {
      const result = await this.networkRepo.getLiveChannels(page, pageSize);
      
      if (result.isSuccess() && result.data) {
        // æ›´æ–°æ”¶è—çŠ¶æ€?        const channelsWithFavoriteStatus = result.data.channels.map(channel => ({
          ...channel,
          isFavorite: this.favoriteChannels.has(channel.id)
        }));
        
        return ApiResponse.success(
          { 
            channels: channelsWithFavoriteStatus,
            total: result.data.total
          }, 
          'è·å–æ‰€æœ‰é¢‘é“æˆåŠ?
        );
      } else {
        return ApiResponse.error(result.code, result.message || 'è·å–é¢‘é“å¤±è´¥');
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to get all channels', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–é¢‘é“å¤±è´¥');
    }
  }

  /**
   * æ ¹æ®IDè·å–ç›´æ’­é¢‘é“è¯¦æƒ…
   */
  public async getChannelById(channelId: string): Promise<ApiResponse<LiveChannel>> {
    try {
      // å…ˆå°è¯•ä»ç¼“å­˜ä¸­æŸ¥æ‰?      let channel: LiveChannel | undefined;
      for (const cache of this.cachedChannels.values()) {
        const found = cache.data.find(c => c.id === channelId);
        if (found) {
          channel = found;
          break;
        }
      }
      
      if (channel && this.isCacheValid(cache.timestamp)) {
        // æ›´æ–°æ”¶è—çŠ¶æ€?        channel.isFavorite = this.favoriteChannels.has(channel.id);
        Logger.debug(TAG, `Returning channel ${channelId} from cache`);
        return ApiResponse.success(channel, 'è·å–é¢‘é“è¯¦æƒ…æˆåŠŸï¼ˆç¼“å­˜ï¼‰');
      }
      
      // ä»ç½‘ç»œè·å–é¢‘é“è¯¦æƒ?      Logger.debug(TAG, `Fetching channel ${channelId} from network`);
      const result = await this.networkRepo.getLiveChannelById(channelId);
      
      if (result.isSuccess() && result.data) {
        // æ›´æ–°æ”¶è—çŠ¶æ€?        const channelWithFavoriteStatus: Record<string, string | number | boolean | null> = { ... };
        
        return ApiResponse.success(channelWithFavoriteStatus, 'è·å–é¢‘é“è¯¦æƒ…æˆåŠŸ');
      } else {
        // å¦‚æœç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œä½†ç¼“å­˜ä¸­æœ‰æ•°æ®
        if (channel) {
          Logger.warn(TAG, `Network failed, using cached channel ${channelId}`);
          channel.isFavorite = this.favoriteChannels.has(channel.id);
          return ApiResponse.success(channel, 'è·å–é¢‘é“è¯¦æƒ…æˆåŠŸï¼ˆç¼“å­˜ï¼‰');
        }
        
        return ApiResponse.error(result.code, result.message || 'è·å–é¢‘é“è¯¦æƒ…å¤±è´¥');
      }
    } catch (error) {
      Logger.error(TAG, `Failed to get channel by id: ${channelId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–é¢‘é“è¯¦æƒ…å¤±è´¥');
    }
  }

  /**
   * æœç´¢ç›´æ’­é¢‘é“
   */
  public async searchChannels(
    keyword: string,
    filter?: LiveFilter,
    sortBy: LiveSortType = LiveSortType.DEFAULT
  ): Promise<ApiResponse<LiveChannel[]>> {
    try {
      if (!keyword || keyword.trim().length === 0) {
        return ApiResponse.validationError([
          { field: 'keyword', message: 'æœç´¢å…³é”®è¯ä¸èƒ½ä¸ºç©? }
        ]);
      }
      
      // æ„å»ºæœç´¢å‚æ•°
      const searchParams: Record<string, string | number | boolean | null> = { ... };
      
      // ä»ç½‘ç»œæœç´¢é¢‘é?      Logger.debug(TAG, `Searching channels with keyword: ${keyword}`);
      const result = await this.networkRepo.searchLiveChannels(searchParams);
      
      if (result.isSuccess() && result.data) {
        // æ›´æ–°æ”¶è—çŠ¶æ€?        const channelsWithFavoriteStatus = result.data.map(channel => ({
          ...channel,
          isFavorite: this.favoriteChannels.has(channel.id)
        }));
        
        return ApiResponse.success(channelsWithFavoriteStatus, 'æœç´¢é¢‘é“æˆåŠŸ');
      } else {
        return ApiResponse.error(result.code, result.message || 'æœç´¢é¢‘é“å¤±è´¥');
      }
    } catch (error) {
      Logger.error(TAG, `Failed to search channels with keyword: ${keyword}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æœç´¢é¢‘é“å¤±è´¥');
    }
  }

  /**
   * è·å–ç›´æ’­é¢‘é“çš„æ’­æ”¾æº
   */
  public async getChannelSources(channelId: string): Promise<ApiResponse<LiveSource[]>> {
    try {
      // ä»ç½‘ç»œè·å–æ’­æ”¾æº
      Logger.debug(TAG, `Fetching sources for channel: ${channelId}`);
      const result = await this.networkRepo.getLiveChannelSources(channelId);
      
      if (result.isSuccess() && result.data) {
        return ApiResponse.success(result.data, 'è·å–æ’­æ”¾æºæˆåŠ?);
      } else {
        return ApiResponse.error(result.code, result.message || 'è·å–æ’­æ”¾æºå¤±è´?);
      }
    } catch (error) {
      Logger.error(TAG, `Failed to get sources for channel: ${channelId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      
      // å°è¯•ä»é¢‘é“ä¿¡æ¯ä¸­æå–æ’­æ”¾æº?      const channelResult = await this.getChannelById(channelId);
      if (channelResult.isSuccess() && channelResult.data && channelResult.data.url) {
        const sources: LiveSource[] = [{
          id: `${channelId}_default`,
          url: channelResult.data.url,
          quality: LiveQuality.AUTO,
          isDefault: true
        }];
        
        return ApiResponse.success(sources, 'è·å–æ’­æ”¾æºæˆåŠŸï¼ˆä»é¢‘é“ä¿¡æ¯ï¼‰');
      }
      
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–æ’­æ”¾æºå¤±è´?);
    }
  }

  /**
   * è·å–é¢‘é“èŠ‚ç›®å?   */
  public async getChannelPrograms(
    channelId: string,
    date: Date = new Date()
  ): Promise<ApiResponse<LiveProgram[]>> {
    try {
      // æ ¼å¼åŒ–æ—¥æœŸä¸ºYYYY-MM-DD
      const formattedDate = DateUtil.formatDate(date, 'YYYY-MM-DD');
      
      // ä»ç½‘ç»œè·å–èŠ‚ç›®å•
      Logger.debug(TAG, `Fetching programs for channel: ${channelId} on date: ${formattedDate}`);
      const result = await this.networkRepo.getLiveChannelPrograms(channelId, formattedDate);
      
      if (result.isSuccess() && result.data) {
        return ApiResponse.success(result.data, 'è·å–èŠ‚ç›®å•æˆåŠ?);
      } else {
        return ApiResponse.error(result.code, result.message || 'è·å–èŠ‚ç›®å•å¤±è´?);
      }
    } catch (error) {
      Logger.error(TAG, `Failed to get programs for channel: ${channelId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–èŠ‚ç›®å•å¤±è´?);
    }
  }

  /**
   * è·å–ç›´æ’­äº‹ä»¶åˆ—è¡¨
   */
  public async getLiveEvents(
    page: number = 1,
    pageSize: number = 20,
    isUpcoming: boolean = false
  ): Promise<ApiResponse<{ events: LiveEvent[], total: number }>> {
    try {
      // ä»ç½‘ç»œè·å–ç›´æ’­äº‹ä»?      Logger.debug(TAG, `Fetching live events (upcoming: ${isUpcoming})`);
      const result = await this.networkRepo.getLiveEvents(page, pageSize, isUpcoming);
      
      if (result.isSuccess() && result.data) {
        return ApiResponse.success(result.data, 'è·å–ç›´æ’­äº‹ä»¶æˆåŠŸ');
      } else {
        return ApiResponse.error(result.code, result.message || 'è·å–ç›´æ’­äº‹ä»¶å¤±è´¥');
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to get live events', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–ç›´æ’­äº‹ä»¶å¤±è´¥');
    }
  }

  /**
   * æ·»åŠ /ç§»é™¤æ”¶è—é¢‘é“
   */
  public async toggleFavoriteChannel(channelId: string): Promise<ApiResponse<{ isFavorite: boolean }>> {
    try {
      // åˆ‡æ¢æ”¶è—çŠ¶æ€?      const isFavorite = this.favoriteChannels.has(channelId);
      
      if (isFavorite) {
        this.favoriteChannels.delete(channelId);
      } else {
        this.favoriteChannels.add(channelId);
      }
      
      // ä¿å­˜åˆ°å­˜å‚?      await this.saveFavoriteChannels();
      
      // é€šçŸ¥ç›‘å¬å™?      this.notifyFavoriteChanged(channelId, !isFavorite);
      
      // æ›´æ–°ç¼“å­˜ä¸­çš„æ”¶è—çŠ¶æ€?      this.updateFavoriteStatusInCache(channelId, !isFavorite);
      
      Logger.info(TAG, `${!isFavorite ? 'Added' : 'Removed'} channel ${channelId} from favorites`);
      return ApiResponse.success(
        { isFavorite: !isFavorite },
        `é¢‘é“${!isFavorite ? 'å·²æ·»åŠ åˆ°' : 'å·²ä»'}æ”¶è—`
      );
    } catch (error) {
      Logger.error(TAG, `Failed to toggle favorite for channel: ${channelId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ›´æ–°æ”¶è—çŠ¶æ€å¤±è´?);
    }
  }

  /**
   * è·å–æ”¶è—é¢‘é“åˆ—è¡¨
   */
  public async getFavoriteChannels(): Promise<ApiResponse<LiveChannel[]>> {
    try {
      if (this.favoriteChannels.size === 0) {
        return ApiResponse.success([], 'æ”¶è—é¢‘é“åˆ—è¡¨ä¸ºç©º');
      }
      
      const favoriteIds = Array.from(this.favoriteChannels);
      const favoriteChannels: LiveChannel[] = [];
      
      // å°è¯•ä»ç¼“å­˜ä¸­è·å–é¢‘é“ä¿¡æ¯
      for (const cache of this.cachedChannels.values()) {
        const cachedChannels = cache.data.filter(channel => favoriteIds.includes(channel.id));
        favoriteChannels.push(...cachedChannels);
      }
      
      // å¯¹äºç¼“å­˜ä¸­æ²¡æœ‰çš„é¢‘é“ï¼Œä»ç½‘ç»œè·å–
      const missingIds = favoriteIds.filter(id => !favoriteChannels.some(c => c.id === id));
      
      if (missingIds.length > 0) {
        // è¿™é‡Œå¯ä»¥æ‰¹é‡è·å–é¢‘é“ä¿¡æ¯ï¼Œä¸ºç®€åŒ–ä»£ç ï¼Œæˆ‘ä»¬ä½¿ç”¨å¾ªç¯å•æ¡è·å–
        for (const id of missingIds) {
          const channelResult = await this.getChannelById(id);
          if (channelResult.isSuccess() && channelResult.data) {
            favoriteChannels.push(channelResult.data);
          }
        }
      }
      
      // ç¡®ä¿æ‰€æœ‰é¢‘é“éƒ½æ ‡è®°ä¸ºæ”¶è—?      favoriteChannels.forEach(channel => {
        channel.isFavorite = true;
      });
      
      return ApiResponse.success(favoriteChannels, 'è·å–æ”¶è—é¢‘é“æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to get favorite channels', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–æ”¶è—é¢‘é“å¤±è´¥');
    }
  }

  /**
   * åˆ›å»ºé¢‘é“ç»?   */
  public async createChannelGroup(name: string): Promise<ApiResponse<ChannelGroup>> {
    try {
      if (!name || name.trim().length === 0) {
        return ApiResponse.validationError([
          { field: 'name', message: 'é¢‘é“ç»„åç§°ä¸èƒ½ä¸ºç©? }
        ]);
      }
      
      // åˆ›å»ºæ–°çš„é¢‘é“ç»?      const newGroup: ChannelGroup = {
        id: `group_${Date.now()}`,
        name: name.trim(),
        channelIds: [],
        order: this.channelGroups.size + 1,
        isDefault: this.channelGroups.size === 0
      };
      
      // æ·»åŠ åˆ°å†…å­?      this.channelGroups.set(newGroup.id, newGroup);
      
      // ä¿å­˜åˆ°æ•°æ®åº“
      await this.databaseRepo.saveLiveChannelGroup(newGroup);
      
      // é€šçŸ¥ç›‘å¬å™?      this.notifyChannelGroupsChanged();
      
      Logger.info(TAG, `Created new channel group: ${newGroup.name} (${newGroup.id})`);
      return ApiResponse.success(newGroup, 'åˆ›å»ºé¢‘é“ç»„æˆåŠ?);
    } catch (error) {
      Logger.error(TAG, 'Failed to create channel group', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'åˆ›å»ºé¢‘é“ç»„å¤±è´?);
    }
  }

  /**
   * æ›´æ–°é¢‘é“ç»?   */
  public async updateChannelGroup(
    groupId: string,
    updates: Partial<ChannelGroup>
  ): Promise<ApiResponse<ChannelGroup>> {
    try {
      const group = this.channelGroups.get(groupId);
      if (!group) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'é¢‘é“ç»„ä¸å­˜åœ¨');
      }
      
      // æ›´æ–°é¢‘é“ç»?      const updatedGroup: ChannelGroup = {
        ...group,
        ...updates
      };
      
      // æ›´æ–°å†…å­˜
      this.channelGroups.set(groupId, updatedGroup);
      
      // ä¿å­˜åˆ°æ•°æ®åº“
      await this.databaseRepo.updateLiveChannelGroup(updatedGroup);
      
      // é€šçŸ¥ç›‘å¬å™?      this.notifyChannelGroupsChanged();
      
      Logger.info(TAG, `Updated channel group: ${groupId}`);
      return ApiResponse.success(updatedGroup, 'æ›´æ–°é¢‘é“ç»„æˆåŠ?);
    } catch (error) {
      Logger.error(TAG, `Failed to update channel group: ${groupId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ›´æ–°é¢‘é“ç»„å¤±è´?);
    }
  }

  /**
   * åˆ é™¤é¢‘é“ç»?   */
  public async deleteChannelGroup(groupId: string): Promise<ApiResponse<boolean>> {
    try {
      if (!this.channelGroups.has(groupId)) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'é¢‘é“ç»„ä¸å­˜åœ¨');
      }
      
      // ç§»é™¤å†…å­˜ä¸­çš„é¢‘é“ç»?      this.channelGroups.delete(groupId);
      
      // ä»æ•°æ®åº“åˆ é™¤
      await this.databaseRepo.deleteLiveChannelGroup(groupId);
      
      // è°ƒæ•´æ’åº
      let order = 1;
      for (const group of this.getSortedChannelGroups()) {
        group.order = order++;
        await this.databaseRepo.updateLiveChannelGroup(group);
      }
      
      // é€šçŸ¥ç›‘å¬å™?      this.notifyChannelGroupsChanged();
      
      Logger.info(TAG, `Deleted channel group: ${groupId}`);
      return ApiResponse.success(true, 'åˆ é™¤é¢‘é“ç»„æˆåŠ?);
    } catch (error) {
      Logger.error(TAG, `Failed to delete channel group: ${groupId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'åˆ é™¤é¢‘é“ç»„å¤±è´?);
    }
  }

  /**
   * è·å–æ‰€æœ‰é¢‘é“ç»„
   */
  public getChannelGroups(): ApiResponse<ChannelGroup[]> {
    try {
      const groups = this.getSortedChannelGroups();
      return ApiResponse.success(groups, 'è·å–é¢‘é“ç»„æˆåŠ?);
    } catch (error) {
      Logger.error(TAG, 'Failed to get channel groups', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–é¢‘é“ç»„å¤±è´?);
    }
  }

  /**
   * è·å–æ’åºåçš„é¢‘é“ç»?   */
  private getSortedChannelGroups(): ChannelGroup[] {
    return Array.from(this.channelGroups.values())
      .sort((a, b) => a.order - b.order);
  }

  /**
   * æ›´æ–°é¢‘é“ç»„ä¸­çš„é¢‘é?   */
  public async updateGroupChannels(
    groupId: string,
    channelIds: string[]
  ): Promise<ApiResponse<ChannelGroup>> {
    try {
      const group = this.channelGroups.get(groupId);
      if (!group) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'é¢‘é“ç»„ä¸å­˜åœ¨');
      }
      
      // æ›´æ–°é¢‘é“IDåˆ—è¡¨
      group.channelIds = channelIds;
      
      // ä¿å­˜åˆ°æ•°æ®åº“
      await this.databaseRepo.updateLiveChannelGroup(group);
      
      // é€šçŸ¥ç›‘å¬å™?      this.notifyChannelGroupsChanged();
      
      Logger.info(TAG, `Updated channels in group: ${groupId}, count: ${channelIds.length}`);
      return ApiResponse.success(group, 'æ›´æ–°é¢‘é“ç»„æˆå‘˜æˆåŠ?);
    } catch (error) {
      Logger.error(TAG, `Failed to update channels in group: ${groupId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ›´æ–°é¢‘é“ç»„æˆå‘˜å¤±è´?);
    }
  }

  /**
   * è·å–é¢‘é“ç»„ä¸­çš„é¢‘é“åˆ—è¡?   */
  public async getGroupChannels(groupId: string): Promise<ApiResponse<LiveChannel[]>> {
    try {
      const group = this.channelGroups.get(groupId);
      if (!group) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'é¢‘é“ç»„ä¸å­˜åœ¨');
      }
      
      if (group.channelIds.length === 0) {
        return ApiResponse.success([], 'é¢‘é“ç»„ä¸ºç©?);
      }
      
      const channels: LiveChannel[] = [];
      
      // è·å–é¢‘é“ä¿¡æ¯
      for (const channelId of group.channelIds) {
        const channelResult = await this.getChannelById(channelId);
        if (channelResult.isSuccess() && channelResult.data) {
          channels.push(channelResult.data);
        }
      }
      
      return ApiResponse.success(channels, 'è·å–é¢‘é“ç»„æˆå‘˜æˆåŠ?);
    } catch (error) {
      Logger.error(TAG, `Failed to get channels in group: ${groupId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–é¢‘é“ç»„æˆå‘˜å¤±è´?);
    }
  }

  /**
   * è·å–ç›´æ’­ç»Ÿè®¡ä¿¡æ¯
   */
  public async getStatistics(): Promise<ApiResponse<LiveStatistics>> {
    try {
      // å…ˆå°è¯•ä»ç½‘ç»œè·å–ç»Ÿè®¡ä¿¡æ¯
      const result = await this.networkRepo.getLiveStatistics();
      
      if (result.isSuccess() && result.data) {
        // åˆå¹¶æœ¬åœ°ç»Ÿè®¡æ•°æ®
        const statistics: LiveStatistics = {
          ...result.data,
          favoriteChannels: this.favoriteChannels.size
        };
        
        return ApiResponse.success(statistics, 'è·å–ç»Ÿè®¡ä¿¡æ¯æˆåŠŸ');
      }
      
      // å¦‚æœç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œç”Ÿæˆç®€å•çš„ç»Ÿè®¡ä¿¡æ¯
      const categoriesResult = await this.getCategories();
      const allChannelsResult = await this.getAllChannels(1, 1); // åªè·å–ç¬¬ä¸€é¡µç”¨äºç»Ÿè®?      
      const statistics: LiveStatistics = {
        totalChannels: allChannelsResult.isSuccess() ? allChannelsResult.data.total : 0,
        liveChannels: 0, // æ²¡æœ‰å®æ—¶æ•°æ®ï¼Œè®¾ä¸?
        offlineChannels: 0,
        totalCategories: categoriesResult.isSuccess() ? categoriesResult.data.length : 0,
        favoriteChannels: this.favoriteChannels.size,
        recentViews: 0
      };
      
      return ApiResponse.success(statistics, 'è·å–ç»Ÿè®¡ä¿¡æ¯æˆåŠŸï¼ˆæœ¬åœ°è®¡ç®—ï¼‰');
    } catch (error) {
      Logger.error(TAG, 'Failed to get statistics', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      
      // è¿”å›åŸºæœ¬ç»Ÿè®¡ä¿¡æ¯
      const statistics: LiveStatistics = {
        totalChannels: 0,
        liveChannels: 0,
        offlineChannels: 0,
        totalCategories: 0,
        favoriteChannels: this.favoriteChannels.size,
        recentViews: 0
      };
      
      return ApiResponse.success(statistics, 'è·å–ç»Ÿè®¡ä¿¡æ¯æˆåŠŸï¼ˆç®€åŒ–ç‰ˆï¼?);
    }
  }

  /**
   * åˆ·æ–°é¢‘é“çŠ¶æ€?   */
  public async refreshChannelStatus(channelIds: string[]): Promise<ApiResponse<Map<string, LiveStatus>>> {
    try {
      // ä»ç½‘ç»œåˆ·æ–°é¢‘é“çŠ¶æ€?      const result = await this.networkRepo.refreshLiveChannelStatus(channelIds);
      
      if (result.isSuccess() && result.data) {
        // é€šçŸ¥çŠ¶æ€å˜æ›?        result.data.forEach((status, channelId) => {
          this.notifyChannelStatusChanged(channelId, status);
        });
        
        return ApiResponse.success(result.data, 'åˆ·æ–°é¢‘é“çŠ¶æ€æˆåŠ?);
      } else {
        return ApiResponse.error(result.code, result.message || 'åˆ·æ–°é¢‘é“çŠ¶æ€å¤±è´?);
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to refresh channel status', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'åˆ·æ–°é¢‘é“çŠ¶æ€å¤±è´?);
    }
  }

  /**
   * æ¸…é™¤ç¼“å­˜
   */
  public async clearCache(): Promise<ApiResponse<boolean>> {
    try {
      // æ¸…é™¤å†…å­˜ä¸­çš„ç¼“å­˜
      this.cachedCategories = null;
      this.cachedChannels.clear();
      
      // æ¸…é™¤å­˜å‚¨ä¸­çš„ç¼“å­˜
      await StorageUtil.remove(LIVE_CATEGORY_CACHE_KEY);
      await StorageUtil.remove(LIVE_CHANNEL_CACHE_KEY);
      
      Logger.info(TAG, 'Cleared all live stream cache');
      return ApiResponse.success(true, 'æ¸…é™¤ç¼“å­˜æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to clear cache', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ¸…é™¤ç¼“å­˜å¤±è´¥');
    }
  }

  /**
   * é€šçŸ¥æ”¶è—çŠ¶æ€å˜æ›?   */
  private notifyFavoriteChanged(channelId: string, isFavorite: boolean): void {
    for (const listener of this.favoriteListeners) {
      try {
        listener(channelId, isFavorite);
      } catch (error) {
        Logger.error(TAG, 'Error in favorite listener', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      }
    }
  }

  /**
   * é€šçŸ¥é¢‘é“ç»„å˜æ›?   */
  private notifyChannelGroupsChanged(): void {
    const groups = this.getSortedChannelGroups();
    for (const listener of this.channelGroupListeners) {
      try {
        listener(groups);
      } catch (error) {
        Logger.error(TAG, 'Error in channel group listener', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      }
    }
  }

  /**
   * é€šçŸ¥é¢‘é“çŠ¶æ€å˜æ›?   */
  private notifyChannelStatusChanged(channelId: string, status: LiveStatus): void {
    if (!this.statusListeners.has(channelId)) return;
    
    const listeners = this.statusListeners.get(channelId)!;
    for (const listener of listeners) {
      try {
        listener(status);
      } catch (error) {
        Logger.error(TAG, `Error in status listener for channel ${channelId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      }
    }
  }

  /**
   * æ›´æ–°ç¼“å­˜ä¸­çš„æ”¶è—çŠ¶æ€?   */
  private updateFavoriteStatusInCache(channelId: string, isFavorite: boolean): void {
    for (const [key, cache] of this.cachedChannels.entries()) {
      const channelIndex = cache.data.findIndex(channel => channel.id === channelId);
      if (channelIndex >= 0) {
        cache.data[channelIndex].isFavorite = isFavorite;
      }
    }
  }

  /**
   * æ·»åŠ æ”¶è—çŠ¶æ€ç›‘å¬å™¨
   */
  public addFavoriteListener(
    listener: (channelId: string, isFavorite: boolean) => void
  ): () => void {
    this.favoriteListeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.favoriteListeners.indexOf(listener);
      if (index > -1) {
        this.favoriteListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ é¢‘é“ç»„ç›‘å¬å™¨
   */
  public addChannelGroupListener(
    listener: (groups: ChannelGroup[]) => void
  ): () => void {
    this.channelGroupListeners.push(listener);
    
    // ç«‹å³å›è°ƒå½“å‰é¢‘é“ç»?    listener(this.getSortedChannelGroups());
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.channelGroupListeners.indexOf(listener);
      if (index > -1) {
        this.channelGroupListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ é¢‘é“çŠ¶æ€ç›‘å¬å™¨
   */
  public addChannelStatusListener(
    channelId: string,
    listener: (status: LiveStatus) => void
  ): () => void {
    if (!this.statusListeners.has(channelId)) {
      this.statusListeners.set(channelId, []);
    }
    
    const listeners = this.statusListeners.get(channelId)!;
    listeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }

  /**
   * å¯¼å‡ºé¢‘é“åˆ—è¡¨
   */
  public async exportChannelList(format: 'm3u' | 'json' = 'json'): Promise<ApiResponse<string>> {
    try {
      // è·å–æ‰€æœ‰é¢‘é?      const allChannelsResult = await this.getAllChannels(1, 1000);
      if (!allChannelsResult.isSuccess() || !allChannelsResult.data) {
        return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–é¢‘é“åˆ—è¡¨å¤±è´¥');
      }
      
      let exportData = '';
      
      if (format === 'm3u') {
        // å¯¼å‡ºä¸ºM3Uæ ¼å¼
        exportData = this.exportToM3U(allChannelsResult.data.channels);
      } else {
        // å¯¼å‡ºä¸ºJSONæ ¼å¼
        exportData = JSON.stringify(allChannelsResult.data.channels, null, 2);
      }
      
      Logger.info(TAG, `Exported ${allChannelsResult.data.channels.length} channels in ${format} format`);
      return ApiResponse.success(exportData, `å¯¼å‡ºé¢‘é“åˆ—è¡¨æˆåŠŸï¼?{format}æ ¼å¼ï¼‰`);
    } catch (error) {
      Logger.error(TAG, `Failed to export channel list in ${format} format`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'å¯¼å‡ºé¢‘é“åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * å¯¼å‡ºä¸ºM3Uæ ¼å¼
   */
  private exportToM3U(channels: LiveChannel[]): string {
    let m3uContent = '#EXTM3U
';
    
    channels.forEach(channel => {
      if (channel.url) {
        m3uContent += `#EXTINF:-1 tvg-id="${channel.id}" tvg-name="${channel.name}" tvg-logo="${channel.logo || ''}" group-title="${channel.categoryName}",${channel.name}\n`;
        m3uContent += `${channel.url}\n`;
      }
    });
    
    return m3uContent;
  }

  /**
   * é”€æ¯ç›´æ’­æœåŠ?   */
  public async destroy(): Promise<void> {
    try {
      Logger.info(TAG, 'Destroying live stream service...');
      
      // æ¸…é™¤ç›‘å¬å™?      this.favoriteListeners = [];
      this.channelGroupListeners = [];
      this.statusListeners.clear();
      
      // æ¸…é™¤ç¼“å­˜
      await this.clearCache();
      
      // é‡ç½®çŠ¶æ€?      this.favoriteChannels.clear();
      this.channelGroups.clear();
      this.cachedCategories = null;
      this.cachedChannels.clear();
      
      Logger.info(TAG, 'Live stream service destroyed successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to destroy live stream service', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
    }
  }
}


