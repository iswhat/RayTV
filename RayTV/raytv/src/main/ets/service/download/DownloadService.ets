// DownloadService - ä¸‹è½½æœåŠ¡ï¿?import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import DateUtil from '../../common/util/DateUtil';
import FileUtil from '../../common/util/FileUtil';
import NetworkUtil from '../../common/util/NetworkUtil';
import RepositoryFactory from '../../data/repository/RepositoryFactory';
import DatabaseRepository from '../../data/repository/DatabaseRepository';
import NetworkRepository from '../../data/repository/NetworkRepository';
import ConfigService from '../config/ConfigService';

// å¯¼å…¥æ¨¡å‹å’ŒDTO
import ApiResponse, { ResponseCode } from '../dto/ApiResponse';
import Movie, { VideoSource, VideoType } from '../model/Movie';

// å¸¸é‡å®šä¹‰
const TAG = 'DownloadService';
const DOWNLOAD_QUEUE_KEY = 'download_queue';
const DOWNLOAD_SETTINGS_KEY = 'download_settings';

// ä¸‹è½½çŠ¶æ€æšï¿?export enum DownloadStatus {
  QUEUED = 'queued',        // å·²åŠ å…¥é˜Ÿï¿?  DOWNLOADING = 'downloading',  // ä¸‹è½½ï¿?  PAUSED = 'paused',        // æš‚åœ
  COMPLETED = 'completed',    // å®Œæˆ
  FAILED = 'failed',        // å¤±è´¥
  CANCELLED = 'cancelled'    // å–æ¶ˆ
}

// ä¸‹è½½é”™è¯¯ç±»å‹æšä¸¾
export enum DownloadErrorType {
  NETWORK_ERROR = 'network_error',
  STORAGE_ERROR = 'storage_error',
  PERMISSION_ERROR = 'permission_error',
  SERVER_ERROR = 'server_error',
  TIMEOUT_ERROR = 'timeout_error',
  INVALID_URL_ERROR = 'invalid_url_error',
  DISK_FULL_ERROR = 'disk_full_error',
  UNKNOWN_ERROR = 'unknown_error'
}

// ä¸‹è½½ä»»åŠ¡æ¥å£
export interface DownloadTask {
  id: string;              // ä»»åŠ¡å”¯ä¸€æ ‡è¯†
  movieId: string;          // ç”µå½±ID
  movieTitle: string;        // ç”µå½±æ ‡é¢˜
  episodeTitle?: string;     // å‰§é›†æ ‡é¢˜ï¼ˆå¯é€‰ï¼‰
  seasonNumber?: number;      // å­£æ•°ï¼ˆå¯é€‰ï¼‰
  episodeNumber?: number;     // é›†æ•°ï¼ˆå¯é€‰ï¼‰
  videoType: VideoType;       // è§†é¢‘ç±»å‹
  videoSource: VideoSource;    // è§†é¢‘ï¿?  videoQuality: string;       // è§†é¢‘è´¨é‡
  videoUrl: string;          // è§†é¢‘URL
  coverUrl?: string;         // å°é¢URL
  totalSize: number;         // æ€»å¤§å°ï¼ˆå­—èŠ‚ï¿?  downloadedSize: number;      // å·²ä¸‹è½½å¤§å°ï¼ˆå­—èŠ‚ï¿?  progress: number;          // ä¸‹è½½è¿›åº¦ï¿?-100ï¿?  status: DownloadStatus;     // ä¸‹è½½çŠ¶ï¿½?  downloadSpeed: number;      // ä¸‹è½½é€Ÿåº¦ï¼ˆå­—ï¿?ç§’ï¼‰
  startTime?: number;         // å¼€å§‹æ—¶ï¿?  endTime?: number;          // ç»“æŸæ—¶é—´
  errorType?: DownloadErrorType; // é”™è¯¯ç±»å‹
  errorMessage?: string;      // é”™è¯¯ä¿¡æ¯
  downloadPath: string;       // ä¸‹è½½æ–‡ä»¶è·¯å¾„
  tempFilePath: string;       // ä¸´æ—¶æ–‡ä»¶è·¯å¾„
  resumedFrom: number;        // ç»­ä¼ èµ·å§‹ä½ç½®
  isActive: boolean;          // æ˜¯å¦ä¸ºæ´»åŠ¨ä»»ï¿?  isHighPriority: boolean;     // æ˜¯å¦é«˜ä¼˜å…ˆçº§
  networkType: 'all' | 'wifi' | 'cellular'; // ç½‘ç»œç±»å‹é™åˆ¶
  autoStart: boolean;         // æ˜¯å¦è‡ªåŠ¨å¼€ï¿?  userData?: Record<string, any>; // ç”¨æˆ·è‡ªå®šä¹‰æ•°ï¿?}

// ä¸‹è½½è®¾ç½®æ¥å£
export interface DownloadSettings {
  maxConcurrentDownloads: number; // æœ€å¤§å¹¶å‘ä¸‹è½½æ•°
  downloadNetworkType: 'all' | 'wifi' | 'cellular'; // å…è®¸çš„ç½‘ç»œç±»ï¿?  autoResumeDownloads: boolean; // æ˜¯å¦è‡ªåŠ¨æ¢å¤ä¸‹è½½
  autoDeleteFailedDownloads: boolean; // æ˜¯å¦è‡ªåŠ¨åˆ é™¤å¤±è´¥ä¸‹è½½
  autoPlayCompletedDownloads: boolean; // æ˜¯å¦è‡ªåŠ¨æ’­æ”¾å®Œæˆçš„ä¸‹ï¿?  downloadFolder: string; // ä¸‹è½½æ–‡ä»¶ï¿?  maxDownloadSize: number; // æœ€å¤§ä¸‹è½½å¤§å°ï¼ˆMBï¿?  allowBackgroundDownloads: boolean; // æ˜¯å¦å…è®¸åå°ä¸‹è½½
  showNotifications: boolean; // æ˜¯å¦æ˜¾ç¤ºé€šçŸ¥
  playWhileDownloading: boolean; // æ˜¯å¦å…è®¸è¾¹ä¸‹è¾¹æ’­
  verifyDownloads: boolean; // æ˜¯å¦éªŒè¯ä¸‹è½½
  deleteSourceFiles: boolean; // æ˜¯å¦åˆ é™¤æºæ–‡ï¿?  cleanTempFiles: boolean; // æ˜¯å¦æ¸…ç†ä¸´æ—¶æ–‡ä»¶
}

// é»˜è®¤ä¸‹è½½è®¾ç½®
export const DEFAULT_DOWNLOAD_SETTINGS: DownloadSettings = {
  maxConcurrentDownloads: 3,
  downloadNetworkType: 'all',
  autoResumeDownloads: true,
  autoDeleteFailedDownloads: false,
  autoPlayCompletedDownloads: false,
  downloadFolder: '', // å°†åœ¨åˆå§‹åŒ–æ—¶è®¾ç½®
  maxDownloadSize: 5000, // 5GB
  allowBackgroundDownloads: true,
  showNotifications: true,
  playWhileDownloading: false,
  verifyDownloads: true,
  deleteSourceFiles: false,
  cleanTempFiles: true
};

/**
 * ä¸‹è½½æœåŠ¡ï¿? * è´Ÿè´£ç®¡ç†è§†é¢‘ä¸‹è½½ä»»åŠ¡å’Œä¸‹è½½é˜Ÿï¿? */
export default class DownloadService {
  private static instance: DownloadService;
  private databaseRepo: DatabaseRepository;
  private networkRepo: NetworkRepository;
  private configService: ConfigService;
  
  private downloadQueue: DownloadTask[] = [];
  private activeTasks: Set<string> = new Set();
  private settings: DownloadSettings = { ...DEFAULT_DOWNLOAD_SETTINGS };
  private isInitialized: boolean = false;
  private pauseDownloadsOnQueueFull: boolean = false;
  
  // ä»»åŠ¡ç›‘å¬ï¿?  private taskListeners: Map<string, Array<(task: DownloadTask) => void>> = new Map();
  private queueListeners: Array<(queue: DownloadTask[]) => void> = [];
  private statusListeners: Map<DownloadStatus, Array<(task: DownloadTask) => void>> = new Map();

  /**
   * æ„é€ å‡½æ•°ï¼ˆç§æœ‰ï¼Œé˜²æ­¢å¤–éƒ¨å®ä¾‹åŒ–ï¿?   */
  private constructor() {
    this.databaseRepo = RepositoryFactory.getRepository('database') as DatabaseRepository;
    this.networkRepo = RepositoryFactory.getRepository('network') as NetworkRepository;
    this.configService = ConfigService.getInstance();
    this.initialize();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): DownloadService {
    if (!DownloadService.instance) {
      DownloadService.instance = new DownloadService();
    }
    return DownloadService.instance;
  }

  /**
   * åˆå§‹åŒ–ä¸‹è½½æœï¿?   */
  public async initialize(): Promise<void> {
    try {
      Logger.info(TAG, 'Initializing download service...');
      
      // è®¾ç½®é»˜è®¤ä¸‹è½½æ–‡ä»¶ï¿?      this.settings.downloadFolder = await FileUtil.getDownloadDirectory('RayTV');
      
      // ä»æ•°æ®åº“åŠ è½½ä¸‹è½½é˜Ÿåˆ—
      const savedQueue = await this.databaseRepo.getDownloadQueue();
      if (savedQueue && savedQueue.length > 0) {
        this.downloadQueue = savedQueue;
        Logger.info(TAG, `Loaded ${this.downloadQueue.length} download tasks from database`);
      }
      
      // ä»é…ç½®æœåŠ¡åŠ è½½è®¾ï¿?      await this.loadSettingsFromConfig();
      
      // ä»æœ¬åœ°å­˜å‚¨åŠ è½½è®¾ç½®ï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
      const savedSettings = await StorageUtil.getObject<DownloadSettings>(DOWNLOAD_SETTINGS_KEY);
      if (savedSettings) {
        this.settings = { ...this.settings, ...savedSettings };
      }
      
      // æ¸…ç†å·²å®Œæˆçš„ä¸´æ—¶æ–‡ä»¶
      if (this.settings.cleanTempFiles) {
        await this.cleanupTempFiles();
      }
      
      // æ£€æŸ¥ä¸‹è½½æ–‡ä»¶å¤¹æ˜¯å¦å­˜åœ¨
      const exists = await FileUtil.directoryExists(this.settings.downloadFolder);
      if (!exists) {
        await FileUtil.createDirectory(this.settings.downloadFolder);
      }
      
      // å¯åŠ¨ç­‰å¾…ä¸­çš„ä»»åŠ¡
      if (this.settings.autoResumeDownloads) {
        await this.startPendingDownloads();
      }
      
      this.isInitialized = true;
      Logger.info(TAG, 'Download service initialized successfully');
    } catch (error) {
      Logger.error(TAG, 'Failed to initialize download service', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * ä»é…ç½®æœåŠ¡åŠ è½½è®¾ï¿?   */
  private async loadSettingsFromConfig(): Promise<void> {
    try {
      const maxDownloads = await this.configService.getConfig('maxConcurrentDownloads');
      if (maxDownloads.isSuccess() && typeof maxDownloads.data === 'number') {
        this.settings.maxConcurrentDownloads = maxDownloads.data;
      }
      
      const networkType = await this.configService.getConfig('downloadNetworkType');
      if (networkType.isSuccess() && 
          (networkType.data === 'all' || networkType.data === 'wifi' || networkType.data === 'cellular')) {
        this.settings.downloadNetworkType = networkType.data;
      }
      
      const cacheLimit = await this.configService.getConfig('cacheLimit');
      if (cacheLimit.isSuccess() && typeof cacheLimit.data === 'number') {
        this.settings.maxDownloadSize = cacheLimit.data;
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to load settings from config', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * æ·»åŠ ä¸‹è½½ä»»åŠ¡
   */
  public async addDownloadTask(
    movie: Movie,
    videoSource: VideoSource,
    videoQuality: string,
    options?: {
      episodeTitle?: string;
      seasonNumber?: number;
      episodeNumber?: number;
      isHighPriority?: boolean;
      autoStart?: boolean;
      userData?: Record<string, unknown>;
    }
  ): Promise<ApiResponse<DownloadTask>> {
    try {
      // æ£€æŸ¥ç½‘ç»œçŠ¶ï¿?      const networkAvailable = await NetworkUtil.isNetworkAvailable();
      if (!networkAvailable) {
        return ApiResponse.error(ResponseCode.NETWORK_ERROR, 'ç½‘ç»œä¸å¯ç”¨ï¼Œæ— æ³•å¼€å§‹ä¸‹ï¿?);
      }
      
      // æ£€æŸ¥ç½‘ç»œç±»å‹é™ï¿?      const networkType = await NetworkUtil.getNetworkType();
      if (this.settings.downloadNetworkType === 'wifi' && networkType !== 'wifi') {
        return ApiResponse.error(ResponseCode.NETWORK_ERROR, 'ä»…åœ¨WiFiç½‘ç»œä¸‹å…è®¸ä¸‹ï¿?);
      }
      
      if (this.settings.downloadNetworkType === 'cellular' && networkType !== 'cellular') {
        return ApiResponse.error(ResponseCode.NETWORK_ERROR, 'ä»…åœ¨ç§»åŠ¨ç½‘ç»œä¸‹å…è®¸ä¸‹ï¿?);
      }
      
      // æ£€æŸ¥å­˜å‚¨ç©ºï¿?      const freeSpace = await FileUtil.getFreeSpace();
      if (freeSpace <= 0) {
        return ApiResponse.error(ResponseCode.STORAGE_ERROR, 'æ— æ³•è·å–å¯ç”¨å­˜å‚¨ç©ºé—´');
      }
      
      // åˆ›å»ºä»»åŠ¡ID
      const taskId = `download_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // ç”Ÿæˆæ–‡ä»¶è·¯å¾„
      const fileName = FileUtil.sanitizeFileName(`${movie.title}${options?.episodeTitle ? `_${options.episodeTitle}` : ''}_${videoQuality}`);
      const fileExtension = videoSource.url.split('.').pop() || 'mp4';
      const downloadPath = `${this.settings.downloadFolder}/${fileName}.${fileExtension}`;
      const tempFilePath = `${downloadPath}.temp`;
      
      // åˆ›å»ºä¸‹è½½ä»»åŠ¡
      const task: DownloadTask = {
        id: taskId,
        movieId: movie.id,
        movieTitle: movie.title,
        episodeTitle: options?.episodeTitle,
        seasonNumber: options?.seasonNumber,
        episodeNumber: options?.episodeNumber,
        videoType: movie.type,
        videoSource: videoSource,
        videoQuality: videoQuality,
        videoUrl: videoSource.url,
        coverUrl: movie.coverUrl,
        totalSize: videoSource.size || 0,
        downloadedSize: 0,
        progress: 0,
        status: DownloadStatus.QUEUED,
        downloadSpeed: 0,
        downloadPath: downloadPath,
        tempFilePath: tempFilePath,
        resumedFrom: 0,
        isActive: false,
        isHighPriority: options?.isHighPriority || false,
        networkType: this.settings.downloadNetworkType,
        autoStart: options?.autoStart !== undefined ? options.autoStart : true,
        userData: options?.userData
      };
      
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
      const fileExists = await FileUtil.fileExists(downloadPath);
      if (fileExists) {
        const fileSize = await FileUtil.getFileSize(downloadPath);
        if (videoSource.size && fileSize === videoSource.size) {
          // æ–‡ä»¶å·²å­˜åœ¨ä¸”å¤§å°åŒ¹é…ï¼Œæ ‡è®°ä¸ºå·²å®Œï¿?          task.status = DownloadStatus.COMPLETED;
          task.progress = 100;
          task.downloadedSize = fileSize;
          task.totalSize = fileSize;
        } else if (this.settings.verifyDownloads) {
          // æ–‡ä»¶å­˜åœ¨ä½†ä¸å®Œæ•´ï¼Œåˆ é™¤æ—§æ–‡ä»¶
          await FileUtil.deleteFile(downloadPath);
        }
      }
      
      // æ·»åŠ åˆ°ä¸‹è½½é˜Ÿï¿?      if (task.isHighPriority) {
        this.downloadQueue.unshift(task);
      } else {
        this.downloadQueue.push(task);
      }
      
      // ä¿å­˜é˜Ÿåˆ—åˆ°æ•°æ®åº“
      await this.saveDownloadQueue();
      
      // é€šçŸ¥é˜Ÿåˆ—å˜æ›´
      this.notifyQueueChanged();
      
      // è‡ªåŠ¨å¼€å§‹ä¸‹ï¿?      if (task.autoStart && task.status === DownloadStatus.QUEUED) {
        await this.startDownload(task.id);
      }
      
      Logger.info(TAG, `Added download task: ${task.id} - ${task.movieTitle}`);
      return ApiResponse.success(task, 'æ·»åŠ ä¸‹è½½ä»»åŠ¡æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to add download task', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ·»åŠ ä¸‹è½½ä»»åŠ¡å¤±è´¥');
    }
  }

  /**
   * å¼€å§‹ä¸‹è½½ä»»ï¿?   */
  public async startDownload(taskId: string): Promise<ApiResponse<DownloadTask>> {
    try {
      Logger.info(TAG, `Starting download task: ${taskId}`);
      
      const taskIndex = this.downloadQueue.findIndex(task => task.id === taskId);
      if (taskIndex === -1) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'ä¸‹è½½ä»»åŠ¡ä¸å­˜ï¿?);
      }
      
      const task = this.downloadQueue[taskIndex];
      
      // æ£€æŸ¥ä»»åŠ¡çŠ¶ï¿?      if (task.status === DownloadStatus.COMPLETED) {
        return ApiResponse.success(task, 'ä»»åŠ¡å·²ç»å®Œæˆ');
      }
      
      if (task.status === DownloadStatus.DOWNLOADING) {
        return ApiResponse.success(task, 'ä»»åŠ¡å·²ç»åœ¨ä¸‹è½½ä¸­');
      }
      
      if (task.status === DownloadStatus.CANCELLED) {
        return ApiResponse.error(ResponseCode.INVALID_OPERATION, 'å·²å–æ¶ˆçš„ä»»åŠ¡æ— æ³•é‡æ–°å¼€ï¿?);
      }
      
      // æ£€æŸ¥æ´»åŠ¨ä»»åŠ¡æ•°ï¿?      if (this.activeTasks.size >= this.settings.maxConcurrentDownloads) {
        this.pauseDownloadsOnQueueFull = true;
        return ApiResponse.error(ResponseCode.LIMIT_EXCEEDED, 'ä¸‹è½½é˜Ÿåˆ—å·²æ»¡ï¼Œè¯·ç­‰å¾…å½“å‰ä»»åŠ¡å®Œæˆ');
      }
      
      // æ›´æ–°ä»»åŠ¡çŠ¶ï¿½?      task.status = DownloadStatus.DOWNLOADING;
      task.isActive = true;
      if (!task.startTime) {
        task.startTime = Date.now();
      }
      
      // æ·»åŠ åˆ°æ´»åŠ¨ä»»åŠ¡é›†
      this.activeTasks.add(taskId);
      
      // æ›´æ–°é˜Ÿåˆ—å¹¶ä¿ï¿?      this.downloadQueue[taskIndex] = task;
      await this.saveDownloadQueue();
      
      // é€šçŸ¥ä»»åŠ¡çŠ¶æ€å˜ï¿?      this.notifyTaskChanged(task);
      this.notifyStatusChanged(DownloadStatus.DOWNLOADING, task);
      this.notifyQueueChanged();
      
      // å¯åŠ¨ä¸‹è½½ï¼ˆå¼‚æ­¥ï¼‰
      this.performDownload(taskId).catch(error => {
        Logger.error(TAG, `Download failed for task: ${taskId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      });
      
      return ApiResponse.success(task, 'å¼€å§‹ä¸‹è½½æˆï¿?);
    } catch (error) {
      Logger.error(TAG, `Failed to start download task: ${taskId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'å¼€å§‹ä¸‹è½½å¤±ï¿?);
    }
  }

  /**
   * æ‰§è¡Œä¸‹è½½ä»»åŠ¡ï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰
   */
  private async performDownload(taskId: string): Promise<void> {
    try {
      const taskIndex = this.downloadQueue.findIndex(task => task.id === taskId);
      if (taskIndex === -1 || !this.downloadQueue[taskIndex].isActive) {
        return;
      }
      
      let task = this.downloadQueue[taskIndex];
      
      // æ£€æŸ¥ä¸´æ—¶æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œç”¨äºç»­ä¼ 
      const tempFileExists = await FileUtil.fileExists(task.tempFilePath);
      if (tempFileExists) {
        const tempSize = await FileUtil.getFileSize(task.tempFilePath);
        task.downloadedSize = tempSize;
        task.resumedFrom = tempSize;
      }
      
      // å¼€å§‹ä¸‹ï¿?      const startTime = Date.now();
      let lastProgressUpdate = startTime;
      let lastDownloadedSize = task.downloadedSize;
      
      // è¿™é‡Œåº”è¯¥å®ç°å®é™…çš„ä¸‹è½½é€»è¾‘
      // ç”±äºè¿™æ˜¯æ¨¡æ‹Ÿå®ç°ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„è¿›åº¦æ›´æ–°ä»£æ›¿
      const updateInterval = setInterval(async () => {
        if (!task.isActive || task.status !== DownloadStatus.DOWNLOADING) {
          clearInterval(updateInterval);
          return;
        }
        
        // æ›´æ–°ä¸‹è½½è¿›åº¦ï¼ˆæ¨¡æ‹Ÿï¼‰
        const currentTime = Date.now();
        const elapsedTime = currentTime - lastProgressUpdate;
        
        if (elapsedTime >= 1000) { // æ¯ç§’æ›´æ–°ä¸€ï¿?          // æ¨¡æ‹Ÿä¸‹è½½é€Ÿåº¦ï¿?0KB/s - 2MB/sï¿?          const simulatedSpeed = 50 * 1024 + Math.random() * 1.95 * 1024 * 1024;
          const downloadedBytes = Math.floor(simulatedSpeed * (elapsedTime / 1000));
          
          task.downloadedSize += downloadedBytes;
          task.downloadSpeed = simulatedSpeed;
          
          // è®¡ç®—è¿›åº¦
          if (task.totalSize > 0) {
            task.progress = Math.min(100, Math.floor((task.downloadedSize / task.totalSize) * 100));
          }
          
          // æ›´æ–°é˜Ÿåˆ—
          this.downloadQueue[taskIndex] = task;
          
          // ï¿?ç§’ä¿å­˜ä¸€æ¬¡è¿›ï¿?          if (currentTime - startTime >= 5000) {
            await this.saveDownloadQueue();
          }
          
          // é€šçŸ¥è¿›åº¦æ›´æ–°
          this.notifyTaskChanged(task);
          
          lastProgressUpdate = currentTime;
          lastDownloadedSize = task.downloadedSize;
        }
        
        // æ£€æŸ¥ä¸‹è½½æ˜¯å¦å®Œï¿?        if (task.totalSize > 0 && task.downloadedSize >= task.totalSize) {
          clearInterval(updateInterval);
          
          // æ ‡è®°ä»»åŠ¡å®Œæˆ
          await this.completeDownload(taskId);
        }
      }, 100); // ï¿?00msæ£€æŸ¥ä¸€ï¿?      
      // æ¨¡æ‹Ÿä¸‹è½½å®Œæˆ
      // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥æ˜¯çœŸå®çš„ä¸‹è½½å®ï¿?      // è¿™é‡Œåªæ˜¯ä¸ºäº†æ¼”ç¤º
    } catch (error) {
      Logger.error(TAG, `Error performing download for task: ${taskId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      await this.failDownload(taskId, DownloadErrorType.UNKNOWN_ERROR, String(error));
    }
  }

  /**
   * æš‚åœä¸‹è½½ä»»åŠ¡
   */
  public async pauseDownload(taskId: string): Promise<ApiResponse<DownloadTask>> {
    try {
      Logger.info(TAG, `Pausing download task: ${taskId}`);
      
      const taskIndex = this.downloadQueue.findIndex(task => task.id === taskId);
      if (taskIndex === -1) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'ä¸‹è½½ä»»åŠ¡ä¸å­˜ï¿?);
      }
      
      const task = this.downloadQueue[taskIndex];
      
      // æ£€æŸ¥ä»»åŠ¡çŠ¶ï¿?      if (task.status !== DownloadStatus.DOWNLOADING) {
        return ApiResponse.error(ResponseCode.INVALID_OPERATION, `ä»»åŠ¡çŠ¶æ€ä¸å…è®¸æš‚åœ: ${task.status}`);
      }
      
      // æ›´æ–°ä»»åŠ¡çŠ¶ï¿½?      task.status = DownloadStatus.PAUSED;
      task.isActive = false;
      
      // ä»æ´»åŠ¨ä»»åŠ¡é›†ä¸­ç§»ï¿?      this.activeTasks.delete(taskId);
      
      // æ›´æ–°é˜Ÿåˆ—å¹¶ä¿ï¿?      this.downloadQueue[taskIndex] = task;
      await this.saveDownloadQueue();
      
      // é€šçŸ¥ä»»åŠ¡çŠ¶æ€å˜ï¿?      this.notifyTaskChanged(task);
      this.notifyStatusChanged(DownloadStatus.PAUSED, task);
      this.notifyQueueChanged();
      
      // æ£€æŸ¥æ˜¯å¦æœ‰ç­‰å¾…çš„ä»»åŠ¡å¯ä»¥å¼€ï¿?      if (this.pauseDownloadsOnQueueFull) {
        await this.startNextTaskInQueue();
      }
      
      return ApiResponse.success(task, 'æš‚åœä¸‹è½½æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, `Failed to pause download task: ${taskId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æš‚åœä¸‹è½½å¤±è´¥');
    }
  }

  /**
   * æ¢å¤ä¸‹è½½ä»»åŠ¡
   */
  public async resumeDownload(taskId: string): Promise<ApiResponse<DownloadTask>> {
    try {
      Logger.info(TAG, `Resuming download task: ${taskId}`);
      
      const taskIndex = this.downloadQueue.findIndex(task => task.id === taskId);
      if (taskIndex === -1) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'ä¸‹è½½ä»»åŠ¡ä¸å­˜ï¿?);
      }
      
      const task = this.downloadQueue[taskIndex];
      
      // æ£€æŸ¥ä»»åŠ¡çŠ¶ï¿?      if (task.status !== DownloadStatus.PAUSED) {
        return ApiResponse.error(ResponseCode.INVALID_OPERATION, `ä»»åŠ¡çŠ¶æ€ä¸å…è®¸æ¢å¤: ${task.status}`);
      }
      
      // æ£€æŸ¥ç½‘ç»œçŠ¶ï¿?      const networkAvailable = await NetworkUtil.isNetworkAvailable();
      if (!networkAvailable) {
        return ApiResponse.error(ResponseCode.NETWORK_ERROR, 'ç½‘ç»œä¸å¯ç”¨ï¼Œæ— æ³•æ¢å¤ä¸‹è½½');
      }
      
      // æ£€æŸ¥ç½‘ç»œç±»å‹é™ï¿?      const networkType = await NetworkUtil.getNetworkType();
      if (task.networkType === 'wifi' && networkType !== 'wifi') {
        return ApiResponse.error(ResponseCode.NETWORK_ERROR, 'ä»…åœ¨WiFiç½‘ç»œä¸‹å…è®¸ä¸‹ï¿?);
      }
      
      if (task.networkType === 'cellular' && networkType !== 'cellular') {
        return ApiResponse.error(ResponseCode.NETWORK_ERROR, 'ä»…åœ¨ç§»åŠ¨ç½‘ç»œä¸‹å…è®¸ä¸‹ï¿?);
      }
      
      // æ›´æ–°ä»»åŠ¡çŠ¶ï¿½?      task.status = DownloadStatus.DOWNLOADING;
      task.isActive = true;
      
      // æ·»åŠ åˆ°æ´»åŠ¨ä»»åŠ¡é›†
      this.activeTasks.add(taskId);
      
      // æ›´æ–°é˜Ÿåˆ—å¹¶ä¿ï¿?      this.downloadQueue[taskIndex] = task;
      await this.saveDownloadQueue();
      
      // é€šçŸ¥ä»»åŠ¡çŠ¶æ€å˜ï¿?      this.notifyTaskChanged(task);
      this.notifyStatusChanged(DownloadStatus.DOWNLOADING, task);
      this.notifyQueueChanged();
      
      // é‡æ–°å¼€å§‹ä¸‹ï¿?      this.performDownload(taskId).catch(error => {
        Logger.error(TAG, `Failed to resume download for task: ${taskId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      });
      
      return ApiResponse.success(task, 'æ¢å¤ä¸‹è½½æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, `Failed to resume download task: ${taskId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ¢å¤ä¸‹è½½å¤±è´¥');
    }
  }

  /**
   * å–æ¶ˆä¸‹è½½ä»»åŠ¡
   */
  public async cancelDownload(taskId: string, deleteFiles: boolean = true): Promise<ApiResponse<boolean>> {
    try {
      Logger.info(TAG, `Cancelling download task: ${taskId}, deleteFiles: ${deleteFiles}`);
      
      const taskIndex = this.downloadQueue.findIndex(task => task.id === taskId);
      if (taskIndex === -1) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'ä¸‹è½½ä»»åŠ¡ä¸å­˜ï¿?);
      }
      
      const task = this.downloadQueue[taskIndex];
      
      // åœæ­¢ä¸‹è½½
      task.status = DownloadStatus.CANCELLED;
      task.isActive = false;
      task.endTime = Date.now();
      
      // ä»æ´»åŠ¨ä»»åŠ¡é›†ä¸­ç§»ï¿?      this.activeTasks.delete(taskId);
      
      // åˆ é™¤æ–‡ä»¶
      if (deleteFiles) {
        try {
          if (await FileUtil.fileExists(task.tempFilePath)) {
            await FileUtil.deleteFile(task.tempFilePath);
          }
          if (await FileUtil.fileExists(task.downloadPath)) {
            await FileUtil.deleteFile(task.downloadPath);
          }
        } catch (fileError) {
          Logger.error(TAG, `Failed to delete files for task: ${taskId}`, fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError  as Error)));
        }
      }
      
      // ä»é˜Ÿåˆ—ä¸­ç§»é™¤
      this.downloadQueue.splice(taskIndex, 1);
      
      // ä¿å­˜é˜Ÿåˆ—
      await this.saveDownloadQueue();
      
      // é€šçŸ¥ä»»åŠ¡çŠ¶æ€å˜ï¿?      this.notifyTaskChanged(task);
      this.notifyStatusChanged(DownloadStatus.CANCELLED, task);
      this.notifyQueueChanged();
      
      // å¯åŠ¨ä¸‹ä¸€ä¸ªç­‰å¾…çš„ä»»åŠ¡
      await this.startNextTaskInQueue();
      
      return ApiResponse.success(true, 'å–æ¶ˆä¸‹è½½æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, `Failed to cancel download task: ${taskId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'å–æ¶ˆä¸‹è½½å¤±è´¥');
    }
  }

  /**
   * å®Œæˆä¸‹è½½ä»»åŠ¡
   */
  private async completeDownload(taskId: string): Promise<void> {
    try {
      Logger.info(TAG, `Completing download task: ${taskId}`);
      
      const taskIndex = this.downloadQueue.findIndex(task => task.id === taskId);
      if (taskIndex === -1) {
        return;
      }
      
      let task = this.downloadQueue[taskIndex];
      
      // æ›´æ–°ä»»åŠ¡çŠ¶ï¿½?      task.status = DownloadStatus.COMPLETED;
      task.isActive = false;
      task.progress = 100;
      task.endTime = Date.now();
      
      // ä»æ´»åŠ¨ä»»åŠ¡é›†ä¸­ç§»ï¿?      this.activeTasks.delete(taskId);
      
      // å¦‚æœæœ‰ä¸´æ—¶æ–‡ä»¶ï¼Œé‡å‘½åä¸ºæœ€ç»ˆæ–‡ï¿?      if (await FileUtil.fileExists(task.tempFilePath)) {
        await FileUtil.moveFile(task.tempFilePath, task.downloadPath);
      }
      
      // æ›´æ–°é˜Ÿåˆ—å¹¶ä¿ï¿?      this.downloadQueue[taskIndex] = task;
      await this.saveDownloadQueue();
      
      // é€šçŸ¥ä»»åŠ¡çŠ¶æ€å˜ï¿?      this.notifyTaskChanged(task);
      this.notifyStatusChanged(DownloadStatus.COMPLETED, task);
      this.notifyQueueChanged();
      
      // è‡ªåŠ¨æ’­æ”¾å®Œæˆçš„ä¸‹ï¿?      if (this.settings.autoPlayCompletedDownloads) {
        // è¿™é‡Œå¯ä»¥è§¦å‘æ’­æ”¾äº‹ä»¶
        Logger.info(TAG, `Auto-playing completed download: ${task.id}`);
      }
      
      // å¯åŠ¨ä¸‹ä¸€ä¸ªç­‰å¾…çš„ä»»åŠ¡
      await this.startNextTaskInQueue();
      
      Logger.info(TAG, `Download completed successfully: ${taskId}`);
    } catch (error) {
      Logger.error(TAG, `Failed to complete download task: ${taskId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      await this.failDownload(taskId, DownloadErrorType.UNKNOWN_ERROR, String(error));
    }
  }

  /**
   * æ ‡è®°ä¸‹è½½ä»»åŠ¡å¤±è´¥
   */
  private async failDownload(
    taskId: string, 
    errorType: DownloadErrorType, 
    errorMessage: string
  ): Promise<void> {
    try {
      Logger.error(TAG, `Download failed for task: ${taskId}`, new Error(JSON.stringify({ errorType, errorMessage })));
      
      const taskIndex = this.downloadQueue.findIndex(task => task.id === taskId);
      if (taskIndex === -1) {
        return;
      }
      
      let task = this.downloadQueue[taskIndex];
      
      // æ›´æ–°ä»»åŠ¡çŠ¶ï¿½?      task.status = DownloadStatus.FAILED;
      task.isActive = false;
      task.errorType = errorType;
      task.errorMessage = errorMessage;
      task.endTime = Date.now();
      
      // ä»æ´»åŠ¨ä»»åŠ¡é›†ä¸­ç§»ï¿?      this.activeTasks.delete(taskId);
      
      // è‡ªåŠ¨åˆ é™¤å¤±è´¥çš„ä¸‹ï¿?      if (this.settings.autoDeleteFailedDownloads) {
        try {
          if (await FileUtil.fileExists(task.tempFilePath)) {
            await FileUtil.deleteFile(task.tempFilePath);
          }
          // ä»é˜Ÿåˆ—ä¸­ç§»é™¤
          this.downloadQueue.splice(taskIndex, 1);
        } catch (fileError) {
          Logger.error(TAG, `Failed to delete failed download files for task: ${taskId}`, fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError instanceof Error ? fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError instanceof Error ? fileError : new Error(String(fileError : new Error(String(fileError  as Error)));
        }
      } else {
        // æ›´æ–°é˜Ÿåˆ—
        this.downloadQueue[taskIndex] = task;
      }
      
      // ä¿å­˜é˜Ÿåˆ—
      await this.saveDownloadQueue();
      
      // é€šçŸ¥ä»»åŠ¡çŠ¶æ€å˜ï¿?      this.notifyTaskChanged(task);
      this.notifyStatusChanged(DownloadStatus.FAILED, task);
      this.notifyQueueChanged();
      
      // å¯åŠ¨ä¸‹ä¸€ä¸ªç­‰å¾…çš„ä»»åŠ¡
      await this.startNextTaskInQueue();
    } catch (error) {
      Logger.error(TAG, `Failed to update failed download task: ${taskId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * å¯åŠ¨é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªä»»ï¿?   */
  private async startNextTaskInQueue(): Promise<void> {
    try {
      // æ£€æŸ¥æ˜¯å¦æœ‰ç©ºé—²ä¸‹è½½ï¿?      if (this.activeTasks.size >= this.settings.maxConcurrentDownloads) {
        return;
      }
      
      // æŸ¥æ‰¾ä¼˜å…ˆçº§æœ€é«˜çš„ç­‰å¾…ä»»åŠ¡
      const nextTask = this.downloadQueue.find(task => 
        (task.status === DownloadStatus.QUEUED || task.status === DownloadStatus.PAUSED) && 
        !task.isActive
      );
      
      if (nextTask) {
        this.pauseDownloadsOnQueueFull = false;
        await this.startDownload(nextTask.id);
        Logger.info(TAG, `Started next task in queue: ${nextTask.id}`);
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to start next task in queue', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * å¯åŠ¨æ‰€æœ‰ç­‰å¾…ä¸­çš„ä»»ï¿?   */
  public async startAllDownloads(): Promise<ApiResponse<{ started: number; failed: number }>> {
    try {
      Logger.info(TAG, 'Starting all download tasks');
      
      let started = 0;
      let failed = 0;
      
      // è·å–æ‰€æœ‰ç­‰å¾…ä¸­çš„ä»»ï¿?      const pendingTasks = this.downloadQueue.filter(task => 
        (task.status === DownloadStatus.QUEUED || task.status === DownloadStatus.PAUSED) && 
        !task.isActive
      );
      
      // å¯åŠ¨ä»»åŠ¡ï¼Œå—æœ€å¤§å¹¶å‘é™ï¿?      for (const task of pendingTasks) {
        if (this.activeTasks.size >= this.settings.maxConcurrentDownloads) {
          break;
        }
        
        const result = await this.startDownload(task.id);
        if (result.isSuccess()) {
          started++;
        } else {
          failed++;
        }
      }
      
      return ApiResponse.success(
        { started, failed },
        `å¼€å§‹ä¸‹è½½å®Œæˆï¼ŒæˆåŠŸ${started}é¡¹ï¼Œå¤±è´¥${failed}é¡¹`
      );
    } catch (error) {
      Logger.error(TAG, 'Failed to start all downloads', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'å¼€å§‹æ‰€æœ‰ä¸‹è½½å¤±ï¿?);
    }
  }

  /**
   * æš‚åœæ‰€æœ‰ä¸‹è½½ä»»ï¿?   */
  public async pauseAllDownloads(): Promise<ApiResponse<{ paused: number; failed: number }>> {
    try {
      Logger.info(TAG, 'Pausing all download tasks');
      
      let paused = 0;
      let failed = 0;
      
      // è·å–æ‰€æœ‰æ­£åœ¨ä¸‹è½½çš„ä»»åŠ¡
      const activeTasks = this.downloadQueue.filter(task => 
        task.status === DownloadStatus.DOWNLOADING
      );
      
      // æš‚åœä»»åŠ¡
      for (const task of activeTasks) {
        const result = await this.pauseDownload(task.id);
        if (result.isSuccess()) {
          paused++;
        } else {
          failed++;
        }
      }
      
      return ApiResponse.success(
        { paused, failed },
        `æš‚åœä¸‹è½½å®Œæˆï¼Œæˆï¿?{paused}é¡¹ï¼Œå¤±è´¥${failed}é¡¹`
      );
    } catch (error) {
      Logger.error(TAG, 'Failed to pause all downloads', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æš‚åœæ‰€æœ‰ä¸‹è½½å¤±ï¿?);
    }
  }

  /**
   * è·å–ä¸‹è½½ä»»åŠ¡
   */
  public async getDownloadTask(taskId: string): Promise<ApiResponse<DownloadTask>> {
    try {
      const task = this.downloadQueue.find(task => task.id === taskId);
      
      if (!task) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'ä¸‹è½½ä»»åŠ¡ä¸å­˜ï¿?);
      }
      
      return ApiResponse.success(task, 'è·å–ä¸‹è½½ä»»åŠ¡æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, `Failed to get download task: ${taskId}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–ä¸‹è½½ä»»åŠ¡å¤±è´¥');
    }
  }

  /**
   * è·å–ä¸‹è½½é˜Ÿåˆ—
   */
  public async getDownloadQueue(
    status?: DownloadStatus,
    videoType?: VideoType
  ): Promise<ApiResponse<DownloadTask[]>> {
    try {
      let tasks = [...this.downloadQueue];
      
      // æŒ‰çŠ¶æ€è¿‡ï¿?      if (status) {
        tasks = tasks.filter(task => task.status === status);
      }
      
      // æŒ‰è§†é¢‘ç±»å‹è¿‡ï¿?      if (videoType) {
        tasks = tasks.filter(task => task.videoType === videoType);
      }
      
      // æŒ‰ä¼˜å…ˆçº§å’ŒçŠ¶æ€æ’ï¿?      tasks.sort((a, b) => {
        // é«˜ä¼˜å…ˆçº§ä»»åŠ¡æ’åœ¨å‰é¢
        if (a.isHighPriority !== b.isHighPriority) {
          return a.isHighPriority ? -1 : 1;
        }
        
        // ä¸‹è½½ä¸­çš„ä»»åŠ¡æ’åœ¨å‰é¢
        if (a.status === DownloadStatus.DOWNLOADING && b.status !== DownloadStatus.DOWNLOADING) {
          return -1;
        }
        if (b.status === DownloadStatus.DOWNLOADING && a.status !== DownloadStatus.DOWNLOADING) {
          return 1;
        }
        
        // æš‚åœçš„ä»»åŠ¡æ’åœ¨é˜Ÿåˆ—ä»»åŠ¡å‰ï¿?        if (a.status === DownloadStatus.PAUSED && b.status === DownloadStatus.QUEUED) {
          return -1;
        }
        if (b.status === DownloadStatus.PAUSED && a.status === DownloadStatus.QUEUED) {
          return 1;
        }
        
        // å…¶ä»–çŠ¶æ€æŒ‰æ·»åŠ æ—¶é—´æ’åº
        return 0;
      });
      
      return ApiResponse.success(tasks, `è·å–ä¸‹è½½é˜Ÿåˆ—æˆåŠŸï¼Œå…±${tasks.length}é¡¹`);
    } catch (error) {
      Logger.error(TAG, 'Failed to get download queue', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–ä¸‹è½½é˜Ÿåˆ—å¤±è´¥');
    }
  }

  /**
   * è·å–ä¸‹è½½ç»Ÿè®¡ä¿¡æ¯
   */
  public async getDownloadStatistics(): Promise<ApiResponse<{
    totalTasks: number;
    activeTasks: number;
    completedTasks: number;
    pausedTasks: number;
    failedTasks: number;
    queuedTasks: number;
    totalDownloadedSize: number;
    totalSize: number;
    totalProgress: number;
    averageSpeed: number;
  }>> {
    try {
      const stats: Record<string, string | number | boolean | null> = { ... };
      
      // è®¡ç®—æ€»å¤§å°å’Œæ€»è¿›ï¿?      const activeTasks = this.downloadQueue.filter(t => t.isActive);
      stats.totalSize = this.downloadQueue.reduce((sum, t) => sum + (t.totalSize || 0), 0);
      stats.averageSpeed = activeTasks.length > 0 
        ? activeTasks.reduce((sum, t) => sum + t.downloadSpeed, 0) / activeTasks.length 
        : 0;
      
      if (stats.totalSize > 0) {
        stats.totalProgress = Math.floor((stats.totalDownloadedSize / stats.totalSize) * 100);
      }
      
      return ApiResponse.success(stats, 'è·å–ä¸‹è½½ç»Ÿè®¡æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to get download statistics', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–ä¸‹è½½ç»Ÿè®¡å¤±è´¥');
    }
  }

  /**
   * æ¸…ç†ä¸´æ—¶æ–‡ä»¶
   */
  private async cleanupTempFiles(): Promise<void> {
    try {
      const tempFiles = await FileUtil.getFilesWithExtension(this.settings.downloadFolder, '.temp');
      
      for (const file of tempFiles) {
        try {
          await FileUtil.deleteFile(file);
          Logger.info(TAG, `Cleaned up temp file: ${file}`);
        } catch (error) {
          Logger.error(TAG, `Failed to delete temp file: ${file}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
        }
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to cleanup temp files', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * ä¿å­˜ä¸‹è½½é˜Ÿåˆ—åˆ°æ•°æ®åº“
   */
  private async saveDownloadQueue(): Promise<void> {
    try {
      await this.databaseRepo.saveDownloadQueue(this.downloadQueue);
      await StorageUtil.setObject(DOWNLOAD_QUEUE_KEY, this.downloadQueue);
    } catch (error) {
      Logger.error(TAG, 'Failed to save download queue', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  /**
   * å¯åŠ¨ç­‰å¾…ä¸­çš„ä¸‹è½½ä»»åŠ¡
   */
  private async startPendingDownloads(): Promise<void> {
    try {
      const pendingTasks = this.downloadQueue.filter(task => 
        task.status === DownloadStatus.QUEUED && !task.isActive
      );
      
      // å¯åŠ¨é€‚é‡çš„ä»»ï¿?      const maxToStart = Math.min(pendingTasks.length, this.settings.maxConcurrentDownloads);
      
      for (let i = 0; i < maxToStart; i++) {
        await this.startDownload(pendingTasks[i].id);
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to start pending downloads', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }

  // ========== äº‹ä»¶ç›‘å¬ç›¸å…³ ==========

  /**
   * æ·»åŠ ä¸‹è½½ä»»åŠ¡ç›‘å¬ï¿?   */
  public addTaskListener(taskId: string, listener: (task: DownloadTask) => void): () => void {
    if (!this.taskListeners.has(taskId)) {
      this.taskListeners.set(taskId, []);
    }
    
    const listeners = this.taskListeners.get(taskId)!;
    listeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ ä¸‹è½½é˜Ÿåˆ—ç›‘å¬ï¿?   */
  public addQueueListener(listener: (queue: DownloadTask[]) => void): () => void {
    this.queueListeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.queueListeners.indexOf(listener);
      if (index > -1) {
        this.queueListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ ä¸‹è½½çŠ¶æ€ç›‘å¬å™¨
   */
  public addStatusListener(status: DownloadStatus, listener: (task: DownloadTask) => void): () => void {
    if (!this.statusListeners.has(status)) {
      this.statusListeners.set(status, []);
    }
    
    const listeners = this.statusListeners.get(status)!;
    listeners.push(listener);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }

  /**
   * é€šçŸ¥ä»»åŠ¡å˜æ›´
   */
  private notifyTaskChanged(task: DownloadTask): void {
    // é€šçŸ¥ç‰¹å®šä»»åŠ¡çš„ç›‘å¬å™¨
    if (this.taskListeners.has(task.id)) {
      const listeners = this.taskListeners.get(task.id)!;
      for (const listener of listeners) {
        try {
          listener(task);
        } catch (error) {
          Logger.error(TAG, `Error in task listener for ${task.id}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
        }
      }
    }
  }

  /**
   * é€šçŸ¥é˜Ÿåˆ—å˜æ›´
   */
  private notifyQueueChanged(): void {
    for (const listener of this.queueListeners) {
      try {
        listener([...this.downloadQueue]);
      } catch (error) {
        Logger.error(TAG, 'Error in queue listener', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      }
    }
  }

  /**
   * é€šçŸ¥çŠ¶æ€å˜ï¿?   */
  private notifyStatusChanged(status: DownloadStatus, task: DownloadTask): void {
    if (this.statusListeners.has(status)) {
      const listeners = this.statusListeners.get(status)!;
      for (const listener of listeners) {
        try {
          listener(task);
        } catch (error) {
          Logger.error(TAG, `Error in status listener for ${status}`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
        }
      }
    }
  }

  // ========== ä¸‹è½½è®¾ç½®ç®¡ç† ==========

  /**
   * è·å–ä¸‹è½½è®¾ç½®
   */
  public getDownloadSettings(): DownloadSettings {
    return { ...this.settings };
  }

  /**
   * æ›´æ–°ä¸‹è½½è®¾ç½®
   */
  public async updateDownloadSettings(
    newSettings: Partial<DownloadSettings>
  ): Promise<ApiResponse<DownloadSettings>> {
    try {
      // æ›´æ–°è®¾ç½®
      this.settings = { ...this.settings, ...newSettings };
      
      // ä¿å­˜è®¾ç½®
      await StorageUtil.setObject(DOWNLOAD_SETTINGS_KEY, this.settings);
      
      // å¦‚æœæ›´æ–°äº†æœ€å¤§å¹¶å‘æ•°ï¼Œå¯èƒ½éœ€è¦å¯åŠ¨æˆ–æš‚åœä»»åŠ¡
      if (newSettings.maxConcurrentDownloads !== undefined) {
        const currentActiveCount = this.activeTasks.size;
        const maxConcurrent = newSettings.maxConcurrentDownloads;
        
        // å¦‚æœå½“å‰æ´»åŠ¨ä»»åŠ¡è¶…è¿‡æ–°é™åˆ¶ï¼Œæš‚åœå¤šä½™çš„ä»»ï¿?        if (currentActiveCount > maxConcurrent) {
          const activeTasks = this.downloadQueue.filter(task => task.isActive);
          const tasksToPause = activeTasks.slice(maxConcurrent);
          
          for (const task of tasksToPause) {
            await this.pauseDownload(task.id);
          }
        }
        // å¦‚æœæœ‰ç©ºé—²æ§½ä½ï¼Œå¯åŠ¨ç­‰å¾…çš„ä»»ï¿?        else if (currentActiveCount < maxConcurrent) {
          await this.startNextTaskInQueue();
        }
      }
      
      Logger.info(TAG, 'Download settings updated', newSettings);
      return ApiResponse.success(this.settings, 'æ›´æ–°ä¸‹è½½è®¾ç½®æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to update download settings', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ›´æ–°ä¸‹è½½è®¾ç½®å¤±è´¥');
    }
  }

  /**
   * é‡ç½®ä¸‹è½½è®¾ç½®ä¸ºé»˜è®¤ï¿½?   */
  public async resetDownloadSettings(): Promise<ApiResponse<DownloadSettings>> {
    try {
      this.settings = { ...DEFAULT_DOWNLOAD_SETTINGS };
      
      // ç¡®ä¿ä¸‹è½½æ–‡ä»¶å¤¹æœ‰ï¿?      this.settings.downloadFolder = await FileUtil.getDownloadDirectory('RayTV');
      
      // ä¿å­˜è®¾ç½®
      await StorageUtil.setObject(DOWNLOAD_SETTINGS_KEY, this.settings);
      
      Logger.info(TAG, 'Download settings reset to default');
      return ApiResponse.success(this.settings, 'é‡ç½®ä¸‹è½½è®¾ç½®æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to reset download settings', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'é‡ç½®ä¸‹è½½è®¾ç½®å¤±è´¥');
    }
  }
}


