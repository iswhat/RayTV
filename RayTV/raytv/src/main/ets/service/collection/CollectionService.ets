// CollectionService - æ”¶è—æœåŠ¡ç±?import Logger from '../../common/util/Logger';
import DateUtil from '../../common/util/DateUtil';
import RepositoryFactory from '../../data/repository/RepositoryFactory';
import DatabaseRepository from '../../data/repository/DatabaseRepository';

// å¯¼å…¥æ¨¡å‹å’ŒDTO
import { VideoType } from '../../data/model/Movie';
import ApiResponse, { ResponseCode } from '../../data/dto/ApiResponse';
import { MovieDetailData } from '../../data/dto/MovieDetailDto';

// å¸¸é‡å®šä¹‰
const TAG = 'CollectionService';
const MAX_COLLECTION_SIZE = 1000; // æœ€å¤§æ”¶è—æ•°é‡é™åˆ?
// æ”¶è—é¡¹æ¥å£å®šä¹?export interface CollectionItem {
  id: string;              // å†…å®¹ID
  title: string;           // æ ‡é¢˜
  coverUrl: string;        // å°é¢URL
  type: VideoType;         // ç±»å‹
  rating?: number;         // è¯„åˆ†
  releaseYear?: number;    // å‘å¸ƒå¹´ä»½
  addedAt: number;         // æ·»åŠ æ—¶é—´
  isFavorite: boolean;     // æ˜¯å¦æ”¶è—ï¼ˆå§‹ç»ˆä¸ºtrueï¼?  genres?: string[];       // ç±»å‹æ ‡ç­¾
  description?: string;    // ç®€ä»?  lastUpdate?: number;     // æœ€åæ›´æ–°æ—¶é—?  watchProgress?: number;  // è§‚çœ‹è¿›åº¦
}

/**
 * æ”¶è—æœåŠ¡ç±? * è´Ÿè´£å¤„ç†ç”¨æˆ·æ”¶è—ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘
 */
export default class CollectionService {
  private static instance: CollectionService;
  private databaseRepo: DatabaseRepository;

  /**
   * æ„é€ å‡½æ•°ï¼ˆç§æœ‰ï¼Œé˜²æ­¢å¤–éƒ¨å®ä¾‹åŒ–ï¼?   */
  private constructor() {
    this.databaseRepo = RepositoryFactory.getRepository('database') as DatabaseRepository;
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): CollectionService {
    if (!CollectionService.instance) {
      CollectionService.instance = new CollectionService();
    }
    return CollectionService.instance;
  }

  /**
   * åˆå§‹åŒ–æœåŠ?   * ç”¨äºå…¼å®¹AppServiceçš„åˆå§‹åŒ–æµç¨‹
   */
  public async initialize(): Promise<void> {
    Logger.info(TAG, 'CollectionService initialized');
    // ç©ºå®ç°ï¼Œç”¨äºå…¼å®¹AppServiceåˆå§‹åŒ–æµç¨?  }

  /**
   * æ·»åŠ æ”¶è—
   */
  public async addToCollection(collectionData: Partial<CollectionItem>): Promise<ApiResponse<CollectionItem>> {
    try {
      Logger.info(TAG, 'Adding to collection...', { 
        id: collectionData.id,
        title: collectionData.title
      });

      // éªŒè¯å¿…è¦å­—æ®µ
      if (!collectionData.id) {
        return ApiResponse.validationError<CollectionItem>([
          { field: 'id', message: 'å†…å®¹IDä¸èƒ½ä¸ºç©º' }
        ]);
      }

      if (!collectionData.title) {
        return ApiResponse.validationError<CollectionItem>([
          { field: 'title', message: 'æ ‡é¢˜ä¸èƒ½ä¸ºç©º' }
        ]);
      }

      // æ£€æŸ¥æ˜¯å¦å·²æ”¶è—
      const isFavorite = await this.databaseRepo.isMovieFavorite(collectionData.id);
      if (isFavorite) {
        return ApiResponse.error(ResponseCode.DUPLICATE_ERROR, 'è¯¥å†…å®¹å·²åœ¨æ”¶è—åˆ—è¡¨ä¸­');
      }

      // æ£€æŸ¥æ”¶è—æ•°é‡é™åˆ?      const collectionCount = await this.databaseRepo.getFavoriteCount();
      if (collectionCount >= MAX_COLLECTION_SIZE) {
        return ApiResponse.error(ResponseCode.LIMIT_EXCEEDED, `æ”¶è—æ•°é‡å·²è¾¾ä¸Šé™(${MAX_COLLECTION_SIZE}ä¸?`);
      }

      // åˆ›å»ºæ”¶è—é¡?      const collectionItem: CollectionItem = {
        id: collectionData.id,
        title: collectionData.title,
        coverUrl: collectionData.coverUrl || '',
        type: collectionData.type || VideoType.MOVIE,
        rating: collectionData.rating,
        releaseYear: collectionData.releaseYear,
        addedAt: Date.now(),
        isFavorite: true,
        genres: collectionData.genres,
        description: collectionData.description,
        lastUpdate: Date.now()
      };

      // æ·»åŠ åˆ°æ”¶è—?      await this.databaseRepo.addToFavorites(collectionItem);
      Logger.info(TAG, 'Added to collection', { id: collectionItem.id });

      return ApiResponse.success(collectionItem, 'æ·»åŠ æ”¶è—æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to add to collection', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ·»åŠ æ”¶è—å¤±è´¥');
    }
  }

  /**
   * ä»æ”¶è—ä¸­ç§»é™¤
   */
  public async removeFromCollection(contentId: string): Promise<ApiResponse<boolean>> {
    try {
      Logger.info(TAG, 'Removing from collection...', { contentId });

      // æ£€æŸ¥æ˜¯å¦å·²æ”¶è—
      const isFavorite = await this.databaseRepo.isMovieFavorite(contentId);
      if (!isFavorite) {
        return ApiResponse.error(ResponseCode.NOT_FOUND, 'è¯¥å†…å®¹ä¸åœ¨æ”¶è—åˆ—è¡¨ä¸­');
      }

      // ä»æ”¶è—ä¸­ç§»é™¤
      await this.databaseRepo.removeFromFavorites(contentId);
      Logger.info(TAG, 'Removed from collection', { contentId });

      return ApiResponse.success(true, 'ç§»é™¤æ”¶è—æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to remove from collection', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'ç§»é™¤æ”¶è—å¤±è´¥');
    }
  }

  /**
   * åˆ‡æ¢æ”¶è—çŠ¶æ€?   */
  public async toggleFavorite(collectionData: Partial<CollectionItem>): Promise<ApiResponse<{ item: CollectionItem | null; isFavorite: boolean }>> {
    try {
      Logger.info(TAG, 'Toggling favorite status...', { 
        id: collectionData.id,
        title: collectionData.title
      });

      const contentId = collectionData.id;
      if (!contentId) {
        return ApiResponse.validationError([
          { field: 'id', message: 'å†…å®¹IDä¸èƒ½ä¸ºç©º' }
        ]);
      }

      // æ£€æŸ¥å½“å‰æ”¶è—çŠ¶æ€?      const isFavorite = await this.databaseRepo.isMovieFavorite(contentId);

      if (isFavorite) {
        // ç§»é™¤æ”¶è—
        await this.databaseRepo.removeFromFavorites(contentId);
        Logger.info(TAG, 'Removed from collection', { contentId });
        return ApiResponse.success({ item: null, isFavorite: false }, 'ç§»é™¤æ”¶è—æˆåŠŸ');
      } else {
        // æ£€æŸ¥æ”¶è—æ•°é‡é™åˆ?        const collectionCount = await this.databaseRepo.getFavoriteCount();
        if (collectionCount >= MAX_COLLECTION_SIZE) {
          return ApiResponse.error(ResponseCode.LIMIT_EXCEEDED, `æ”¶è—æ•°é‡å·²è¾¾ä¸Šé™(${MAX_COLLECTION_SIZE}ä¸?`);
        }

        // æ·»åŠ æ”¶è—
        const collectionItem: CollectionItem = {
          id: contentId,
          title: collectionData.title || '',
          coverUrl: collectionData.coverUrl || '',
          type: collectionData.type || VideoType.MOVIE,
          rating: collectionData.rating,
          releaseYear: collectionData.releaseYear,
          addedAt: Date.now(),
          isFavorite: true,
          genres: collectionData.genres,
          description: collectionData.description,
          lastUpdate: Date.now()
        };

        await this.databaseRepo.addToFavorites(collectionItem);
        Logger.info(TAG, 'Added to collection', { contentId });
        return ApiResponse.success({ item: collectionItem, isFavorite: true }, 'æ·»åŠ æ”¶è—æˆåŠŸ');
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to toggle favorite status', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'åˆ‡æ¢æ”¶è—çŠ¶æ€å¤±è´?);
    }
  }

  /**
   * è·å–æ”¶è—åˆ—è¡¨
   */
  public async getCollectionList(params: {
    page?: number;
    pageSize?: number;
    type?: VideoType;
    sortBy?: 'addedAt' | 'title' | 'rating' | 'releaseYear';
    sortOrder?: 'asc' | 'desc';
  } = {}): Promise<ApiResponse<{
    items: (CollectionItem & { movieInfo?: Partial<MovieDetailData> })[];
    total: number;
    page: number;
    pageSize: number;
    totalPages: number;
  }>> {
    try {
      const {
        page = 1,
        pageSize = 20,
        type,
        sortBy = 'addedAt',
        sortOrder = 'desc'
      } = params;

      Logger.info(TAG, 'Getting collection list...', { page, pageSize, type, sortBy, sortOrder });

      // è·å–æ”¶è—åˆ—è¡¨
      const collectionItems = await this.databaseRepo.getFavoritesList({
        page,
        pageSize,
        type,
        sortBy,
        sortOrder
      });

      // è·å–æ€»æ•°
      const total = await this.databaseRepo.getFavoriteCount(type);
      const totalPages = Math.ceil(total / pageSize);

      // å¢å¼ºæ”¶è—æ•°æ®
      const enhancedItems = await this.enhanceCollectionWithMovieInfo(collectionItems);

      return ApiResponse.success({
        items: enhancedItems,
        total,
        page,
        pageSize,
        totalPages
      }, 'è·å–æ”¶è—åˆ—è¡¨æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to get collection list', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–æ”¶è—åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * è·å–æ”¶è—è¯¦æƒ…
   */
  public async getCollectionItem(contentId: string): Promise<ApiResponse<CollectionItem | null>> {
    try {
      Logger.info(TAG, 'Getting collection item...', { contentId });

      const item = await this.databaseRepo.getFavoriteById(contentId);
      if (item) {
        return ApiResponse.success(item, 'è·å–æ”¶è—è¯¦æƒ…æˆåŠŸ');
      } else {
        return ApiResponse.success(null, 'æ”¶è—é¡¹ä¸å­˜åœ¨');
      }
    } catch (error) {
      Logger.error(TAG, 'Failed to get collection item', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–æ”¶è—è¯¦æƒ…å¤±è´¥');
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²æ”¶è—
   */
  public async isFavorite(contentId: string): Promise<ApiResponse<boolean>> {
    try {
      Logger.info(TAG, 'Checking if favorite...', { contentId });

      const isFavorite = await this.databaseRepo.isMovieFavorite(contentId);
      return ApiResponse.success(isFavorite, 'æ£€æŸ¥å®Œæˆ?);
    } catch (error) {
      Logger.error(TAG, 'Failed to check favorite status', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.success(false, 'æ£€æŸ¥å¤±è´¥ï¼Œé»˜è®¤è¿”å›æœªæ”¶è—?);
    }
  }

  /**
   * æ‰¹é‡æ·»åŠ æ”¶è—
   */
  public async batchAddToCollection(items: Partial<CollectionItem>[]): Promise<ApiResponse<{
    success: number;
    failed: number;
    failedItems: string[];
  }>> {
    try {
      Logger.info(TAG, 'Batch adding to collection...', { totalItems: items.length });

      let success = 0;
      let failed = 0;
      const failedItems: string[] = [];

      // æ£€æŸ¥å½“å‰æ”¶è—æ•°é‡?      const currentCount = await this.databaseRepo.getFavoriteCount();
      const availableSlots = MAX_COLLECTION_SIZE - currentCount;

      if (availableSlots <= 0) {
        return ApiResponse.error(ResponseCode.LIMIT_EXCEEDED, `æ”¶è—æ•°é‡å·²è¾¾ä¸Šé™(${MAX_COLLECTION_SIZE}ä¸?`);
      }

      // é™åˆ¶æ‰¹é‡æ·»åŠ çš„æ•°é‡?      const itemsToAdd = items.slice(0, Math.min(items.length, availableSlots));

      for (const item of itemsToAdd) {
        try {
          // æ£€æŸ¥æ˜¯å¦å·²æ”¶è—
          const isFavorite = await this.databaseRepo.isMovieFavorite(item.id);
          if (isFavorite) {
            failed++;
            failedItems.push(item.id);
            continue;
          }

          const collectionItem: CollectionItem = {
            id: item.id,
            title: item.title || '',
            coverUrl: item.coverUrl || '',
            type: item.type || VideoType.MOVIE,
            rating: item.rating,
            releaseYear: item.releaseYear,
            addedAt: Date.now(),
            isFavorite: true,
            genres: item.genres,
            description: item.description,
            lastUpdate: Date.now()
          };

          await this.databaseRepo.addToFavorites(collectionItem);
          success++;
        } catch (error) {
          Logger.warn(TAG, `Failed to add item ${item.id} to collection`, error);
          failed++;
          if (item.id) {
            failedItems.push(item.id);
          }
        }
      }

      Logger.info(TAG, 'Batch add completed', { success, failed, totalProcessed: success + failed });
      return ApiResponse.success({
        success,
        failed,
        failedItems
      }, `æ‰¹é‡æ·»åŠ å®Œæˆï¼ŒæˆåŠ?{success}ä¸ªï¼Œå¤±è´¥${failed}ä¸ª`);
    } catch (error) {
      Logger.error(TAG, 'Failed to batch add to collection', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ‰¹é‡æ·»åŠ æ”¶è—å¤±è´¥');
    }
  }

  /**
   * æ‰¹é‡ç§»é™¤æ”¶è—
   */
  public async batchRemoveFromCollection(contentIds: string[]): Promise<ApiResponse<{
    success: number;
    failed: number;
  }>> {
    try {
      Logger.info(TAG, 'Batch removing from collection...', { totalItems: contentIds.length });

      let success = 0;
      let failed = 0;

      for (const contentId of contentIds) {
        try {
          await this.databaseRepo.removeFromFavorites(contentId);
          success++;
        } catch (error) {
          Logger.warn(TAG, `Failed to remove item ${contentId} from collection`, error);
          failed++;
        }
      }

      Logger.info(TAG, 'Batch remove completed', { success, failed });
      return ApiResponse.success({
        success,
        failed
      }, `æ‰¹é‡ç§»é™¤å®Œæˆï¼ŒæˆåŠ?{success}ä¸ªï¼Œå¤±è´¥${failed}ä¸ª`);
    } catch (error) {
      Logger.error(TAG, 'Failed to batch remove from collection', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ‰¹é‡ç§»é™¤æ”¶è—å¤±è´¥');
    }
  }

  /**
   * æ¸…ç©ºæ”¶è—
   */
  public async clearAllCollection(type?: VideoType): Promise<ApiResponse<boolean>> {
    try {
      Logger.info(TAG, 'Clearing all collection...', { type });

      await this.databaseRepo.clearAllFavorites(type);
      Logger.info(TAG, 'All collection cleared', { type });

      return ApiResponse.success(true, 'æ¸…ç©ºæ”¶è—æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to clear all collection', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æ¸…ç©ºæ”¶è—å¤±è´¥');
    }
  }

  /**
   * è·å–æ”¶è—ç»Ÿè®¡
   */
  public async getCollectionStats(): Promise<ApiResponse<{
    totalCount: number;
    movieCount: number;
    tvCount: number;
    animeCount: number;
    recentAdded: CollectionItem[];
    ratingDistribution: {
      rating: number;
      count: number;
    }[];
    yearDistribution: {
      year: number;
      count: number;
    }[];
  }>> {
    try {
      Logger.info(TAG, 'Getting collection stats...');

      // è·å–æ€»æ•°
      const totalCount = await this.databaseRepo.getFavoriteCount();
      const movieCount = await this.databaseRepo.getFavoriteCount(VideoType.MOVIE);
      const tvCount = await this.databaseRepo.getFavoriteCount(VideoType.TV_SERIES);
      const animeCount = await this.databaseRepo.getFavoriteCount(VideoType.ANIME);

      // è·å–æœ€è¿‘æ·»åŠ çš„æ”¶è—
      const recentAdded = await this.databaseRepo.getFavoritesList({
        page: 1,
        pageSize: 5,
        sortBy: 'addedAt',
        sortOrder: 'desc'
      });

      // è·å–è¯„åˆ†åˆ†å¸ƒ
      const ratingDistribution = await this.databaseRepo.getFavoriteRatingStats();

      // è·å–å¹´ä»½åˆ†å¸ƒ
      const yearDistribution = await this.databaseRepo.getFavoriteYearStats();

      return ApiResponse.success({
        totalCount,
        movieCount,
        tvCount,
        animeCount,
        recentAdded,
        ratingDistribution,
        yearDistribution
      }, 'è·å–æ”¶è—ç»Ÿè®¡æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to get collection stats', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–æ”¶è—ç»Ÿè®¡å¤±è´¥');
    }
  }

  /**
   * æœç´¢æ”¶è—
   */
  public async searchCollection(keyword: string, type?: VideoType): Promise<ApiResponse<CollectionItem[]>> {
    try {
      Logger.info(TAG, 'Searching collection...', { keyword, type });

      if (!keyword || keyword.trim().length === 0) {
        return ApiResponse.validationError([
          { field: 'keyword', message: 'æœç´¢å…³é”®è¯ä¸èƒ½ä¸ºç©? }
        ]);
      }

      const results = await this.databaseRepo.searchFavorites(keyword.trim(), type);
      return ApiResponse.success(results, `æ‰¾åˆ°${results.length}ä¸ªåŒ¹é…çš„æ”¶è—é¡¹`);
    } catch (error) {
      Logger.error(TAG, 'Failed to search collection', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æœç´¢æ”¶è—å¤±è´¥');
    }
  }

  /**
   * å¯¼å‡ºæ”¶è—
   */
  public async exportCollection(): Promise<ApiResponse<string>> {
    try {
      Logger.info(TAG, 'Exporting collection...');

      // è·å–æ‰€æœ‰æ”¶è—?      const allItems = await this.databaseRepo.getAllFavorites();

      // è½¬æ¢ä¸ºå¯¼å‡ºæ ¼å¼?      const exportData = {
        exportDate: new Date().toISOString(),
        totalItems: allItems.length,
        items: allItems.map(item => ({
          id: item.id,
          title: item.title,
          coverUrl: item.coverUrl,
          type: item.type,
          rating: item.rating,
          releaseYear: item.releaseYear,
          addedAt: item.addedAt,
          genres: item.genres,
          description: item.description
        }))
      };

      const jsonStr = JSON.stringify(exportData, null, 2);
      return ApiResponse.success(jsonStr, 'å¯¼å‡ºæ”¶è—æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to export collection', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'å¯¼å‡ºæ”¶è—å¤±è´¥');
    }
  }

  /**
   * å¯¼å…¥æ”¶è—
   */
  public async importCollection(jsonData: string, merge: boolean = true): Promise<ApiResponse<{
    imported: number;
    skipped: number;
    existing: number;
  }>> {
    try {
      Logger.info(TAG, 'Importing collection...', { merge });

      // è§£æJSONæ•°æ®
      const importData = JSON.parse(jsonData);
      const items = importData.items || [];

      let imported = 0;
      let skipped = 0;
      let existing = 0;

      // æ£€æŸ¥æ”¶è—æ•°é‡é™åˆ?      const currentCount = await this.databaseRepo.getFavoriteCount();
      const availableSlots = MAX_COLLECTION_SIZE - currentCount;

      if (availableSlots <= 0 && !merge) {
        return ApiResponse.error(ResponseCode.LIMIT_EXCEEDED, `æ”¶è—æ•°é‡å·²è¾¾ä¸Šé™(${MAX_COLLECTION_SIZE}ä¸?`);
      }

      for (const itemData of items) {
        try {
          // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
          const isFavorite = await this.databaseRepo.isMovieFavorite(itemData.id);

          if (isFavorite) {
            if (merge) {
              // æ›´æ–°å·²å­˜åœ¨çš„æ”¶è—
              const updatedItem: CollectionItem = {
                id: itemData.id,
                title: itemData.title || '',
                coverUrl: itemData.coverUrl || '',
                type: itemData.type || VideoType.MOVIE,
                rating: itemData.rating,
                releaseYear: itemData.releaseYear,
                addedAt: itemData.addedAt || Date.now(), // ä¿ç•™åŸå§‹æ·»åŠ æ—¶é—´
                isFavorite: true,
                genres: itemData.genres,
                description: itemData.description,
                lastUpdate: Date.now()
              };
              
              await this.databaseRepo.updateFavorite(updatedItem);
              imported++;
            } else {
              existing++;
            }
          } else {
            // æ£€æŸ¥æ˜¯å¦è¶…å‡ºé™åˆ?            if (imported >= availableSlots && !merge) {
              skipped++;
              continue;
            }

            // æ·»åŠ æ–°æ”¶è—?            const collectionItem: CollectionItem = {
              id: itemData.id,
              title: itemData.title || '',
              coverUrl: itemData.coverUrl || '',
              type: itemData.type || VideoType.MOVIE,
              rating: itemData.rating,
              releaseYear: itemData.releaseYear,
              addedAt: itemData.addedAt || Date.now(),
              isFavorite: true,
              genres: itemData.genres,
              description: itemData.description,
              lastUpdate: Date.now()
            };

            await this.databaseRepo.addToFavorites(collectionItem);
            imported++;
          }
        } catch (error) {
          Logger.warn(TAG, `Failed to import collection item ${itemData.id}`, error);
          skipped++;
        }
      }

      Logger.info(TAG, 'Collection import completed', { imported, skipped, existing });
      return ApiResponse.success({
        imported,
        skipped,
        existing
      }, `å¯¼å…¥å®Œæˆï¼ŒæˆåŠŸå¯¼å…?{imported}ä¸ªï¼Œè·³è¿‡${skipped}ä¸ªï¼Œå·²å­˜åœ?{existing}ä¸ª`);
    } catch (error) {
      Logger.error(TAG, 'Failed to import collection', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'å¯¼å…¥æ”¶è—å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®æ ¼å¼?);
    }
  }

  // ========== å†…éƒ¨è¾…åŠ©æ–¹æ³• ==========

  /**
   * å¢å¼ºæ”¶è—æ•°æ®
   */
  private async enhanceCollectionWithMovieInfo(items: CollectionItem[]): Promise<(CollectionItem & { movieInfo?: Partial<MovieDetailData> })[]> {
    try {
      // è¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦å¢å¼ºæ”¶è—æ•°æ®ï¼Œæ·»åŠ ç”µå½±è¯¦ç»†ä¿¡æ¯
      // ç›®å‰åªè¿”å›åŸå§‹æ”¶è—æ•°æ?      return items.map(item => ({ ...item }));
    } catch (error) {
      Logger.error(TAG, 'Failed to enhance collection with movie info', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return items;
    }
  }

  /**
   * æŒ‰æ ‡ç­¾è·å–æ”¶è—?   */
  public async getFavoritesByGenre(genre: string, page: number = 1, pageSize: number = 20): Promise<ApiResponse<CollectionItem[]>> {
    try {
      Logger.info(TAG, 'Getting favorites by genre...', { genre, page, pageSize });

      const results = await this.databaseRepo.getFavoritesByGenre(genre, page, pageSize);
      return ApiResponse.success(results, `æ‰¾åˆ°${results.length}ä¸ªåŒ¹é…çš„æ”¶è—é¡¹`);
    } catch (error) {
      Logger.error(TAG, 'Failed to get favorites by genre', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æŒ‰æ ‡ç­¾è·å–æ”¶è—å¤±è´?);
    }
  }

  /**
   * è·å–æ‰€æœ‰æ”¶è—æ ‡ç­?   */
  public async getAllGenres(): Promise<ApiResponse<Array<{ genre: string; count: number }>>> {
    try {
      Logger.info(TAG, 'Getting all genres...');

      const genres = await this.databaseRepo.getFavoriteGenres();
      return ApiResponse.success(genres, 'è·å–æ ‡ç­¾åˆ—è¡¨æˆåŠŸ');
    } catch (error) {
      Logger.error(TAG, 'Failed to get all genres', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'è·å–æ ‡ç­¾åˆ—è¡¨å¤±è´¥');
    }
  }

  /**
   * æŒ‰å¹´ä»½è·å–æ”¶è—?   */
  public async getFavoritesByYear(year: number, page: number = 1, pageSize: number = 20): Promise<ApiResponse<CollectionItem[]>> {
    try {
      Logger.info(TAG, 'Getting favorites by year...', { year, page, pageSize });

      const results = await this.databaseRepo.getFavoritesByYear(year, page, pageSize);
      return ApiResponse.success(results, `æ‰¾åˆ°${results.length}ä¸ªåŒ¹é…çš„æ”¶è—é¡¹`);
    } catch (error) {
      Logger.error(TAG, 'Failed to get favorites by year', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error)))))));
      return ApiResponse.error(ResponseCode.UNKNOWN_ERROR, 'æŒ‰å¹´ä»½è·å–æ”¶è—å¤±è´?);
    }
  }
}


