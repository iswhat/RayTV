// çˆ¬è™«æœåŠ¡
// ç®¡ç†å¤šç«™ç‚¹æ•°æ®è·å–ã€è§£æå’Œç»Ÿä¸€æ¥å£

import { SiteInfo } from '../../data/bean/Site';
import { ConfigService } from '../config/ConfigService';
import { HttpService } from '../HttpService';
import { StorageUtil } from '../../common/util/StorageUtil';
import { ConfigParser } from '../config/ConfigParser';
import Logger from '../../common/util/Logger';

/**
 * è§†é¢‘é¡¹æ¥å£å®šä¹? */
interface VideoItem {
  id: string;
  title: string;
  cover?: string;
  url?: string;
  rating?: number;
  type?: string;
  updateInfo?: string;
  hot?: number;
  updateTime?: string;
}

/**
 * è§†é¢‘è¯¦æƒ…æ¥å£å®šä¹‰
 */
interface VideoDetail {
  id: string;
  title: string;
  cover?: string;
  description?: string;
  category?: string;
  tags?: string[];
  rating?: number;
  year?: string;
  region?: string;
  director?: string;
  actors?: string[];
  updateTime?: string;
  playSources?: Array<{ name: string; url: string }>;
  episodes?: Array<{ id: string; name: string }>;
}

/**
 * çˆ¬è™«æœåŠ¡æ¥å£å®šä¹‰
 */
interface SiteSpider {
  // è·å–ç«™ç‚¹ä¿¡æ¯
  getSiteInfo(): Promise<SiteInfo>;
  
  // è·å–æ¨èåˆ—è¡¨
  getRecommendList(): Promise<VideoItem[]>;
  
  // è·å–çƒ­é—¨åˆ—è¡¨
  getHotList(): Promise<VideoItem[]>;
  
  // è·å–æœ€æ–°æ›´æ–?  getLatestList(): Promise<VideoItem[]>;
  
  // è·å–åˆ†ç±»åˆ—è¡¨
  getCategories(): Promise<string[]>;
  
  // è·å–åˆ†ç±»å†…å®¹
  getCategoryList(category: string, page: number): Promise<VideoItem[]>;
  
  // æœç´¢å†…å®¹
  search(keyword: string, page?: number): Promise<VideoItem[]>;
  
  // è·å–è¯¦æƒ…
  getDetail(id: string): Promise<VideoDetail>;
  
  // è·å–æ’­æ”¾é“¾æ¥
  getPlayUrl(id: string, episodeId?: string): Promise<string>;
  
  // è·å–æœç´¢å»ºè®®ï¼ˆå¯é€‰ï¼‰
  getSearchSuggestions?(keyword: string): Promise<string[]>;
}

/**
 * çˆ¬è™«æœåŠ¡å®ç°ç±? * ç®¡ç†æ‰€æœ‰ç«™ç‚¹çˆ¬è™«ï¼Œæä¾›ç»Ÿä¸€çš„æ•°æ®è·å–æ¥å? */
export class CrawlerService {
  private static instance: CrawlerService;
  private siteSpiders: Map<string, SiteSpider> = new Map();
  private siteConfigs: Map<string, SiteInfo> = new Map();
  private initialized: boolean = false;
  private readonly TAG: string = 'CrawlerService';
  
  private configService: ConfigService;
  private httpService: HttpService;
  private storageUtil: StorageUtil;
  private configParser: ConfigParser;
  
  private constructor() {
    this.configService = ConfigService.getInstance();
    this.httpService = HttpService.getInstance();
    this.storageUtil = StorageUtil.getInstance();
    this.configParser = new ConfigParser();
  }
  
  public static getInstance(): CrawlerService {
    if (!CrawlerService.instance) {
      CrawlerService.instance = new CrawlerService();
    }
    return CrawlerService.instance;
  }
  
  /**
   * åˆå§‹åŒ–çˆ¬è™«æœåŠ?   */
  public async initialize(): Promise<void> {
    if (this.initialized) return;
    
    try {
      // åŠ è½½ä¿å­˜çš„ç«™ç‚¹é…ç½?      await this.loadSiteConfigs();
      // åˆå§‹åŒ–é»˜è®¤ç«™ç‚?      await this.initDefaultSites();
      this.initialized = true;
    } catch (error) {
      console.error('Failed to initialize crawler service:', error);
      // åˆå§‹åŒ–å¤±è´¥æ—¶ä»è®¾ç½®ä¸ºå·²åˆå§‹åŒ–ï¼Œä»¥å…è®¸åº”ç”¨ç»§ç»­è¿è¡Œ
      this.initialized = true;
    }
  }
  
  /**
   * åŠ è½½ç«™ç‚¹é…ç½®
   */
  private async loadSiteConfigs(): Promise<void> {
    try {
      const configs = await this.storageUtil.getSitesConfig();
      if (configs && Array.isArray(configs)) {
        for (const config of configs) {
          this.siteConfigs.set(config.key, config);
        }
      }
    } catch (error) {
      console.error('Failed to load site configs:', error);
    }
  }
  
  /**
   * åˆå§‹åŒ–é»˜è®¤ç«™ç‚?   */
  private async initDefaultSites(): Promise<void> {
    try {
      // å¦‚æœæ²¡æœ‰ç«™ç‚¹é…ç½®ï¼Œæ·»åŠ é»˜è®¤çš„æ¨¡æ‹Ÿç«™ç‚¹
      if (this.siteConfigs.size === 0) {
        const defaultSites = this.getDefaultSites();
        for (const site of defaultSites) {
          this.siteConfigs.set(site.key, site);
          // ä¸ºæ¯ä¸ªé»˜è®¤ç«™ç‚¹åˆ›å»ºå¯¹åº”çš„çˆ¬è™«å®ä¾‹
          const spider = this.createMockSpider(site);
          this.siteSpiders.set(site.key, spider);
        }
        
        // ä¿å­˜é»˜è®¤ç«™ç‚¹é…ç½®
        await this.storageUtil.saveSitesConfig(defaultSites);
      } else {
        // ä¸ºå·²æœ‰çš„ç«™ç‚¹é…ç½®åˆ›å»ºçˆ¬è™«å®ä¾‹
        for (const [key, config] of this.siteConfigs.entries()) {
          if (!this.siteSpiders.has(key)) {
            const spider = this.createSpider(key, config);
            if (spider) {
              this.siteSpiders.set(key, spider);
            }
          }
        }
      }
    } catch (error) {
      console.error('Failed to init default sites:', error);
    }
  }
  
  /**
   * åˆ›å»ºçˆ¬è™«å®ä¾‹
   */
  private createSpider(key: string, config: Record<string, unknown>): SiteSpider | null {
    try {
      // æ ¹æ®ç«™ç‚¹ç±»å‹å’Œé…ç½®åˆ›å»ºå¯¹åº”çš„çˆ¬è™«å®ä¾‹
      // å®é™…å®ç°åº”è¯¥æ ¹æ®é…ç½®åŠ¨æ€åˆ›å»ºä¸åŒç±»å‹çš„çˆ¬è™«
      Logger.info(this.TAG, `Creating spider for site: ${key}`);
      
      // è¿™é‡Œåº”è¯¥æ˜¯æ ¹æ®ç«™ç‚¹é…ç½®åˆ›å»ºå®é™…çˆ¬è™«çš„é€»è¾‘
      // ç”±äºæ²¡æœ‰å…·ä½“çš„çˆ¬è™«å®ç°ï¼Œæš‚æ—¶è¿”å›ä¸€ä¸ªç©ºå®ç°ï¼Œä¼šåœ¨åç»­å®Œå–?      return {
        getSiteInfo: async () => config as SiteInfo,
        getRecommendList: async () => [],
        getHotList: async () => [],
        getLatestList: async () => [],
        getCategories: async () => [],
        getCategoryList: async () => [],
        search: async () => [],
        getDetail: async () => ({} as VideoDetail),
        getPlayUrl: async () => ''
      };
    } catch (error) {
      Logger.error(this.TAG, `Failed to create spider for site ${key}:`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      return null;
    }
  }
  
  /**
   * è·å–é»˜è®¤ç«™ç‚¹é…ç½®
   */
  private getDefaultSites(): SiteInfo[] {
    // è¿”å›å®é™…å¯ç”¨çš„ç«™ç‚¹é…ç½®ï¼Œè€Œä¸æ˜¯æ¨¡æ‹Ÿç«™ç‚?    // å®é™…é¡¹ç›®ä¸­åº”è¯¥ä»é…ç½®æ–‡ä»¶æˆ–ç½‘ç»œè·å?    return [
      {
        key: 'official_video_site',
        name: 'å®˜æ–¹è§†é¢‘ç«?,
        type: 'vod',
        url: 'https://api.raytv.com/v1',
        enabled: true,
        updateTime: new Date().toISOString(),
        version: '1.0.0',
        userAgent: '',
        requestHeaders: {},
        searchRule: {},
        detailRule: {},
        playRule: {}
      }
    ];
  }
  
  /**
   * è·å–æ‰€æœ‰ç«™ç‚?   */
  public async getAllSites(): Promise<SiteInfo[]> {
    await this.initialize();
    const sites: SiteInfo[] = [];
    
    for (const [key, config] of this.siteConfigs.entries()) {
      sites.push(config);
    }
    
    return sites.sort((a, b) => {
      // æŒ‰å¯ç”¨çŠ¶æ€å’Œåç§°æ’åº
      if (a.enabled !== b.enabled) {
        return a.enabled ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });
  }
  
  /**
   * è·å–å·²å¯ç”¨çš„ç«™ç‚¹
   */
  public async getActiveSites(): Promise<SiteInfo[]> {
    await this.initialize();
    const sites: SiteInfo[] = [];
    
    for (const [key, config] of this.siteConfigs.entries()) {
      if (config.enabled) {
        sites.push(config);
      }
    }
    
    return sites.sort((a, b) => a.name.localeCompare(b.name));
  }
  
  /**
   * è®¾ç½®ç«™ç‚¹çŠ¶æ€?   */
  public async setSiteStatus(siteKey: string, enabled: boolean): Promise<void> {
    await this.initialize();
    
    const config = this.siteConfigs.get(siteKey);
    if (config) {
      config.enabled = enabled;
      this.siteConfigs.set(siteKey, config);
      
      // ä¿å­˜æ›´æ–°åçš„é…ç½®
      const allSites = await this.getAllSites();
      await this.storageUtil.saveSitesConfig(allSites);
    }
  }
  
  /**
   * å¯¼å…¥ç«™ç‚¹é…ç½®
   */
  public async importSiteConfig(configStr: string): Promise<SiteInfo | null> {
    await this.initialize();
    
    try {
      // ä½¿ç”¨ConfigParserè§£æç«™ç‚¹é…ç½®
      const siteConfig = this.configParser.parseSiteConfig(configStr);
      
      if (siteConfig && siteConfig.key) {
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåç«™ç‚¹
        if (this.siteConfigs.has(siteConfig.key)) {
          // æ›´æ–°ç°æœ‰ç«™ç‚¹
          const existingConfig = this.siteConfigs.get(siteConfig.key);
          siteConfig.enabled = existingConfig.enabled;
        }
        
        // ä¿å­˜ç«™ç‚¹é…ç½®
        this.siteConfigs.set(siteConfig.key, siteConfig);
        
        // åˆ›å»ºçˆ¬è™«å®ä¾‹
        const spider = this.createSpider(siteConfig.key, siteConfig);
        if (spider) {
          this.siteSpiders.set(siteConfig.key, spider);
        }
        
        // ä¿å­˜åˆ°å­˜å‚?        const allSites = await this.getAllSites();
        await this.storageUtil.saveSitesConfig(allSites);
        
        return siteConfig;
      }
      
      return null;
    } catch (error) {
      console.error('Failed to import site config:', error);
      throw new Error('å¯¼å…¥ç«™ç‚¹é…ç½®å¤±è´¥');
    }
  }
  
  /**
   * åˆ é™¤ç«™ç‚¹
   */
  public async removeSite(siteKey: string): Promise<void> {
    await this.initialize();
    
    if (this.siteConfigs.has(siteKey)) {
      this.siteConfigs.delete(siteKey);
      this.siteSpiders.delete(siteKey);
      
      // æ›´æ–°å­˜å‚¨
      const allSites = await this.getAllSites();
      await this.storageUtil.saveSitesConfig(allSites);
    }
  }
  
  /**
   * è°ƒç”¨ç«™ç‚¹æ–¹æ³•
   */
  public async callSiteMethod<T>(siteKey: string, methodName: string, args: Record<string, string | number | boolean | null>[]): Promise<T> {
    await this.initialize();
    
    const spider = this.siteSpiders.get(siteKey);
    if (!spider) {
      Logger.error(this.TAG, `No spider found for site: ${siteKey}`);
      // è¿”å›ç©ºæ•°æ®è€Œä¸æ˜¯ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ?      return this.getDefaultEmptyData<T>(methodName);
    }
    
    return this.callSpiderMethod<T>(spider, methodName, args instanceof Error ? methodName, args : new Error(String(methodName, args instanceof Error ? methodName, args instanceof Error ? methodName, args : new Error(String(methodName, args : new Error(String(methodName, args instanceof Error ? methodName, args : new Error(String(methodName, args instanceof Error ? methodName, args instanceof Error ? methodName, args : new Error(String(methodName, args instanceof Error ? methodName, args instanceof Error ? methodName, args : new Error(String(methodName, args : new Error(String(methodName, args instanceof Error ? methodName, args : new Error(String(methodName, args : new Error(String(methodName, args instanceof Error ? methodName, args : new Error(String(methodName, args instanceof Error ? methodName, args instanceof Error ? methodName, args : new Error(String(methodName, args : new Error(String(methodName, args instanceof Error ? methodName, args : new Error(String(methodName, args)))))));
  }
  
  /**
   * è°ƒç”¨çˆ¬è™«å®ä¾‹æ–¹æ³•
   */
  private async callSpiderMethod<T>(spider: SiteSpider, methodName: string, args: Record<string, string | number | boolean | null>[]): Promise<T> {
    try {
      const method = (spider as Record<string, unknown>)[methodName];
      if (typeof method === 'function') {
        // ArkTSå…¼å®¹ï¼šä½¿ç”¨ç›´æ¥è°ƒç”¨æ›¿ä»£apply
        return await (spider as Record<string, Function>)[methodName](...args) as T;
      } else {
        throw new Error(`Method ${methodName} not found in spider`);
      }
    } catch (error) {
      Logger.error(this.TAG, `Failed to call ${methodName} on spider:`, error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
      // è¿”å›ç©ºæ•°æ®è€Œä¸æ˜¯æ¨¡æ‹Ÿæ•°æ?      return this.getDefaultEmptyData<T>(methodName);
    }
  }
  
  /**
   * æ ¹æ®æ–¹æ³•åè¿”å›é»˜è®¤ç©ºæ•°æ®
   */
  private getDefaultEmptyData<T>(methodName: string): T {
    Logger.warn(this.TAG, `Returning default empty data for method: ${methodName}`);
    
    // æ ¹æ®ä¸åŒæ–¹æ³•è¿”å›ç›¸åº”çš„ç©ºæ•°æ®ç±»å‹
    switch (methodName) {
      case 'getRecommendList':
      case 'getHotList':
      case 'getLatestList':
      case 'getCategoryList':
      case 'search':
      case 'getSearchSuggestions':
        return [] as unknown as T;
      case 'getCategories':
        return [] as unknown as T;
      case 'getDetail':
        return {} as unknown as T;
      case 'getPlayUrl':
        return '' as unknown as T;
      case 'getSiteInfo':
        return {} as unknown as T;
      default:
        return {} as unknown as T;
    }
  }
}

// ç§»é™¤äº†æ¨¡æ‹Ÿæ•°æ®ç”Ÿæˆå™¨å’Œç›¸å…³ç±»å®šä¹‰

// å¯¼å‡ºä¸€äº›é¢å¤–çš„ç±»å‹å’Œå·¥å…·å‡½æ•?export interface CrawlerOptions {
  timeout?: number;
  retryCount?: number;
  userAgent?: string;
}

export class CrawlerError extends Error {
  constructor(message: string, public code?: string) {
    super(message);
    this.name = 'CrawlerError';
  }
}


