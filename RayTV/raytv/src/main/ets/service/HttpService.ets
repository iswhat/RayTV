// HTTPæœåŠ¡ç±?// æä¾›ç½‘ç»œè¯·æ±‚çš„ç»Ÿä¸€æ¥å£ï¼Œæ”¯æŒGETã€POSTç­‰æ–¹æ³•ï¼Œå¤„ç†è¯·æ±‚å¤´ã€å“åº”æ‹¦æˆªç­‰

import http from '@ohos.net.http';
import { ConfigService } from './config/ConfigService';
import { AdBlockManager } from './adblock/AdBlockManager';
import abilityAccessCtrl from '@ohos.abilityAccessCtrl';
import common from '@ohos.app.ability.common';
import { HttpResponse, HttpOptions } from '../types/common';

// HTTPè¯·æ±‚é€‰é¡¹æ¥å£
export interface HttpRequestOptions extends HttpOptions {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  data?: Record<string, string | number | boolean | null> | string;
}

export class HttpService {
  private static instance: HttpService;
  private httpConfig: { timeout: number; retryCount: number; userAgent: string };
  private adBlockManager: AdBlockManager;
  private context: common.Context | null = null;

  private constructor() {
    // åˆå§‹åŒ–é»˜è®¤é…ç½?    const defaultTimeout = 30;
    const defaultRetryCount = 3;
    const networkConfig = ConfigService.getInstance().getConfig('network');
    
    // æ‰‹åŠ¨åˆå§‹åŒ–é…ç½®ï¼Œé¿å…ä½¿ç”¨å¯¹è±¡å­—é¢é‡?    this.httpConfig = {
      timeout: networkConfig?.timeout !== undefined ? networkConfig.timeout as number : defaultTimeout,
      retryCount: networkConfig?.retryCount !== undefined ? networkConfig.retryCount as number : defaultRetryCount,
      userAgent: networkConfig?.userAgent as string || ''
    };
    
    this.adBlockManager = AdBlockManager.getInstance();
  }

  /**
   * è®¾ç½®åº”ç”¨ä¸Šä¸‹æ–?   * @param ctx åº”ç”¨ä¸Šä¸‹æ–?   */
  public setContext(ctx: common.Context): void {
    this.context = ctx;
  }

  /**
   * è·å–åº”ç”¨ä¸Šä¸‹æ–?   * @returns åº”ç”¨ä¸Šä¸‹æ–?   */
  private getContext(): common.Context {
    if (!this.context) {
      throw new Error('HttpService context not set. Please call setContext() first.');
    }
    return this.context;
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): HttpService {
    if (!HttpService.instance) {
      HttpService.instance = new HttpService();
    }
    return HttpService.instance;
  }

  /**
   * åˆå§‹åŒ–HTTPæœåŠ¡ï¼ˆç©ºå®ç°ï¼Œç”¨äºå…¼å®¹AppServiceçš„åˆå§‹åŒ–æµç¨‹ï¼?   */
  public async initialize(): Promise<void> {
    // HTTPæœåŠ¡åœ¨æ„é€ å‡½æ•°ä¸­å·²ç»åˆå§‹åŒ–å®Œæˆ?    // è¿™é‡Œæä¾›ä¸€ä¸ªç©ºå®ç°ä»¥å…¼å®¹AppServiceçš„åˆå§‹åŒ–æµç¨‹
  }
  
  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰é”®
   * æ›¿ä»£Object.keysï¼Œå…¼å®¹ArkTSè¯­æ³•
   */
  private getObjectKeys<T extends object>(obj: T): string[] {
    // ç›´æ¥ä½¿ç”¨Object.keysè·å–é”®ï¼Œé¿å…for-inå¾ªç¯
    return Object.keys(obj);
  }

  /**
   * å‘é€GETè¯·æ±‚
   * @param url è¯·æ±‚URL
   * @param options è¯·æ±‚é€‰é¡¹
   */
  public async get<T>(url: string, options?: HttpOptions): Promise<HttpResponse<T>> {
    const requestOptions: HttpRequestOptions = {
      method: 'GET'
    };
    
    // æ‰‹åŠ¨åˆå¹¶é€‰é¡¹
    if (options) {
      if (options.headers) requestOptions.headers = options.headers;
      if (options.timeout !== undefined) requestOptions.timeout = options.timeout;
      if (options.retryCount !== undefined) requestOptions.retryCount = options.retryCount;
      if (options.responseType) requestOptions.responseType = options.responseType;
    }
    
    return this.request<T>(url, requestOptions);
  }

  /**
   * å‘é€POSTè¯·æ±‚
   * @param url è¯·æ±‚URL
   * @param data è¯·æ±‚æ•°æ®
   * @param options è¯·æ±‚é€‰é¡¹
   */
  public async post<T>(url: string, data?: Record<string, string | number | boolean | null> | string, options?: HttpOptions): Promise<HttpResponse<T>> {
    const requestOptions: HttpRequestOptions = {
      method: 'POST',
      data: data
    };
    
    // æ‰‹åŠ¨åˆå¹¶é€‰é¡¹
    if (options) {
      if (options.headers) requestOptions.headers = options.headers;
      if (options.timeout !== undefined) requestOptions.timeout = options.timeout;
      if (options.retryCount !== undefined) requestOptions.retryCount = options.retryCount;
      if (options.responseType) requestOptions.responseType = options.responseType;
    }
    
    return this.request<T>(url, requestOptions);
  }

  /**
   * æ£€æŸ¥å¹¶è¯·æ±‚ç½‘ç»œæƒé™
   * åªåœ¨éœ€è¦æ—¶è¯·æ±‚æƒé™ï¼Œé¿å…é‡å¤ç”³è¯?   */
  private async checkAndRequestNetworkPermission(): Promise<void> {
    try {
      const atManager = abilityAccessCtrl.createAtManager();
      const context = this.getContext();
      
      // å…ˆæ£€æŸ¥æƒé™çŠ¶æ€ï¼Œé¿å…é‡å¤ç”³è¯·
      const permissionResult = await atManager.checkPermission(context, 'ohos.permission.INTERNET');
      
      // åªæœ‰å½“æƒé™æœªæˆæƒæ—¶æ‰è¯·æ±‚
      if (permissionResult !== abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
        await atManager.requestPermissionsFromUser(context, ['ohos.permission.INTERNET']);
      }
    } catch (error) {
      console.error('Failed to check or request INTERNET permission', error);
      // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå…è®¸åº”ç”¨ç»§ç»­å°è¯•ç½‘ç»œæ“ä½œ
    }
  }

  /**
   * å‘é€ç½‘ç»œè¯·æ±?   * @param url è¯·æ±‚URL
   * @param options è¯·æ±‚é€‰é¡¹
   */
  public async request<T>(url: string, options: HttpRequestOptions): Promise<HttpResponse<T>> {
    try {
      // æ£€æŸ¥ç½‘ç»œæƒé™ï¼ˆåªåœ¨éœ€è¦æ—¶è¯·æ±‚ï¼?      await this.checkAndRequestNetworkPermission();

      // æ£€æŸ¥URLæ˜¯å¦åœ¨å¹¿å‘Šå±è”½åˆ—è¡¨ä¸­
      if (this.adBlockManager.isEnabled() && this.adBlockManager.shouldBlockUrl(url)) {
        throw new Error(`URL blocked by ad blocker: ${url}`);
      }

      const method = options.method || 'GET';
      const headers = options.headers || {};
      const requestData = options.data || null;
      const timeout = options.timeout !== undefined ? options.timeout : (this.httpConfig.timeout as number) * 1000;

      // åˆ›å»ºHTTPè¯·æ±‚å¯¹è±¡
      const httpRequest = http.createHttp();
      
      // æ„å»ºè¯·æ±‚é…ç½®
      const requestConfig: http.HttpRequestOptions = {
        method,
        connectTimeout: timeout,
        readTimeout: timeout,
        header: {
          'User-Agent': (this.httpConfig.userAgent as string) || 'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36',
          'Content-Type': 'application/json'
        }
      };
      
      // æ‰‹åŠ¨åˆå¹¶headers
      if (headers) {
        // ç¡®ä¿headerå¯¹è±¡å­˜åœ¨
        if (!requestConfig.header) {
          requestConfig.header = {};
        }
        const headerKeys = this.getObjectKeys(headers);
        for (let i = 0; i < headerKeys.length; i++) {
          const key = headerKeys[i];
          requestConfig.header![key] = headers[key];
        }
      }

      // æ·»åŠ è¯·æ±‚æ•°æ®
      if (requestData !== null && requestData !== undefined) {
        const contentType = requestConfig.header?.['Content-Type'] || 'application/json';
        if (contentType.includes('json')) {
          requestConfig.extraData = JSON.stringify(requestData);
        } else {
          requestConfig.extraData = requestData;
        }
      }

      // å‘é€è¯·æ±?      let response: http.HttpResponse | null = null;
      let retryCount = 0;
      let lastError: Error | null = null;
      const maxRetryCount = options.retryCount !== undefined ? options.retryCount : (this.httpConfig.retryCount as number);

      while (retryCount <= maxRetryCount) {
        try {
          response = await httpRequest.request(url, requestConfig);
          break;
        } catch (error) {
          lastError = error instanceof Error ? error : new Error(String(error));
          retryCount++;
          
          if (retryCount > maxRetryCount) {
            throw lastError;
          }
          
          // é‡è¯•å‰ç­‰å¾?          await this.sleep(1000 * retryCount);
        }
      }

      // ç¡®ä¿responseæœ‰å€?      if (!response) {
        throw new Error('Failed to get HTTP response');
      }

      // å¤„ç†å“åº”
      const result: HttpResponse<T> = {
        status: response.responseCode,
        data: this.parseResponseData<T>(response.result as string),
        headers: this.sanitizeHeaders(response.header),
        url: response.requestURL || ''
      };

      // å…³é—­è¯·æ±‚å¯¹è±¡
      httpRequest.destroy();

      // æ£€æŸ¥çŠ¶æ€ç 
      if (result.status < 200 || result.status >= 300) {
        const error = new Error(`HTTP Error: ${result.status} - ${url}`);
        throw error;
      }

      return result;
    } catch (error) {
      console.error(`HTTP request failed: ${url}`, error);
      throw error instanceof Error ? error : new Error(String(error));
    }
  }

  /**
   * ä¸‹è½½æ–‡ä»¶
   * @param url æ–‡ä»¶URL
   * @param filePath ä¿å­˜è·¯å¾„
   * @param options ä¸‹è½½é€‰é¡¹
   */
  public async downloadFile(url: string, filePath: string, options?: DownloadOptions): Promise<DownloadResult> {
    try {
      // æ£€æŸ¥ç½‘ç»œæƒé™?      try {
        const atManager = abilityAccessCtrl.createAtManager();
        await atManager.requestPermissionsFromUser(this.getContext(), ['ohos.permission.INTERNET']);
      } catch (permissionError) {
        console.error('Failed to request INTERNET permission', permissionError);
        throw new Error('Network permission denied');
      }

      // æ£€æŸ¥URLæ˜¯å¦åœ¨å¹¿å‘Šå±è”½åˆ—è¡¨ä¸­
      if (this.adBlockManager.isEnabled() && this.adBlockManager.shouldBlockUrl(url)) {
        throw new Error(`URL blocked by ad blocker: ${url}`);
      }

      const headers = options?.headers || {};
      const timeout = options?.timeout !== undefined ? options.timeout : (this.httpConfig.timeout as number) * 1000;
      
      // åˆ›å»ºHTTPè¯·æ±‚å¯¹è±¡
      const httpRequest = http.createHttp();
      
      // æ„å»ºè¯·æ±‚é…ç½®
      const requestConfig: http.HttpRequestOptions = {
        method: 'GET',
        connectTimeout: timeout,
        readTimeout: timeout,
        header: {
          'User-Agent': (this.httpConfig.userAgent as string) || 'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Mobile Safari/537.36'
        }
      };
      
      // æ‰‹åŠ¨åˆå¹¶headers
      if (headers) {
        // ç¡®ä¿requestConfig.headerå­˜åœ¨
        if (!requestConfig.header) {
          requestConfig.header = {};
        }
        const headerKeys = this.getObjectKeys(headers);
        for (let i = 0; i < headerKeys.length; i++) {
          const key = headerKeys[i];
          requestConfig.header[key] = headers[key];
        }
      }

      // ä¸ºä¸‹è½½é…ç½®åˆ›å»ºæ˜ç¡®çš„ç±»å‹
      interface DownloadConfig {
        filePath: string;
        method: string;
        connectTimeout: number;
        readTimeout: number;
        header: Record<string, string>;
        extraData?: string | Record<string, string | number | boolean>;
        expectDataType?: http.HttpDataType;
      }
      
      // å‘é€è¯·æ±?      // ç¡®ä¿æ‰€æœ‰å±æ€§éƒ½æœ‰æ­£ç¡®çš„ç±»å‹
      const method: string = typeof requestConfig.method === 'string' ? requestConfig.method : 'GET';
      const connectTimeout: number = typeof requestConfig.connectTimeout === 'number' ? requestConfig.connectTimeout : 30000;
      const readTimeout: number = typeof requestConfig.readTimeout === 'number' ? requestConfig.readTimeout : 30000;
      const header: Record<string, string> = requestConfig.header || {};
      
      const downloadConfig: DownloadConfig = {
        filePath: filePath,
        method: method,
        connectTimeout: connectTimeout,
        readTimeout: readTimeout,
        header: header,
        extraData: requestConfig.extraData,
        expectDataType: requestConfig.expectDataType
      };
      
      const response = await httpRequest.downloadFile(url, downloadConfig);

      // å…³é—­è¯·æ±‚å¯¹è±¡
      httpRequest.destroy();

      const result: DownloadResult = {
        status: response.responseCode,
        filePath,
        headers: this.sanitizeHeaders(response.header),
        fileSize: response.fileSize
      };

      return result;
    } catch (error) {
      console.error(`File download failed: ${url}`, error);
      throw error instanceof Error ? error : new Error(String(error));
    }
  }

  /**
   * è§£æå“åº”æ•°æ®
   * @param data åŸå§‹å“åº”æ•°æ®
   */
  private parseResponseData<T>(data: string): T {
    try {
      return JSON.parse(data) as T;
    } catch {
      // å¦‚æœä¸æ˜¯JSONæ ¼å¼ï¼Œç›´æ¥è¿”å›?      return data as T;
    }
  }

  /**
   * å®‰å…¨åœ°å°†headerè½¬æ¢ä¸ºRecord<string, string>
   */
  private sanitizeHeaders(headers: Record<string, string | number | boolean> | null | undefined): Record<string, string> {
    const result: Record<string, string> = {};
    
    if (!headers || typeof headers !== 'object') {
      return result;
    }
    
    const headersObj = headers as Record<string, string | number | boolean>;
    for (const [key, value] of Object.entries(headersObj)) {
      if (value !== null && value !== undefined) {
        result[key] = String(value);
      }
    }
    
    return result;
  }

  /**
   * å»¶è¿Ÿå‡½æ•°
   * @param ms å»¶è¿Ÿæ¯«ç§’æ•?   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

/**
 * HTTPè¯·æ±‚é€‰é¡¹
 */
export interface HttpOptions {
  headers?: Record<string, string>;
  timeout?: number;
  retryCount?: number;
  responseType?: 'json' | 'text' | 'arraybuffer';
}

/**
 * HTTPå“åº”
 */
export interface HttpResponse<T> {
  status: number;
  data: T;
  headers: Record<string, string>;
  url: string;
}

/**
 * ä¸‹è½½é€‰é¡¹
 */
export interface DownloadOptions extends HttpOptions {
  onProgress?: (receivedSize: number, totalSize: number) => void;
}

/**
 * ä¸‹è½½ç»“æœ
 */
export interface DownloadResult {
  status: number;
  filePath: string;
  headers: Record<string, string>;
  fileSize?: number;
}
