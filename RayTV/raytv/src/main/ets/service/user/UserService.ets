// UserService.ets - ç”¨æˆ·æœåŠ¡
// ç”¨æˆ·æœåŠ¡ç±?// è´Ÿè´£å¤„ç†ç”¨æˆ·è®¤è¯ã€ç”¨æˆ·ä¿¡æ¯ç®¡ç†å’Œç”¨æˆ·æ•°æ®åŒæ­¥
import Logger from '../../common/util/Logger';
import StorageUtil from '../../common/util/StorageUtil';
import DateUtil from '../../common/util/DateUtil';
import NetworkUtil from '../../common/util/NetworkUtil';
import ConfigService from '../config/ConfigService';
import DatabaseManager from '../../data/db/DatabaseManager';
import RepositoryFactory from '../../data/repository/RepositoryFactory';
import NetworkRepository from '../../data/repository/NetworkRepository';
import DatabaseRepository from '../../data/repository/DatabaseRepository';
import { BusinessError } from '@ohos.base';
import http from '@ohos.net.http';

// å¸¸é‡å®šä¹‰
const TAG = 'UserService';
const USER_DATA_KEY = 'user_data';
const AUTH_TOKEN_KEY = 'auth_token';
const USER_PREFERENCES_KEY = 'user_preferences';
const AUTO_LOGIN_KEY = 'auto_login_enabled';
const SESSION_EXPIRY_TIME = 7 * 24 * 60 * 60 * 1000; // 7å¤?
// è®¤è¯ç›¸å…³çš„APIç«¯ç‚¹
const API_ENDPOINTS: Record<string, string | number | boolean | null> = { ... };

// ç”¨æˆ·è§’è‰²æšä¸¾
export enum UserRole {
  GUEST = 0,              // è®¿å®¢
  REGISTERED = 1,         // æ³¨å†Œç”¨æˆ·
  PREMIUM = 2,            // é«˜çº§ç”¨æˆ·
  ADMIN = 3               // ç®¡ç†å‘?}

// ç™»å½•ç±»å‹æšä¸¾
export enum LoginType {
  LOCAL = 0,              // æœ¬åœ°ç™»å½•
  WECHAT = 1,             // å¾®ä¿¡ç™»å½•
  QQ = 2,                 // QQç™»å½•
  PHONE = 3,              // æ‰‹æœºå·ç™»å½?  EMAIL = 4               // é‚®ç®±ç™»å½•
}

// è®¤è¯çŠ¶æ€æšä¸?export enum AuthStatus {
  UNAUTHENTICATED = 0,    // æœªè®¤è¯?  AUTHENTICATING = 1,     // è®¤è¯ä¸?  AUTHENTICATED = 2,      // å·²è®¤è¯?  EXPIRED = 3,            // è®¤è¯è¿‡æœŸ
  ERROR = 4               // è®¤è¯é”™è¯¯
}

// æ€§åˆ«æšä¸¾
export enum Gender {
  MALE = 0,
  FEMALE = 1,
  OTHER = 2
}

// ç”¨æˆ·çŠ¶æ€æšä¸?export enum UserStatus {
  ACTIVE = 0,             // æ´»è·ƒ
  INACTIVE = 1,           // éæ´»è·?  SUSPENDED = 2,          // æš‚åœ
  BANNED = 3              // å°ç¦
}

// ç”¨æˆ·æ¥å£
export interface User {
  id: string;             // ç”¨æˆ·ID
  username: string;       // ç”¨æˆ·å?  email?: string;         // é‚®ç®±ï¼ˆå¯é€‰ï¼‰
  phone?: string;         // æ‰‹æœºå·ï¼ˆå¯é€‰ï¼‰
  nickname: string;       // æ˜µç§°
  avatar?: string;        // å¤´åƒURL
  gender?: Gender;        // æ€§åˆ«
  birthday?: string;      // ç”Ÿæ—¥
  location?: string;      // æ‰€åœ¨åœ°
  bio?: string;           // ä¸ªäººç®€ä»?  role: UserRole;         // ç”¨æˆ·è§’è‰²
  status: UserStatus;     // ç”¨æˆ·çŠ¶æ€?  createdAt: number;      // åˆ›å»ºæ—¶é—´
  updatedAt: number;      // æ›´æ–°æ—¶é—´
  lastLoginAt?: number;   // æœ€åç™»å½•æ—¶é—?  loginCount: number;     // ç™»å½•æ¬¡æ•°
  preferences?: UserPreferences; // ç”¨æˆ·åå¥½è®¾ç½®
  statistics?: UserStatistics;   // ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
}

// è®¤è¯ä»¤ç‰Œæ¥å£
export interface AuthToken {
  accessToken: string;    // è®¿é—®ä»¤ç‰Œ
  refreshToken: string;   // åˆ·æ–°ä»¤ç‰Œ
  tokenType: string;      // ä»¤ç‰Œç±»å‹
  expiresIn: number;      // è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼?  issuedAt: number;       // é¢å‘æ—¶é—´
  scope?: string;         // æƒé™èŒƒå›´
  userId: string;         // ç”¨æˆ·ID
}

// ç”¨æˆ·åå¥½è®¾ç½®æ¥å£
export interface UserPreferences {
  theme: string;          // ä¸»é¢˜è®¾ç½®
  language: string;       // è¯­è¨€è®¾ç½®
  playQuality: string;    // æ’­æ”¾è´¨é‡åå¥½
  subtitleEnabled: boolean; // æ˜¯å¦å¯ç”¨å­—å¹•
  subtitleLanguage: string; // å­—å¹•è¯­è¨€
  autoPlay: boolean;      // æ˜¯å¦è‡ªåŠ¨æ’­æ”¾
  bandwidthSaver: boolean; // æ˜¯å¦å¯ç”¨æµé‡èŠ‚çœ
  parentalControlEnabled: boolean; // æ˜¯å¦å¯ç”¨å®¶é•¿æ§åˆ¶
  parentalControlPin?: string; // å®¶é•¿æ§åˆ¶PINç ?  notificationEnabled: boolean; // æ˜¯å¦å¯ç”¨é€šçŸ¥
  downloadQuality: string; // ä¸‹è½½è´¨é‡åå¥½
  downloadWifiOnly: boolean; // æ˜¯å¦ä»…WiFiä¸‹è½½
}

// ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯æ¥å£
export interface UserStatistics {
  totalWatchTime: number; // æ€»è§‚çœ‹æ—¶é•¿ï¼ˆç§’ï¼‰
  watchedMovies: number;  // å·²è§‚çœ‹ç”µå½±æ•°
  favoriteMovies: number; // æ”¶è—ç”µå½±æ•?  downloadCount: number;  // ä¸‹è½½æ¬¡æ•°
  totalDownloadSize: number; // æ€»ä¸‹è½½å¤§å°ï¼ˆå­—èŠ‚ï¼?  lastWatchDate?: number; // æœ€åè§‚çœ‹æ—¶é—?  mostWatchedGenre?: string; // æœ€å¸¸è§‚çœ‹çš„ç±»å‹
  currentStreak: number;  // å½“å‰è¿ç»­è§‚çœ‹å¤©æ•°
  longestStreak: number;  // æœ€é•¿è¿ç»­è§‚çœ‹å¤©æ•?}

// ç™»å½•è¯·æ±‚æ¥å£
export interface LoginRequest {
  username: string;       // ç”¨æˆ·å?æ‰‹æœºå?é‚®ç®±
  password?: string;      // å¯†ç ï¼ˆå¦‚æœæ˜¯è´¦å·å¯†ç ç™»å½•ï¼?  code?: string;          // éªŒè¯ç ï¼ˆå¦‚æœæ˜¯éªŒè¯ç ç™»å½•ï¼?  type: LoginType;        // ç™»å½•ç±»å‹
  deviceId?: string;      // è®¾å¤‡ID
  deviceInfo?: DeviceInfo; // è®¾å¤‡ä¿¡æ¯
}

// æ³¨å†Œè¯·æ±‚æ¥å£
export interface RegisterRequest {
  username: string;       // ç”¨æˆ·å?  email?: string;         // é‚®ç®±ï¼ˆå¯é€‰ï¼‰
  phone?: string;         // æ‰‹æœºå·ï¼ˆå¯é€‰ï¼‰
  password: string;       // å¯†ç 
  confirmPassword: string; // ç¡®è®¤å¯†ç 
  nickname?: string;      // æ˜µç§°ï¼ˆå¯é€‰ï¼‰
  agreeToTerms: boolean;  // æ˜¯å¦åŒæ„æ¡æ¬¾
  inviteCode?: string;    // é‚€è¯·ç ï¼ˆå¯é€‰ï¼‰
}

// è®¾å¤‡ä¿¡æ¯æ¥å£
export interface DeviceInfo {
  deviceId: string;       // è®¾å¤‡ID
  deviceName: string;     // è®¾å¤‡åç§°
  deviceModel: string;    // è®¾å¤‡å‹å·
  osVersion: string;      // æ“ä½œç³»ç»Ÿç‰ˆæœ¬
  appVersion: string;     // åº”ç”¨ç‰ˆæœ¬
  platform: string;       // å¹³å°ï¼ˆHarmonyOSç­‰ï¼‰
  screenWidth: number;    // å±å¹•å®½åº¦
  screenHeight: number;   // å±å¹•é«˜åº¦
}

// ç”¨æˆ·èµ„æ–™æ›´æ–°è¯·æ±‚æ¥å£
export interface UpdateProfileRequest {
  nickname?: string;      // æ˜µç§°
  avatar?: string;        // å¤´åƒ
  gender?: Gender;        // æ€§åˆ«
  birthday?: string;      // ç”Ÿæ—¥
  location?: string;      // æ‰€åœ¨åœ°
  bio?: string;           // ä¸ªäººç®€ä»?}

// å¯†ç é‡ç½®è¯·æ±‚æ¥å£
export interface ResetPasswordRequest {
  oldPassword?: string;   // æ—§å¯†ç ï¼ˆå¯é€‰ï¼Œå¦‚æœæ˜¯ä¿®æ”¹å¯†ç ï¼‰
  newPassword: string;    // æ–°å¯†ç ?  confirmPassword: string; // ç¡®è®¤æ–°å¯†ç ?  resetToken?: string;    // é‡ç½®ä»¤ç‰Œï¼ˆå¦‚æœæ˜¯å¿˜è®°å¯†ç ï¼?}

// è®¤è¯å“åº”æ¥å£
export interface AuthResponse {
  success: boolean;       // æ˜¯å¦æˆåŠŸ
  user?: User;            // ç”¨æˆ·ä¿¡æ¯
  token?: AuthToken;      // è®¤è¯ä»¤ç‰Œ
  error?: string;         // é”™è¯¯ä¿¡æ¯
  errorCode?: number;     // é”™è¯¯ç ?}

// é»˜è®¤ç”¨æˆ·åå¥½è®¾ç½®
const DEFAULT_USER_PREFERENCES: UserPreferences = {
  theme: 'dark',
  language: 'zh_CN',
  playQuality: 'auto',
  subtitleEnabled: true,
  subtitleLanguage: 'zh_CN',
  autoPlay: true,
  bandwidthSaver: false,
  parentalControlEnabled: false,
  notificationEnabled: true,
  downloadQuality: 'high',
  downloadWifiOnly: true
};

// é»˜è®¤ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
const DEFAULT_USER_STATISTICS: UserStatistics = {
  totalWatchTime: 0,
  watchedMovies: 0,
  favoriteMovies: 0,
  downloadCount: 0,
  totalDownloadSize: 0,
  currentStreak: 0,
  longestStreak: 0
};

// è®¿å®¢ç”¨æˆ·
const GUEST_USER: User = {
  id: 'guest',
  username: 'guest',
  nickname: 'è®¿å®¢',
  role: UserRole.GUEST,
  status: UserStatus.ACTIVE,
  createdAt: Date.now(),
  updatedAt: Date.now(),
  loginCount: 0,
  preferences: DEFAULT_USER_PREFERENCES,
  statistics: DEFAULT_USER_STATISTICS
};

export default class UserService {
  private static instance: UserService;
  private configService: ConfigService;
  private databaseManager: DatabaseManager;
  private networkRepo: NetworkRepository;
  private databaseRepo: DatabaseRepository;
  private currentUser: User | null = null;
  private authToken: AuthToken | null = null;
  private authStatus: AuthStatus = AuthStatus.UNAUTHENTICATED;
  private autoLoginEnabled: boolean = false;
  private isInitialized: boolean = false;
  private loginAttempts: number = 0;
  private lastLoginAttempt: number = 0;
  private deviceInfo: DeviceInfo | null = null;
  private tokenRefreshTimer: number | null = null;
  
  // ç›‘å¬å™?  private userChangeListeners: Array<(user: User | null) => void> = [];
  private authStatusListeners: Array<(status: AuthStatus) => void> = [];
  private preferenceListeners: Array<(preferences: UserPreferences) => void> = [];
  private statisticsListeners: Array<(statistics: UserStatistics) => void> = [];

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): UserService {
    if (!UserService.instance) {
      UserService.instance = new UserService();
    }
    return UserService.instance;
  }

  /**
   * æ„é€ å‡½æ•?   */
  private constructor() {
    this.configService = ConfigService.getInstance();
    this.databaseManager = DatabaseManager.getInstance();
    this.networkRepo = RepositoryFactory.getRepository('network') as NetworkRepository;
    this.databaseRepo = RepositoryFactory.getRepository('database') as DatabaseRepository;
    this.initializeDeviceInfo();
  }
  
  /**
   * åˆå§‹åŒ–è®¾å¤‡ä¿¡æ?   */
  private async initializeDeviceInfo(): Promise<void> {
    try {
      // å°è¯•ä»å­˜å‚¨ä¸­è·å–è®¾å¤‡ID
      let deviceId = await StorageUtil.getString('device_id');
      
      if (!deviceId) {
        // ç”Ÿæˆæ–°çš„è®¾å¤‡ID
        deviceId = this.generateDeviceId();
        await StorageUtil.setString('device_id', deviceId);
      }

      // æ„å»ºè®¾å¤‡ä¿¡æ¯
      this.deviceInfo = {
        deviceId,
        deviceName: this.getDeviceName(),
        deviceModel: this.getDeviceModel(),
        osVersion: this.getOSVersion(),
        appVersion: this.getAppVersion(),
        platform: this.getPlatform(),
        screenWidth: this.getScreenWidth(),
        screenHeight: this.getScreenHeight()
      };

      Logger.info(TAG, `Device initialized: ${JSON.stringify(this.deviceInfo)}`);
    } catch (error) {
      Logger.error(TAG, 'Failed to initialize device info', error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error instanceof Error ? error instanceof Error ? error : new Error(String(error : new Error(String(error instanceof Error ? error : new Error(String(error : new Error(String(error  as Error)));
    }
  }
  
  /**
   * ç”Ÿæˆè®¾å¤‡ID
   */
  private generateDeviceId(): string {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 11);
    return `device_${timestamp}_${random}`;
  }
  
  /**
   * è·å–è®¾å¤‡åç§°
   */
  private getDeviceName(): string {
    try {
      return 'HarmonyOS Device';
    } catch {
      return 'Unknown Device';
    }
  }
  
  /**
   * è·å–è®¾å¤‡å‹å·
   */
  private getDeviceModel(): string {
    try {
      return 'HarmonyOS Model';
    } catch {
      return 'Unknown Model';
    }
  }
  
  /**
   * è·å–æ“ä½œç³»ç»Ÿç‰ˆæœ¬
   */
  private getOSVersion(): string {
    try {
      return 'HarmonyOS 3.0';
    } catch {
      return 'Unknown OS';
    }
  }
  
  /**
   * è·å–åº”ç”¨ç‰ˆæœ¬
   */
  private getAppVersion(): string {
    try {
      return '1.0.0';
    } catch {
      return 'Unknown Version';
    }
  }
  
  /**
   * è·å–å¹³å°ä¿¡æ¯
   */
  private getPlatform(): string {
    return 'HarmonyOS';
  }
  
  /**
   * è·å–å±å¹•å®½åº¦
   */
  private getScreenWidth(): number {
    try {
      return 1080;
    } catch {
      return 0;
    }
  }
  
  /**
   * è·å–å±å¹•é«˜åº¦
   */
  private getScreenHeight(): number {
    try {
      return 1920;
    } catch {
      return 0;
    }
  }

  /**
   * åˆå§‹åŒ–ç”¨æˆ·æœåŠ?   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      Logger.info(TAG, 'User service already initialized');
      return;
    }

    try {
      Logger.info(TAG, 'Initializing user service...');
      
      // åŠ è½½è‡ªåŠ¨ç™»å½•è®¾ç½®
      this.autoLoginEnabled = await StorageUtil.getBoolean(AUTO_LOGIN_KEY, false);
      
      // å°è¯•æ¢å¤ç”¨æˆ·ä¼šè¯
      if (this.autoLoginEnabled) {
        await this.restoreSession();
      } else {
        // å¦‚æœæœªå¯ç”¨è‡ªåŠ¨ç™»å½•ï¼Œä½¿ç”¨è®¿å®¢æ¨¡å¼
        this.setGuestMode();
      }
      
      this.isInitialized = true;
      Logger.info(TAG, 'User service initialized successfully');
    } catch (error) {
      Logger.error(TAG, `Failed to initialize user service: ${error}`);
      // åˆå§‹åŒ–å¤±è´¥æ—¶ä½¿ç”¨è®¿å®¢æ¨¡å¼
      this.setGuestMode();
      this.isInitialized = true;
    }
  }
  
  /**
   * è®¾ç½®ä»¤ç‰Œè‡ªåŠ¨åˆ·æ–°
   */
  private setupTokenRefresh(): void {
    // æ¸…é™¤ç°æœ‰çš„å®šæ—¶å™¨
    this.clearTokenRefreshTimer();
    
    if (!this.authToken) return;
    
    // è®¡ç®—åˆ·æ–°æ—¶é—´ï¼ˆåœ¨ä»¤ç‰Œè¿‡æœŸå‰?åˆ†é’Ÿï¼?    const refreshTime = (this.authToken.expiresIn * 1000) - (5 * 60 * 1000);
    
    if (refreshTime > 0) {
      this.tokenRefreshTimer = setTimeout(async () => {
        await this.refreshToken();
      }, refreshTime instanceof Error ? refreshTime : new Error(String(refreshTime instanceof Error ? refreshTime instanceof Error ? refreshTime : new Error(String(refreshTime : new Error(String(refreshTime instanceof Error ? refreshTime : new Error(String(refreshTime instanceof Error ? refreshTime instanceof Error ? refreshTime : new Error(String(refreshTime instanceof Error ? refreshTime instanceof Error ? refreshTime : new Error(String(refreshTime : new Error(String(refreshTime instanceof Error ? refreshTime : new Error(String(refreshTime : new Error(String(refreshTime instanceof Error ? refreshTime : new Error(String(refreshTime instanceof Error ? refreshTime instanceof Error ? refreshTime : new Error(String(refreshTime : new Error(String(refreshTime instanceof Error ? refreshTime : new Error(String(refreshTime)))))));
      
      Logger.info(TAG, `Token refresh scheduled in ${refreshTime}ms`);
    }
  }
  
  /**
   * æ¸…é™¤ä»¤ç‰Œåˆ·æ–°å®šæ—¶å™?   */
  private clearTokenRefreshTimer(): void {
    if (this.tokenRefreshTimer) {
      clearTimeout(this.tokenRefreshTimer);
      this.tokenRefreshTimer = null;
    }
  }

  /**
   * è®¾ç½®è®¿å®¢æ¨¡å¼
   */
  private setGuestMode(): void {
    this.currentUser = GUEST_USER;
    this.authToken = null;
    this.authStatus = AuthStatus.UNAUTHENTICATED;
    this.notifyUserChanged();
    this.notifyAuthStatusChanged();
  }

  /**
   * æ¢å¤ç”¨æˆ·ä¼šè¯
   */
  private async restoreSession(): Promise<boolean> {
    try {
      // ä»å­˜å‚¨ä¸­åŠ è½½ç”¨æˆ·æ•°æ®å’Œä»¤ç‰?      const savedUser = await StorageUtil.getObject<User>(USER_DATA_KEY);
      const savedToken = await StorageUtil.getObject<AuthToken>(AUTH_TOKEN_KEY);
      
      if (savedUser && savedToken) {
        // æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦è¿‡æœ?        const now = Date.now();
        const expiresAt = savedToken.issuedAt + (savedToken.expiresIn * 1000);
        
        if (now < expiresAt) {
          // ä»¤ç‰Œæœ‰æ•ˆï¼Œæ¢å¤ç”¨æˆ·ä¼šè¯?          this.currentUser = savedUser;
          this.authToken = savedToken;
          this.authStatus = AuthStatus.AUTHENTICATED;
          
          // éªŒè¯ä¼šè¯æœ‰æ•ˆæ€§ï¼ˆå¯é€‰ï¼šå‘æœåŠ¡å™¨éªŒè¯ï¼?          // const isValid = await this.validateSession();
          // if (!isValid) {
          //   this.logout();
          //   return false;
          // }
          
          this.notifyUserChanged();
          this.notifyAuthStatusChanged();
          
          Logger.info(TAG, 'Session restored successfully');
          return true;
        } else {
          // ä»¤ç‰Œå·²è¿‡æœŸï¼Œå°è¯•åˆ·æ–°
          if (await this.refreshToken(savedToken.refreshToken)) {
            Logger.info(TAG, 'Session restored after token refresh');
            return true;
          }
        }
      }
      
      // æ— æ³•æ¢å¤ä¼šè¯ï¼Œä½¿ç”¨è®¿å®¢æ¨¡å¼?      this.setGuestMode();
      return false;
    } catch (error) {
      Logger.error(TAG, `Failed to restore session: ${error}`);
      this.setGuestMode();
      return false;
    }
  }

  /**
   * ç™»å½•
   */
  public async login(request: LoginRequest): Promise<AuthResponse> {
    try {
      Logger.info(TAG, 'Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username } instanceof Error ? 'Attempting login...', { username: request.username } : new Error(String('Attempting login...', { username: request.username })))))));
      
      // æ£€æŸ¥ç™»å½•å°è¯•é¢‘ç?      if (!this.canAttemptLogin()) {
        return {
          success: false,
          error: 'ç™»å½•å°è¯•è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•',
          errorCode: 429
        };
      }
      
      // æ›´æ–°ç™»å½•å°è¯•ä¿¡æ¯
      this.loginAttempts++;
      this.lastLoginAttempt = Date.now();
      
      // è®¾ç½®è®¤è¯çŠ¶æ€ä¸ºè®¤è¯ä¸?      this.authStatus = AuthStatus.AUTHENTICATING;
      this.notifyAuthStatusChanged();
      
      // æ·»åŠ è®¾å¤‡ä¿¡æ¯åˆ°ç™»å½•è¯·æ±?      const loginData: Record<string, string | number | boolean | null> = { ... };
      
      // è°ƒç”¨å®é™…çš„ç™»å½•API
      try {
        const apiResponse = await this.networkRepo.request<ApiResponse<AuthResponseData>>({
          url: API_ENDPOINTS.LOGIN,
          method: 'POST',
          data: loginData
        });
        
        if (apiResponse.isSuccess() && apiResponse.data) {
          const { user, token } = apiResponse.data;
          
          if (user && token) {
            // ç›´æ¥ä½¿ç”¨APIè¿”å›çš„ç”¨æˆ·æ•°æ®ï¼Œç¡®ä¿ç¬¦åˆå†…éƒ¨Useræ¥å£
            const internalUser: User = {
              id: user.id,
              username: user.username,
              email: user.email,
              phone: user.phone,
              nickname: user.nickname,
              avatar: user.avatar,
              gender: user.gender,
              birthday: user.birthday,
              location: user.location,
              bio: user.bio,
              role: user.role,
              status: user.status,
              createdAt: user.createdAt,
              updatedAt: user.updatedAt,
              lastLoginAt: user.lastLoginAt,
              loginCount: user.loginCount,
              preferences: user.preferences,
              statistics: user.statistics
            };
            
            // ç™»å½•æˆåŠŸ
            this.currentUser = internalUser;
            this.authToken = token;
            this.authStatus = AuthStatus.AUTHENTICATED;
            this.loginAttempts = 0;
            
            // æ›´æ–°æœ€åç™»å½•ä¿¡æ?            this.currentUser.lastLoginAt = Date.now();
            this.currentUser.loginCount++;
            this.currentUser.updatedAt = Date.now();
            
            // ä¿å­˜ç”¨æˆ·æ•°æ®å’Œä»¤ç‰?            await this.saveUserData();
            await this.saveAuthToken();
            
            // è®¾ç½®ä»¤ç‰Œè‡ªåŠ¨åˆ·æ–°
            this.setupTokenRefresh();
            
            // åŒæ­¥ç”¨æˆ·ä¿¡æ¯åˆ°æœ¬åœ°æ•°æ®åº“
            await this.syncUserInfo(user);
            
            // é€šçŸ¥ç›‘å¬å™?            this.notifyUserChanged();
            this.notifyAuthStatusChanged();
            
            Logger.info(TAG, 'Login successful');
            return {
              success: true,
              user: this.currentUser,
              token: this.authToken
            };
          }
        }
        
        // ç™»å½•å¤±è´¥
        Logger.warn(TAG, `Login failed with status: ${apiResponse.code}`);
        this.authStatus = AuthStatus.UNAUTHENTICATED;
        this.notifyAuthStatusChanged();
        
        return {
          success: false,
          error: apiResponse.message || 'ç™»å½•å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·åå’Œå¯†ç ?,
          errorCode: apiResponse.code || 401
        };
      } catch (apiError) {
        // APIè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨æ¨¡æ‹Ÿç™»å½•ï¼ˆå¼€å‘ç¯å¢ƒï¼‰
        Logger.warn(TAG, 'API login failed, using mock login for development', apiError);
        
        // æ¨¡æ‹Ÿç™»å½•å“åº”
        const response = await this.mockLoginResponse(request);
        
        if (response.success && response.user && response.token) {
          // ç™»å½•æˆåŠŸ
          this.currentUser = response.user;
          this.authToken = response.token;
          this.authStatus = AuthStatus.AUTHENTICATED;
          this.loginAttempts = 0;
          
          // æ›´æ–°æœ€åç™»å½•ä¿¡æ?          this.currentUser.lastLoginAt = Date.now();
          this.currentUser.loginCount++;
          this.currentUser.updatedAt = Date.now();
          
          // ä¿å­˜ç”¨æˆ·æ•°æ®å’Œä»¤ç‰?          await this.saveUserData();
          await this.saveAuthToken();
          
          // è®¾ç½®ä»¤ç‰Œè‡ªåŠ¨åˆ·æ–°
          this.setupTokenRefresh();
          
          // åŒæ­¥ç”¨æˆ·æ•°æ®
        await this.syncUserData();
        
        // é€šçŸ¥ç›‘å¬å™?        this.notifyUserChanged();
        this.notifyAuthStatusChanged();
        
        Logger.info(TAG, `User logged in successfully: ${this.currentUser.username}`);
        return response;
      } else {
        // ç™»å½•å¤±è´¥
        this.authStatus = AuthStatus.ERROR;
        this.notifyAuthStatusChanged();
        
        Logger.error(TAG, `Login failed: ${response.error || 'Unknown error'}`);
        return response;
      }
    } catch (error) {
      Logger.error(TAG, `Login error: ${error}` instanceof Error ? `Login error: ${error}` : new Error(String(`Login error: ${error}` instanceof Error ? `Login error: ${error}` instanceof Error ? `Login error: ${error}` : new Error(String(`Login error: ${error}` : new Error(String(`Login error: ${error}` instanceof Error ? `Login error: ${error}` : new Error(String(`Login error: ${error}` instanceof Error ? `Login error: ${error}` instanceof Error ? `Login error: ${error}` : new Error(String(`Login error: ${error}` instanceof Error ? `Login error: ${error}` instanceof Error ? `Login error: ${error}` : new Error(String(`Login error: ${error}` : new Error(String(`Login error: ${error}` instanceof Error ? `Login error: ${error}` : new Error(String(`Login error: ${error}` : new Error(String(`Login error: ${error}` instanceof Error ? `Login error: ${error}` : new Error(String(`Login error: ${error}` instanceof Error ? `Login error: ${error}` instanceof Error ? `Login error: ${error}` : new Error(String(`Login error: ${error}` : new Error(String(`Login error: ${error}` instanceof Error ? `Login error: ${error}` : new Error(String(`Login error: ${error}`)))))));
      
      this.authStatus = AuthStatus.ERROR;
      this.notifyAuthStatusChanged();
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'ç™»å½•å¤±è´¥ï¼Œè¯·ç¨åå†è¯•',
        errorCode: 500
      };
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥å°è¯•ç™»å½?   */
  private canAttemptLogin(): boolean {
    // é™åˆ¶ç™»å½•å°è¯•é¢‘ç‡ï¼šæ¯10åˆ†é’Ÿæœ€å¤?æ¬¡å°è¯?    const now = Date.now();
    const tenMinutesAgo = now - (10 * 60 * 1000);
    
    // å¦‚æœæœ€åä¸€æ¬¡å°è¯•æ˜¯10åˆ†é’Ÿå‰ï¼Œé‡ç½®è®¡æ•°å™?    if (this.lastLoginAttempt < tenMinutesAgo) {
      this.loginAttempts = 0;
    }
    
    return this.loginAttempts < 5;
  }

  /**
   * æ¨¡æ‹Ÿç™»å½•å“åº”ï¼ˆç”¨äºæ¼”ç¤ºï¼‰
   */
  private async mockLoginResponse(request: LoginRequest): Promise<AuthResponse> {
    // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // ç®€å•çš„éªŒè¯é€»è¾‘
    if (request.type === LoginType.LOCAL && request.username === 'test' && request.password === '123456') {
      const user: User = {
        id: 'user_123',
        username: 'test',
        email: 'test@example.com',
        nickname: 'æµ‹è¯•ç”¨æˆ·',
        avatar: 'https://example.com/avatar.jpg',
        gender: Gender.MALE,
        role: UserRole.PREMIUM,
        status: UserStatus.ACTIVE,
        createdAt: Date.now() - 30 * 24 * 60 * 60 * 1000, // 30å¤©å‰
        updatedAt: Date.now(),
        lastLoginAt: Date.now(),
        loginCount: 15,
        preferences: DEFAULT_USER_PREFERENCES,
        statistics: DEFAULT_USER_STATISTICS
      };
      
      const token: AuthToken = {
        accessToken: 'mock_access_token_' + Date.now(),
        refreshToken: 'mock_refresh_token_' + Date.now(),
        tokenType: 'Bearer',
        expiresIn: 24 * 60 * 60, // 24å°æ—¶
        issuedAt: Date.now(),
        userId: user.id
      };
      
      return {
        success: true,
        user,
        token
      };
    }
    
    return {
      success: false,
      error: 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯',
      errorCode: 401
    };
  }

  /**
   * æ‰§è¡Œå®é™…çš„ç™»å½•è¯·æ±‚ï¼ˆå¾…å®ç°ï¼‰
   */
  private async performLoginRequest(request: LoginRequest): Promise<AuthResponse> {
    // TODO: å®ç°å®é™…çš„ç™»å½•APIè°ƒç”¨
    throw new Error('Not implemented');
  }

  /**
   * æ³¨å†Œæ–°ç”¨æˆ?   */
  public async register(request: RegisterRequest): Promise<AuthResponse> {
    try {
      // éªŒè¯æ³¨å†Œä¿¡æ¯
      if (!request.username || request.username.length < 3) {
        return {
          success: false,
          error: 'ç”¨æˆ·åé•¿åº¦è‡³å°‘ä¸º3ä¸ªå­—ç¬?,
          errorCode: 400
        };
      }
      
      if (!request.password || request.password.length < 6) {
        return {
          success: false,
          error: 'å¯†ç é•¿åº¦è‡³å°‘ä¸?ä¸ªå­—ç¬?,
          errorCode: 400
        };
      }
      
      if (request.password !== request.confirmPassword) {
        return {
          success: false,
          error: 'ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡?,
          errorCode: 400
        };
      }
      
      if (!request.agreeToTerms) {
        return {
          success: false,
          error: 'è¯·åŒæ„æœåŠ¡æ¡æ¬¾å’Œéšç§æ”¿ç­–',
          errorCode: 400
        };
      }
      
      // æ¨¡æ‹Ÿæ³¨å†Œè¯·æ±‚
      // const response = await this.performRegisterRequest(request);
      
      // æ¨¡æ‹Ÿæ³¨å†Œå“åº”
      const response = await this.mockRegisterResponse(request);
      
      if (response.success && response.user && response.token) {
        // æ³¨å†ŒæˆåŠŸï¼Œè‡ªåŠ¨ç™»å½?        this.currentUser = response.user;
        this.authToken = response.token;
        this.authStatus = AuthStatus.AUTHENTICATED;
        
        // ä¿å­˜ç”¨æˆ·æ•°æ®å’Œä»¤ç‰?        await this.saveUserData();
        await this.saveAuthToken();
        
        // é€šçŸ¥ç›‘å¬å™?        this.notifyUserChanged();
        this.notifyAuthStatusChanged();
        
        Logger.info(TAG, `User registered successfully: ${this.currentUser.username}`);
        return response;
      } else {
        Logger.error(TAG, `Registration failed: ${response.error || 'Unknown error'}`);
        return response;
      }
    } catch (error) {
      Logger.error(TAG, `Registration error: ${error}` instanceof Error ? `Registration error: ${error}` : new Error(String(`Registration error: ${error}` instanceof Error ? `Registration error: ${error}` instanceof Error ? `Registration error: ${error}` : new Error(String(`Registration error: ${error}` : new Error(String(`Registration error: ${error}` instanceof Error ? `Registration error: ${error}` : new Error(String(`Registration error: ${error}` instanceof Error ? `Registration error: ${error}` instanceof Error ? `Registration error: ${error}` : new Error(String(`Registration error: ${error}` instanceof Error ? `Registration error: ${error}` instanceof Error ? `Registration error: ${error}` : new Error(String(`Registration error: ${error}` : new Error(String(`Registration error: ${error}` instanceof Error ? `Registration error: ${error}` : new Error(String(`Registration error: ${error}` : new Error(String(`Registration error: ${error}` instanceof Error ? `Registration error: ${error}` : new Error(String(`Registration error: ${error}` instanceof Error ? `Registration error: ${error}` instanceof Error ? `Registration error: ${error}` : new Error(String(`Registration error: ${error}` : new Error(String(`Registration error: ${error}` instanceof Error ? `Registration error: ${error}` : new Error(String(`Registration error: ${error}`)))))));
      return {
        success: false,
        error: error instanceof Error ? error.message : 'æ³¨å†Œå¤±è´¥ï¼Œè¯·ç¨åå†è¯•',
        errorCode: 500
      };
    }
  }

  /**
   * æ¨¡æ‹Ÿæ³¨å†Œå“åº”ï¼ˆç”¨äºæ¼”ç¤ºï¼‰
   */
  private async mockRegisterResponse(request: RegisterRequest): Promise<AuthResponse> {
    // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨ï¼ˆç®€å•æ¨¡æ‹Ÿï¼‰
    if (request.username === 'test') {
      return {
        success: false,
        error: 'ç”¨æˆ·åå·²å­˜åœ¨',
        errorCode: 409
      };
    }
    
    const user: User = {
      id: 'user_' + Date.now(),
      username: request.username,
      email: request.email,
      phone: request.phone,
      nickname: request.nickname || request.username,
      role: UserRole.REGISTERED,
      status: UserStatus.ACTIVE,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      loginCount: 0,
      preferences: DEFAULT_USER_PREFERENCES,
      statistics: DEFAULT_USER_STATISTICS
    };
    
    const token: AuthToken = {
      accessToken: 'mock_access_token_' + Date.now(),
      refreshToken: 'mock_refresh_token_' + Date.now(),
      tokenType: 'Bearer',
      expiresIn: 24 * 60 * 60,
      issuedAt: Date.now(),
      userId: user.id
    };
    
    return {
      success: true,
      user,
      token
    };
  }

  /**
   * ç™»å‡º
   */
  public async logout(): Promise<boolean> {
    try {
      Logger.info(TAG, 'User logging out');
      
      // å¦‚æœæœ‰ä»¤ç‰Œï¼Œè°ƒç”¨ç™»å‡ºAPIï¼ˆå¯é€‰ï¼‰
      if (this.authToken) {
        // await this.performLogoutRequest();
      }
      
      // æ¸…é™¤ç”¨æˆ·æ•°æ®å’Œä»¤ç‰?      await this.clearUserData();
      
      // é‡ç½®çŠ¶æ€?      this.setGuestMode();
      
      Logger.info(TAG, 'User logged out successfully');
      return true;
    } catch (error) {
      Logger.error(TAG, `Logout error: ${error}`);
      
      // å³ä½¿å‡ºé”™ï¼Œä¹Ÿè¦æ¸…ç†æœ¬åœ°æ•°æ?      await this.clearUserData();
      this.setGuestMode();
      
      return false;
    }
  }

  /**
   * åˆ·æ–°ä»¤ç‰Œ
   */
  public async refreshToken(refreshToken: string): Promise<boolean> {
    try {
      // æ¨¡æ‹Ÿåˆ·æ–°ä»¤ç‰Œè¯·æ±‚
      // const response = await this.performRefreshTokenRequest(refreshToken);
      
      // æ¨¡æ‹Ÿåˆ·æ–°ä»¤ç‰ŒæˆåŠŸ
      await new Promise(resolve => setTimeout(resolve, 500 instanceof Error ? 500 : new Error(String(500 instanceof Error ? 500 instanceof Error ? 500 : new Error(String(500 : new Error(String(500 instanceof Error ? 500 : new Error(String(500 instanceof Error ? 500 instanceof Error ? 500 : new Error(String(500 instanceof Error ? 500 instanceof Error ? 500 : new Error(String(500 : new Error(String(500 instanceof Error ? 500 : new Error(String(500 : new Error(String(500 instanceof Error ? 500 : new Error(String(500 instanceof Error ? 500 instanceof Error ? 500 : new Error(String(500 : new Error(String(500 instanceof Error ? 500 : new Error(String(500))))))));
      
      if (this.currentUser) {
        const newToken: AuthToken = {
          accessToken: 'mock_access_token_' + Date.now(),
          refreshToken: 'mock_refresh_token_' + Date.now(),
          tokenType: 'Bearer',
          expiresIn: 24 * 60 * 60,
          issuedAt: Date.now(),
          userId: this.currentUser.id
        };
        
        this.authToken = newToken;
        await this.saveAuthToken();
        
        Logger.info(TAG, 'Token refreshed successfully');
        return true;
      }
      
      return false;
    } catch (error) {
      Logger.error(TAG, `Token refresh error: ${error}`);
      return false;
    }
  }

  /**
   * ä¿å­˜ç”¨æˆ·æ•°æ®
   */
  private async saveUserData(): Promise<void> {
    if (this.currentUser) {
      await StorageUtil.setObject(USER_DATA_KEY, this.currentUser instanceof Error ? this.currentUser : new Error(String(this.currentUser instanceof Error ? this.currentUser instanceof Error ? this.currentUser : new Error(String(this.currentUser : new Error(String(this.currentUser instanceof Error ? this.currentUser : new Error(String(this.currentUser instanceof Error ? this.currentUser instanceof Error ? this.currentUser : new Error(String(this.currentUser instanceof Error ? this.currentUser instanceof Error ? this.currentUser : new Error(String(this.currentUser : new Error(String(this.currentUser instanceof Error ? this.currentUser : new Error(String(this.currentUser : new Error(String(this.currentUser instanceof Error ? this.currentUser : new Error(String(this.currentUser instanceof Error ? this.currentUser instanceof Error ? this.currentUser : new Error(String(this.currentUser : new Error(String(this.currentUser instanceof Error ? this.currentUser : new Error(String(this.currentUser)))))));
    }
  }

  /**
   * ä¿å­˜è®¤è¯ä»¤ç‰Œ
   */
  private async saveAuthToken(): Promise<void> {
    if (this.authToken) {
      await StorageUtil.setObject(AUTH_TOKEN_KEY, this.authToken);
    }
  }

  /**
   * æ¸…é™¤ç”¨æˆ·æ•°æ®
   */
  private async clearUserData(): Promise<void> {
    await StorageUtil.remove(USER_DATA_KEY);
    await StorageUtil.remove(AUTH_TOKEN_KEY);
    this.currentUser = null;
    this.authToken = null;
  }

  /**
   * è·å–å½“å‰ç”¨æˆ·
   */
  public getCurrentUser(): User | null {
    return this.currentUser ? { ...this.currentUser } : null;
  }

  /**
   * è·å–è®¤è¯çŠ¶æ€?   */
  public getAuthStatus(): AuthStatus {
    return this.authStatus;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²ç™»å½•
   */
  public isLoggedIn(): boolean {
    return this.authStatus === AuthStatus.AUTHENTICATED && 
           this.currentUser?.role !== UserRole.GUEST;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºè®¿å®¢ç”¨æˆ·
   */
  public isGuest(): boolean {
    return this.currentUser?.role === UserRole.GUEST;
  }

  /**
   * æ›´æ–°ç”¨æˆ·èµ„æ–™
   */
  public async updateProfile(request: UpdateProfileRequest): Promise<boolean> {
    if (!this.isLoggedIn() || !this.currentUser) {
      return false;
    }

    try {
      // æ›´æ–°ç”¨æˆ·ä¿¡æ¯
      if (request.nickname !== undefined) {
        this.currentUser.nickname = request.nickname;
      }
      if (request.avatar !== undefined) {
        this.currentUser.avatar = request.avatar;
      }
      if (request.gender !== undefined) {
        this.currentUser.gender = request.gender;
      }
      if (request.birthday !== undefined) {
        this.currentUser.birthday = request.birthday;
      }
      if (request.location !== undefined) {
        this.currentUser.location = request.location;
      }
      if (request.bio !== undefined) {
        this.currentUser.bio = request.bio;
      }
      
      // æ›´æ–°æ—¶é—´
      this.currentUser.updatedAt = Date.now();
      
      // ä¿å­˜æ›´æ–°åçš„ç”¨æˆ·æ•°æ®
      await this.saveUserData();
      
      // åŒæ­¥åˆ°æœåŠ¡å™¨
      await this.syncUserData();
      
      // é€šçŸ¥ç›‘å¬å™?      this.notifyUserChanged();
      
      Logger.info(TAG, `User profile updated: ${this.currentUser.username}`);
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to update user profile: ${error}`);
      return false;
    }
  }

  /**
   * æ›´æ”¹å¯†ç 
   */
  public async changePassword(request: ResetPasswordRequest): Promise<boolean> {
    if (!this.isLoggedIn()) {
      return false;
    }

    try {
      // éªŒè¯å¯†ç 
      if (request.newPassword !== request.confirmPassword) {
        throw new Error('ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡?);
      }
      
      if (request.newPassword.length < 6) {
        throw new Error('å¯†ç é•¿åº¦è‡³å°‘ä¸?ä¸ªå­—ç¬?);
      }
      
      // æ¨¡æ‹Ÿå¯†ç æ›´æ”¹è¯·æ±‚
      // await this.performChangePasswordRequest(request);
      
      // æ¨¡æ‹ŸæˆåŠŸ
      await new Promise(resolve => setTimeout(resolve, 1000 instanceof Error ? 1000 : new Error(String(1000 instanceof Error ? 1000 instanceof Error ? 1000 : new Error(String(1000 : new Error(String(1000 instanceof Error ? 1000 : new Error(String(1000 instanceof Error ? 1000 instanceof Error ? 1000 : new Error(String(1000 instanceof Error ? 1000 instanceof Error ? 1000 : new Error(String(1000 : new Error(String(1000 instanceof Error ? 1000 : new Error(String(1000 : new Error(String(1000 instanceof Error ? 1000 : new Error(String(1000 instanceof Error ? 1000 instanceof Error ? 1000 : new Error(String(1000 : new Error(String(1000 instanceof Error ? 1000 : new Error(String(1000))))))));
      
      Logger.info(TAG, 'Password changed successfully');
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to change password: ${error}`);
      return false;
    }
  }

  /**
   * è·å–ç”¨æˆ·åå¥½è®¾ç½®
   */
  public getUserPreferences(): UserPreferences {
    if (this.currentUser?.preferences) {
      return { ...this.currentUser.preferences };
    }
    return DEFAULT_USER_PREFERENCES;
  }

  /**
   * æ›´æ–°ç”¨æˆ·åå¥½è®¾ç½®
   */
  public async updatePreferences(preferences: Partial<UserPreferences>): Promise<boolean> {
    if (!this.currentUser) {
      return false;
    }

    try {
      // ç¡®ä¿åå¥½è®¾ç½®å¯¹è±¡å­˜åœ¨
      if (!this.currentUser.preferences) {
        this.currentUser.preferences = DEFAULT_USER_PREFERENCES;
      }
      
      // æ›´æ–°åå¥½è®¾ç½®
      this.currentUser.preferences = { ...this.currentUser.preferences, ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...preferences };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData()))))));
      
      // åŒæ­¥åˆ°é…ç½®æœåŠ?      if (preferences.theme) {
        await this.configService.setConfig('theme', preferences.theme);
      }
      if (preferences.language) {
        await this.configService.setConfig('language', preferences.language);
      }
      if (preferences.playQuality) {
        await this.configService.setConfig('playQuality', preferences.playQuality);
      }
      
      // é€šçŸ¥ç›‘å¬å™?      this.notifyUserChanged();
      this.notifyPreferenceChanged();
      
      Logger.info(TAG, 'User preferences updated');
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to update preferences: ${error}`);
      return false;
    }
  }

  /**
   * è·å–ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
   */
  public getUserStatistics(): UserStatistics {
    if (this.currentUser?.statistics) {
      return { ...this.currentUser.statistics };
    }
    return DEFAULT_USER_STATISTICS;
  }

  /**
   * æ›´æ–°ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
   */
  public async updateStatistics(updates: Partial<UserStatistics>): Promise<boolean> {
    if (!this.currentUser) {
      return false;
    }

    try {
      // ç¡®ä¿ç»Ÿè®¡ä¿¡æ¯å¯¹è±¡å­˜åœ¨
      if (!this.currentUser.statistics) {
        this.currentUser.statistics = DEFAULT_USER_STATISTICS;
      }
      
      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      this.currentUser.statistics = { ...this.currentUser.statistics, ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( instanceof Error ? ...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData( : new Error(String(...updates };
      
      // ä¿å­˜ç”¨æˆ·æ•°æ®
      await this.saveUserData()))))));
      
      // é€šçŸ¥ç›‘å¬å™?      this.notifyUserChanged();
      this.notifyStatisticsChanged();
      
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to update statistics: ${error}`);
      return false;
    }
  }

  /**
   * å¢åŠ è§‚çœ‹æ—¶é•¿ç»Ÿè®¡
   */
  public async addWatchTime(seconds: number): Promise<void> {
    if (!this.currentUser || this.isGuest()) {
      return;
    }
    
    // ç¡®ä¿ç»Ÿè®¡ä¿¡æ¯å¯¹è±¡å­˜åœ¨
    if (!this.currentUser.statistics) {
      this.currentUser.statistics = DEFAULT_USER_STATISTICS;
    }
    
    // æ›´æ–°è§‚çœ‹æ—¶é•¿
    this.currentUser.statistics.totalWatchTime += seconds;
    this.currentUser.statistics.lastWatchDate = Date.now();
    
    // æ›´æ–°è¿ç»­è§‚çœ‹å¤©æ•°
    await this.updateWatchStreak();
    
    // ä¿å­˜æ›´æ–°
    await this.saveUserData();
    this.notifyStatisticsChanged();
  }

  /**
   * æ›´æ–°è§‚çœ‹è¿ç»­å¤©æ•°
   */
  private async updateWatchStreak(): Promise<void> {
    if (!this.currentUser || !this.currentUser.statistics) {
      return;
    }
    
    const now = Date.now();
    const lastWatchDate = this.currentUser.statistics.lastWatchDate;
    
    if (lastWatchDate) {
      const daysSinceLastWatch = DateUtil.daysBetween(lastWatchDate, now instanceof Error ? now : new Error(String(now instanceof Error ? now instanceof Error ? now : new Error(String(now : new Error(String(now instanceof Error ? now : new Error(String(now instanceof Error ? now instanceof Error ? now : new Error(String(now instanceof Error ? now instanceof Error ? now : new Error(String(now : new Error(String(now instanceof Error ? now : new Error(String(now : new Error(String(now instanceof Error ? now : new Error(String(now instanceof Error ? now instanceof Error ? now : new Error(String(now : new Error(String(now instanceof Error ? now : new Error(String(now)))))));
      
      if (daysSinceLastWatch === 1) {
        // è¿ç»­è§‚çœ‹ï¼Œå¢åŠ å½“å‰è¿ç»­å¤©æ•?        this.currentUser.statistics.currentStreak++;
        // æ›´æ–°æœ€é•¿è¿ç»­å¤©æ•?        if (this.currentUser.statistics.currentStreak > this.currentUser.statistics.longestStreak) {
          this.currentUser.statistics.longestStreak = this.currentUser.statistics.currentStreak;
        }
      } else if (daysSinceLastWatch > 1) {
        // ä¸­æ–­äº†è¿ç»­è§‚çœ‹ï¼Œé‡ç½®å½“å‰è¿ç»­å¤©æ•°
        this.currentUser.statistics.currentStreak = 1;
      }
    } else {
      // é¦–æ¬¡è§‚çœ‹
      this.currentUser.statistics.currentStreak = 1;
      this.currentUser.statistics.longestStreak = 1;
    }
  }

  /**
   * è®¾ç½®è‡ªåŠ¨ç™»å½•
   */
  public async setAutoLogin(enabled: boolean): Promise<void> {
    this.autoLoginEnabled = enabled;
    await StorageUtil.setBoolean(AUTO_LOGIN_KEY, enabled);
    Logger.info(TAG, `Auto login ${enabled ? 'enabled' : 'disabled'}`);
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†è‡ªåŠ¨ç™»å½•
   */
  public isAutoLoginEnabled(): boolean {
    return this.autoLoginEnabled;
  }

  /**
   * åŒæ­¥ç”¨æˆ·æ•°æ®
   */
  public async syncUserData(): Promise<boolean> {
    if (!this.isLoggedIn() || !this.currentUser || !this.authToken) {
      return false;
    }

    try {
      // æ£€æŸ¥ç½‘ç»œè¿æ?      const isConnected = await NetworkUtil.isNetworkAvailable();
      if (!isConnected) {
        Logger.warn(TAG, 'Cannot sync user data: no network connection');
        return false;
      }
      
      // æ¨¡æ‹Ÿæ•°æ®åŒæ­¥
      // await this.performSyncUserData();
      
      Logger.info(TAG, 'User data synced successfully');
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to sync user data: ${error}`);
      return false;
    }
  }

  /**
   * è·å–è®¿é—®ä»¤ç‰Œ
   */
  public getAccessToken(): string | null {
    if (this.authToken) {
      // æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦è¿‡æœ?      const now = Date.now();
      const expiresAt = this.authToken.issuedAt + (this.authToken.expiresIn * 1000);
      
      if (now < expiresAt) {
        return this.authToken.accessToken;
      } else {
        // ä»¤ç‰Œå·²è¿‡æœŸï¼Œå°è¯•åˆ·æ–°
        this.refreshToken(this.authToken.refreshToken).catch(error => {
          Logger.error(TAG, `Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}` instanceof Error ? `Failed to refresh token automatically: ${error}` : new Error(String(`Failed to refresh token automatically: ${error}`)))))));
        });
      }
    }
    return null;
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™
   */
  public hasPermission(minRole: UserRole): boolean {
    if (!this.currentUser) {
      return minRole === UserRole.GUEST;
    }
    return this.currentUser.role >= minRole;
  }

  /**
   * æ·»åŠ ç”¨æˆ·å˜æ›´ç›‘å¬å™?   */
  public addUserChangeListener(listener: (user: User | null) => void): () => void {
    this.userChangeListeners.push(listener);
    
    // ç«‹å³é€šçŸ¥å½“å‰ç”¨æˆ·çŠ¶æ€?    listener(this.getCurrentUser());
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.userChangeListeners.indexOf(listener);
      if (index > -1) {
        this.userChangeListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ è®¤è¯çŠ¶æ€ç›‘å¬å™¨
   */
  public addAuthStatusListener(listener: (status: AuthStatus) => void): () => void {
    this.authStatusListeners.push(listener);
    
    // ç«‹å³é€šçŸ¥å½“å‰è®¤è¯çŠ¶æ€?    listener(this.authStatus);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.authStatusListeners.indexOf(listener);
      if (index > -1) {
        this.authStatusListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ åå¥½è®¾ç½®ç›‘å¬å™?   */
  public addPreferenceListener(listener: (preferences: UserPreferences) => void): () => void {
    this.preferenceListeners.push(listener);
    
    // ç«‹å³é€šçŸ¥å½“å‰åå¥½è®¾ç½®
    listener(this.getUserPreferences());
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.preferenceListeners.indexOf(listener);
      if (index > -1) {
        this.preferenceListeners.splice(index, 1);
      }
    };
  }

  /**
   * æ·»åŠ ç»Ÿè®¡ä¿¡æ¯ç›‘å¬å™?   */
  public addStatisticsListener(listener: (statistics: UserStatistics) => void): () => void {
    this.statisticsListeners.push(listener);
    
    // ç«‹å³é€šçŸ¥å½“å‰ç»Ÿè®¡ä¿¡æ¯
    listener(this.getUserStatistics());
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      const index = this.statisticsListeners.indexOf(listener);
      if (index > -1) {
        this.statisticsListeners.splice(index, 1);
      }
    };
  }

  /**
   * é€šçŸ¥ç”¨æˆ·å˜æ›´
   */
  private notifyUserChanged(): void {
    const user = this.getCurrentUser();
    for (const listener of this.userChangeListeners) {
      try {
        listener(user);
      } catch (error) {
        Logger.error(TAG, `Error in user change listener: ${error}`);
      }
    }
  }

  /**
   * é€šçŸ¥è®¤è¯çŠ¶æ€å˜æ›?   */
  private notifyAuthStatusChanged(): void {
    for (const listener of this.authStatusListeners) {
      try {
        listener(this.authStatus);
      } catch (error) {
        Logger.error(TAG, `Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}` instanceof Error ? `Error in auth status listener: ${error}` : new Error(String(`Error in auth status listener: ${error}`)))))));
      }
    }
  }

  /**
   * é€šçŸ¥åå¥½è®¾ç½®å˜æ›´
   */
  private notifyPreferenceChanged(): void {
    const preferences = this.getUserPreferences();
    for (const listener of this.preferenceListeners) {
      try {
        listener(preferences);
      } catch (error) {
        Logger.error(TAG, `Error in preference listener: ${error}`);
      }
    }
  }

  /**
   * é€šçŸ¥ç»Ÿè®¡ä¿¡æ¯å˜æ›´
   */
  private notifyStatisticsChanged(): void {
    const statistics = this.getUserStatistics();
    for (const listener of this.statisticsListeners) {
      try {
        listener(statistics);
      } catch (error) {
        Logger.error(TAG, `Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}` instanceof Error ? `Error in statistics listener: ${error}` : new Error(String(`Error in statistics listener: ${error}`)))))));
      }
    }
  }

  /**
   * å¯¼å‡ºç”¨æˆ·æ•°æ®
   */
  public async exportUserData(): Promise<{ user?: User | null; exportDate: number; appVersion: string } | null> {
    if (!this.currentUser) {
      return null;
    }
    
    try {
      // å‡†å¤‡å¯¼å‡ºæ•°æ®
      const exportData = {
        user: {
          id: this.currentUser.id,
          username: this.currentUser.username,
          nickname: this.currentUser.nickname,
          email: this.currentUser.email,
          phone: this.currentUser.phone,
          avatar: this.currentUser.avatar,
          preferences: this.currentUser.preferences,
          statistics: this.currentUser.statistics,
          createdAt: this.currentUser.createdAt,
          updatedAt: this.currentUser.updatedAt
        },
        exportDate: Date.now(),
        appVersion: '1.0.0' // åº”è¯¥ä»åº”ç”¨é…ç½®ä¸­è·å–
      };
      
      Logger.info(TAG, 'User data exported successfully');
      return exportData;
    } catch (error) {
      Logger.error(TAG, `Failed to export user data: ${error}`);
      return null;
    }
  }

  /**
   * æ¸…ç†ç”¨æˆ·æ•°æ®ï¼ˆç”¨äºè´¦æˆ·åˆ é™¤ç­‰åœºæ™¯ï¼?   */
  public async clearAllUserData(): Promise<boolean> {
    try {
      // æ¸…é™¤æ‰€æœ‰ç”¨æˆ·ç›¸å…³æ•°æ?      await Promise.all([
        StorageUtil.remove(USER_DATA_KEY), StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY instanceof Error ? StorageUtil.remove(AUTH_TOKEN_KEY : new Error(String(StorageUtil.remove(AUTH_TOKEN_KEY))))))),
        StorageUtil.remove(USER_PREFERENCES_KEY),
        StorageUtil.remove(AUTO_LOGIN_KEY)
      ]);
      
      // æ¸…é™¤æ•°æ®åº“ä¸­çš„ç”¨æˆ·æ•°æ?      await this.databaseManager.clearUserData();
      
      // é‡ç½®çŠ¶æ€?      this.setGuestMode();
      
      Logger.info(TAG, 'All user data cleared');
      return true;
    } catch (error) {
      Logger.error(TAG, `Failed to clear user data: ${error}`);
      return false;
    }
  }

  /**
   * å…³é—­ç”¨æˆ·æœåŠ¡
   */
  public async close(): Promise<void> {
    try {
      // æ¸…ç†ç›‘å¬å™?      this.userChangeListeners = [];
      this.authStatusListeners = [];
      this.preferenceListeners = [];
      this.statisticsListeners = [];
      
      // ä¿å­˜å½“å‰çŠ¶æ€?      if (this.currentUser) {
        await this.saveUserData();
      }
      
      Logger.info(TAG, 'User service closed' instanceof Error ? 'User service closed' : new Error(String('User service closed' instanceof Error ? 'User service closed' instanceof Error ? 'User service closed' : new Error(String('User service closed' : new Error(String('User service closed' instanceof Error ? 'User service closed' : new Error(String('User service closed' instanceof Error ? 'User service closed' instanceof Error ? 'User service closed' : new Error(String('User service closed' instanceof Error ? 'User service closed' instanceof Error ? 'User service closed' : new Error(String('User service closed' : new Error(String('User service closed' instanceof Error ? 'User service closed' : new Error(String('User service closed' : new Error(String('User service closed' instanceof Error ? 'User service closed' : new Error(String('User service closed' instanceof Error ? 'User service closed' instanceof Error ? 'User service closed' : new Error(String('User service closed' : new Error(String('User service closed' instanceof Error ? 'User service closed' : new Error(String('User service closed')))))));
    } catch (error) {
      Logger.error(TAG, `Error closing user service: ${error}`);
    }
  }
}


