/**
 * EnhancedInput.ets
 * å¢å¼ºå‹è¾“å…¥æ¡†ç»„ä»¶ - ä¸“ä¸ºTVåº”ç”¨ä¼˜åŒ–çš„ArkTSè¾“å…¥æ¡†å®ç°
 */

import { Component, Prop, State, Builder, AboutToAppear } from '@ohos/arkui'
import { FocusStyle } from '../../common/style/FocusStyle'

// ==================== ç±»å‹å®šä¹‰ ====================

export type InputType = 'text' | 'password' | 'number' | 'email' | 'tel' | 'url'
export type InputSize = 'small' | 'medium' | 'large'
export type InputVariant = 'outlined' | 'filled' | 'standard'

export interface EnhancedInputProps {
  // åŸºç¡€å±æ€§
  value?: string
  placeholder?: string
  type?: InputType
  size?: InputSize
  variant?: InputVariant
  
  // çŠ¶æ€æ§åˆ¶
  disabled?: boolean
  readOnly?: boolean
  required?: boolean
  
  // äº¤äº’å±æ€§
  focusable?: boolean
  autoFocus?: boolean
  clearable?: boolean
  
  // æ ·å¼å®šåˆ¶
  width?: string | number
  height?: string | number
  maxLength?: number
  customStyle?: Record<string, any>
  
  // å‰åç¼€
  prefix?: string
  suffix?: string
  prefixIcon?: string
  suffixIcon?: string
  
  // äº‹ä»¶å›è°ƒ
  onChange?: (value: string) => void
  onInput?: (value: string) => void
  onFocus?: () => void
  onBlur?: () => void
  onClear?: () => void
  onSubmit?: (value: string) => void
}

// ==================== ä¸»é¢˜é…ç½® ====================

const INPUT_THEMES = {
  outlined: {
    normal: { 
      bg: '#FFFFFF', 
      border: '#D1D1D6', 
      text: '#000000',
      placeholder: '#8E8E93'
    },
    focused: { 
      bg: '#FFFFFF', 
      border: '#007AFF', 
      text: '#000000',
      placeholder: '#8E8E93'
    },
    disabled: { 
      bg: '#F2F2F7', 
      border: '#E5E5EA', 
      text: '#8E8E93',
      placeholder: '#C7C7CC'
    }
  },
  filled: {
    normal: { 
      bg: '#F2F2F7', 
      border: 'transparent', 
      text: '#000000',
      placeholder: '#8E8E93'
    },
    focused: { 
      bg: '#E5E5EA', 
      border: 'transparent', 
      text: '#000000',
      placeholder: '#8E8E93'
    },
    disabled: { 
      bg: '#F2F2F7', 
      border: 'transparent', 
      text: '#8E8E93',
      placeholder: '#C7C7CC'
    }
  },
  standard: {
    normal: { 
      bg: 'transparent', 
      border: 'transparent', 
      text: '#000000',
      placeholder: '#8E8E93',
      underline: '#D1D1D6'
    },
    focused: { 
      bg: 'transparent', 
      border: 'transparent', 
      text: '#000000',
      placeholder: '#8E8E93',
      underline: '#007AFF'
    },
    disabled: { 
      bg: 'transparent', 
      border: 'transparent', 
      text: '#8E8E93',
      placeholder: '#C7C7CC',
      underline: '#E5E5EA'
    }
  }
}

const SIZE_CONFIGS = {
  small: { 
    height: 40, 
    fontSize: 14, 
    padding: '8vp 12vp',
    iconSize: 16
  },
  medium: { 
    height: 48, 
    fontSize: 16, 
    padding: '12vp 16vp',
    iconSize: 20
  },
  large: { 
    height: 56, 
    fontSize: 18, 
    padding: '16vp 20vp',
    iconSize: 24
  }
}

// ==================== å¢å¼ºå‹è¾“å…¥æ¡†ç»„ä»¶ ====================

@Component
export struct EnhancedInput {
  // Props
  @Prop value: string = ''
  @Prop placeholder: string = 'è¯·è¾“å…¥å†…å®¹'
  @Prop type: InputType = 'text'
  @Prop size: InputSize = 'medium'
  @Prop variant: InputVariant = 'outlined'
  @Prop disabled: boolean = false
  @Prop readOnly: boolean = false
  @Prop required: boolean = false
  @Prop focusable: boolean = true
  @Prop autoFocus: boolean = false
  @Prop clearable: boolean = false
  @Prop width: string | number = '100%'
  @Prop height: string | number = 'auto'
  @Prop maxLength: number = 1000
  @Prop customStyle: Record<string, any> = {}
  @Prop prefix: string = ''
  @Prop suffix: string = ''
  @Prop prefixIcon: string = ''
  @Prop suffixIcon: string = ''
  @Prop onChange: (value: string) => void = () => {}
  @Prop onInput: (value: string) => void = () => {}
  @Prop onFocus: () => void = () => {}
  @Prop onBlur: () => void = () => {}
  @Prop onClear: () => void = () => {}
  @Prop onSubmit: (value: string) => void = () => {}
  
  // State
  @State currentValue: string = ''
  @State isFocused: boolean = false
  @State isHovered: boolean = false
  @State showPassword: boolean = false
  
  // Private properties
  private focusStyle: FocusStyle = new FocusStyle()
  private animationDuration: number = 200
  
  @AboutToAppear
  aboutToAppear(): void {
    this.currentValue = this.value
    
    // åˆå§‹åŒ–ç„¦ç‚¹æ ·å¼
    this.focusStyle.setBorder({
      width: 2,
      color: '#007AFF',
      radius: 8
    })
    this.focusStyle.setShadow({
      color: 'rgba(0,122,255,0.2)',
      radius: 8,
      offsetX: 0,
      offsetY: 2
    })
  }
  
  // ==================== è®¡ç®—å±æ€§ ====================
  
  private getThemeConfig() {
    return INPUT_THEMES[this.variant] || INPUT_THEMES.outlined
  }
  
  private getSizeConfig() {
    return SIZE_CONFIGS[this.size] || SIZE_CONFIGS.medium
  }
  
  private getCurrentState() {
    if (this.disabled) return 'disabled'
    if (this.isFocused) return 'focused'
    return 'normal'
  }
  
  private getBackgroundColor(): string {
    const state = this.getCurrentState()
    return this.getThemeConfig()[state].bg
  }
  
  private getBorderColor(): string {
    const state = this.getCurrentState()
    return this.getThemeConfig()[state].border
  }
  
  private getTextColor(): string {
    const state = this.getCurrentState()
    return this.getThemeConfig()[state].text
  }
  
  private getPlaceholderColor(): string {
    const state = this.getCurrentState()
    return this.getThemeConfig()[state].placeholder
  }
  
  private getUnderlineColor(): string {
    if (this.variant !== 'standard') return 'transparent'
    const state = this.getCurrentState()
    return this.getThemeConfig()[state].underline || 'transparent'
  }
  
  private getOpacity(): number {
    return this.disabled ? 0.6 : 1.0
  }
  
  private getInputType(): InputType {
    if (this.type === 'password' && this.showPassword) {
      return 'text'
    }
    return this.type
  }
  
  private shouldShowClear(): boolean {
    return this.clearable && !this.disabled && this.currentValue.length > 0
  }
  
  private shouldShowPasswordToggle(): boolean {
    return this.type === 'password' && !this.disabled
  }
  
  // ==================== äº‹ä»¶å¤„ç† ====================
  
  private handleInputChange(value: string): void {
    if (this.disabled || this.readOnly) return
    
    this.currentValue = value
    this.onInput(value)
  }
  
  private handleValueChange(value: string): void {
    if (this.disabled || this.readOnly) return
    
    this.currentValue = value
    this.onChange(value)
  }
  
  private handleSubmit(value: string): void {
    if (this.disabled || this.readOnly) return
    
    this.onSubmit(value)
  }
  
  private handleFocus(): void {
    if (this.disabled) return
    this.isFocused = true
    this.onFocus()
  }
  
  private handleBlur(): void {
    if (this.disabled) return
    this.isFocused = false
    this.onBlur()
  }
  
  private handleHover(enter: boolean): void {
    if (this.disabled) return
    this.isHovered = enter
  }
  
  private handleClear(): void {
    if (this.disabled || this.readOnly) return
    
    this.currentValue = ''
    this.onChange('')
    this.onClear()
  }
  
  private handlePasswordToggle(): void {
    if (this.disabled || this.readOnly) return
    this.showPassword = !this.showPassword
  }
  
  // ==================== æ¸²æŸ“æ–¹æ³• ====================
  
  @Builder
  private renderPrefix(): void {
    if (this.prefix || this.prefixIcon) {
      Row() {
        if (this.prefixIcon) {
          // å›¾æ ‡å‰ç¼€
          Text(this.prefixIcon)
            .fontSize(this.getSizeConfig().iconSize)
            .fontColor(this.getTextColor())
            .margin({ right: 8 })
        }
        
        if (this.prefix) {
          // æ–‡æœ¬å‰ç¼€
          Text(this.prefix)
            .fontSize(this.getSizeConfig().fontSize - 2)
            .fontColor(this.getTextColor())
            .margin({ right: 8 })
        }
      }
      .alignItems(VerticalAlign.Center)
    }
  }
  
  @Builder
  private renderSuffix(): void {
    Row() {
      // å¯†ç åˆ‡æ¢æŒ‰é’®
      if (this.shouldShowPasswordToggle()) {
        Button() {
          Text(this.showPassword ? 'ğŸ‘ï¸' : 'ğŸ”’')
            .fontSize(this.getSizeConfig().iconSize - 4)
            .fontColor(this.getTextColor())
        }
        .width(32)
        .height(32)
        .backgroundColor('transparent')
        .borderRadius(16)
        .margin({ right: 8 })
        .onClick(() => this.handlePasswordToggle())
      }
      
      // æ¸…é™¤æŒ‰é’®
      if (this.shouldShowClear()) {
        Button() {
          Text('âœ•')
            .fontSize(this.getSizeConfig().iconSize - 4)
            .fontColor(this.getPlaceholderColor())
        }
        .width(32)
        .height(32)
        .backgroundColor('transparent')
        .borderRadius(16)
        .margin({ right: 8 })
        .onClick(() => this.handleClear())
      }
      
      if (this.suffix || this.suffixIcon) {
        if (this.suffixIcon) {
          // å›¾æ ‡åç¼€
          Text(this.suffixIcon)
            .fontSize(this.getSizeConfig().iconSize)
            .fontColor(this.getTextColor())
            .margin({ left: 8 })
        }
        
        if (this.suffix) {
          // æ–‡æœ¬åç¼€
          Text(this.suffix)
            .fontSize(this.getSizeConfig().fontSize - 2)
            .fontColor(this.getTextColor())
            .margin({ left: 8 })
        }
      }
    }
    .alignItems(VerticalAlign.Center)
  }
  
  @Builder
  private renderTextInput(): void {
    TextInput({ 
      placeholder: this.required ? `${this.placeholder} *` : this.placeholder,
      text: this.currentValue
    })
    .placeholderColor(this.getPlaceholderColor())
    .caretColor('#007AFF')
    .maxLength(this.maxLength)
    .readOnly(this.readOnly)
    .onChange((value: string) => this.handleInputChange(value))
    .onSubmit((value: string) => this.handleSubmit(value))
    .textInputStyle({
      fontSize: this.getSizeConfig().fontSize,
      fontColor: this.getTextColor()
    })
    .layoutWeight(1)
  }
  
  @Builder
  private renderFocusIndicator(): void {
    if (this.isFocused) {
      Stack()
        .width('100%')
        .height('100%')
        .border({
          width: this.focusStyle.border.width,
          color: this.focusStyle.border.color,
          radius: this.focusStyle.border.radius
        })
        .shadow({
          radius: this.focusStyle.shadow.radius,
          color: this.focusStyle.shadow.color,
          offsetX: this.focusStyle.shadow.offsetX,
          offsetY: this.focusStyle.shadow.offsetY
        })
    }
  }
  
  build() {
    Row() {
      // å‰ç¼€
      this.renderPrefix()
      
      // è¾“å…¥æ¡†ä¸»ä½“
      this.renderTextInput()
      
      // åç¼€
      this.renderSuffix()
    }
    .width(this.width)
    .height(this.height === 'auto' ? this.getSizeConfig().height : this.height)
    .padding(this.getSizeConfig().padding)
    .backgroundColor(this.getBackgroundColor())
    .border({
      width: this.variant === 'standard' ? 0 : 1,
      color: this.getBorderColor(),
      radius: 8
    })
    .border({ // ä¸‹åˆ’çº¿ï¼ˆä»…standardå˜ä½“ï¼‰
      width: this.variant === 'standard' ? 0 : 0,
      color: 'transparent',
      radius: 0,
      bottom: this.variant === 'standard' ? 2 : 0,
      bottomColor: this.getUnderlineColor()
    })
    .opacity(this.getOpacity())
    .focusable(this.focusable && !this.disabled)
    .autoFocus(this.autoFocus)
    .onFocus(() => this.handleFocus())
    .onBlur(() => this.handleBlur())
    .onHover((isHover: boolean) => this.handleHover(isHover))
    {
      // ç„¦ç‚¹æŒ‡ç¤ºå™¨
      this.renderFocusIndicator()
    }
    // åº”ç”¨è‡ªå®šä¹‰æ ·å¼
    .attrs(this.customStyle)
  }
}

// ==================== ä¾¿æ·å·¥å‚æ–¹æ³• ====================

export const createInput = (props: EnhancedInputProps): EnhancedInput => {
  return new EnhancedInput(props)
}

export const OutlinedInput = (props: Omit<EnhancedInputProps, 'variant'>): EnhancedInput => {
  return new EnhancedInput({ ...props, variant: 'outlined' })
}

export const FilledInput = (props: Omit<EnhancedInputProps, 'variant'>): EnhancedInput => {
  return new EnhancedInput({ ...props, variant: 'filled' })
}

export const StandardInput = (props: Omit<EnhancedInputProps, 'variant'>): EnhancedInput => {
  return new EnhancedInput({ ...props, variant: 'standard' })
}

// ==================== å¯¼å‡ºç±»å‹ ====================

export type { InputType, InputSize, InputVariant, EnhancedInputProps }