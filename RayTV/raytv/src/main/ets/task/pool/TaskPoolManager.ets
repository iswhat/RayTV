// TaskPoolManager - æµ è¯²å§Ÿå§¹çŠµî…¸éå——æ«?import Logger from '../../common/util/Logger';
import taskPool from '@ohos.taskpool';
import MemoryManager from '../../common/util/MemoryManager';

const TAG = 'TaskPoolManager';

/**
 * æµ è¯²å§Ÿæµ¼æ¨ºå›ç»¾Ñ„ç‡é”? */
export enum TaskPriority {
  LOW = 0,
  NORMAL = 1,
  HIGH = 2,
  CRITICAL = 3
}

/**
 * æµ è¯²å§Ÿé˜èˆµâ‚¬ä½¹ç‡é”? */
export enum TaskStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}

/**
 * æµ è¯²å§Ÿéºãƒ¥å½›ç€¹æ°«ç®? */
export interface Task<T = unknown> {
  id: string;
  priority: TaskPriority;
  execute: () => Promise<T>;
  onComplete?: (result: T) => void;
  onError?: (error: Error) => void;
  onCancel?: () => void;
  timeout?: number;
}

/**
 * æµ è¯²å§Ÿå§¹çŠµî…¸éå——æ«? * é»æ„ªç·µé©è½°ç°¬TaskPoolé¨å‹ªæ¢é”Â¤çšŸæ´ï¹€æ‹°ç» ï¼„æ‚Šé”ç†»å…? */
export class TaskPoolManager {
  static instance: TaskPoolManager;
  taskQueue: Task[] = [];
  runningTasks: Map<string, Task> = new Map();
  maxConcurrentTasks: number = 3;
  isProcessing: boolean = false;
  memoryManager: MemoryManager;

  /**
   * é‹å‹¯â‚¬çŠ²åš±é”Ÿ?   */
  constructor() {
    Logger.info(TAG, 'TaskPoolManager initialized');
    this.memoryManager = MemoryManager.getInstance();
  }

  /**
   * é‘¾å³°å½‡é—æ›šç·¥ç€¹ç‚°ç·?   */
  static getInstance(): TaskPoolManager {
    if (!TaskPoolManager.instance) {
      TaskPoolManager.instance = new TaskPoolManager();
    }
    return TaskPoolManager.instance;
  }

  /**
   * ç’å‰§ç–†éˆâ‚¬æ¾¶Ñƒè‹Ÿé™æˆœæ¢é”â„ƒæš?   * @param max éˆâ‚¬æ¾¶Ñƒè‹Ÿé™æˆœæ¢é”â„ƒæšŸ
   */
  setMaxConcurrentTasks(max: number): void {
    if (max > 0) {
      this.maxConcurrentTasks = max;
      Logger.info(TAG, `Max concurrent tasks set to: ${max}`);
      // é–²å¶†æŸŠæ¾¶å‹­æ‚Šé—ƒç†·å?      this.processQueue();
    }
  }

  /**
   * é»æ„ªæ°¦æµ è¯²å§Ÿé’ä¼´æ§¦é”Ÿ?   * @param task æµ è¯²å§Ÿç€µç¡…è–?   */
  submit<T = unknown>(task: Task<T>): void {
    if (!task || !task.execute) {
      Logger.error(TAG, 'Invalid task submitted');
      return;
    }

    // å¨£è¯²å§é’é¢æ¢é”ï¿ æ§¦é”Ÿ?    this.taskQueue.push(task);
    Logger.debug(TAG, `Task ${task.id} submitted with priority: ${task.priority}`);

    // é¸å¤‰ç´­éå ¢éª‡éºæ‘ç°?    this.sortTasks();

    // å¯®â‚¬æ¿®å¬ªî˜©éå—›æ§¦é”?    this.processQueue();
  }
  
  /**
   * çå—šåšœç€¹æ°«ç®Ÿæµ¼æ¨ºå›ç»¾Ñ†æµ†é¹î­è´ŸTaskPoolæµ¼æ¨ºå›é”Ÿ?   * @param priority é‘·î„ç•¾æ¶”å¤‰ç´­éå ¢éª?   * @returns taskPool.Priority ç€µç‘°ç°²é¨å‡¾askPoolæµ¼æ¨ºå›é”Ÿ?   */
  getTaskPoolPriority(priority: TaskPriority): taskPool.Priority {
    switch (priority) {
      case TaskPriority.HIGH:
      case TaskPriority.CRITICAL:
        return taskPool.Priority.HIGH;
      case TaskPriority.NORMAL:
        return taskPool.Priority.MEDIUM;
      case TaskPriority.LOW:
        return taskPool.Priority.LOW;
      default:
        return taskPool.Priority.MEDIUM;
    }
  }

  /**
   * éµÑ†î”‘é—æ›šé‡œæµ è¯²å§Ÿ
   * @param task ç‘•ä½¹å¢½ç›å²€æ®‘æµ è¯²å§Ÿ
   */
  async execute<T = unknown>(task: Task<T>): Promise<T> {
    if (!task || !task.execute) {
      throw new Error('Invalid task');
    }

    const taskId = task.id || `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    task.id = taskId;

    return new Promise((resolve, reject) => {
      const timeoutId = task.timeout ? setTimeout(() => {
        const error = new Error(`Task ${taskId} timed out after ${task.timeout}ms`);
        this.handleTaskError(task, error);
        reject(error);
      }, task.timeout) : null;

      this.submit({
        ...task,
        id: taskId,
        onComplete: (result: T) => {
          if (timeoutId) clearTimeout(timeoutId);
          task.onComplete?.(result);
          resolve(result);
        },
        onError: (error: Error) => {
          if (timeoutId) clearTimeout(timeoutId);
          task.onError?.(error);
          reject(error);
        }
      });
    });
  }

  /**
   * é™æ ¨ç§·æµ è¯²å§Ÿ
   * @param taskId æµ è¯²å§ŸID
   * @returns é„îˆšæƒé´æ„¬å§›é™æ ¨ç§?   */
  cancelTask(taskId: string): boolean {
    // å¦«â‚¬éŒãƒ¨ç¹ç›å±¼è…‘é¨å‹ªæ¢é”Ÿ?    const runningTask = this.runningTasks.get(taskId);
    if (runningTask) {
      // éå›ªî†‡æ¶“å“„å½‡å¨‘å ¢å§¸é”Ÿ?      this.runningTasks.delete(taskId);
      try {
        runningTask.onCancel?.();
      } catch (error) {
        Logger.error(TAG, `Error in task ${taskId} onCancel callback: ${(error as Error).message}`);
      }
      Logger.info(TAG, `Running task ${taskId} cancelled`);
      return true;
    }

    // å¦«â‚¬éŒãƒ©æ§¦é’æ¤¾è…‘é¨å‹ªæ¢é”Ÿ?    const index = this.taskQueue.findIndex(task => task.id === taskId);
    if (index !== -1) {
      const task = this.taskQueue[index];
      this.taskQueue.splice(index, 1);
      try {
        task.onCancel?.();
      } catch (error) {
        Logger.error(TAG, `Error in task ${taskId} onCancel callback: ${(error as Error).message}`);
      }
      Logger.info(TAG, `Queued task ${taskId} cancelled`);
      return true;
    }

    Logger.warn(TAG, `Task ${taskId} not found`);
    return false;
  }

  /**
   * å¨“å‘¯â”–æµ è¯²å§Ÿé—ƒç†·å?   */
  public clearQueue(): void {
    for (const task of this.taskQueue) {
      try {
        task.onCancel?.();
      } catch (error) {
        Logger.error(TAG, `Error in task onCancel callback: ${(error as Error).message}`);
      }
    }
    this.taskQueue = [];
    Logger.info(TAG, 'Task queue cleared');
  }

  /**
   * é‘¾å³°å½‡æµ è¯²å§Ÿé˜è®¹æ‹?   * @param taskId æµ è¯²å§ŸID
   * @returns æµ è¯²å§Ÿé˜èˆµâ‚¬ä¾Šç´æ¿¡å‚›ç‰æµ è¯²å§Ÿæ¶“å¶…ç“¨é¦ã„¨ç¹‘é¥ç€—ull
   */
  public getTaskStatus(taskId: string): TaskStatus | null {
    if (this.runningTasks.has(taskId)) {
      return TaskStatus.RUNNING;
    }
    const task = this.taskQueue.find(t => t.id === taskId);
    if (task) {
      return TaskStatus.PENDING;
    }
    return null;
  }

  /**
   * é‘¾å³°å½‡è¤°æ’³å¢ æ©æ„¯î”‘æ¶“î… æ®‘æµ è¯²å§Ÿéä¼´å™º
   */
  public getRunningTaskCount(): number {
    return this.runningTasks.size;
  }

  /**
   * é‘¾å³°å½‡è¤°æ’³å¢ é—ƒç†·åªæ¶“î… æ®‘æµ è¯²å§Ÿéä¼´å™º
   */
  public getQueuedTaskCount(): number {
    return this.taskQueue.length;
  }

  /**
   * é¸å¤‰ç´­éå ¢éª‡éºæ‘ç°­æµ è¯²å§Ÿé—ƒç†·å?   */
  private sortTasks(): void {
    this.taskQueue.sort((a, b) => b.priority - a.priority);
  }

  /**
   * æ¾¶å‹­æ‚Šæµ è¯²å§Ÿé—ƒç†·å?   */
  private processQueue(): void {
    if (this.isProcessing) return;
    
    this.isProcessing = true;
    
    try {
      // é”ã„¦â‚¬ä½½çšŸéæ‘è‹Ÿé™æˆœæ¢é”â„ƒæšŸé©è½°ç°¬éå‘­ç“¨æµ£è·¨æ•¤é¯å‘­å–Œ
      const memoryStats = this.memoryManager.getMemoryStats();
      const adjustedMaxConcurrentTasks = this.calculateOptimalConcurrentTasks(memoryStats.currentUsage);
      
      // éµÑ†î”‘çè—‰å½²é‘³è—‰î˜¿é¨å‹«è‹Ÿé™æˆœæ¢é”?      while (
        this.runningTasks.size < adjustedMaxConcurrentTasks &&
        this.taskQueue.length > 0
      ) {
        // é¦ã„¦ç˜¡å¨†â„ƒå¢½ç›å±¼æ¢é”â€³å¢ é–²å¶†æŸŠå¦«â‚¬éŒãƒ¥å”´ç€›æ¨ºå½²é¢îŸ’æ‹·?        if (!this.memoryManager.checkMemoryAvailability()) {
          Logger.warn(TAG, `Insufficient memory to process tasks (${(memoryStats.currentUsage * 100).toFixed(1)}%), pausing queue`);
          // çæ¿Šç˜¯å¨“å‘¯æ‚Šéå‘­ç“?          this.memoryManager.clearMemory();
          // å¯¤æƒ°ç¹œé–²å¶ˆç˜¯é”›å±¾ç‰´é¹î†¼å”´ç€›æ¨¹å¨‡é¢ã„¦å„éé›å§©é¬ä½½çšŸéæ‘æ¬¢æ©ç†¸æ¤‚é”?          const retryDelay = this.calculateRetryDelay(memoryStats.currentUsage);
          setTimeout(() => this.processQueue(), retryDelay);
          return;
        }
        
        const task = this.taskQueue.shift();
        if (task) {
          this.executeTask(task);
        }
      }
      
      // æ¿¡å‚›ç‰é—ƒç†·åªæ¶“å¶„è´Ÿç»Œè½°çµ¾å¨Œâ„ƒæ¹éµÑ†î”‘æµ è¯²å§Ÿé”›å±½å½²é‘³èŠ¥æ§¸é¥çŠ±è´Ÿéå‘­ç“¨æ¶“å¶ˆå†?      if (this.taskQueue.length > 0 && this.runningTasks.size < this.maxConcurrentTasks) {
        Logger.info(TAG, `Task queue has ${this.taskQueue.length} tasks, but running at capacity (${this.runningTasks.size}/${adjustedMaxConcurrentTasks})`);
      }
    } finally {
      this.isProcessing = false;
      
      // æ¿¡å‚›ç‰æ©æ¨»æ¹æµ è¯²å§Ÿé¦ã„©æ§¦é’æ¤¾è…‘æ¶“æ—€ç—…éˆå¤æªé’ç‰ˆæ¸¶æ¾¶Ñƒè‹Ÿé™æˆæšŸé”›å²€æˆ·ç¼î…î˜©é”?      if (this.taskQueue.length > 0 && this.runningTasks.size < this.maxConcurrentTasks) {
        setTimeout(() => this.processQueue(), 0);
      }
    }
  }
  
  /**
   * éè§„åµéå‘­ç“¨æµ£è·¨æ•¤é¯å‘­å–Œç’ï¼„ç•»éˆâ‚¬æµ£å†²è‹Ÿé™æˆœæ¢é”â„ƒæšŸ
   * @param memoryUsage è¤°æ’³å¢ éå‘­ç“¨æµ£è·¨æ•¤é”Ÿ?   * @returns ç’‹å†©æš£éšåº£æ®‘éˆâ‚¬æ¾¶Ñƒè‹Ÿé™æˆœæ¢é”â„ƒæšŸ
   */
  private calculateOptimalConcurrentTasks(memoryUsage: number): number {
    // éå‘­ç“¨æµ£è·¨æ•¤éœå›¦ç¶†é”Ÿ?0%é”›æ°«å¨‡é¢ã„¦æ¸¶æ¾¶Ñƒè‹Ÿé™æˆæš?    if (memoryUsage < 0.5) {
      return this.maxConcurrentTasks;
    }
    // éå‘­ç“¨æµ£è·¨æ•¤é”?0%-70%é”›æ°«å¨‡é”Ÿ?5%é¨å‹¬æ¸¶æ¾¶Ñƒè‹Ÿé™æˆæšŸ
    else if (memoryUsage < 0.7) {
      return Math.max(1, Math.floor(this.maxConcurrentTasks * 0.75));
    }
    // éå‘­ç“¨æµ£è·¨æ•¤é”?0%-85%é”›æ°«å¨‡é”Ÿ?0%é¨å‹¬æ¸¶æ¾¶Ñƒè‹Ÿé™æˆæšŸ
    else if (memoryUsage < 0.85) {
      return Math.max(1, Math.floor(this.maxConcurrentTasks * 0.5));
    }
    // éå‘­ç“¨æµ£è·¨æ•¤éœå›¬ç®é”Ÿ?5%é”›æ°¬å½§éä½½î†1æ¶“î„è‹Ÿé™æˆœæ¢é”?    else {
      return 1;
    }
  }
  
  /**
   * éè§„åµéå‘­ç“¨æµ£è·¨æ•¤é¯å‘­å–Œç’ï¼„ç•»é–²å¶ˆç˜¯å¯¤æƒ°ç¹?   * @param memoryUsage è¤°æ’³å¢ éå‘­ç“¨æµ£è·¨æ•¤é”Ÿ?   * @returns é–²å¶ˆç˜¯å¯¤æƒ°ç¹œéƒå •æ£¿é”›å Ÿî‡ ç»‰æç´?   */
  private calculateRetryDelay(memoryUsage: number): number {
    // éå‘­ç“¨æµ£è·¨æ•¤ç“’å©‡ç®é”›å²„å™¸ç’‡æ›æ¬¢æ©ç†»ç§ºé”?    if (memoryUsage < 0.7) return 1000;     // 70%æµ ãƒ¤ç¬…é”Ÿ?é”?    if (memoryUsage < 0.8) return 2000;     // 70%-80%é”?é”?    if (memoryUsage < 0.9) return 3000;     // 80%-90%é”?é”?    return 5000;                            // 90%æµ ãƒ¤ç¬‚é”Ÿ?é”?  }

  /**
   * éµÑ†î”‘é—æ›šé‡œæµ è¯²å§Ÿ
   * @param task ç‘•ä½¹å¢½ç›å²€æ®‘æµ è¯²å§Ÿ
   */
  private async executeTask(task: Task): Promise<void> {
    if (!task.id) {
      task.id = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    this.runningTasks.set(task.id, task);
    Logger.debug(TAG, `Task ${task.id} started execution with priority ${task.priority}`);
    
    // ç’æ¿ç¶æµ è¯²å§Ÿå¯®â‚¬æ¿®å¬ªå¢ é¨å‹«å”´ç€›æ¨¹å¨‡é¢ã„¦å„é”?    const startMemoryUsage = this.memoryManager.getCurrentMemoryUsage();
    const startTime = Date.now();

    try {
      // éè§„åµæµ è¯²å§Ÿæµ¼æ¨ºå›ç»¾Ñƒæ‹°éå‘­ç“¨é¯å‘­å–Œé”ã„¦â‚¬ä½½çšŸéç¿ æ¢é”ï¿ å¤é”?      const memoryStats = this.memoryManager.getMemoryStats();
      const taskOptions = this.createOptimizedTaskOptions(task.priority, memoryStats);
      
      // æµ£è·¨æ•¤TaskPooléµÑ†î”‘æµ è¯²å§Ÿé”›å±½ç–„éœæ‰®æ¹¡å§ï½‡æ®‘ç»¯è¤ç²ºç»¾Ñƒè‹Ÿé”Ÿ?      const taskFunction = async () => {
        try {
          return await task.execute();
        } catch (error) {
          Logger.error(TAG, `Task function execution error: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      };

      // éµÑ†î”‘æµ è¯²å§?      const result = await taskPool.execute(taskFunction, taskOptions);
      
      // æ¾¶å‹­æ‚Šç€¹å±¾å?      this.handleTaskComplete(task, result);
      
      // ç’æ¿ç¶æµ è¯²å§Ÿç€¹å±¾åšéšåº£æ®‘éå‘­ç“¨æµ£è·¨æ•¤é¯å‘­å–Œé”›å²€æ´ƒéºÑƒå”´ç€›æ¨»ç¡ é”Ÿ?      this.logTaskMemoryUsage(task.id, startMemoryUsage, startTime);
    } catch (error) {
      // æ¾¶å‹­æ‚Šé–¿æ¬’î‡¤
      this.handleTaskError(task, error as Error);
    } finally {
      // æµ åº¤ç¹ç›å±¼è…‘æµ è¯²å§Ÿç»‰å©šæ«
      this.runningTasks.delete(task.id);
      
      // é¦ã„¤æ¢é”â€³ç•¬é´æ„¬æ‚—éå¶†î‚¼å¦«â‚¬éŒãƒ¥å”´ç€›æ©ˆç´æ¿¡å‚›ç‰éå‘­ç“¨æµ£è·¨æ•¤æ©å›¬ç®çæ¿Šç˜¯å¨“å‘¯æ‚?      this.checkAndCleanupMemory();
      
      // ç¼Ñ…ç”»æ¾¶å‹­æ‚Šé—ƒç†·åª
      this.processQueue();
    }
  }
  
  /**
   * é’æ¶˜ç¼“æµ¼æ¨ºå¯²é¨å‹ªæ¢é”ï¿ â‚¬å¤ã€?   * @param priority æµ è¯²å§Ÿæµ¼æ¨ºå›é”?   * @param memoryStats éå‘­ç“¨ç¼ç†»î…¸æ·‡â„ƒä¼?   * @returns æµ¼æ¨ºå¯²é¨å‹ªæ¢é”ï¿ â‚¬å¤ã€?   */
  private createOptimizedTaskOptions(priority: TaskPriority, memoryStats: { currentUsage: number }): taskPool.TaskOptions {
    const taskOptions: taskPool.TaskOptions = {
      priority: this.getTaskPoolPriority(priority)
    };
    
    // é¦ã„¥å”´ç€›æ¨¼æ£å¯®çŠ³æ¤‚é”›å±½î‡®æµ£åºç´­éå ¢éª‡æµ è¯²å§Ÿæ´æ—‚æ•¤é‡ç¿ å¼—éè‚©æ®‘ç’§å‹¬ç°®é—„æ„¬åŸ?    if (memoryStats.currentUsage > 0.8 && priority <= TaskPriority.NORMAL) {
      Logger.info(TAG, `Applying resource limits for low priority task due to high memory usage (${(memoryStats.currentUsage * 100).toFixed(1)}%)`);
      // å¨‰ã„¦å‰°é”›æ­askPoolé™îˆå…˜æ¶“å¶‡æ´¿éºãƒ¦æ•®é¸ä½½ç¹–æµœæ¶¢â‚¬å¤ã€é”›å²ƒç¹–é–²å±¼ç²æµ£æ»€è´Ÿç»€è½°ç·¥
      // taskOptions.maxMemoryUsage = 0.1; // é—„æ„¬åŸ—æµ è¯²å§Ÿéå‘­ç“¨æµ£è·¨æ•¤
    }
    
    return taskOptions;
  }
  
  /**
   * ç’æ¿ç¶æµ è¯²å§Ÿé¨å‹«å”´ç€›æ¨¹å¨‡é¢ã„¦å„é”?   * @param taskId æµ è¯²å§ŸID
   * @param startUsage å¯®â‚¬æ¿®å¬«æ¤‚é¨å‹«å”´ç€›æ¨¹å¨‡é¢ã„§å·¼
   * @param startTime å¯®â‚¬æ¿®å¬«æ¤‚é”Ÿ?   */
  private logTaskMemoryUsage(taskId: string, startUsage: number, startTime: number): void {
    const endUsage = this.memoryManager.getCurrentMemoryUsage();
    const duration = Date.now() - startTime;
    const memoryDiff = endUsage - startUsage;
    
    // æ¿¡å‚›ç‰éå‘­ç“¨æµ£è·¨æ•¤æ¾§ç‚²å§é”?%æµ ãƒ¤ç¬‚é”›å²ƒî†‡è¤°æ›¡î„Ÿé”Ÿ?    if (memoryDiff > 0.05) {
      Logger.warn(TAG, `Task ${taskId} may be leaking memory: memory usage increased by ${(memoryDiff * 100).toFixed(1)}%`);
    }
    
    if (duration > 10000) { // æµ è¯²å§ŸéµÑ†î”‘ç“’å‘°ç¹ƒ10é”?      Logger.info(TAG, `Long-running task ${taskId} completed in ${duration}ms`);
    }
  }
  
  /**
   * å¦«â‚¬éŒãƒ¥è‹Ÿé¦ã„©æ¸¶ç‘•ä½¹æ¤‚å¨“å‘¯æ‚Šéå‘­ç“?   */
  private checkAndCleanupMemory(): void {
    const memoryUsage = this.memoryManager.getCurrentMemoryUsage();
    
    // è¤°æ’³å”´ç€›æ¨¹å¨‡é¢ã„¨ç§´é”?5%éƒè·ºçš¾ç’‡æ›Ÿç«»é”?    if (memoryUsage > 0.85) {
      Logger.warn(TAG, `Memory usage high (${(memoryUsage * 100).toFixed(1)}%), attempting cleanup`);
      this.memoryManager.clearMemory();
      
      // å¨“å‘¯æ‚Šéšåº¡å•€å¨†â„ƒî—…é”Ÿ?      const afterCleanupUsage = this.memoryManager.getCurrentMemoryUsage();
      const freedMemory = memoryUsage - afterCleanupUsage;
      
      if (freedMemory > 0.05) {
        Logger.info(TAG, `Memory cleanup successful: freed ${(freedMemory * 100).toFixed(1)}%`);
      }
    }
  }

  /**
   * æ¾¶å‹­æ‚Šæµ è¯²å§Ÿç€¹å±¾å?   * @param task æµ è¯²å§Ÿç€µç¡…è–?   * @param result æµ è¯²å§Ÿç¼æ’´ç‰
   */
  private handleTaskComplete<T>(task: Task<T>, result: T): void {
    Logger.debug(TAG, `Task ${task.id} completed successfully`);
    try {
      task.onComplete?.(result);
    } catch (error) {
      Logger.error(TAG, `Error in task ${task.id} onComplete callback: ${(error as Error).message}`);
    }
  }

  /**
   * æ¾¶å‹­æ‚Šæµ è¯²å§Ÿé–¿æ¬’î‡?   * @param task æµ è¯²å§Ÿç€µç¡…è–?   * @param error é–¿æ¬’î‡¤ç€µç¡…è–?   */
  private handleTaskError(task: Task, error: Error): void {
    Logger.error(TAG, `Task ${task.id} failed: ${error.message}`);
    try {
      task.onError?.(error);
    } catch (callbackError) {
      Logger.error(TAG, `Error in task ${task.id} onError callback: ${callbackError instanceof Error ? callbackError.message : String(callbackError)}`);
    }
  }
}

export default TaskPoolManager.getInstance();







