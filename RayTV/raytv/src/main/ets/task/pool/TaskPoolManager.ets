// TaskPoolManager - ä»»åŠ¡æ± ç®¡ç†å™¨
import Logger from '../../common/util/Logger';
import taskPool from '@ohos.taskpool';
import MemoryManager from '../../common/util/MemoryManager';

const TAG = 'TaskPoolManager';

/**
 * ä»»åŠ¡ä¼˜å…ˆçº§æšä¸? */
export enum TaskPriority {
  LOW = 0,
  NORMAL = 1,
  HIGH = 2,
  CRITICAL = 3
}

/**
 * ä»»åŠ¡çŠ¶æ€æšä¸? */
export enum TaskStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}

/**
 * ä»»åŠ¡æ¥å£å®šä¹‰
 */
export interface Task<T = unknown> {
  id: string;
  priority: TaskPriority;
  execute: () => Promise<T>;
  onComplete?: (result: T) => void;
  onError?: (error: Error) => void;
  onCancel?: () => void;
  timeout?: number;
}

/**
 * ä»»åŠ¡æ± ç®¡ç†å™¨
 * æä¾›åŸºäºTaskPoolçš„ä»»åŠ¡è°ƒåº¦å’Œç®¡ç†åŠŸèƒ½
 */
export class TaskPoolManager {
  static instance: TaskPoolManager;
  taskQueue: Task[] = [];
  runningTasks: Map<string, Task> = new Map();
  maxConcurrentTasks: number = 3;
  isProcessing: boolean = false;
  memoryManager: MemoryManager;

  /**
   * æ„é€ å‡½æ•?   */
  constructor() {
    Logger.info(TAG, 'TaskPoolManager initialized');
    this.memoryManager = MemoryManager.getInstance();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): TaskPoolManager {
    if (!TaskPoolManager.instance) {
      TaskPoolManager.instance = new TaskPoolManager();
    }
    return TaskPoolManager.instance;
  }

  /**
   * è®¾ç½®æœ€å¤§å¹¶å‘ä»»åŠ¡æ•°
   * @param max æœ€å¤§å¹¶å‘ä»»åŠ¡æ•°
   */
  setMaxConcurrentTasks(max: number): void {
    if (max > 0) {
      this.maxConcurrentTasks = max;
      Logger.info(TAG, `Max concurrent tasks set to: ${max}`);
      // é‡æ–°å¤„ç†é˜Ÿåˆ—
      this.processQueue();
    }
  }

  /**
   * æäº¤ä»»åŠ¡åˆ°é˜Ÿåˆ?   * @param task ä»»åŠ¡å¯¹è±¡
   */
  submit<T = any>(task: Task<T>): void {
    if (!task || !task.execute) {
      Logger.error(TAG, 'Invalid task submitted');
      return;
    }

    // æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ?    this.taskQueue.push(task);
    Logger.debug(TAG, `Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}` instanceof Error ? `Task ${task.id} submitted with priority: ${task.priority}` : new Error(String(`Task ${task.id} submitted with priority: ${task.priority}`)))))));

    // æŒ‰ä¼˜å…ˆçº§æ’åº
    this.sortTasks();

    // å¼€å§‹å¤„ç†é˜Ÿåˆ?    this.processQueue();
  }
  
  /**
   * å°†è‡ªå®šä¹‰ä¼˜å…ˆçº§è½¬æ¢ä¸ºTaskPoolä¼˜å…ˆçº?   * @param priority è‡ªå®šä¹‰ä¼˜å…ˆçº§
   * @returns taskPool.Priority å¯¹åº”çš„TaskPoolä¼˜å…ˆçº?   */
  getTaskPoolPriority(priority: TaskPriority): taskPool.Priority {
    switch (priority) {
      case TaskPriority.HIGH:
      case TaskPriority.CRITICAL:
        return taskPool.Priority.HIGH;
      case TaskPriority.NORMAL:
        return taskPool.Priority.MEDIUM;
      case TaskPriority.LOW:
        return taskPool.Priority.LOW;
      default:
        return taskPool.Priority.MEDIUM;
    }
  }

  /**
   * æ‰§è¡Œå•ä¸ªä»»åŠ¡
   * @param task è¦æ‰§è¡Œçš„ä»»åŠ¡
   */
  async execute<T = any>(task: Task<T>): Promise<T> {
    if (!task || !task.execute) {
      throw new Error('Invalid task');
    }

    const taskId = task.id || `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    task.id = taskId;

    return new Promise((resolve, reject) => {
      const timeoutId = task.timeout ? setTimeout(() => {
        const error = new Error(`Task ${taskId} timed out after ${task.timeout}ms`);
        this.handleTaskError(task, error);
        reject(error);
      }, task.timeout) : null;

      this.submit({
        ...task,
        id: taskId,
        onComplete: (result: T) => {
          if (timeoutId) clearTimeout(timeoutId);
          task.onComplete?.(result);
          resolve(result);
        },
        onError: (error: Error) => {
          if (timeoutId) clearTimeout(timeoutId);
          task.onError?.(error);
          reject(error);
        }
      });
    });
  }

  /**
   * å–æ¶ˆä»»åŠ¡
   * @param taskId ä»»åŠ¡ID
   * @returns æ˜¯å¦æˆåŠŸå–æ¶ˆ
   */
  cancelTask(taskId: string): boolean {
    // æ£€æŸ¥è¿è¡Œä¸­çš„ä»»åŠ?    const runningTask = this.runningTasks.get(taskId);
    if (runningTask) {
      // æ ‡è®°ä¸ºå–æ¶ˆçŠ¶æ€?      this.runningTasks.delete(taskId);
      try {
        runningTask.onCancel?.();
      } catch (error) {
        Logger.error(TAG, `Error in task ${taskId} onCancel callback: ${(error as Error).message}`);
      }
      Logger.info(TAG, `Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled` instanceof Error ? `Running task ${taskId} cancelled` : new Error(String(`Running task ${taskId} cancelled`)))))));
      return true;
    }

    // æ£€æŸ¥é˜Ÿåˆ—ä¸­çš„ä»»åŠ?    const index = this.taskQueue.findIndex(task => task.id === taskId);
    if (index !== -1) {
      const task = this.taskQueue[index];
      this.taskQueue.splice(index, 1);
      try {
        task.onCancel?.();
      } catch (error) {
        Logger.error(TAG, `Error in task ${taskId} onCancel callback: ${(error as Error).message}`);
      }
      Logger.info(TAG, `Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled` instanceof Error ? `Queued task ${taskId} cancelled` : new Error(String(`Queued task ${taskId} cancelled`)))))));
      return true;
    }

    Logger.warn(TAG, `Task ${taskId} not found`);
    return false;
  }

  /**
   * æ¸…ç©ºä»»åŠ¡é˜Ÿåˆ—
   */
  public clearQueue(): void {
    for (const task of this.taskQueue) {
      try {
        task.onCancel?.();
      } catch (error) {
        Logger.error(TAG, `Error in task onCancel callback: ${(error as Error).message}`);
      }
    }
    this.taskQueue = [];
    Logger.info(TAG, 'Task queue cleared' instanceof Error ? 'Task queue cleared' : new Error(String('Task queue cleared' instanceof Error ? 'Task queue cleared' instanceof Error ? 'Task queue cleared' : new Error(String('Task queue cleared' : new Error(String('Task queue cleared' instanceof Error ? 'Task queue cleared' : new Error(String('Task queue cleared' instanceof Error ? 'Task queue cleared' instanceof Error ? 'Task queue cleared' : new Error(String('Task queue cleared' instanceof Error ? 'Task queue cleared' instanceof Error ? 'Task queue cleared' : new Error(String('Task queue cleared' : new Error(String('Task queue cleared' instanceof Error ? 'Task queue cleared' : new Error(String('Task queue cleared' : new Error(String('Task queue cleared' instanceof Error ? 'Task queue cleared' : new Error(String('Task queue cleared' instanceof Error ? 'Task queue cleared' instanceof Error ? 'Task queue cleared' : new Error(String('Task queue cleared' : new Error(String('Task queue cleared' instanceof Error ? 'Task queue cleared' : new Error(String('Task queue cleared')))))));
  }

  /**
   * è·å–ä»»åŠ¡çŠ¶æ€?   * @param taskId ä»»åŠ¡ID
   * @returns ä»»åŠ¡çŠ¶æ€ï¼Œå¦‚æœä»»åŠ¡ä¸å­˜åœ¨è¿”å›null
   */
  public getTaskStatus(taskId: string): TaskStatus | null {
    if (this.runningTasks.has(taskId)) {
      return TaskStatus.RUNNING;
    }
    const task = this.taskQueue.find(t => t.id === taskId);
    if (task) {
      return TaskStatus.PENDING;
    }
    return null;
  }

  /**
   * è·å–å½“å‰è¿è¡Œä¸­çš„ä»»åŠ¡æ•°é‡
   */
  public getRunningTaskCount(): number {
    return this.runningTasks.size;
  }

  /**
   * è·å–å½“å‰é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡æ•°é‡
   */
  public getQueuedTaskCount(): number {
    return this.taskQueue.length;
  }

  /**
   * æŒ‰ä¼˜å…ˆçº§æ’åºä»»åŠ¡é˜Ÿåˆ—
   */
  private sortTasks(): void {
    this.taskQueue.sort((a, b) => b.priority - a.priority);
  }

  /**
   * å¤„ç†ä»»åŠ¡é˜Ÿåˆ—
   */
  private processQueue(): void {
    if (this.isProcessing) return;
    
    this.isProcessing = true;
    
    try {
      // åŠ¨æ€è°ƒæ•´å¹¶å‘ä»»åŠ¡æ•°åŸºäºå†…å­˜ä½¿ç”¨æƒ…å†µ
      const memoryStats = this.memoryManager.getMemoryStats();
      const adjustedMaxConcurrentTasks = this.calculateOptimalConcurrentTasks(memoryStats.currentUsage);
      
      // æ‰§è¡Œå°½å¯èƒ½å¤šçš„å¹¶å‘ä»»åŠ?      while (
        this.runningTasks.size < adjustedMaxConcurrentTasks &&
        this.taskQueue.length > 0
      ) {
        // åœ¨æ¯æ¬¡æ‰§è¡Œä»»åŠ¡å‰é‡æ–°æ£€æŸ¥å†…å­˜å¯ç”¨æ€?        if (!this.memoryManager.checkMemoryAvailability()) {
          Logger.warn(TAG, `Insufficient memory to process tasks (${(memoryStats.currentUsage * 100).toFixed(1)}%), pausing queue`);
          // å°è¯•æ¸…ç†å†…å­˜
          this.memoryManager.clearMemory();
          // å»¶è¿Ÿé‡è¯•ï¼Œæ ¹æ®å†…å­˜ä½¿ç”¨æƒ…å†µåŠ¨æ€è°ƒæ•´å»¶è¿Ÿæ—¶é—?          const retryDelay = this.calculateRetryDelay(memoryStats.currentUsage);
          setTimeout(() => this.processQueue(), retryDelay);
          return;
        }
        
        const task = this.taskQueue.shift();
        if (task) {
          this.executeTask(task);
        }
      }
      
      // å¦‚æœé˜Ÿåˆ—ä¸ä¸ºç©ºä½†æ²¡æœ‰æ‰§è¡Œä»»åŠ¡ï¼Œå¯èƒ½æ˜¯å› ä¸ºå†…å­˜ä¸è¶³
      if (this.taskQueue.length > 0 && this.runningTasks.size < this.maxConcurrentTasks) {
        Logger.info(TAG, `Task queue has ${this.taskQueue.length} tasks, but running at capacity (${this.runningTasks.size}/${adjustedMaxConcurrentTasks})`);
      }
    } finally {
      this.isProcessing = false;
      
      // å¦‚æœè¿˜æœ‰ä»»åŠ¡åœ¨é˜Ÿåˆ—ä¸­ä¸”æ²¡æœ‰è¾¾åˆ°æœ€å¤§å¹¶å‘æ•°ï¼Œç»§ç»­å¤„ç?      if (this.taskQueue.length > 0 && this.runningTasks.size < this.maxConcurrentTasks) {
        setTimeout(() => this.processQueue(), 0);
      }
    }
  }
  
  /**
   * æ ¹æ®å†…å­˜ä½¿ç”¨æƒ…å†µè®¡ç®—æœ€ä½³å¹¶å‘ä»»åŠ¡æ•°
   * @param memoryUsage å½“å‰å†…å­˜ä½¿ç”¨ç?   * @returns è°ƒæ•´åçš„æœ€å¤§å¹¶å‘ä»»åŠ¡æ•°
   */
  private calculateOptimalConcurrentTasks(memoryUsage: number): number {
    // å†…å­˜ä½¿ç”¨ç‡ä½äº?0%ï¼šä½¿ç”¨æœ€å¤§å¹¶å‘æ•°
    if (memoryUsage < 0.5) {
      return this.maxConcurrentTasks;
    }
    // å†…å­˜ä½¿ç”¨ç?0%-70%ï¼šä½¿ç”?5%çš„æœ€å¤§å¹¶å‘æ•°
    else if (memoryUsage < 0.7) {
      return Math.max(1, Math.floor(this.maxConcurrentTasks * 0.75));
    }
    // å†…å­˜ä½¿ç”¨ç?0%-85%ï¼šä½¿ç”?0%çš„æœ€å¤§å¹¶å‘æ•°
    else if (memoryUsage < 0.85) {
      return Math.max(1, Math.floor(this.maxConcurrentTasks * 0.5));
    }
    // å†…å­˜ä½¿ç”¨ç‡é«˜äº?5%ï¼šåªå…è®¸1ä¸ªå¹¶å‘ä»»åŠ?    else {
      return 1;
    }
  }
  
  /**
   * æ ¹æ®å†…å­˜ä½¿ç”¨æƒ…å†µè®¡ç®—é‡è¯•å»¶è¿Ÿ
   * @param memoryUsage å½“å‰å†…å­˜ä½¿ç”¨ç?   * @returns é‡è¯•å»¶è¿Ÿæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
   */
  private calculateRetryDelay(memoryUsage: number): number {
    // å†…å­˜ä½¿ç”¨è¶Šé«˜ï¼Œé‡è¯•å»¶è¿Ÿè¶Šé•?    if (memoryUsage < 0.7) return 1000;     // 70%ä»¥ä¸‹ï¼?ç§?    if (memoryUsage < 0.8) return 2000;     // 70%-80%ï¼?ç§?    if (memoryUsage < 0.9) return 3000;     // 80%-90%ï¼?ç§?    return 5000;                            // 90%ä»¥ä¸Šï¼?ç§?  }

  /**
   * æ‰§è¡Œå•ä¸ªä»»åŠ¡
   * @param task è¦æ‰§è¡Œçš„ä»»åŠ¡
   */
  private async executeTask(task: Task): Promise<void> {
    if (!task.id) {
      task.id = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    this.runningTasks.set(task.id, task);
    Logger.debug(TAG, `Task ${task.id} started execution with priority ${task.priority}`);
    
    // è®°å½•ä»»åŠ¡å¼€å§‹å‰çš„å†…å­˜ä½¿ç”¨æƒ…å†?    const startMemoryUsage = this.memoryManager.getCurrentMemoryUsage();
    const startTime = Date.now();

    try {
      // æ ¹æ®ä»»åŠ¡ä¼˜å…ˆçº§å’Œå†…å­˜æƒ…å†µåŠ¨æ€è°ƒæ•´ä»»åŠ¡é…ç½?      const memoryStats = this.memoryManager.getMemoryStats();
      const taskOptions = this.createOptimizedTaskOptions(task.priority, memoryStats);
      
      // ä½¿ç”¨TaskPoolæ‰§è¡Œä»»åŠ¡ï¼Œå®ç°çœŸæ­£çš„ç³»ç»Ÿçº§å¹¶å?      const taskFunction = async () => {
        try {
          return await task.execute();
        } catch (error) {
          Logger.error(TAG, `Task function execution error: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      };

      // æ‰§è¡Œä»»åŠ¡
      const result = await taskPool.execute(taskFunction, taskOptions instanceof Error ? taskOptions : new Error(String(taskOptions instanceof Error ? taskOptions instanceof Error ? taskOptions : new Error(String(taskOptions : new Error(String(taskOptions instanceof Error ? taskOptions : new Error(String(taskOptions instanceof Error ? taskOptions instanceof Error ? taskOptions : new Error(String(taskOptions instanceof Error ? taskOptions instanceof Error ? taskOptions : new Error(String(taskOptions : new Error(String(taskOptions instanceof Error ? taskOptions : new Error(String(taskOptions : new Error(String(taskOptions instanceof Error ? taskOptions : new Error(String(taskOptions instanceof Error ? taskOptions instanceof Error ? taskOptions : new Error(String(taskOptions : new Error(String(taskOptions instanceof Error ? taskOptions : new Error(String(taskOptions)))))));
      
      // å¤„ç†å®Œæˆ
      this.handleTaskComplete(task, result);
      
      // è®°å½•ä»»åŠ¡å®Œæˆåçš„å†…å­˜ä½¿ç”¨æƒ…å†µï¼Œç›‘æ§å†…å­˜æ³„æ¼?      this.logTaskMemoryUsage(task.id, startMemoryUsage, startTime);
    } catch (error) {
      // å¤„ç†é”™è¯¯
      this.handleTaskError(task, error as Error);
    } finally {
      // ä»è¿è¡Œä¸­ä»»åŠ¡ç§»é™¤
      this.runningTasks.delete(task.id);
      
      // åœ¨ä»»åŠ¡å®Œæˆåå†æ¬¡æ£€æŸ¥å†…å­˜ï¼Œå¦‚æœå†…å­˜ä½¿ç”¨è¿‡é«˜å°è¯•æ¸…ç†
      this.checkAndCleanupMemory();
      
      // ç»§ç»­å¤„ç†é˜Ÿåˆ—
      this.processQueue();
    }
  }
  
  /**
   * åˆ›å»ºä¼˜åŒ–çš„ä»»åŠ¡é€‰é¡¹
   * @param priority ä»»åŠ¡ä¼˜å…ˆçº?   * @param memoryStats å†…å­˜ç»Ÿè®¡ä¿¡æ¯
   * @returns ä¼˜åŒ–çš„ä»»åŠ¡é€‰é¡¹
   */
  private createOptimizedTaskOptions(priority: TaskPriority, memoryStats: { currentUsage: number }): taskPool.TaskOptions {
    const taskOptions: taskPool.TaskOptions = {
      priority: this.getTaskPoolPriority(priority)
    };
    
    // åœ¨å†…å­˜ç´§å¼ æ—¶ï¼Œå¯¹ä½ä¼˜å…ˆçº§ä»»åŠ¡åº”ç”¨æ›´ä¸¥æ ¼çš„èµ„æºé™åˆ¶
    if (memoryStats.currentUsage > 0.8 && priority <= TaskPriority.NORMAL) {
      Logger.info(TAG, `Applying resource limits for low priority task due to high memory usage (${(memoryStats.currentUsage * 100).toFixed(1)}%)`);
      // æ³¨æ„ï¼šTaskPoolå¯èƒ½ä¸ç›´æ¥æ”¯æŒè¿™äº›é€‰é¡¹ï¼Œè¿™é‡Œä»…ä½œä¸ºç¤ºä¾‹
      // taskOptions.maxMemoryUsage = 0.1; // é™åˆ¶ä»»åŠ¡å†…å­˜ä½¿ç”¨
    }
    
    return taskOptions;
  }
  
  /**
   * è®°å½•ä»»åŠ¡çš„å†…å­˜ä½¿ç”¨æƒ…å†?   * @param taskId ä»»åŠ¡ID
   * @param startUsage å¼€å§‹æ—¶çš„å†…å­˜ä½¿ç”¨ç‡
   * @param startTime å¼€å§‹æ—¶é—?   */
  private logTaskMemoryUsage(taskId: string, startUsage: number, startTime: number): void {
    const endUsage = this.memoryManager.getCurrentMemoryUsage();
    const duration = Date.now() - startTime;
    const memoryDiff = endUsage - startUsage;
    
    // å¦‚æœå†…å­˜ä½¿ç”¨å¢åŠ äº?%ä»¥ä¸Šï¼Œè®°å½•è­¦å‘?    if (memoryDiff > 0.05) {
      Logger.warn(TAG, `Task ${taskId} may be leaking memory: memory usage increased by ${(memoryDiff * 100).toFixed(1)}%`);
    }
    
    if (duration > 10000) { // ä»»åŠ¡æ‰§è¡Œè¶…è¿‡10ç§?      Logger.info(TAG, `Long-running task ${taskId} completed in ${duration}ms`);
    }
  }
  
  /**
   * æ£€æŸ¥å¹¶åœ¨éœ€è¦æ—¶æ¸…ç†å†…å­˜
   */
  private checkAndCleanupMemory(): void {
    const memoryUsage = this.memoryManager.getCurrentMemoryUsage();
    
    // å½“å†…å­˜ä½¿ç”¨è¶…è¿?5%æ—¶å°è¯•æ¸…ç?    if (memoryUsage > 0.85) {
      Logger.warn(TAG, `Memory usage high (${(memoryUsage * 100).toFixed(1)}%), attempting cleanup`);
      this.memoryManager.clearMemory();
      
      // æ¸…ç†åå†æ¬¡æ£€æŸ?      const afterCleanupUsage = this.memoryManager.getCurrentMemoryUsage();
      const freedMemory = memoryUsage - afterCleanupUsage;
      
      if (freedMemory > 0.05) {
        Logger.info(TAG, `Memory cleanup successful: freed ${(freedMemory * 100).toFixed(1)}%`);
      }
    }
  }

  /**
   * å¤„ç†ä»»åŠ¡å®Œæˆ
   * @param task ä»»åŠ¡å¯¹è±¡
   * @param result ä»»åŠ¡ç»“æœ
   */
  private handleTaskComplete<T>(task: Task<T>, result: T): void {
    Logger.debug(TAG, `Task ${task.id} completed successfully`);
    try {
      task.onComplete?.(result);
    } catch (error) {
      Logger.error(TAG, `Error in task ${task.id} onComplete callback: ${(error as Error).message}`);
    }
  }

  /**
   * å¤„ç†ä»»åŠ¡é”™è¯¯
   * @param task ä»»åŠ¡å¯¹è±¡
   * @param error é”™è¯¯å¯¹è±¡
   */
  private handleTaskError(task: Task, error: Error instanceof Error ? error: Error : new Error(String(error: Error instanceof Error ? error: Error instanceof Error ? error: Error : new Error(String(error: Error : new Error(String(error: Error instanceof Error ? error: Error : new Error(String(error: Error instanceof Error ? error: Error instanceof Error ? error: Error : new Error(String(error: Error instanceof Error ? error: Error instanceof Error ? error: Error : new Error(String(error: Error : new Error(String(error: Error instanceof Error ? error: Error : new Error(String(error: Error : new Error(String(error: Error instanceof Error ? error: Error : new Error(String(error: Error instanceof Error ? error: Error instanceof Error ? error: Error : new Error(String(error: Error : new Error(String(error: Error instanceof Error ? error: Error : new Error(String(error: Error))))))): void {
    Logger.error(TAG, `Task ${task.id} failed: ${error.message}`);
    try {
      task.onError?.(error);
    } catch (callbackError) {
      Logger.error(TAG, `Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error instanceof Error ? `Error in task ${task.id} onError callback: ${(callbackError as Error : new Error(String(`Error in task ${task.id} onError callback: ${(callbackError as Error))))))).message}`);
    }
  }
}

export default TaskPoolManager.getInstance();


