// FileUtil - æ–‡ä»¶æ“ä½œå·¥å…·ç±?import fs from '@ohos.file.fs';
import common from '@ohos.app.ability.common';
import Logger from './Logger';
import UIAbilityContext from '@ohos.app.ability.UIAbilityContext';
import JsonUtil, { safeStringify } from './JsonUtil';

const TAG = 'FileUtil';

/**
 * æ–‡ä»¶æ“ä½œå·¥å…·ç±? * æä¾›æ–‡ä»¶çš„è¯»å†™ã€åˆ›å»ºã€åˆ é™¤ç­‰åŸºæœ¬æ“ä½œ
 */
export default class FileUtil {
  /**
   * è¯»å–æ–‡ä»¶å†…å®¹
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @returns æ–‡ä»¶å†…å®¹å­—ç¬¦ä¸?   */
  public static async readFile(filePath: string): Promise<string> {
    try {
      const file = await fs.open(filePath, fs.OpenMode.READ_ONLY);
      const fileInfo = await fs.stat(filePath);
      const buffer = new ArrayBuffer(fileInfo.size);
      await fs.read(file.fd, buffer);
      await fs.close(file.fd);
      // ä¿®å¤anyç±»å‹é—®é¢˜ï¼Œä½¿ç”¨æ˜¾å¼çš„ç±»å‹è½¬æ¢
      const uint8Array = new Uint8Array(buffer);
      let result = '';
      for (let i = 0; i < uint8Array.length; i++) {
        result += String.fromCharCode(uint8Array[i]);
      }
      return result;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to read file: ${filePath}, error: ${errorMessage}`);
      throw new Error(`Failed to read file: ${filePath}. ${errorMessage}`);
    }
  }

  /**
   * å†™å…¥æ–‡ä»¶å†…å®¹
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @param content æ–‡ä»¶å†…å®¹
   */
  public static async writeFile(filePath: string, content: string): Promise<void> {
    try {
      // ç¡®ä¿ç›®å½•å­˜åœ¨
      await FileUtil.ensureDirExists(filePath.substring(0, filePath.lastIndexOf('/')));
      
      const file = await fs.open(filePath, fs.OpenMode.CREATE | fs.OpenMode.WRITE_ONLY | fs.OpenMode.TRUNCATE);
      // ä¿®å¤anyç±»å‹é—®é¢˜ï¼Œä½¿ç”¨æ˜¾å¼çš„ç±»å‹è½¬æ¢
      const buffer = new ArrayBuffer(content.length);
      const view = new Uint8Array(buffer);
      for (let i = 0; i < content.length; i++) {
        view[i] = content.charCodeAt(i);
      }
      await fs.write(file.fd, buffer);
      await fs.close(file.fd);
      Logger.getInstance().info(`${TAG} - File written successfully: ${filePath}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to write file: ${filePath}, error: ${errorMessage}`);
      throw new Error(`Failed to write file: ${filePath}. ${errorMessage}`);
    }
  }

  /**
   * è¿½åŠ å†…å®¹åˆ°æ–‡ä»?   * @param filePath æ–‡ä»¶è·¯å¾„
   * @param content è¿½åŠ çš„å†…å®?   */
  public static async appendFile(filePath: string, content: string): Promise<void> {
    try {
      // ç¡®ä¿ç›®å½•å­˜åœ¨
      await FileUtil.ensureDirExists(filePath.substring(0, filePath.lastIndexOf('/')));
      
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
      if (!(await FileUtil.exists(filePath))) {
        await FileUtil.writeFile(filePath, content);
        return;
      }
      
      const file = await fs.open(filePath, fs.OpenMode.READ_WRITE);
      await fs.seek(file.fd, { offset: 0, whence: fs.SeekMode.SEEK_END });
      // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºArrayBuffer
      const buffer = new ArrayBuffer(content.length);
      const view = new Uint8Array(buffer);
      for (let i = 0; i < content.length; i++) {
        view[i] = content.charCodeAt(i);
      }
      await fs.write(file.fd, buffer);
      await fs.close(file.fd);
      Logger.getInstance().info(`${TAG} - Content appended to file: ${filePath}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to append to file: ${filePath}, error: ${errorMessage}`);
      throw new Error(`Failed to append to file: ${filePath}. ${errorMessage}`);
    }
  }

  /**
   * åˆ é™¤æ–‡ä»¶
   * @param filePath æ–‡ä»¶è·¯å¾„
   */
  public static async deleteFile(filePath: string): Promise<void> {
    try {
      if (await FileUtil.exists(filePath)) {
        await fs.unlink(filePath);
        Logger.getInstance().info(`${TAG} - File deleted successfully: ${filePath}`);
      } else {
        Logger.getInstance().warn(`${TAG} - File not found: ${filePath}`);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to delete file: ${filePath}, error: ${errorMessage}`);
      throw new Error(`Failed to delete file: ${filePath}. ${errorMessage}`);
    }
  }

  /**
   * åˆ›å»ºç›®å½•
   * @param dirPath ç›®å½•è·¯å¾„
   */
  public static async mkdir(dirPath: string): Promise<void> {
    try {
      await fs.mkdir(dirPath, 0o777);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to create directory ${dirPath}: ${errorMessage}`);
      throw new Error(`Failed to create directory ${dirPath}: ${errorMessage}`);
    }
  }

  /**
   * ç¡®ä¿ç›®å½•å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»?   * @param dirPath ç›®å½•è·¯å¾„
   */
  public static async ensureDirExists(dirPath: string): Promise<void> {
    try {
      await fs.mkdir(dirPath, 0o777, true);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to ensure directory exists ${dirPath}: ${errorMessage}`);
      throw new Error(`Failed to ensure directory exists ${dirPath}: ${errorMessage}`);
    }
  }

  /**
   * åˆ¤æ–­æ–‡ä»¶æˆ–ç›®å½•æ˜¯å¦å­˜åœ?   * @param path è·¯å¾„
   * @returns æ˜¯å¦å­˜åœ¨
   */
  public static async exists(path: string): Promise<boolean> {
    try {
      await fs.stat(path);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * è·å–æ–‡ä»¶ä¿¡æ¯
   * @param filePath æ–‡ä»¶è·¯å¾„
   * @returns æ–‡ä»¶ä¿¡æ¯
   */
  public static async getFileStat(filePath: string): Promise<fs.Stat> {
    try {
      return await fs.stat(filePath);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to get file stat ${filePath}: ${errorMessage}`);
      throw new Error(`Failed to get file stat ${filePath}: ${errorMessage}`);
    }
  }

  /**
   * åˆ—å‡ºç›®å½•ä¸‹çš„æ–‡ä»¶
   * @param dirPath ç›®å½•è·¯å¾„
   * @returns æ–‡ä»¶åˆ—è¡¨
   */
  public static async listFiles(dirPath: string): Promise<string[]> {
    try {
      return await fs.listDir(dirPath);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to list files in directory ${dirPath}: ${errorMessage}`);
      throw new Error(`Failed to list files in directory ${dirPath}: ${errorMessage}`);
    }
  }

  /**
   * å¤åˆ¶æ–‡ä»¶
   * @param srcPath æºæ–‡ä»¶è·¯å¾?   * @param destPath ç›®æ ‡æ–‡ä»¶è·¯å¾„
   */
  public static async copyFile(srcPath: string, destPath: string): Promise<void> {
    try {
      // ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
      await FileUtil.ensureDirExists(FileUtil.getParentPath(destPath));
      await fs.copyFile(srcPath, destPath);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to copy file from ${srcPath} to ${destPath}: ${errorMessage}`);
      throw new Error(`Failed to copy file from ${srcPath} to ${destPath}: ${errorMessage}`);
    }
  }

  /**
   * ç§»åŠ¨æ–‡ä»¶
   * @param srcPath æºæ–‡ä»¶è·¯å¾?   * @param destPath ç›®æ ‡æ–‡ä»¶è·¯å¾„
   */
  public static async moveFile(srcPath: string, destPath: string): Promise<void> {
    try {
      // ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
      await FileUtil.ensureDirExists(FileUtil.getParentPath(destPath));
      await fs.rename(srcPath, destPath);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to move file from ${srcPath} to ${destPath}: ${errorMessage}`);
      throw new Error(`Failed to move file from ${srcPath} to ${destPath}: ${errorMessage}`);
    }
  }

  /**
   * è·å–æ–‡ä»¶æ‰©å±•å?   * @param filename æ–‡ä»¶å?   * @returns æ–‡ä»¶æ‰©å±•å?   */
  public static getFileExtension(filename: string): string {
    const lastDotIndex = filename.lastIndexOf('.');
    return lastDotIndex > 0 ? filename.slice(lastDotIndex + 1).toLowerCase() : '';
  }

  /**
   * è·å–æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰
   * @param filename æ–‡ä»¶å?   * @returns æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰
   */
  public static getFileNameWithoutExtension(filename: string): string {
    const lastDotIndex = filename.lastIndexOf('.');
    return lastDotIndex > 0 ? filename.slice(0, lastDotIndex) : filename;
  }

  /**
   * è·å–çˆ¶ç›®å½•è·¯å¾?   * @param path æ–‡ä»¶æˆ–ç›®å½•è·¯å¾?   * @returns çˆ¶ç›®å½•è·¯å¾?   */
  public static getParentPath(path: string): string {
    const parts = path.split('/').filter(Boolean);
    parts.pop();
    return parts.length > 0 ? parts.join('/') : '/';
  }

  /**
   * è·å–æ–‡ä»¶å?   * @param path æ–‡ä»¶è·¯å¾„
   * @returns æ–‡ä»¶å?   */
  public static getFileName(path: string): string {
    const parts = path.split('/').filter(Boolean);
    return parts.length > 0 ? parts[parts.length - 1] : '';
  }

  /**
   * æ¸…ç©ºç›®å½•å†…å®¹
   * @param dirPath ç›®å½•è·¯å¾„
   */
  public static async clearDirectory(dirPath: string): Promise<void> {
    try {
      if (!(await FileUtil.exists(dirPath))) {
        return;
      }
      
      const files = await FileUtil.listFiles(dirPath);
      for (const file of files) {
        const filePath = `${dirPath}/${file}`;
        const stat = await FileUtil.getFileStat(filePath);
        if (stat.isDirectory()) {
          await FileUtil.clearDirectory(filePath);
          await fs.rmdir(filePath);
        } else {
          await fs.unlink(filePath);
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to clear directory ${dirPath}: ${errorMessage}`);
      throw new Error(`Failed to clear directory ${dirPath}: ${errorMessage}`);
    }
  }

  /**
   * è·å–åº”ç”¨ç¨‹åºæ•°æ®ç›®å½•
   * @returns åº”ç”¨ç¨‹åºæ•°æ®ç›®å½•è·¯å¾„
   */
  public static async getApplicationDataDir(): Promise<string> {
    try {
      // ä½¿ç”¨æ–°çš„APIæ–¹å¼è·å–åº”ç”¨ä¸Šä¸‹æ–?      // è·å–åº”ç”¨ç¨‹åºä¸Šä¸‹æ–?      const context = common.getApplicationContext() as UIAbilityContext;
      return context.filesDir;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.getInstance().error(`${TAG} - Failed to get application data directory: ${errorMessage}`);
      // å¦‚æœè·å–å¤±è´¥ï¼Œè¿”å›ä¸€ä¸ªé»˜è®¤è·¯å¾?      return '/data/app/';
    }
  }

  /**
   * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ?   * @param filePath æ–‡ä»¶è·¯å¾„
   * @returns æ–‡ä»¶æ˜¯å¦å­˜åœ¨
   */
  public static async isFileExists(filePath: string): Promise<boolean> {
    return await FileUtil.exists(filePath);
  }
}
