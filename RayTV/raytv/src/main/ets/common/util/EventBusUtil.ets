/**
 * äº‹ä»¶æ€»çº¿å·¥å…·ç±? * æä¾›ç»Ÿä¸€çš„äº‹ä»¶å‘å¸?è®¢é˜…æœºåˆ¶ï¼Œæ”¯æŒå‘½åç©ºé—´ã€é˜²æŠ–ã€æ‰¹é‡æ“ä½œç­‰åŠŸèƒ½
 */

import Logger from './Logger';

/**
 * äº‹ä»¶å¤„ç†å™¨ç±»å? */
export type EventHandler<T = unknown> = (data?: T) => void;

/**
 * äº‹ä»¶è®¢é˜…æ¥å£
 */
export interface Subscription {
  /**
   * äº‹ä»¶å¤„ç†å™?   */
  handler: EventHandler;
  
  /**
   * ä¼˜å…ˆçº§ï¼ˆæ•°å€¼è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ï¼?   */
  priority: number;
  
  /**
   * æ˜¯å¦ä¸€æ¬¡æ€§è®¢é˜?   */
  once: boolean;
  
  /**
   * å‘½åç©ºé—´
   */
  namespace?: string;
}

/**
 * äº‹ä»¶æ€»çº¿å·¥å…·ç±? */
export class EventBusUtil {
  private static instance: EventBusUtil;
  private logger = Logger;
  private eventMap: Record<string, Subscription[]> = {};
  private isPublishing = false;
  private debounceTimers: Record<string, number> = {};

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): EventBusUtil {
    if (!EventBusUtil.instance) {
      EventBusUtil.instance = new EventBusUtil();
    }
    return EventBusUtil.instance;
  }

  /**
   * è®¢é˜…äº‹ä»¶
   * @param eventName äº‹ä»¶åç§°
   * @param handler äº‹ä»¶å¤„ç†å™?   * @param priority ä¼˜å…ˆçº§ï¼ˆé»˜è®¤0ï¼?   * @param once æ˜¯å¦ä¸€æ¬¡æ€§è®¢é˜…ï¼ˆé»˜è®¤falseï¼?   * @param namespace å‘½åç©ºé—´
   */
  public on<T = unknown>(
    eventName: string,
    handler: EventHandler<T>,
    priority: number = 0,
    once: boolean = false,
    namespace?: string
  ): void {
    if (!this.eventMap[eventName]) {
      this.eventMap[eventName] = [];
    }

    const subscription: Subscription = {
      handler: handler as EventHandler,
      priority,
      once,
      namespace
    };

    this.eventMap[eventName].push(subscription);
    // æŒ‰ä¼˜å…ˆçº§æ’åº
    this.eventMap[eventName].sort((a, b) => a.priority - b.priority);

    this.logger.d('EventBus', `Subscribed to event: ${eventName}, priority: ${priority}, once: ${once}`);
  }

  /**
   * ä¸€æ¬¡æ€§è®¢é˜…äº‹ä»?   * @param eventName äº‹ä»¶åç§°
   * @param handler äº‹ä»¶å¤„ç†å™?   * @param priority ä¼˜å…ˆçº?   * @param namespace å‘½åç©ºé—´
   */
  public once<T = unknown>(
    eventName: string,
    handler: EventHandler<T>,
    priority: number = 0,
    namespace?: string
  ): void {
    this.on(eventName, handler, priority, true, namespace);
  }

  /**
   * å–æ¶ˆäº‹ä»¶è®¢é˜…
   * @param eventName äº‹ä»¶åç§°
   * @param handler äº‹ä»¶å¤„ç†å™¨ï¼ˆå¯é€‰ï¼Œä¸ä¼ åˆ™å–æ¶ˆè¯¥äº‹ä»¶çš„æ‰€æœ‰è®¢é˜…ï¼‰
   */
  public off<T = unknown>(eventName: string, handler?: EventHandler<T>): void {
    if (!this.eventMap[eventName]) {
      return;
    }

    if (handler) {
      // å–æ¶ˆç‰¹å®šå¤„ç†å™¨çš„è®¢é˜…
      const index = this.findIndex(this.eventMap[eventName], sub => sub.handler === handler);
      if (index !== -1) {
        this.eventMap[eventName].splice(index, 1);
        this.logger.d('EventBus', `Unsubscribed handler from event: ${eventName}`);
      }
    } else {
      // å–æ¶ˆè¯¥äº‹ä»¶çš„æ‰€æœ‰è®¢é˜?      this.eventMap[eventName] = [];
      this.logger.d('EventBus', `Unsubscribed all handlers from event: ${eventName}`);
    }

    // å¦‚æœäº‹ä»¶æ²¡æœ‰è®¢é˜…è€…äº†ï¼Œåˆ é™¤äº‹ä»¶æ¡ç›?    if (this.eventMap[eventName] && this.eventMap[eventName].length === 0) {
      delete this.eventMap[eventName];
    }
  }

  /**
   * å‘å¸ƒäº‹ä»¶
   * @param eventName äº‹ä»¶åç§°
   * @param data äº‹ä»¶æ•°æ®
   */
  public emit<T = unknown>(eventName: string, data?: T): void {
    if (!this.eventMap[eventName]) {
      return;
    }

    // é˜²æ­¢åœ¨äº‹ä»¶å¤„ç†è¿‡ç¨‹ä¸­ä¿®æ”¹è®¢é˜…åˆ—è¡¨
    this.isPublishing = true;

    try {
      // å¤åˆ¶è®¢é˜…åˆ—è¡¨ï¼Œé¿å…åœ¨éå†è¿‡ç¨‹ä¸­ä¿®æ”?      const subscriptions = this.eventMap[eventName].slice();
      const onceSubscriptions: number[] = [];

      // æ‰§è¡Œæ‰€æœ‰è®¢é˜…è€?      for (let i = 0; i < subscriptions.length; i++) {
        const subscription = subscriptions[i];
        
        try {
          subscription.handler(data);
          
          // æ ‡è®°ä¸€æ¬¡æ€§è®¢é˜?          if (subscription.once) {
            onceSubscriptions.push(i);
          }
        } catch (error) {
          this.logger.e('EventBus', `Error in event handler for ${eventName}:`, { error });
        }
      }

      // ç§»é™¤ä¸€æ¬¡æ€§è®¢é˜?      if (onceSubscriptions.length > 0) {
        // ä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–
        for (let i = onceSubscriptions.length - 1; i >= 0; i--) {
          const index = onceSubscriptions[i];
          if (this.eventMap[eventName]) {
            this.eventMap[eventName].splice(index, 1);
          }
        }
        
        // å¦‚æœäº‹ä»¶æ²¡æœ‰è®¢é˜…è€…äº†ï¼Œåˆ é™¤äº‹ä»¶æ¡ç›?        if (this.eventMap[eventName] && this.eventMap[eventName].length === 0) {
          delete this.eventMap[eventName];
        }
      }

      this.logger.d('EventBus', `Emitted event: ${eventName}, subscribers: ${subscriptions.length}`);
    } finally {
      this.isPublishing = false;
    }
  }

  /**
   * æ‰¹é‡è®¢é˜…äº‹ä»¶
   * @param events äº‹ä»¶é…ç½®æ•°ç»„
   */
  public onBatch(events: Array<{
    eventName: string;
    handler: EventHandler;
    priority?: number;
    once?: boolean;
    namespace?: string;
  }>): void {
    events.forEach(event => {
      this.on(
        event.eventName,
        event.handler,
        event.priority || 0,
        event.once || false,
        event.namespace
      );
    });
  }

  /**
   * æ‰¹é‡å‘å¸ƒäº‹ä»¶
   * @param events äº‹ä»¶æ•°ç»„
   */
  public emitBatch(events: Array<{ eventName: string; data?: Record<string, string | number | boolean | null> }>): void {
    events.forEach(event => {
      this.emit(event.eventName, event.data);
    });
  }

  /**
   * é˜²æŠ–äº‹ä»¶å‘å¸ƒ
   * @param eventName äº‹ä»¶åç§°
   * @param data äº‹ä»¶æ•°æ®
   * @param wait ç­‰å¾…æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
   */
  public emitDebounced<T = unknown>(eventName: string, data?: T, wait: number = 300): void {
    const debounceKey = `__debounce_${eventName}`;
    
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    this.clearDebounceTimer(debounceKey);
    
    // åˆ›å»ºæ–°çš„å®šæ—¶å™?    const timerId = setTimeout(() => {
      // æ¸…é™¤å®šæ—¶å™¨å¼•ç”?      delete this.debounceTimers[debounceKey];
      // å‘å¸ƒäº‹ä»¶
      this.emit(eventName, data);
      this.logger.debug(`Debounced event emitted: ${eventName}`);
    }, wait);
    
    // å­˜å‚¨å®šæ—¶å™¨ID
    this.debounceTimers[debounceKey] = timerId;
    this.logger.debug(`Debounced event scheduled: ${eventName}, wait: ${wait}ms`);
  }

  /**
   * æ¸…é™¤æŒ‡å®šäº‹ä»¶çš„é˜²æŠ–å®šæ—¶å™¨
   * @param debounceKey é˜²æŠ–é”?   */
  private clearDebounceTimer(debounceKey: string): void {
    if (this.debounceTimers[debounceKey]) {
      const timerId = this.debounceTimers[debounceKey];
      clearTimeout(timerId);
      delete this.debounceTimers[debounceKey];
      this.logger.debug(`Debounced timer cleared for key: ${debounceKey}`);
    }
  }

  /**
   * æ¸…é™¤æ‰€æœ‰é˜²æŠ–å®šæ—¶å™¨
   */
  public clearAllDebounceTimers(): void {
    try {
      this.logger.debug('Clearing all debounce timers');
      for (const debounceKey in this.debounceTimers) {
        if (this.debounceTimers.hasOwnProperty(debounceKey)) {
          const timerId = this.debounceTimers[debounceKey];
          clearTimeout(timerId);
        }
      }
      this.debounceTimers = {};
    } catch (error) {
      this.Logger.error('Failed to clear debounce timers', error as Error);
    }
  }

  /**
   * è·å–äº‹ä»¶è®¢é˜…æ•°é‡
   * @param eventName äº‹ä»¶åç§°
   * @returns è®¢é˜…æ•°é‡
   */
  public getSubscriptionCount(eventName: string): number {
    if (this.eventMap[eventName]) {
      return this.eventMap[eventName].length;
    }
    return 0;
  }

  /**
   * æŸ¥æ‰¾æ•°ç»„ä¸­å…ƒç´ çš„ç´¢å¼•ï¼ˆå…¼å®¹ES5çš„findIndexå®ç°ï¼?   * @param array æ•°ç»„
   * @param predicate æ–­è¨€å‡½æ•°
   * @returns ç´¢å¼•ï¼Œæœªæ‰¾åˆ°è¿”å›-1
   */
  private findIndex<T>(array: T[], predicate: (item: T instanceof Error ? predicate: (item: T : new Error(String(predicate: (item: T instanceof Error ? predicate: (item: T instanceof Error ? predicate: (item: T : new Error(String(predicate: (item: T : new Error(String(predicate: (item: T instanceof Error ? predicate: (item: T : new Error(String(predicate: (item: T instanceof Error ? predicate: (item: T instanceof Error ? predicate: (item: T : new Error(String(predicate: (item: T instanceof Error ? predicate: (item: T instanceof Error ? predicate: (item: T : new Error(String(predicate: (item: T : new Error(String(predicate: (item: T instanceof Error ? predicate: (item: T : new Error(String(predicate: (item: T : new Error(String(predicate: (item: T instanceof Error ? predicate: (item: T : new Error(String(predicate: (item: T instanceof Error ? predicate: (item: T instanceof Error ? predicate: (item: T : new Error(String(predicate: (item: T : new Error(String(predicate: (item: T instanceof Error ? predicate: (item: T : new Error(String(predicate: (item: T))))))) => boolean): number {
    for (let i = 0; i < array.length; i++) {
      if (predicate(array[i])) {
        return i;
      }
    }
    return -1;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰ç‰¹å®šäº‹ä»¶çš„è®¢é˜…è€?   * @param eventName äº‹ä»¶åç§°
   * @returns æ˜¯å¦æœ‰è®¢é˜…è€?   */
  public hasSubscribers(eventName: string): boolean {
    return !!this.eventMap[eventName] && this.eventMap[eventName].length > 0;
  }

  /**
   * è·å–æ‰€æœ‰äº‹ä»¶åç§?   * @returns äº‹ä»¶åç§°æ•°ç»„
   */
  public getEventNames(): string[] {
    return Object.keys(this.eventMap);
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰äº‹ä»¶è®¢é˜?   */
  public clear(): void {
    // ä½¿ç”¨å»¶è¿Ÿæ“ä½œé¿å…åœ¨äº‹ä»¶å¤„ç†è¿‡ç¨‹ä¸­ä¿®æ”¹
    if (this.isPublishing) {
      setTimeout(() => this.clear(), 0);
      return;
    }

    const operation = () => {
      this.eventMap = {};
      // åŒæ—¶æ¸…é™¤æ‰€æœ‰é˜²æŠ–å®šæ—¶å™¨
      this.clearAllDebounceTimers();
      this.logger.debug('All event subscriptions cleared');
    };

    // å¦‚æœå½“å‰æ­£åœ¨å‘å¸ƒäº‹ä»¶ï¼Œå»¶è¿Ÿæ‰§è¡?    if (this.isPublishing) {
      setTimeout(operation, 0);
    } else {
      operation();
    }
  }

  /**
   * é”€æ¯äº‹ä»¶æ€»çº¿å®ä¾‹
   */
  public destroy(): void {
    this.clear();
    EventBusUtil.instance = null as any;
    this.logger.debug('EventBus instance destroyed');
  }
}

/**
 * äº‹ä»¶å‘½åç©ºé—´ç±? */
export class EventNamespace {
  private namespace: string;
  private eventBus: EventBusUtil;

  constructor(namespace: string) {
    this.namespace = namespace;
    this.eventBus = EventBusUtil.getInstance();
  }

  /**
   * è®¢é˜…å‘½åç©ºé—´äº‹ä»¶
   */
  public on<T = unknown>(eventName: string, handler: EventHandler<T>, priority: number = 0, once: boolean = false): void {
    const fullEventName = `${this.namespace}:${eventName}`;
    this.eventBus.on(fullEventName, handler, priority, once, this.namespace);
  }

  /**
   * ä¸€æ¬¡æ€§è®¢é˜…å‘½åç©ºé—´äº‹ä»?   */
  public once<T = unknown>(eventName: string, handler: EventHandler<T>, priority: number = 0): void {
    this.on(eventName, handler, priority, true);
  }

  /**
   * å–æ¶ˆå‘½åç©ºé—´äº‹ä»¶è®¢é˜…
   */
  public off<T = unknown>(eventName: string, handler?: EventHandler<T>): void {
    const fullEventName = `${this.namespace}:${eventName}`;
    this.eventBus.off(fullEventName, handler);
  }

  /**
   * å‘å¸ƒå‘½åç©ºé—´äº‹ä»¶
   */
  public emit<T = unknown>(eventName: string, data?: T): void {
    const fullEventName = `${this.namespace}:${eventName}`;
    this.eventBus.emit(fullEventName, data);
  }

  /**
   * æ¸…ç©ºå‘½åç©ºé—´ä¸‹çš„æ‰€æœ‰äº‹ä»¶è®¢é˜?   */
  public clear(): void {
    const allEvents = this.eventBus.getEventNames();
    const namespaceEvents = allEvents.filter(event => event.indexOf(`${this.namespace}:`) === 0);
    
    namespaceEvents.forEach(event => {
      this.eventBus.clearEvent(event);
    });
  }
}

/**
 * å…¨å±€äº‹ä»¶ç±»å‹æšä¸¾
 */
export enum GlobalEventType {
  // åº”ç”¨äº‹ä»¶
  APP_START = 'app:start',
  APP_READY = 'app:ready',
  APP_PAUSE = 'app:pause',
  APP_RESUME = 'app:resume',
  APP_STOP = 'app:stop',
  
  // ç½‘ç»œäº‹ä»¶
  NETWORK_CONNECTED = 'network:connected',
  NETWORK_DISCONNECTED = 'network:disconnected',
  NETWORK_CHANGED = 'network:changed',
  
  // ç”¨æˆ·äº‹ä»¶
  USER_LOGIN = 'user:login',
  USER_LOGOUT = 'user:logout',
  USER_PROFILE_UPDATED = 'user:profile_updated',
  
  // æ’­æ”¾äº‹ä»¶
  PLAYBACK_START = 'playback:start',
  PLAYBACK_PAUSE = 'playback:pause',
  PLAYBACK_STOP = 'playback:stop',
  PLAYBACK_COMPLETE = 'playback:complete',
  PLAYBACK_ERROR = 'playback:error',
  
  // æ•°æ®åŒæ­¥äº‹ä»¶
  DATA_SYNC_START = 'data_sync:start',
  DATA_SYNC_COMPLETE = 'data_sync:complete',
  DATA_SYNC_ERROR = 'data_sync:error'
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default EventBusUtil.getInstance();


