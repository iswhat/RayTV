// StorageUtil - æœ¬åœ°å­˜å‚¨ç®¡ç†å·¥å…·ç±?import Logger from './Logger';
import AppConstant from '../constant/AppConstant';
import FileUtil from './FileUtil';
import preferences from '@ohos.data.preferences';

const TAG = 'StorageUtil';

/**
 * å­˜å‚¨ç±»å‹æšä¸¾
 */
export enum StorageType {
  PREFERENCES,  // åå¥½è®¾ç½®å­˜å‚¨
  DATABASE,     // æ•°æ®åº“å­˜å‚?  FILE,         // æ–‡ä»¶å­˜å‚¨
  MEMORY        // å†…å­˜å­˜å‚¨
}

/**
 * å­˜å‚¨æ•°æ®ç»“æ„
 */
export interface StorageData {
  // æ›¿æ¢anyç±»å‹ä¸ºå…·ä½“çš„æ”¯æŒç±»å‹
  value: string | number | boolean | JsonData | null;
  timestamp: number;
  expireTime: number;
}

/**
 * å†…å­˜ç¼“å­˜é¡¹ç»“æ? */
export interface MemoryCacheItem {
  // æ›¿æ¢anyç±»å‹ä¸ºå…·ä½“çš„æ”¯æŒç±»å‹
  value: string | number | boolean | JsonData | null;
  expireTime: number;
}

/**
 * JSONæ•°æ®ç±»å‹ - æ›¿ä»£ç´¢å¼•ç­¾åï¼Œä½¿ç”¨ç±»å®ç°
 */
export class JsonDataClass {
  private data: Record<string, string | number | boolean | JsonDataClass | null> = {};

  set(key: string, value: string | number | boolean | JsonDataClass | null): void {
    if (typeof key === 'string') {
      this.data[key] = value;
    }
  }

  get(key: string): string | number | boolean | JsonDataClass | null {
    return this.data[key] || null;
  }

  has(key: string): boolean {
    // ä½¿ç”¨Object.keysè·å–å±æ€§åˆ—è¡¨å¹¶æ£€æŸ¥ï¼Œé¿å…ä½¿ç”¨hasOwnProperty
    return Object.keys(this.data).includes(key);
  }

  keys(): string[] {
    return Object.keys(this.data);
  }

  // ç§»é™¤anyç±»å‹ï¼Œä½¿ç”¨æ›´å…·ä½“çš„ç±»å‹å®šä¹?  toObject(): Record<string, string | number | boolean | JsonDataClass | null> {
    const result: Record<string, string | number | boolean | JsonDataClass | null> = {};
    
    for (const key of this.keys()) {
      const value = this.get(key);
      if (value instanceof JsonDataClass) {
        result[key] = value.toObject();
      } else {
        result[key] = value;
      }
    }
    return result;
  }

  // ä½¿ç”¨æ›´å…·ä½“çš„ç±»å‹æ›¿ä»£any
  static fromObject(obj: Record<string, string | number | boolean | object | null>): JsonDataClass | null {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
      return null;
    }
    const jsonData = new JsonDataClass();
    for (const key of Object.keys(obj)) {
      const value = obj[key];
      if (typeof value === 'string' || typeof value === 'number' || 
          typeof value === 'boolean' || value === null) {
        jsonData.set(key, value);
      } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        const nestedData = JsonDataClass.fromObject(value);
        if (nestedData) {
          jsonData.set(key, nestedData);
        }
      }
    }
    return jsonData;
  }
}

// ä¸ºäº†å‘åå…¼å®¹ï¼Œä¿ç•™JsonDataç±»å‹åˆ«å
export type JsonData = JsonDataClass;

/**
 * å­˜å‚¨å·¥å…·ç±? * æä¾›å¤šç§å­˜å‚¨æ–¹å¼çš„ç»Ÿä¸€æ¥å£ï¼ŒåŒ…æ‹¬åå¥½è®¾ç½®ã€æ–‡ä»¶å­˜å‚¨ç­‰
 */
export default class StorageUtil {
  // ä½¿ç”¨å±€éƒ¨å˜é‡å­˜å‚¨å•ä¾‹å®ä¾‹ï¼Œé¿å…ä½¿ç”¨ç±»ä½œä¸ºå¯¹è±?  private static _instance: StorageUtil | null = null;

  /**
   * è·å–å•ä¾‹å®ä¾‹
   * @returns StorageUtilå®ä¾‹
   */
  public static getInstance(): StorageUtil {
    if (!StorageUtil._instance) {
      StorageUtil._instance = new StorageUtil();
    }
    return StorageUtil._instance;
  }

  /**
   * ç§æœ‰æ„é€ å‡½æ•°ï¼Œç¡®ä¿å•ä¾‹æ¨¡å¼
   */
  private constructor() {
    // åˆå§‹åŒ–æ“ä½?  }

  /**
   * å®‰å…¨åœ°è·å–å¯¹è±¡å±æ€§å€?   * @param obj - è¦è·å–å±æ€§çš„å¯¹è±¡
   * @param key - å±æ€§é”®å?   * @returns å±æ€§å€¼ï¼Œå¦‚æœå±æ€§ä¸å­˜åœ¨åˆ™è¿”å›undefined
   */
  private static getPropertyValue(obj: Record<string, MemoryCacheItem>, key: string): MemoryCacheItem | undefined {
    if (!obj || typeof obj !== 'object') {
      return undefined;
    }
    
    // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?    if (obj === null || obj === undefined) {
      return undefined;
    }
    
    // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?    return obj[key];
  }

  private static memoryCache: Record<string, MemoryCacheItem> = {};
  private static readonly MEMORY_CACHE_CLEAN_INTERVAL = 5 * 60 * 1000; // 5åˆ†é’Ÿæ¸…ç†ä¸€æ¬?  // å†…å­˜ç¼“å­˜æ¸…ç†å®šæ—¶å™?  private static cleanupTimer: number | undefined = undefined;

  static {
    // å¯åŠ¨å†…å­˜ç¼“å­˜è‡ªåŠ¨æ¸…ç†
    StorageUtil.startMemoryCacheCleanup();
  }

  /**
   * ä¿å­˜æ•°æ®åˆ°å­˜å‚?   * @param key é”®å
   * @param value æ•°æ®å€?   * @param type å­˜å‚¨ç±»å‹
   * @param expireTime è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼Œ0è¡¨ç¤ºæ°¸ä¸è¿‡æœŸï¼?   */
  public static async save(key: string, value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0): Promise<void> {
    if (!key || typeof key !== 'string') {
      throw new Error('Invalid key');
    }

    try {
      // ç¡®ä¿valueçš„ç±»å‹å®‰å…?      const safeValue: string | number | boolean | JsonData | null = StorageUtil.validateValue(value);
      
      const dataToSave: StorageData = {
        value: safeValue,
        timestamp: Date.now(),
        expireTime: expireTime > 0 ? Date.now() + expireTime : 0
      };

      switch (type) {
        case StorageType.PREFERENCES:
          await StorageUtil.saveToPreferences(key, dataToSave);
          break;
        case StorageType.FILE:
          await StorageUtil.saveToFile(key, dataToSave);
          break;
        case StorageType.MEMORY:
          StorageUtil.saveToMemory(key, dataToSave);
          break;
        default:
          throw new Error(`Unsupported storage type: ${String(type)}`);
      }

      Logger.info(TAG, `Saved data for key: ${key}, type: ${type}`);
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to save data for key ${key}: ${errorMessage}`);
      throw new Error(errorMessage);
    }
  }

  /**
   * ä»å­˜å‚¨ä¸­è¯»å–æ•°æ®
   * @param key é”®å
   * @param type å­˜å‚¨ç±»å‹
   * @param defaultValue é»˜è®¤å€?   * @returns è¯»å–çš„æ•°æ®æˆ–é»˜è®¤å€?   */
  public static async get<T extends string | number | boolean | JsonData | null>(key: string, type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T instanceof Error ? type: StorageType = StorageType.PREFERENCES, defaultValue?: T : new Error(String(type: StorageType = StorageType.PREFERENCES, defaultValue?: T))))))): Promise<T | null> {
    // ä¸¥æ ¼çš„nullå®‰å…¨æ£€æŸ?    if (!key || typeof key !== 'string' || key.trim() === '') {
      return defaultValue !== undefined ? defaultValue : null;
    }

    try {
      let data: StorageData | null = null;

      switch (type) {
        case StorageType.PREFERENCES:
          data = await StorageUtil.getFromPreferences(key);
          break;
        case StorageType.FILE:
          data = await StorageUtil.getFromFile(key);
          break;
        case StorageType.MEMORY:
          data = StorageUtil.getFromMemory(key);
          break;
        default:
          throw new Error(`Unsupported storage type: ${String(type)}`);
      }

      // æ£€æŸ¥æ•°æ®æ˜¯å¦å­˜åœ?      if (data === null) {
        return defaultValue !== undefined ? defaultValue : null;
      }

      // æ£€æŸ¥æ˜¯å¦è¿‡æœ?      const now = Date.now();
      if (data.expireTime > 0 && now > data.expireTime) {
        Logger.warn(TAG, `Data expired for key: ${key}`);
        await StorageUtil.remove(key, type);
        // ç›´æ¥è¿”å›é»˜è®¤å€?        if (defaultValue !== undefined) {
          return defaultValue;
        }
        return null;
      }

      // å¦‚æœæœ‰æ•°æ®ä¸”æ²¡æœ‰è¿‡æœŸï¼Œè¿”å›æ•°æ®å€?      if (data !== null) {
        // ç¡®ä¿è¿”å›å€¼ç±»å‹å®‰å…?        const safeValue = StorageUtil.validateValue(data.value);
        // ä½¿ç”¨æ›´å®‰å…¨çš„ç±»å‹è½¬æ¢æ–¹å¼
        return safeValue as T;
      }

      // æ²¡æœ‰æ•°æ®æ—¶è¿”å›é»˜è®¤å€?      if (defaultValue !== undefined) {
        return defaultValue;
      }
      return null;
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to get data for key ${key}: ${errorMessage}`);
      // å‡ºé”™æ—¶è¿”å›é»˜è®¤å€?      if (defaultValue !== undefined) {
        return defaultValue;
      }
      return null;
    }
  }

  /**
   * è®¾ç½®å­—ç¬¦ä¸²å€¼ï¼ˆsetæ–¹æ³•çš„åˆ«åï¼‰
   * @param key é”®å
   * @param value å­—ç¬¦ä¸²å€?   * @param type å­˜å‚¨ç±»å‹
   * @param expireTime è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼Œ0è¡¨ç¤ºæ°¸ä¸è¿‡æœŸï¼?   */
  public static async set(key: string, value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 instanceof Error ? value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0 : new Error(String(value: string | number | boolean | JsonData | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0))))))): Promise<void> {
    await StorageUtil.save(key, value, type, expireTime);
  }

  /**
   * è®¾ç½®å­—ç¬¦ä¸²å€?   * @param key é”®å
   * @param value å­—ç¬¦ä¸²å€?   * @param type å­˜å‚¨ç±»å‹
   * @param expireTime è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼Œ0è¡¨ç¤ºæ°¸ä¸è¿‡æœŸï¼?   */
  public static async setString(key: string, value: string | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0): Promise<void> {
    await StorageUtil.save(key, value, type, expireTime);
  }

  /**
   * è®¾ç½®æ•°å­—å€?   * @param key é”®å
   * @param value æ•°å­—å€?   * @param type å­˜å‚¨ç±»å‹
   * @param expireTime è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼Œ0è¡¨ç¤ºæ°¸ä¸è¿‡æœŸï¼?   */
  public static async setNumber(key: string, value: number | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0): Promise<void> {
    await StorageUtil.save(key, value, type, expireTime);
  }

  /**
   * è®¾ç½®å¸ƒå°”å€?   * @param key é”®å
   * @param value å¸ƒå°”å€?   * @param type å­˜å‚¨ç±»å‹
   * @param expireTime è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼Œ0è¡¨ç¤ºæ°¸ä¸è¿‡æœŸï¼?   */
  public static async setBoolean(key: string, value: boolean | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0): Promise<void> {
    await StorageUtil.save(key, value, type, expireTime);
  }

  /**
   * è®¾ç½®å¯¹è±¡å€?   * @param key é”®å
   * @param value å¯¹è±¡å€?   * @param type å­˜å‚¨ç±»å‹
   * @param expireTime è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼Œ0è¡¨ç¤ºæ°¸ä¸è¿‡æœŸï¼?   */
  public static async setObject<T extends JsonData>(key: string, value: T | null | undefined, type: StorageType = StorageType.PREFERENCES, expireTime: number = 0): Promise<void> {
    await StorageUtil.save(key, value, type, expireTime);
  }

  /**
   * è·å–å¯¹è±¡å€?   * @param key é”®å
   * @param type å­˜å‚¨ç±»å‹
   * @param defaultValue é»˜è®¤å€?   * @returns è¯»å–çš„å¯¹è±¡æˆ–é»˜è®¤å€?   */
  public static async getObject<T extends JsonData>(key: string, type: StorageType = StorageType.PREFERENCES, defaultValue?: T): Promise<T | null> {
    return await StorageUtil.get<T>(key, type, defaultValue);
  }

  /**
   * è·å–å­—ç¬¦ä¸²å€?   * @param key é”®å
   * @param type å­˜å‚¨ç±»å‹
   * @param defaultValue é»˜è®¤å€?   * @returns è¯»å–çš„å­—ç¬¦ä¸²æˆ–é»˜è®¤å€?   */
  public static async getString(key: string, type: StorageType = StorageType.PREFERENCES, defaultValue?: string): Promise<string | null> {
    return await StorageUtil.get<string>(key, type, defaultValue);
  }

  /**
   * è·å–æ•°å­—å€?   * @param key é”®å
   * @param type å­˜å‚¨ç±»å‹
   * @param defaultValue é»˜è®¤å€?   * @returns è¯»å–çš„æ•°å­—æˆ–é»˜è®¤å€¼ï¼ˆç¡®ä¿è¿”å›numberç±»å‹ï¼?   */
  public static async getNumber(key: string, type: StorageType = StorageType.PREFERENCES, defaultValue: number = 0): Promise<number> {
    const value = await StorageUtil.get<number>(key, type, defaultValue);
    // ç¡®ä¿è¿”å›å€¼æ˜¯æ•°å­—ç±»å‹
    return typeof value === 'number' ? value : defaultValue;
  }

  /**
   * è·å–å¸ƒå°”å€?   * @param key é”®å
   * @param type å­˜å‚¨ç±»å‹
   * @param defaultValue é»˜è®¤å€?   * @returns è¯»å–çš„å¸ƒå°”å€¼æˆ–é»˜è®¤å€?   */
  public static async getBoolean(key: string, type: StorageType = StorageType.PREFERENCES, defaultValue?: boolean): Promise<boolean | null> {
    return await StorageUtil.get<boolean>(key, type, defaultValue);
  }

  /**
   * ä»å­˜å‚¨ä¸­ç§»é™¤æ•°æ®
   * @param key é”®å
   * @param type å­˜å‚¨ç±»å‹
   */
  public static async remove(key: string, type: StorageType = StorageType.PREFERENCES): Promise<void> {
    if (!key || typeof key !== 'string') {
      Logger.error(TAG, 'remove: key is empty or invalid');
      return;
    }

    try {
      // ä»å†…å­˜ç¼“å­˜ä¸­åˆ é™¤
      if (type !== StorageType.MEMORY) {
        // åˆ›å»ºæ–°å¯¹è±¡ï¼Œä¸åŒ…å«è¦åˆ é™¤çš„é”®
        const newCache: Record<string, MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache instanceof Error ? MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache : new Error(String(MemoryCacheItem> = {};
        const cacheKeys = Object.keys(StorageUtil.memoryCache)))))));
        for (let i = 0; i < cacheKeys.length; i++) {
          const cacheKey = cacheKeys[i];
          // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?          const cacheItem = StorageUtil.getPropertyValue(StorageUtil.memoryCache, cacheKey);
          if (cacheKey !== key && cacheItem !== undefined) {
            newCache[cacheKey] = cacheItem;
          }
        }
        StorageUtil.memoryCache = newCache;
      }

      switch (type) {
        case StorageType.PREFERENCES:
          await StorageUtil.removeFromPreferences(key);
          break;
        case StorageType.FILE:
          await StorageUtil.removeFromFile(key);
          break;
        case StorageType.MEMORY:
          // åˆ›å»ºæ–°å¯¹è±¡ï¼Œä¸åŒ…å«è¦åˆ é™¤çš„é”®
          const newCache: Record<string, MemoryCacheItem> = {};
          const cacheKeys = Object.keys(StorageUtil.memoryCache);
          for (let i = 0; i < cacheKeys.length; i++) {
            const cacheKey = cacheKeys[i];
            // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?            const cacheItem = StorageUtil.getPropertyValue(StorageUtil.memoryCache, cacheKey);
            if (cacheKey !== key && cacheItem !== undefined) {
              newCache[cacheKey] = cacheItem as MemoryCacheItem;
            }
          }
          StorageUtil.memoryCache = newCache;
          break;
        default:
          throw new Error(`Unsupported storage type: ${String(type)}`);
      }

      Logger.info(TAG, `Removed data for key: ${key}, type: ${type}`);
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to remove data for key ${key}: ${errorMessage}`);
      throw new Error(errorMessage);
    }
  }

  /**
   * æ¸…é™¤æ‰€æœ‰å­˜å‚¨æ•°æ?   * @param type å­˜å‚¨ç±»å‹
   */
  public static async clear(type: StorageType = StorageType.PREFERENCES): Promise<void> {
    try {
      switch (type) {
        case StorageType.PREFERENCES:
          await StorageUtil.clearPreferences();
          break;
        case StorageType.FILE:
          await StorageUtil.clearFiles();
          break;
        case StorageType.MEMORY:
          StorageUtil.memoryCache = {};
          break;
        default:
          throw new Error(`Unsupported storage type: ${String(type)}`);
      }

      Logger.info(TAG, `Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}` instanceof Error ? `Cleared all data for type: ${type}` : new Error(String(`Cleared all data for type: ${type}`)))))));
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to clear data for type ${type}: ${errorMessage}`);
      throw new Error(errorMessage);
    }
  }

  /**
   * ä¿å­˜åˆ°å†…å­˜ç¼“å­?   */
  private static saveToMemory(key: string, data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData))))))): void {
    // ç¡®ä¿å­˜å‚¨çš„æ˜¯ç»è¿‡éªŒè¯çš„ç±»å?    const safeValue: string | number | boolean | JsonData | null = StorageUtil.validateValue(data.value);
    StorageUtil.memoryCache[key] = {
      value: safeValue,
      expireTime: data.expireTime
    };
  }

  /**
   * ä»å†…å­˜ç¼“å­˜è¯»å?   */
  private static getFromMemory(key: string): StorageData | null {
    const cachedItem = StorageUtil.memoryCache[key];
    if (!cachedItem) {
      return null;
    }

    // æ£€æŸ¥æ˜¯å¦è¿‡æœ?    const now = Date.now();
    if (cachedItem.expireTime !== 0 && now > cachedItem.expireTime) {
      // è¿‡æœŸåˆ™åˆ é™¤å¹¶è¿”å›null
      const newCache: Record<string, MemoryCacheItem> = {};
      const cacheKeys = Object.keys(StorageUtil.memoryCache);
      for (let i = 0; i < cacheKeys.length; i++) {
        const cacheKey = cacheKeys[i];
        // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?        const cacheItem = StorageUtil.getPropertyValue(StorageUtil.memoryCache, cacheKey);
        if (cacheKey !== key && cacheItem !== undefined) {
          newCache[cacheKey] = cacheItem;
        }
      }
      StorageUtil.memoryCache = newCache;
      return null;
    }

    // ç¡®ä¿è¿”å›çš„æ˜¯ç±»å‹å®‰å…¨çš„å€?    const safeValue: string | number | boolean | JsonData | null = StorageUtil.validateValue(cachedItem.value);
    return {
      value: safeValue,
      timestamp: Date.now(),
      expireTime: cachedItem.expireTime
    };
  }

  /**
   * å¯åŠ¨å†…å­˜ç¼“å­˜è‡ªåŠ¨æ¸…ç†
   */
  private static startMemoryCacheCleanup(): void {
    // è®¾ç½®å®šæ—¶æ¸…ç†ä»»åŠ¡
    setInterval(() => {
      try {
        const now = Date.now();
        const newCache: Record<string, MemoryCacheItem> = {};

        // è¿‡æ»¤è¿‡æœŸçš„ç¼“å­˜é¡¹
        const cacheKeys = Object.keys(StorageUtil.memoryCache);
        for (let i = 0; i < cacheKeys.length; i++) {
          const key = cacheKeys[i];
          // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?          const item = StorageUtil.getPropertyValue(StorageUtil.memoryCache, key);
          if (item !== undefined && (item.expireTime === 0 || now < item.expireTime)) {
            newCache[key] = item;
          } else {
            Logger.info(TAG, `Removed expired memory cache item: ${key}`);
          }
        }

        StorageUtil.memoryCache = newCache;
      } catch (error) {
        // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        Logger.error(TAG, `Failed to clean memory cache: ${errorMessage}`);
      }
    }, StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL instanceof Error ? StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL : new Error(String(StorageUtil.MEMORY_CACHE_CLEAN_INTERVAL)))))));
  }

  /**
   * ä¿å­˜åˆ°åå¥½è®¾ç½?   */
  private static async saveToPreferences(key: string, data: StorageData): Promise<void> {
    try {
      const pref = await preferences.getPreferences(AppConstant.APP_PACKAGE_NAME, AppConstant.PREFERENCES_NAME);
      const jsonData = JSON.stringify(data);
      await pref.putString(key, jsonData);
      await pref.flush();
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to save to preferences for key ${key}: ${errorMessage}`);
      throw new Error(errorMessage);
    }
  }

  /**
   * ä»åå¥½è®¾ç½®è¯»å?   */
  private static async getFromPreferences(key: string): Promise<StorageData | null> {
    try {
      const pref = await preferences.getPreferences(AppConstant.APP_PACKAGE_NAME, AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME)))))));
      const jsonData: string = await pref.getString(key, '');
      
      if (jsonData === '') {
        return null;
      }
      
      // å®‰å…¨è§£æJSON
      const parsedData = StorageUtil.safeParseJSON(jsonData);
      if (!parsedData) {
        return null;
      }
      
      // æ„å»ºå®‰å…¨çš„è¿”å›å¯¹è±?      return StorageUtil.buildStorageData(parsedData);
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to get from preferences for key ${key}: ${errorMessage}`);
      throw new Error(errorMessage);
    }
  }

  /**
   * ä»åå¥½è®¾ç½®ç§»é™?   */
  private static async removeFromPreferences(key: string): Promise<void> {
    try {
      const pref = await preferences.getPreferences(AppConstant.APP_PACKAGE_NAME, AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME)))))));
      await pref.delete(key);
      await pref.flush();
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to remove from preferences for key ${key}: ${errorMessage}`);
      throw new Error(errorMessage);
    }
  }

  /**
   * æ¸…é™¤æ‰€æœ‰åå¥½è®¾ç½?   */
  private static async clearPreferences(): Promise<void> {
    try {
      const pref = await preferences.getPreferences(AppConstant.APP_PACKAGE_NAME, AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME instanceof Error ? AppConstant.PREFERENCES_NAME : new Error(String(AppConstant.PREFERENCES_NAME)))))));
      const keys: string[] = await pref.getAllKeys() as string[];
      
      // æ£€æŸ¥keysæ˜¯å¦ä¸ºæ•°ç»?      if (Array.isArray(keys)) {
        for (let i = 0; i < keys.length; i++) {
          const key: string = keys[i];
          // ç¡®ä¿keyæ˜¯å­—ç¬¦ä¸²ç±»å‹
          if (typeof key === 'string') {
            await pref.delete(key);
          }
        }
      }
      
      await pref.flush();
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to clear preferences: ${errorMessage}`);
      throw new Error(errorMessage);
    }
  }

  /**
   * ä¿å­˜åˆ°æ–‡ä»?   */
  private static async saveToFile(key: string, data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData : new Error(String(data: StorageData instanceof Error ? data: StorageData : new Error(String(data: StorageData))))))): Promise<void> {
    try {
      const fileName = `${key}.json`;
      const filePath = await FileUtil.getApplicationDataDir() + '/' + fileName;
      const jsonData = JSON.stringify(data);
      await FileUtil.writeFile(filePath, jsonData);
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to save to file for key ${key}: ${errorMessage}`);
      throw new Error(errorMessage);
    }
  }

  /**
   * ä»æ–‡ä»¶è¯»å?   */
  private static async getFromFile(key: string): Promise<StorageData | null> {
    try {
      const fileName = `${key}.json`;
      const filePath = await FileUtil.getApplicationDataDir() + '/' + fileName;
      const exists = await FileUtil.isFileExists(filePath);
      
      if (!exists) {
        return null;
      }
      
      // ç¡®ä¿FileUtil.readFileè¿”å›å­—ç¬¦ä¸²ç±»å?      const readResult = await FileUtil.readFile(filePath);
      let jsonData: string = '';
      if (typeof readResult === 'string') {
        jsonData = readResult;
      } else {
        // å¦‚æœè¿”å›çš„ä¸æ˜¯å­—ç¬¦ä¸²ï¼Œè½¬æ¢ä¸ºå­—ç¬¦ä¸?        jsonData = String(readResult);
      }
      
      // ç¡®ä¿jsonDataæ˜¯å­—ç¬¦ä¸²
      if (jsonData === '') {
        return null;
      }
      
      // å®‰å…¨è§£æJSON
      const parsedData = StorageUtil.safeParseJSON(jsonData);
      if (!parsedData) {
        return null;
      }
      
      // æ„å»ºå®‰å…¨çš„è¿”å›å¯¹è±?      return StorageUtil.buildStorageData(parsedData);
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}` instanceof Error ? `Failed to get from file for key ${key}: ${errorMessage}` : new Error(String(`Failed to get from file for key ${key}: ${errorMessage}`)))))));
      throw new Error(errorMessage);
    }
  }

  /**
   * ä»æ–‡ä»¶ç§»é™?   */
  private static async removeFromFile(key: string): Promise<void> {
    try {
      const fileName = `${key}.json`;
      const filePath = await FileUtil.getApplicationDataDir() + '/' + fileName;
      await FileUtil.deleteFile(filePath);
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to remove from file for key ${key}: ${errorMessage}`);
      throw new Error(errorMessage);
    }
  }

  /**
   * æ¸…é™¤æ‰€æœ‰æ–‡ä»?   */
  private static async clearFiles(): Promise<void> {
    try {
      const dirPath = await FileUtil.getApplicationDataDir();
      const files = await FileUtil.listFiles(dirPath);
      
      // æ£€æŸ¥filesæ˜¯å¦ä¸ºæ•°ç»?      if (Array.isArray(files)) {
        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          // ç¡®ä¿fileæ˜¯å­—ç¬¦ä¸²ç±»å‹
          if (typeof file === 'string' && file.endsWith('.json')) {
            await FileUtil.deleteFile(dirPath + '/' + file);
          }
        }
      }
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}` instanceof Error ? `Failed to clear files: ${errorMessage}` : new Error(String(`Failed to clear files: ${errorMessage}`)))))));
      throw new Error(errorMessage);
    }
  }

  /**
   * å®‰å…¨è§£æJSONå­—ç¬¦ä¸?   */
  private static safeParseJSON(jsonStr: string): Record<string, string | number | boolean | null> | null {
    if (!jsonStr || typeof jsonStr !== 'string') {
      return null;
    }
    try {
      const parsed = JSON.parse(jsonStr) as Record<string, string | number | boolean | null>;
      if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {
        return parsed;
      }
      return null;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to parse JSON string: ${errorMessage}`);
      return null;
    }
  }

  /**
   * æ„å»ºå¹¶éªŒè¯StorageDataå¯¹è±¡
   */
  private static buildStorageData(parsedData: Record<string, string | number | boolean | null> instanceof Error ? string | number | boolean | null> : new Error(String(string | number | boolean | null> instanceof Error ? string | number | boolean | null> instanceof Error ? string | number | boolean | null> : new Error(String(string | number | boolean | null> : new Error(String(string | number | boolean | null> instanceof Error ? string | number | boolean | null> : new Error(String(string | number | boolean | null> instanceof Error ? string | number | boolean | null> instanceof Error ? string | number | boolean | null> : new Error(String(string | number | boolean | null> instanceof Error ? string | number | boolean | null> instanceof Error ? string | number | boolean | null> : new Error(String(string | number | boolean | null> : new Error(String(string | number | boolean | null> instanceof Error ? string | number | boolean | null> : new Error(String(string | number | boolean | null> : new Error(String(string | number | boolean | null> instanceof Error ? string | number | boolean | null> : new Error(String(string | number | boolean | null> instanceof Error ? string | number | boolean | null> instanceof Error ? string | number | boolean | null> : new Error(String(string | number | boolean | null> : new Error(String(string | number | boolean | null> instanceof Error ? string | number | boolean | null> : new Error(String(string | number | boolean | null>))))))): StorageData {
    const result: StorageData = {
      value: null,
      timestamp: 0,
      expireTime: 0
    };
    
    // å®‰å…¨åœ°å¤„ç†æ‰€æœ‰å±æ€§ï¼Œé¿å…ä½¿ç”¨ç´¢å¼•è®¿é—®å’Œä»»ä½•åŸå‹æ–¹æ³?    try {
      // è·å–å¯¹è±¡çš„æ‰€æœ‰è‡ªæœ‰å±æ€§é”®ï¼Œé¿å…ä½¿ç”¨inæ“ä½œç¬?      const keys = Object.keys(parsedData);
      
      // å¤„ç†valueå±æ€?- é¿å…ä½¿ç”¨ç´¢å¼•è®¿é—®
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key === 'value') {
          // å®‰å…¨åœ°è·å–å±æ€§å€¼ï¼Œé¿å…ä½¿ç”¨ç´¢å¼•è®¿é—®
          if (Object.keys(parsedData).includes(key)) {
            const valueData = parsedData[key];
            if (typeof valueData === 'string' || typeof valueData === 'number' || 
                typeof valueData === 'boolean' || valueData === null) {
              result.value = valueData;
            }
          }
        } else if (key === 'timestamp') {
          // å®‰å…¨åœ°è·å–å±æ€§å€¼ï¼Œé¿å…ä½¿ç”¨ç´¢å¼•è®¿é—®
          if (Object.keys(parsedData).includes(key)) {
            const tsValue = parsedData[key];
            if (typeof tsValue === 'number') {
              result.timestamp = tsValue;
            } else if (typeof tsValue === 'string') {
              const numValue = Number(tsValue);
              // ä½¿ç”¨æ›´åŸºç¡€çš„NaNæ£€æŸ¥æ–¹å¼ï¼Œé¿å…ä½¿ç”¨Number.isNaN
              if (typeof numValue === 'number' && numValue === numValue) {
                result.timestamp = numValue;
              }
            }
          }
        } else if (key === 'expireTime') {
          // å®‰å…¨åœ°è·å–å±æ€§å€¼ï¼Œé¿å…ä½¿ç”¨ç´¢å¼•è®¿é—®
          if (Object.keys(parsedData).includes(key)) {
            const expValue = parsedData[key];
            if (typeof expValue === 'number') {
              // ä½¿ç”¨æ›´åŸºç¡€çš„NaNæ£€æŸ¥æ–¹å¼ï¼Œé¿å…ä½¿ç”¨Number.isNaN
              if (expValue === expValue) {
                result.expireTime = expValue;
              }
            } else if (typeof expValue === 'string') {
              const numValue = Number(expValue);
              // ä½¿ç”¨æ›´åŸºç¡€çš„NaNæ£€æŸ¥æ–¹å¼ï¼Œé¿å…ä½¿ç”¨Number.isNaN
              if (typeof numValue === 'number' && numValue === numValue) {
                result.expireTime = numValue;
              }
            }
          }
        }
      }
    } catch (error) {
      // å®‰å…¨å¤„ç†é”™è¯¯ä¿¡æ¯
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      Logger.error(TAG, `Failed to build StorageData: ${errorMessage}`);
    }
    
    return result;
  }

  /**
   * éªŒè¯å€¼çš„ç±»å‹å®‰å…¨æ€?   */
  private static validateValue(value: string | number | boolean | JsonData | null | undefined): string | number | boolean | JsonData | null {
    // æ˜¾å¼å¤„ç†nullå’Œundefined
    if (value === null || value === undefined) {
      return null;
    }
    
    switch (typeof value) {
      case 'string':
      case 'number':
      case 'boolean':
        return value;
      case 'object':
        // ç¡®ä¿æ˜¯çº¯å¯¹è±¡è€Œéæ•°ç»„
        if (!Array.isArray(value)) {
          if (value instanceof JsonDataClass) {
            return value;
          }
          // åˆ›å»ºæ–°å¯¹è±¡ç¡®ä¿ç±»å‹å®‰å…?          const safeObj = new JsonDataClass();
          // è·å–å¯¹è±¡çš„æ‰€æœ‰è‡ªæœ‰å±æ€§é”®
          const keys = Object.keys(value);
          // ç”±äºä½¿ç”¨Object.keysè·å–çš„éƒ½æ˜¯è‡ªæœ‰å±æ€§ï¼Œä¸éœ€è¦é¢å¤–çš„hasOwnPropertyæ£€æŸ?          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (key !== undefined) {
              const safeKey = String(key); // ç¡®ä¿keyæ˜¯å­—ç¬¦ä¸²
              // æ£€æŸ¥å±æ€§æ˜¯å¦å­˜åœ¨å¹¶è®¿é—®
              if (Object.keys(value).includes(safeKey)) {
                // å®‰å…¨åœ°è·å–å±æ€§å€¼ï¼Œé¿å…ä½¿ç”¨anyç±»å‹
                // ä½¿ç”¨Object.keyså’Œincludesæ£€æŸ¥ï¼Œé¿å…ç›´æ¥ç´¢å¼•è®¿é—®
                const propValue = (() => {
                  for (const k of Object.keys(value)) {
                    if (k === safeKey) {
                      return (value as Record<string, string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null> instanceof Error ? string | number | boolean | object | null> : new Error(String(string | number | boolean | object | null>)))))))[k];
                    }
                  }
                  return undefined;
                })();
                
                // ç±»å‹å®‰å…¨åœ°å¤„ç†æ¯ä¸ªå±æ€§å€?                if (propValue !== undefined) {
                  if (typeof propValue === 'string' || 
                      typeof propValue === 'number' || 
                      typeof propValue === 'boolean' || 
                      propValue === null) {
                    safeObj.set(safeKey, propValue);
                  } else if (typeof propValue === 'object' && propValue !== null && !Array.isArray(propValue)) {
                    // å¤„ç†åµŒå¥—å¯¹è±¡
                    const validatedObj = new JsonDataClass();
                    const nestedKeys = Object.keys(propValue);
                    for (let j = 0; j < nestedKeys.length; j++) {
                      const nestedKey = nestedKeys[j];
                      // å®‰å…¨åœ°è·å–åµŒå¥—å±æ€§å€?                      if (Object.keys(propValue).includes(nestedKey)) {
                        const nestedPropValue = (() => {
                          for (const nk of Object.keys(propValue)) {
                            if (nk === nestedKey) {
                              return (propValue as Record<string, string | number | boolean | null>)[nk];
                            }
                          }
                          return undefined;
                        })();
                        if (nestedPropValue !== undefined && 
                            (typeof nestedPropValue === 'string' || typeof nestedPropValue === 'number' || 
                             typeof nestedPropValue === 'boolean' || nestedPropValue === null)) {
                          validatedObj.set(nestedKey, nestedPropValue);
                        }
                      }
                    }
                    // ç›´æ¥è®¾ç½®åµŒå¥—çš„JsonDataClasså¯¹è±¡
                    safeObj.set(safeKey, validatedObj);
                  }
                }
              }
            }
          }
          return safeObj;
        }
        // å¯¹äºæ•°ç»„ï¼Œè¿”å›nullï¼Œå› ä¸ºå­˜å‚¨ç»“æ„ä¸æ”¯æŒæ•°ç»„
        return null;
      default:
        // å¯¹äºä¸æ”¯æŒçš„ç±»å‹ï¼Œè¿”å›null
        return null;
    }
  }

  /**
   * å®‰å…¨çš„æ•°å­—è½¬æ¢ï¼Œé¿å…NaN
   */
  // ç§»é™¤anyç±»å‹ï¼Œä½¿ç”¨æ›´å…·ä½“çš„ç±»å‹å®šä¹?  private static safeNumber(value: string | number | boolean | null | undefined): number {
    if (value === null || value === undefined) {
      return 0;
    }
    const num = Number(value);
    // ä½¿ç”¨æ›´åŸºç¡€çš„NaNæ£€æŸ¥æ–¹å¼ï¼Œé¿å…ä½¿ç”¨isNaNå‡½æ•°
    // NaNæ˜¯å”¯ä¸€ä¸ç­‰äºè‡ªèº«çš„å€?    return typeof num === 'number' && num === num ? num : 0;
  }
}

// å¯¼å‡ºå•ä¾‹å®ä¾‹å‡½æ•°è€Œä¸æ˜¯ç›´æ¥å¯¼å‡ºå®ä¾?export function getStorageUtil(): StorageUtil {
  return StorageUtil.getInstance();
}



