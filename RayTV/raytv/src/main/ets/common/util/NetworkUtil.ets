// NetworkUtil - ç½‘ç»œè¯·æ±‚å’Œè¿æ¥ç®¡ç†å·¥å…·ç±»
import Logger from './Logger';
import { AppConstant } from '../constant/AppConstant';
import http from '@ohos.net.http';
import connection from '@ohos.net.connection';
import BusinessError from '@ohos.base';
import fs from '@ohos.file.fs';
import fileIO from '@ohos.file.fileIO';
import { CacheManager } from '../../service/spider/CacheManager';
import abilityAccessCtrl from '@ohos.abilityAccessCtrl';
import common from '@ohos.app.ability.common';

const TAG = 'NetworkUtil';

/**
 * ç½‘ç»œè¯·æ±‚é…ç½®æ¥å£
 */
export interface RequestConfig {
  url: string;
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  headers?: Record<string, string>;
  params?: Record<string, string | number | boolean | string[]>;
  data?: string | number | boolean | Record<string, string | number | boolean | null>;
  timeout?: number;
  responseType?: 'text' | 'json' | 'arraybuffer';
}

/**
 * ç½‘ç»œå“åº”æ¥å£
 */
export interface Response<T> {
  status: number;
  statusText: string;
  data: T;
  headers: Record<string, string>;
}

/**
 * æ–‡ä»¶ä¸‹è½½é€‰é¡¹æ¥å£
 */
export interface DownloadOptions {
  headers?: Record<string, string>;
  timeout?: number;
  onProgress?: (receivedSize: number, totalSize: number) => void;
}

/**
 * æ–‡æœ¬ä¸‹è½½é€‰é¡¹æ¥å£
 */
export interface DownloadTextOptions {
  headers?: Record<string, string>;
  timeout?: number;
}

/**
 * ç½‘ç»œå·¥å…·ç±? * æä¾›ç½‘ç»œè¯·æ±‚ã€è¿æ¥çŠ¶æ€æ£€æŸ¥ç­‰åŠŸèƒ½
 */
export default class NetworkUtil {
  private static readonly DEFAULT_TIMEOUT = 30000;
  private static readonly MAX_RETRY_COUNT = 3;
  private static networkStatusListeners: Set<(isOnline: boolean, networkType: string) => void> = new Set();
  private static isInitialized: boolean = false;
  private static context: common.Context | null = null;

  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰é”®
   * æ›¿ä»£Object.keysï¼Œå…¼å®¹ArkTSè¯­æ³•
   */
  private static getObjectKeys<T extends object>(obj: T): string[] {
    const keys: string[] = [];
    // ç›´æ¥ä½¿ç”¨Object.keysè·å–é”®ï¼Œé¿å…for-inå¾ªç¯ä¸­çš„åŸå‹é“¾é—®é¢?    const objectKeys = Object.keys(obj);
    for (let i = 0; i < objectKeys.length; i++) {
      keys.push(objectKeys[i]);
    }
    return keys;
  }

  /**
   * è®¾ç½®åº”ç”¨ä¸Šä¸‹æ–?   * @param ctx åº”ç”¨ä¸Šä¸‹æ–?   */
  public static setContext(ctx: common.Context): void {
    NetworkUtil.context = ctx;
  }

  /**
   * è·å–åº”ç”¨ä¸Šä¸‹æ–?   * @returns åº”ç”¨ä¸Šä¸‹æ–?   */
  private static getContext(): common.Context {
    if (!NetworkUtil.context) {
      throw new Error('NetworkUtil context not set. Please call NetworkUtil.setContext() first.');
    }
    return NetworkUtil.context;
  }

  /**
   * æ£€æŸ¥å¹¶è¯·æ±‚ç½‘ç»œæƒé™
   * åªåœ¨éœ€è¦æ—¶è¯·æ±‚æƒé™ï¼Œé¿å…é‡å¤ç”³è¯?   */
  private static async checkAndRequestNetworkPermission(): Promise<void> {
    try {
      const atManager = abilityAccessCtrl.createAtManager();
      const context = NetworkUtil.getContext();
      
      // å…ˆæ£€æŸ¥æƒé™çŠ¶æ€ï¼Œé¿å…é‡å¤ç”³è¯·
      const permissionResult: abilityAccessCtrl.GrantStatus = await atManager.checkPermission(context, 'ohos.permission.INTERNET');
      
      // åªæœ‰å½“æƒé™æœªæˆæƒæ—¶æ‰è¯·æ±‚
      if (permissionResult !== abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
        await atManager.requestPermissionsFromUser(context, ['ohos.permission.INTERNET']);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error(TAG, 'Failed to check or request INTERNET permission', error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage))))))));
      // ç¡®ä¿ä¼ é€’ç»™Logger.errorçš„æ˜¯Errorå¯¹è±¡
      // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå…è®¸åº”ç”¨ç»§ç»­å°è¯•ç½‘ç»œæ“ä½œ
    }
  }

  /**
   * åˆå§‹åŒ–ç½‘ç»œå·¥å…·ï¼Œåœ¨åº”ç”¨å¯åŠ¨æ—¶è°ƒç”¨
   */
  public static async initialize(): Promise<void> {
    if (!NetworkUtil.isInitialized) {
      // åˆå§‹åŒ–æ—¶æ£€æŸ¥æƒé™?      await NetworkUtil.checkAndRequestNetworkPermission();
      NetworkUtil.isInitialized = true;
    }
  }

  /**
   * GETè¯·æ±‚ä¾¿æ·æ–¹æ³•
   * @param url è¯·æ±‚URL
   * @param config è¯·æ±‚é…ç½®ï¼ˆå¯é€‰ï¼‰
   * @returns Promise<Response<T>>
   */
  public static async get<T>(url: string, config?: Partial<RequestConfig>): Promise<Response<T>> {
    const requestConfig: RequestConfig = {
      url,
      method: 'GET'
    };
    
    // æ‰‹åŠ¨å¤åˆ¶é…ç½®å±æ€§ï¼Œé¿å…ä½¿ç”¨æ‰©å±•è¿ç®—ç¬?    if (config) {
      if (config.headers) requestConfig.headers = config.headers;
      if (config.params) requestConfig.params = config.params;
      if (config.timeout !== undefined) requestConfig.timeout = config.timeout;
      if (config.responseType) requestConfig.responseType = config.responseType;
    }
    
    return NetworkUtil.request<T>(requestConfig);
  }

  /**
   * POSTè¯·æ±‚ä¾¿æ·æ–¹æ³•
   * @param url è¯·æ±‚URL
   * @param data è¯·æ±‚æ•°æ®
   * @param config è¯·æ±‚é…ç½®ï¼ˆå¯é€‰ï¼‰
   * @returns Promise<Response<T>>
   */
  public static async post<T>(url: string, data?: string | number | boolean | object, config?: Partial<RequestConfig>): Promise<Response<T>> {
    const requestConfig: RequestConfig = {
      url,
      method: 'POST',
      data
    };
    
    // æ‰‹åŠ¨å¤åˆ¶é…ç½®å±æ€§ï¼Œé¿å…ä½¿ç”¨æ‰©å±•è¿ç®—ç¬?    if (config) {
      if (config.headers) requestConfig.headers = config.headers;
      if (config.params) requestConfig.params = config.params;
      if (config.timeout !== undefined) requestConfig.timeout = config.timeout;
      if (config.responseType) requestConfig.responseType = config.responseType;
    }
    
    return NetworkUtil.request<T>(requestConfig);
  }

  /**
   * PUTè¯·æ±‚ä¾¿æ·æ–¹æ³•
   * @param url è¯·æ±‚URL
   * @param data è¯·æ±‚æ•°æ®
   * @param config è¯·æ±‚é…ç½®ï¼ˆå¯é€‰ï¼‰
   * @returns Promise<Response<T>>
   */
  public static async put<T>(url: string, data?: string | number | boolean | object, config?: Partial<RequestConfig>): Promise<Response<T>> {
    const requestConfig: RequestConfig = {
      url,
      method: 'PUT',
      data
    };
    
    // æ‰‹åŠ¨å¤åˆ¶é…ç½®å±æ€§ï¼Œé¿å…ä½¿ç”¨æ‰©å±•è¿ç®—ç¬?    if (config) {
      if (config.headers) requestConfig.headers = config.headers;
      if (config.params) requestConfig.params = config.params;
      if (config.timeout !== undefined) requestConfig.timeout = config.timeout;
      if (config.responseType) requestConfig.responseType = config.responseType;
    }
    
    return NetworkUtil.request<T>(requestConfig);
  }

  /**
   * DELETEè¯·æ±‚ä¾¿æ·æ–¹æ³•
   * @param url è¯·æ±‚URL
   * @param config è¯·æ±‚é…ç½®ï¼ˆå¯é€‰ï¼‰
   * @returns Promise<Response<T>>
   */
  public static async delete<T>(url: string, config?: Partial<RequestConfig>): Promise<Response<T>> {
    const requestConfig: RequestConfig = {
      url,
      method: 'DELETE'
    };
    
    // æ‰‹åŠ¨å¤åˆ¶é…ç½®å±æ€§ï¼Œé¿å…ä½¿ç”¨æ‰©å±•è¿ç®—ç¬?    if (config) {
      if (config.headers) requestConfig.headers = config.headers;
      if (config.params) requestConfig.params = config.params;
      if (config.timeout !== undefined) requestConfig.timeout = config.timeout;
      if (config.responseType) requestConfig.responseType = config.responseType;
    }
    
    return NetworkUtil.request<T>(requestConfig);
  }

  /**
   * å‘é€HTTPè¯·æ±‚
   * @param config è¯·æ±‚é…ç½®
   * @param retryCount å½“å‰é‡è¯•æ¬¡æ•°
   * @returns Promise<Response>
   */
  public static async request<T>(config: RequestConfig, retryCount: number = 0): Promise<Response<T>> {
    const url = config.url;
    const method = config.method || 'GET';
    const headers = config.headers || {};
    const params = config.params || {};
    const data = config.data;
    const timeout = config.timeout || NetworkUtil.DEFAULT_TIMEOUT;
    const responseType = config.responseType || 'json';

    try {
      // ç¡®ä¿å·²åˆå§‹åŒ–ï¼ˆå¦‚æœæœªåˆå§‹åŒ–ï¼Œä¼šè‡ªåŠ¨æ£€æŸ¥æƒé™ï¼‰
      if (!NetworkUtil.isInitialized) {
        await NetworkUtil.initialize();
      }

      // æ„å»ºå®Œæ•´URLï¼ˆæ·»åŠ æŸ¥è¯¢å‚æ•°ï¼‰
      let fullUrl = url;
      if (NetworkUtil.getObjectKeys(params).length > 0) {
        const queryString = NetworkUtil.buildQueryString(params);
        fullUrl = `${url}${url.includes('?') ? '&' : '?'}${queryString}`;
      }

      Logger.info(TAG, `Sending ${method} request to ${fullUrl}`);

      // åˆ›å»ºHTTPè¯·æ±‚
      const httpRequest = http.createHttp();
      
      // è®¾ç½®è¯·æ±‚é€‰é¡¹
      const httpOptions: http.HttpRequestOptions = {
        method,
        header: {
          'Content-Type': 'application/json'
        },
        connectTimeout: timeout,
        readTimeout: timeout
      };
      
      // æ‰‹åŠ¨åˆå¹¶headersï¼Œé¿å…æ•°ç»„å±•å¼€æ“ä½œ
      if (headers) {
        const headerKeys = NetworkUtil.getObjectKeys(headers);
        if (!httpOptions.header) {
          httpOptions.header = {};
        }
        for (let i = 0; i < headerKeys.length; i++) {
          const key = headerKeys[i];
          httpOptions.header[key] = headers[key];
        }
      }

      // æ·»åŠ è¯·æ±‚ä½?      if (data && ['POST', 'PUT', 'PATCH'].includes(method)) {
        httpOptions.extraData = typeof data === 'string' ? data : JSON.stringify(data);
      }

      try {
        // å‘é€è¯·æ±?        const response = await httpRequest.request(fullUrl, httpOptions);
        
        // è¯»å–å“åº”æ•°æ®
        let responseData: string | object | null = response.result;
        
        // å¤„ç†ä¸åŒå“åº”ç±»å‹
        if (responseType === 'json' && typeof responseData === 'string') {
          try {
            responseData = JSON.parse(responseData);
          } catch (parseError) {
            const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
            Logger.error(TAG, 'Failed to parse JSON response', parseError as Error instanceof Error ? parseError as Error : new Error(String(parseError as Error instanceof Error ? parseError as Error instanceof Error ? parseError as Error : new Error(String(parseError as Error : new Error(String(parseError as Error instanceof Error ? parseError as Error : new Error(String(parseError as Error instanceof Error ? parseError as Error instanceof Error ? parseError as Error : new Error(String(parseError as Error instanceof Error ? parseError as Error instanceof Error ? parseError as Error : new Error(String(parseError as Error : new Error(String(parseError as Error instanceof Error ? parseError as Error : new Error(String(parseError as Error : new Error(String(parseError as Error instanceof Error ? parseError as Error : new Error(String(parseError as Error instanceof Error ? parseError as Error instanceof Error ? parseError as Error : new Error(String(parseError as Error : new Error(String(parseError as Error instanceof Error ? parseError as Error : new Error(String(parseError as Error)))))));
          }
        }

        // æ„å»ºå“åº”å¤?        const responseHeaders: Record<string, string> = {};
        if (response.header) {
          const headerKeys = Object.keys(response.header);
          for (let i = 0; i < headerKeys.length; i++) {
            const key = headerKeys[i];
            responseHeaders[key] = String(response.header[key]);
          }
        }

        // æ£€æŸ¥çŠ¶æ€ç 
        if (response.responseCode < 200 || response.responseCode >= 300) {
          throw new Error(`HTTP error! status: ${response.responseCode}`);
        }

        return {
          status: response.responseCode,
          statusText: String(response.responseCode),
          data: responseData as T,
          headers: responseHeaders
        };
      } catch (error) {
        // é‡è¯•é€»è¾‘
        if (retryCount < NetworkUtil.MAX_RETRY_COUNT && NetworkUtil.isRetryableError(error)) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          Logger.warn(TAG, `Request failed, retrying (${retryCount + 1}/${NetworkUtil.MAX_RETRY_COUNT}): ${errorMessage}`);
          // æŒ‡æ•°é€€é¿ç­–ç•?          const delay = Math.pow(2, retryCount) * 1000;
          await NetworkUtil.sleep(delay);
          return NetworkUtil.request(config, retryCount + 1);
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        Logger.error(TAG, 'Request error', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
        throw error instanceof Error ? error : new Error(errorMessage);
      } finally {
        // é”€æ¯HTTPè¯·æ±‚
        httpRequest.destroy();
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error(TAG, 'Request failed with error', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
      throw error instanceof Error ? error : new Error(errorMessage);
    }
  }

  /**
   * åˆ¤æ–­é”™è¯¯æ˜¯å¦å¯é‡è¯?   * @param error é”™è¯¯å¯¹è±¡
   * @returns æ˜¯å¦å¯é‡è¯?   */
  private static isRetryableError(error: Error | string): boolean {
    // ç½‘ç»œé”™è¯¯ã€è¶…æ—¶ã€æœåŠ¡å™¨é”™è¯¯(5xx)å¯é‡è¯?    if (error instanceof Error) {
      const errorName = error.name;
      const errorMessage = error.message;
      return errorName === 'AbortError' || 
             errorMessage.includes('Network') ||
             errorMessage.includes('timeout');
    }
    return false;
  }

  /**
   * å»¶æ—¶å‡½æ•°
   * @param ms å»¶æ—¶æ¯«ç§’æ•?   * @returns Promise<void>
   */
  private static sleep(ms: number): Promise<void> {
    // ä½¿ç”¨PromiseåŒ…è£…setTimeoutï¼Œè¿™åœ¨HarmonyOSä¸­æ˜¯å…¼å®¹çš?    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, ms);
    });
  }

  /**
   * æ£€æŸ¥ç½‘ç»œè¿æ¥çŠ¶æ€?   * @returns Promise<boolean>
   */
  public static async checkNetworkStatus(): Promise<boolean> {
    try {
      // ä½¿ç”¨HarmonyOSåŸç”ŸAPIæ£€æŸ¥ç½‘ç»œçŠ¶æ€?      const netStatus: connection.NetworkStatus = await connection.getStatus();
      return netStatus.isInternetAvailable;
    } catch (error) {
      Logger.warn(TAG, 'Network check failed:', error);
      // å¤‡ç”¨æ–¹æ³•ï¼šä½¿ç”¨HTTPè¯·æ±‚æ£€æŸ?      try {
        const httpRequest = http.createHttp();
        const response = await httpRequest.request(AppConstant.NETWORK_CHECK_URL, {
          method: 'HEAD',
          connectTimeout: 3000,
          readTimeout: 3000
        });
        httpRequest.destroy();
        return response.responseCode >= 200 && response.responseCode < 300;
      } catch (httpError) {
        Logger.warn(TAG, 'HTTP network check failed:', httpError);
        return false;
      }
    }
  }

  /**
   * ä¸‹è½½æ–‡ä»¶
   * @param url æ–‡ä»¶URL
   * @param savePath ä¿å­˜è·¯å¾„
   * @param options ä¸‹è½½é€‰é¡¹
   * @returns Promise<void>
   */
  public static async downloadFile(url: string, savePath: string, options?: DownloadOptions): Promise<void> {
    try {
      // åˆ›å»ºHTTPè¯·æ±‚
      const httpRequest = http.createHttp();
      
      // åˆå§‹åŒ–headerå¯¹è±¡
      const headers = options?.headers || {};
      
      const downloadOptions: http.HttpRequestOptions = {
        method: 'GET',
        header: headers,
        responseType: http.HttpResponseType.ARRAY_BUFFER,
        connectTimeout: options?.timeout || 60000,
        readTimeout: options?.timeout || 60000
      };

      // å‘é€ä¸‹è½½è¯·æ±?      const response = await httpRequest.request(url, downloadOptions);
      
      // æ£€æŸ¥å“åº”çŠ¶æ€?      if (response.responseCode < 200 || response.responseCode >= 300) {
        throw new Error(`Download failed with status ${response.responseCode}`);
      }
      
      // ç¡®ä¿å“åº”æ˜¯ArrayBufferç±»å‹
      if (typeof response.result !== 'object' || !(response.result instanceof ArrayBuffer)) {
        throw new Error('Invalid response data type');
      }
      
      // è·å–æ–‡ä»¶æ€»å¤§å°?      const totalSize = response.result.byteLength;
      
      // å†™å…¥æ–‡ä»¶
      const file: fileIO.File = await fileIO.open(savePath, fileIO.OpenMode.READ_WRITE | fileIO.OpenMode.CREATE);
      
      try {
        // å°†ArrayBufferå†™å…¥æ–‡ä»¶
        const writeResult: fileIO.WriteResult = await fileIO.write(file.fd, response.result);
        
        // é€šçŸ¥è¿›åº¦å®Œæˆ
        if (options?.onProgress) {
          options.onProgress(totalSize, totalSize);
        }
        
        Logger.info(TAG, `File downloaded successfully: ${savePath}, size: ${writeResult.bytesWritten} bytes`);
      } finally {
        // å…³é—­æ–‡ä»¶
        await fileIO.close(file.fd);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error(TAG, 'Failed to download file', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
      throw error instanceof Error ? error : new Error(errorMessage);
    }
  }
  
  /**
   * åˆå§‹åŒ–ç½‘ç»œçŠ¶æ€ç›‘å?   */
  private static async initializeNetworkListener(): Promise<void> {
    if (NetworkUtil.isInitialized) return;
    
    try {
      // è®¢é˜…ç½‘ç»œçŠ¶æ€å˜åŒ?      await connection.on('netStatusChange', async (data: connection.NetworkStatus | null) => {
        const isOnline = data !== null && data.isInternetAvailable !== false;
        const networkType = isOnline ? await NetworkUtil.getNetworkType() : 'NONE';
        
        Logger.info(TAG, `Network status changed: online=${isOnline}, type=${networkType}`);
        
        // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
        NetworkUtil.notifyNetworkStatusChanged(isOnline, networkType);
      });
      
      // è·å–åˆå§‹ç½‘ç»œçŠ¶æ€?      const status: connection.NetworkStatus = await connection.getStatus();
      const isOnline = status.isInternetAvailable !== false;
      const networkType = isOnline ? await NetworkUtil.getNetworkType() : 'NONE';
      
      Logger.info(TAG, `Initial network status: online=${isOnline}, type=${networkType}`);
      
      NetworkUtil.isInitialized = true;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error(TAG, 'Failed to initialize network listener', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
    }
  }

  /**
   * é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨ç½‘ç»œçŠ¶æ€å˜åŒ?   * @param isOnline æ˜¯å¦åœ¨çº¿
   * @param networkType ç½‘ç»œç±»å‹
   */
  private static notifyNetworkStatusChanged(isOnline: boolean, networkType: string): void {
    NetworkUtil.networkStatusListeners.forEach((listener) => {
      try {
        listener(isOnline, networkType);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        Logger.error(TAG, 'Error in network status listener', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
      }
    });
  }

  /**
   * æ·»åŠ ç½‘ç»œçŠ¶æ€ç›‘å¬å™¨
   * @param listener ç›‘å¬å™¨å›è°ƒå‡½æ•?   * @returns å–æ¶ˆç›‘å¬çš„å‡½æ•?   */
  public static addNetworkStatusListener(listener: (isOnline: boolean, networkType: string) => void): () => void {
    NetworkUtil.networkStatusListeners.add(listener);
    
    // è‡ªåŠ¨åˆå§‹åŒ–ç›‘å?    NetworkUtil.initializeNetworkListener().catch((error) => {
      Logger.error(TAG, 'Failed to initialize network listener after adding', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
    });
    
    // è¿”å›å–æ¶ˆç›‘å¬çš„å‡½æ•?    return () => {
      NetworkUtil.removeNetworkStatusListener(listener);
    };
  }

  /**
   * ç§»é™¤ç½‘ç»œçŠ¶æ€ç›‘å¬å™¨
   * @param listener è¦ç§»é™¤çš„ç›‘å¬å™?   */
  public static removeNetworkStatusListener(listener: (isOnline: boolean, networkType: string) => void): void {
    NetworkUtil.networkStatusListeners.delete(listener);
  }

  /**
   * è·å–å½“å‰æ˜¯å¦åœ¨çº¿
   * @returns æ˜¯å¦åœ¨çº¿çš„Promise
   */
  public static async isOnline(): Promise<boolean> {
    try {
      const status = await connection.getStatus();
      return status !== null && status.isInternetAvailable !== false;
    } catch (error) {
      Logger.warn(TAG, `Failed to check online status: ${error}`);
      return false;
    }
  }

  /**
   * ä¸‹è½½æ–‡æœ¬å†…å®¹
   * @param url æ–‡æœ¬URL
   * @param options ä¸‹è½½é€‰é¡¹
   * @returns Promise<string>
   */
  public static async downloadText(url: string, options?: DownloadTextOptions): Promise<string> {
    try {
      // åˆ›å»ºHTTPè¯·æ±‚
      const httpRequest = http.createHttp();
      
      // åˆå§‹åŒ–headerå¯¹è±¡
      const headers = options?.headers || {};
      
      const downloadOptions: http.HttpRequestOptions = {
        method: 'GET',
        header: headers,
        connectTimeout: options?.timeout || 30000,
        readTimeout: options?.timeout || 30000
      };

      // å‘é€è¯·æ±?      const response = await httpRequest.request(url, downloadOptions);
      httpRequest.destroy();
      
      // æ£€æŸ¥å“åº”çŠ¶æ€?      if (response.responseCode < 200 || response.responseCode >= 300) {
        throw new Error(`Download failed with status ${response.responseCode}`);
      }
      
      // è¿”å›æ–‡æœ¬å†…å®¹
      return response.result as string;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error(TAG, 'Failed to download text', error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage instanceof Error ? error instanceof Error ? error : new Error(errorMessage : new Error(String(error instanceof Error ? error : new Error(errorMessage))))))));
      throw error instanceof Error ? error : new Error(errorMessage);
    }
  }

  /**
   * æ„å»ºæŸ¥è¯¢å­—ç¬¦ä¸?   * @param params æŸ¥è¯¢å‚æ•°å¯¹è±¡
   * @returns æ„å»ºå¥½çš„æŸ¥è¯¢å­—ç¬¦ä¸?   */
  private static buildQueryString(params: Record<string, string | number | boolean | string[]>): string {
    const parts: string[] = [];
    const keys = NetworkUtil.getObjectKeys(params);
    
    for (const key of keys) {
      const value = params[key];
      if (Array.isArray(value)) {
        // å¤„ç†æ•°ç»„å‚æ•°
        for (const item of value) {
          const encodedKey = encodeURIComponent(key);
          const encodedValue = encodeURIComponent(String(item));
          parts.push(`${encodedKey}=${encodedValue}`);
        }
      } else {
        const encodedKey = encodeURIComponent(key);
        const encodedValue = encodeURIComponent(String(value));
        parts.push(`${encodedKey}=${encodedValue}`);
      }
    }
    
    return parts.join('&');
  }

  /**
   * è·å–ç½‘ç»œç±»å‹
   * @returns ç½‘ç»œç±»å‹
   */
  public static async getNetworkType(): Promise<string> {
    try {
      // ä½¿ç”¨HarmonyOSåŸç”ŸAPIè·å–ç½‘ç»œç±»å‹
      const netStatus = await connection.getStatus();
      
      // æ ¹æ®ç½‘ç»œç±»å‹è¿”å›æ ‡å‡†åŒ–çš„ç»“æœ
      switch (netStatus.type) {
        case connection.NetConnectType.NONE:
          return 'none';
        case connection.NetConnectType.WIFI:
          return 'wifi';
        case connection.NetConnectType.MOBILE:
          // è¿›ä¸€æ­¥åŒºåˆ†ç§»åŠ¨ç½‘ç»œç±»å?          if (netStatus.subtype) {
            if (netStatus.subtype >= connection.NetConnectSubtype.NR_5G && netStatus.subtype <= connection.NetConnectSubtype.NR_5G_E) {
              return '5g';
            } else if (netStatus.subtype >= connection.NetConnectSubtype.LTE && netStatus.subtype <= connection.NetConnectSubtype.LTE_ADVANCED_PRO) {
              return '4g';
            } else if (netStatus.subtype >= connection.NetConnectSubtype.UMTS && netStatus.subtype <= connection.NetConnectSubtype.HSPA_PLUS) {
              return '3g';
            } else if (netStatus.subtype >= connection.NetConnectSubtype.GPRS && netStatus.subtype <= connection.NetConnectSubtype.EDGE) {
              return '2g';
            }
          }
          return 'mobile';
        case connection.NetConnectType.ETHERNET:
          return 'ethernet';
        default:
          return 'unknown';
      }
    } catch (error) {
      Logger.warn(TAG, 'Failed to detect network type:', error);
      // å¤‡ç”¨æ–¹æ³•ï¼šé€šè¿‡HTTPè¯·æ±‚å“åº”æ—¶é—´ä¼°è®¡
      try {
        const startTime = Date.now();
        const httpRequest = http.createHttp();
        await httpRequest.request(AppConstant.NETWORK_CHECK_URL, {
          method: 'HEAD',
          connectTimeout: 3000
        });
        httpRequest.destroy();
        const endTime = Date.now();
        const responseTime = endTime - startTime;
        
        if (responseTime < 100) return '4g';
        if (responseTime < 300) return '3g';
        if (responseTime < 1000) return '2g';
        return 'slow';
      } catch (fallbackError) {
        Logger.warn(TAG, 'Fallback network type detection failed:', fallbackError);
        return 'unknown';
      }
    }
  }

  /**
   * åˆ›å»ºå¸¦ç¼“å­˜çš„è¯·æ±‚
   * @param url è¯·æ±‚URL
   * @param cacheTime ç¼“å­˜æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
   * @returns Promise<T>
   */
// ç¼“å­˜å“åº”æ•°æ®ç»“æ„
export interface CachedResponse<T> {
  data: T;
  timestamp: number;
}

  public static async cachedRequest<T>(url: string, cacheTime: number = 5 * 60 * 1000): Promise<T> {
    try {
      const cacheKey = `network_cache_${url.replace(/[^a-zA-Z0-9]/g, '_')}`;
      
      // å°è¯•ä»ç¼“å­˜è·å–æ•°æ?      const cacheManager: CacheManager = CacheManager.getInstance();
      
      try {
        const cachedData = cacheManager.get(cacheKey);
        if (cachedData && typeof cachedData === 'string') {
          const parsedData: CachedResponse<T> = JSON.parse(cachedData);
          const cacheData: T = parsedData.data;
          const timestamp: number = parsedData.timestamp;
          const now: number = Date.now();
          
          // æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•?          if (now - timestamp < cacheTime) {
            Logger.info(TAG, `Using cached data for ${url}`);
            return cacheData;
          }
        }
      } catch (cacheError) {
        const errorMessage = cacheError instanceof Error ? cacheError.message : String(cacheError);
        Logger.warn(TAG, `Cache read error: ${errorMessage}`);
        // ç¼“å­˜è¯»å–å¤±è´¥ï¼Œç»§ç»­å‘é€ç½‘ç»œè¯·æ±?      }
      
      // æ£€æŸ¥ç½‘ç»œçŠ¶æ€?      const isNetworkAvailable = await NetworkUtil.checkNetworkStatus();
      if (!isNetworkAvailable) {
        // ç¦»çº¿æ¨¡å¼ï¼Œå°è¯•è¿”å›æ—§ç¼“å­˜ï¼ˆå³ä½¿è¿‡æœŸï¼‰
        try {
          const oldCachedData = cacheManager.get(cacheKey);
          if (oldCachedData && typeof oldCachedData === 'string') {
            Logger.warn(TAG, `Offline mode: using expired cache for ${url}`);
            const parsedData: CachedResponse<T> = JSON.parse(oldCachedData);
            const cacheData: T = parsedData.data;
            return cacheData;
          }
        } catch (offlineCacheError) {
          const errorMessage = offlineCacheError instanceof Error ? offlineCacheError.message : String(offlineCacheError);
          Logger.error(TAG, 'Offline cache error', offlineCacheError as Error instanceof Error ? offlineCacheError as Error : new Error(String(offlineCacheError as Error instanceof Error ? offlineCacheError as Error instanceof Error ? offlineCacheError as Error : new Error(String(offlineCacheError as Error : new Error(String(offlineCacheError as Error instanceof Error ? offlineCacheError as Error : new Error(String(offlineCacheError as Error instanceof Error ? offlineCacheError as Error instanceof Error ? offlineCacheError as Error : new Error(String(offlineCacheError as Error instanceof Error ? offlineCacheError as Error instanceof Error ? offlineCacheError as Error : new Error(String(offlineCacheError as Error : new Error(String(offlineCacheError as Error instanceof Error ? offlineCacheError as Error : new Error(String(offlineCacheError as Error : new Error(String(offlineCacheError as Error instanceof Error ? offlineCacheError as Error : new Error(String(offlineCacheError as Error instanceof Error ? offlineCacheError as Error instanceof Error ? offlineCacheError as Error : new Error(String(offlineCacheError as Error : new Error(String(offlineCacheError as Error instanceof Error ? offlineCacheError as Error : new Error(String(offlineCacheError as Error)))))));
        }
        throw new Error('Network unavailable and no cached data available');
      }
      
      // ç¼“å­˜æ— æ•ˆæˆ–ä¸å­˜åœ¨ï¼Œå‘é€æ–°è¯·æ±‚
      const response = await NetworkUtil.get<T>(url);
      
      // ä¿å­˜æ–°ç¼“å­?      // ä½¿ç”¨Object.createå’Œå±æ€§èµ‹å€¼æ›¿ä»£å¯¹è±¡å­—é¢é‡
      const cacheData: CachedResponse<T> = Object.create(null) as CachedResponse<T>;
      cacheData.data = response.data;
      cacheData.timestamp = Date.now();
      
      // å°è¯•ä¿å­˜åˆ°ç¼“å­?      if (cacheManager) {
        try {
          cacheManager.set(cacheKey, JSON.stringify(cacheData));
          Logger.info(TAG, `Cached response for ${url}`);
        } catch (cacheWriteError) {
          const errorMessage = cacheWriteError instanceof Error ? cacheWriteError.message : String(cacheWriteError);
          Logger.warn(TAG, `Cache write error: ${errorMessage}`);
          // ç¼“å­˜å†™å…¥å¤±è´¥ï¼Œç»§ç»­è¿”å›æ•°æ?        }
      }
      
      return response.data;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error(TAG, 'Cached request failed', error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error instanceof Error ? error as Error instanceof Error ? error as Error : new Error(String(error as Error : new Error(String(error as Error instanceof Error ? error as Error : new Error(String(error as Error)))))));
      // ç¡®ä¿é”™è¯¯æ˜¯Errorç±»å‹
      throw error instanceof Error ? error : new Error(errorMessage);
    }
  }
}

// å®šä¹‰æ¥å£ä»¥æ›¿ä»£å¯¹è±¡å­—é¢é‡ä½œä¸ºç±»å‹
export interface CacheData {
  data: string;
  timestamp: number;
  expirationTime?: number;
}

export interface NetworkCacheItem {
  key: string;
  data: string;
  timestamp: number;
  expirationTime?: number;
}

// ä¿®å¤throwè¯­å¥ä¸èƒ½æ¥å—ä»»æ„ç±»å‹çš„é—®é¢?export function createNetworkError(message: string, code?: number): Error {
  const error = new Error(message);
  // é¿å…ä½¿ç”¨Object.assignï¼Œç›´æ¥è®¾ç½®å±æ€?  if (code) {
    // ä½¿ç”¨ç±»å‹æ–­è¨€ä¸ºErroræ·»åŠ codeå±æ€?    Object.defineProperty(error, 'code', {
      value: code,
      writable: false,
      enumerable: true,
      configurable: true
    });
  }
  return error;
}


