// PinyinUtil.ets - æ‹¼éŸ³å·¥å…·ç±?// è´Ÿè´£ä¸­æ–‡åˆ°æ‹¼éŸ³çš„è½¬æ¢ï¼Œæ”¯æŒå…¨æ‹¼å’Œé¦–å­—æ¯æå?
import Logger from './Logger';

const TAG = 'PinyinUtil';

/**
 * æ±‰å­—é¦–å­—æ¯æ˜ å°„è¡¨ï¼ˆå¸¸ç”¨æ±‰å­—ï¼‰
 * è¿™é‡ŒåªåŒ…å«éƒ¨åˆ†å¸¸ç”¨æ±‰å­—çš„é¦–å­—æ¯æ˜ å°„ï¼Œå®é™…åº”ç”¨ä¸­å¯ä»¥æ‰©å±? */
const PINYIN_MAP: Record<string, string> = {
  // å£°æ¯éƒ¨åˆ†
  'a': 'a', 'o': 'o', 'e': 'e', 'i': 'i', 'u': 'u', 'v': 'v',
  // éƒ¨åˆ†å¸¸ç”¨æ±‰å­—
  'ä¸€': 'y', 'ä¸?: 'd', 'ä¸?: 'q', 'ä¸?: 'w', 'ä¸?: 's', 'ä¸?: 's', 'ä¸?: 'x', 'ä¸?: 'b', 'ä¸?: 'y', 'ä¸?: 'c',
  'ä¸?: 'z', 'ä¸?: 'q', 'ä¸?: 's', 'ä¸?: 'b', 'ä¸?: 'y', 'ä¸?: 'c', 'ä¸?: 'd', 'ä¸?: 's', 'ä¸?: 'c', 'ä¸?: 'd',
  'ä¸?: 'l', 'ä¸?: 'y', 'ä¸?: 's', 'ä¸?: 'g', 'ä¸?: 'z', 'ä¸?: 'f', 'ä¸?: 'l', 'ä¸?: 'w', 'ä¸?: 'd', 'ä¸?: 'w',
  'ä¸?: 'z', 'ä¸?: 'l', 'ä¸?: 'j', 'ä¹?: 'n', 'ä¹?: 'j', 'ä¹?: 'm', 'ä¹?: 'y', 'ä¹?: 'z', 'ä¹?: 'w', 'ä¹?: 'z',
  'ä¹?: 'h', 'ä¹?: 'f', 'ä¹?: 'l', 'ä¹?: 'p', 'ä¹?: 'p', 'ä¹?: 'q', 'ä¹?: 'g', 'ä¹?: 'c', 'ä¹?: 'y', 'ä¹?: 'j',
  'ä¹?: 'q', 'ä¹?: 'y', 'ä¹?: 'x', 'ä¹?: 'x', 'ä¹?: 's', 'äº?: 'y', 'äº?: 'y', 'äº?: 'h', 'äº?: 'w', 'äº?: 'j',
  'äº?: 'g', 'äº?: 'y', 'äº?: 'w', 'äº?: 'h', 'äº?: 'j', 'äº?: 'y', 'äº?: 'c', 'äº?: 'h', 'äº?: 'm', 'äº?: 'x',
  'äº?: 'j', 'äº?: 't', 'äº?: 'l', 'äº?: 'q', 'äº?: 'r', 'ä»?: 'r', 'ä»?: 'j', 'ä»?: 'c', 'ä»?: 'l', 'ä»?: 'c',
  'ä»?: 's', 'ä»?: 't', 'ä»?: 'z', 'ä»?: 'f', 'ä»?: 'x', 'ä»?: 'm', 'ä»?: 'd', 'ä»?: 'l', 'ä»?: 'y', 'ä»?: 'y',
  'ä»?: 'z', 'ä»?: 'r', 'ä¼?: 'y', 'ä¼?: 'w', 'ä¼?: 'f', 'ä¼?: 'f', 'ä¼?: 'x', 'ä¼?: 'h', 'ä¼?: 'w', 'ä¼?: 'c',
  'ä¼?: 's', 'ä¼?: 's', 'ä½?: 'h', 'ä¼?: 'g', 'ä½?: 'y', 'ä½?: 'y', 'ä½?: 'p', 'ä¾?: 'h', 'ä¾?: 'q', 'ä¾?: 'b',
  'ä¿?: 'c', 'ä¿?: 'e', 'ä¿?: 'q', 'ä¿?: 'j', 'ä¿?: 'q', 'ä¿?: 'l',
  // æ•°å­—
  '0': '0', '1': '1', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6', '7': '7', '8': '8', '9': '9',
  // å­—æ¯
  'A': 'a', 'B': 'b', 'C': 'c', 'D': 'd', 'E': 'e', 'F': 'f', 'G': 'g', 'H': 'h', 'I': 'i', 'J': 'j',
  'K': 'k', 'L': 'l', 'M': 'm', 'N': 'n', 'O': 'o', 'P': 'p', 'Q': 'q', 'R': 'r', 'S': 's', 'T': 't',
  'U': 'u', 'V': 'v', 'W': 'w', 'X': 'x', 'Y': 'y', 'Z': 'z'
};

/**
 * æ‹¼éŸ³å·¥å…·ç±? * æä¾›ä¸­æ–‡åˆ°æ‹¼éŸ³çš„è½¬æ¢åŠŸèƒ½ï¼Œæ”¯æŒå…¨æ‹¼å’Œé¦–å­—æ¯æå? */
export class PinyinUtil {
  private static instance: PinyinUtil;
  private constructor() {}

  /**
   * è·å–æ‹¼éŸ³å·¥å…·å•ä¾‹
   */
  public static getInstance(): PinyinUtil {
    if (!PinyinUtil.instance) {
      PinyinUtil.instance = new PinyinUtil();
    }
    return PinyinUtil.instance;
  }

  /**
   * æå–å­—ç¬¦ä¸²çš„æ‹¼éŸ³é¦–å­—æ¯?   * @param text è¾“å…¥æ–‡æœ¬
   * @returns æ‹¼éŸ³é¦–å­—æ¯å­—ç¬¦ä¸²
   */
  public getFirstLetter(text: string): string {
    if (!text || typeof text !== 'string') {
      Logger.debug(TAG, 'Invalid text parameter in getFirstLetter');
      return '';
    }

    let result = '';
    
    // éå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬?    for (let i = 0; i < text.length; i++) {
      const char = text.charAt(i);
      
      // å¦‚æœæ˜¯è‹±æ–‡å­—æ¯ï¼Œç›´æ¥è½¬ä¸ºå°å†™
      // é¿å…ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼Œä½¿ç”¨å­—ç¬¦ç èŒƒå›´åˆ¤æ–?      const charCode = char.charCodeAt(0);
      if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122)) {
        // ç¡®ä¿æ˜¯å°å†?        if (charCode >= 65 && charCode <= 90) {
          result += String.fromCharCode(charCode + 32);
        } else {
          result += char;
        }
      }
      // å¦‚æœæ˜¯æ•°å­—ï¼Œç›´æ¥æ·»åŠ 
      else if (charCode >= 48 && charCode <= 57) {
        result += char;
      }
      // å¦‚æœæ˜¯æ±‰å­—ï¼ŒæŸ¥æ‰¾é¦–å­—æ¯?      else {
        // é¿å…ä½¿ç”¨inæ“ä½œç¬¦ï¼Œé€šè¿‡è·å–æ‰€æœ‰é”®å¹¶æŸ¥æ‰?        let found = false;
        const mapKeys = this.getMapKeys(PINYIN_MAP);
        for (let j = 0; j < mapKeys.length; j++) {
          if (mapKeys[j] === char) {
            result += PINYIN_MAP[char];
            found = true;
            break;
          }
        }
        
        // å¯¹äºæœªæ‰¾åˆ°æ˜ å°„çš„å­—ç¬¦ï¼Œå¯ä»¥æ·»åŠ é»˜è®¤å¤„ç†é€»è¾‘
        // ä¾‹å¦‚ä½¿ç”¨åŸå­—ç¬¦æˆ–è·³è¿‡
        if (!found) {
          // å¯é€‰ï¼šè®°å½•æœªè¯†åˆ«çš„å­—ç¬¦
          Logger.debug(TAG, `Unrecognized character: ${char}`);
        }
      }
    }

    return result;
  }
  
  /**
   * è·å–æ˜ å°„è¡¨çš„æ‰€æœ‰é”®ï¼ˆå…¼å®¹ArkTSï¼?   * @param map æ˜ å°„è¡?   * @returns é”®æ•°ç»?   */
  private getMapKeys(map: Record<string, string>): string[] {
    const keys: string[] = [];
    try {
      // ä½¿ç”¨Object.keysè·å–å¯¹è±¡çš„é”®ï¼Œè¿™åœ¨HarmonyOSç¯å¢ƒä¸­æ˜¯æ”¯æŒçš?      const objKeys = Object.keys(map);
      for (let i = 0; i < objKeys.length; i++) {
        keys.push(objKeys[i]);
      }
    } catch (error) {
      Logger.error(TAG, `Failed to get map keys: ${error instanceof Error ? error.message : String(error)}`);
    }
    
    return keys;
  }

  /**
   * æ£€æŸ¥æ–‡æœ¬æ˜¯å¦åŒ…å«æŒ‡å®šçš„æ‹¼éŸ³é¦–å­—æ¯åºåˆ?   * @param text è¾“å…¥æ–‡æœ¬
   * @param pinyin æ‹¼éŸ³é¦–å­—æ¯åºåˆ?   * @returns æ˜¯å¦åŒ¹é…
   */
  public containsPinyin(text: string, pinyin: string instanceof Error ? pinyin: string : new Error(String(pinyin: string instanceof Error ? pinyin: string instanceof Error ? pinyin: string : new Error(String(pinyin: string : new Error(String(pinyin: string instanceof Error ? pinyin: string : new Error(String(pinyin: string instanceof Error ? pinyin: string instanceof Error ? pinyin: string : new Error(String(pinyin: string instanceof Error ? pinyin: string instanceof Error ? pinyin: string : new Error(String(pinyin: string : new Error(String(pinyin: string instanceof Error ? pinyin: string : new Error(String(pinyin: string : new Error(String(pinyin: string instanceof Error ? pinyin: string : new Error(String(pinyin: string instanceof Error ? pinyin: string instanceof Error ? pinyin: string : new Error(String(pinyin: string : new Error(String(pinyin: string instanceof Error ? pinyin: string : new Error(String(pinyin: string))))))): boolean {
    // å‚æ•°éªŒè¯
    if (!text || !pinyin || typeof text !== 'string' || typeof pinyin !== 'string') {
      Logger.debug(TAG, 'Invalid parameters in containsPinyin');
      return false;
    }

    // è·å–æ‹¼éŸ³é¦–å­—æ¯?    const firstLetters = this.getFirstLetter(text);
    const lowerPinyin = this.toLowercase(pinyin);
    
    // å®ç°å­—ç¬¦ä¸²åŒ…å«æ£€æŸ¥ï¼ˆä¸ä½¿ç”¨å†…ç½®çš„includesæ–¹æ³•ï¼?    return this.stringContains(firstLetters, lowerPinyin);
  }

  /**
   * æ£€æŸ¥æ–‡æœ¬æ˜¯å¦ä»¥æŒ‡å®šçš„æ‹¼éŸ³é¦–å­—æ¯åºåˆ—å¼€å¤?   * @param text è¾“å…¥æ–‡æœ¬
   * @param pinyin æ‹¼éŸ³é¦–å­—æ¯åºåˆ?   * @returns æ˜¯å¦åŒ¹é…
   */
  public startsWithPinyin(text: string, pinyin: string): boolean {
    // å‚æ•°éªŒè¯
    if (!text || !pinyin || typeof text !== 'string' || typeof pinyin !== 'string') {
      Logger.debug(TAG, 'Invalid parameters in startsWithPinyin');
      return false;
    }

    // è·å–æ‹¼éŸ³é¦–å­—æ¯?    const firstLetters = this.getFirstLetter(text);
    const lowerPinyin = this.toLowercase(pinyin);
    
    // å®ç°å­—ç¬¦ä¸²å¼€å¤´åŒ¹é…æ£€æŸ¥ï¼ˆä¸ä½¿ç”¨å†…ç½®çš„startsWithæ–¹æ³•ï¼?    return this.stringStartsWith(firstLetters, lowerPinyin);
  }
  
  /**
   * æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä»¥æŒ‡å®šå­å­—ç¬¦ä¸²å¼€å¤?   * å…¼å®¹ArkTSè¯­æ³•çš„å®ç?   */
  private stringStartsWith(str: string, prefix: string): boolean {
    if (!str || !prefix || prefix.length > str.length) {
      return false;
    }
    
    for (let i = 0; i < prefix.length; i++) {
      if (str.charAt(i) !== prefix.charAt(i)) {
        return false;
      }
    }
    return true;
  }
  
  /**
   * å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå°å†?   * å…¼å®¹ArkTSè¯­æ³•çš„å®ç?   */
  private toLowercase(str: string): string {
    if (!str || typeof str !== 'string') {
      return str || '';
    }
    
    let result = '';
    for (let i = 0; i < str.length; i++) {
      const char = str.charAt(i);
      const charCode = char.charCodeAt(0);
      // å¤§å†™å­—æ¯A-Z (65-90) è½¬æ¢ä¸ºå°å†?a-z (97-122)
      if (charCode >= 65 && charCode <= 90) {
        result += String.fromCharCode(charCode + 32);
      } else {
        result += char;
      }
    }
    return result;
  }
  
  /**
   * æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ…å«å­å­—ç¬¦ä¸²
   * å…¼å®¹ArkTSè¯­æ³•çš„å®ç?   */
  private stringContains(str: string, substr: string): boolean {
    if (!str || !substr || substr.length > str.length) {
      return false;
    }
    
    for (let i = 0; i <= str.length - substr.length; i++) {
      let match = true;
      for (let j = 0; j < substr.length; j++) {
        if (str.charAt(i + j) !== substr.charAt(j)) {
          match = false;
          break;
        }
      }
      if (match) {
        return true;
      }
    }
    return false;
  }
  
  /**
   * æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä»¥æŒ‡å®šå­å­—ç¬¦ä¸²å¼€å¤?   * å…¼å®¹ArkTSè¯­æ³•çš„å®ç?   */
  private stringStartsWith(str: string, prefix: string): boolean {
    if (!str || !prefix || prefix.length > str.length) {
      return false;
    }
    
    for (let i = 0; i < prefix.length; i++) {
      if (str.charAt(i) !== prefix.charAt(i)) {
        return false;
      }
    }
    return true;
  }

  /**
   * æ‰©å±•æ‹¼éŸ³æ˜ å°„è¡?   * @param map è¦æ·»åŠ çš„æ˜ å°„
   */
  public extendPinyinMap(map: Record<string, string>): void {
    try {
      // éªŒè¯è¾“å…¥å‚æ•°
      if (!map || typeof map !== 'object') {
        Logger.warn(TAG, 'Invalid map parameter provided to extendPinyinMap');
        return;
      }
      
      let addedCount = 0;
      let updatedCount = 0;
      
      // ä½¿ç”¨JSONåºåˆ—åŒ–å’Œå¥å£®çš„è§£æé€»è¾‘è·å–å¯¹è±¡é”®å€¼å¯¹
      // è¿™ç§æ–¹æ³•å¯ä»¥é¿å…ä½¿ç”¨for..inå¾ªç¯å’ŒObject.keysï¼Œç¬¦åˆArkTSè¯­æ³•è§„èŒƒ
      const mapStr = JSON.stringify(map);
      
      // å¥å£®çš„JSONè§£æé€»è¾‘
      let inKey = false;
      let inValue = false;
      let currentKey = '';
      let currentValue = '';
      let isEscaped = false;
      let valueStartIndex = 0;
      
      // è·³è¿‡JSONå¯¹è±¡çš„å¼€å§‹å¤§æ‹¬å·
      let i = 1;
      
      while (i < mapStr.length) {
        const char = mapStr[i];
        
        if (isEscaped) {
          // å¤„ç†è½¬ä¹‰å­—ç¬¦
          if (inKey) {
            currentKey += char;
          } else if (inValue) {
            currentValue += char;
          }
          isEscaped = false;
        } else if (char === '\\') {
          // æ£€æµ‹è½¬ä¹‰ç¬¦å?          isEscaped = true;
        } else if (char === '"' && !inKey && !inValue) {
          // å¼€å§‹è§£æé”®
          inKey = true;
          currentKey = '';
        } else if (char === '"' && inKey) {
          // é”®è§£æç»“æ?          inKey = false;
        } else if (char === ':' && !inKey && !inValue) {
          // å¼€å§‹è§£æå€?          inValue = true;
          currentValue = '';
          i++;
          valueStartIndex = i;
          
          // å¤„ç†å€¼çš„ä¸åŒç±»å‹ï¼šå­—ç¬¦ä¸²ã€æ•°å­—ã€å¸ƒå°”å€¼ç­‰
          if (i < mapStr.length) {
            const nextChar = mapStr[i];
            if (nextChar === '"') {
              // å­—ç¬¦ä¸²å€¼ï¼Œéœ€è¦å¤„ç†å¼•å?              i++; // è·³è¿‡å¼€å§‹å¼•å?              while (i < mapStr.length) {
                const valueChar = mapStr[i];
                if (valueChar === '\\') {
                  // è½¬ä¹‰å­—ç¬¦
                  if (i + 1 < mapStr.length) {
                    currentValue += mapStr[i + 1];
                    i += 2;
                  } else {
                    i++;
                  }
                } else if (valueChar === '"') {
                  // å­—ç¬¦ä¸²ç»“æ?                  i++;
                  break;
                } else {
                  currentValue += valueChar;
                  i++;
                }
              }
              inValue = false;
            } else {
              // éå­—ç¬¦ä¸²å€¼ï¼ˆæ•°å­—ã€å¸ƒå°”å€¼ç­‰ï¼?              while (i < mapStr.length) {
                const valueChar = mapStr[i];
                if (valueChar === ',' || valueChar === '}') {
                  break;
                }
                currentValue += valueChar;
                i++;
              }
              // å»é™¤ç©ºæ ¼å¹¶è½¬æ¢ä¸ºå­—ç¬¦ä¸?              currentValue = currentValue.trim();
              inValue = false;
            }
            
            // å¤„ç†å½“å‰é”®å€¼å¯¹
            if (currentKey && currentValue) {
              const isUpdate = currentKey in PINYIN_MAP;
              
              // éªŒè¯å€¼çš„æœ‰æ•ˆæ€?- ç¡®ä¿æ˜¯å•å­—ç¬¦æ‹¼éŸ³ï¼ˆé€šå¸¸æ˜¯å­—æ¯ï¼‰
              // ä½†ä¹Ÿå…è®¸ç‰¹æ®Šæƒ…å†µï¼Œå¦‚å¤šå­—ç¬¦æ‹¼éŸ³æˆ–éŸ³è°ƒæ ‡è®°
              if (typeof currentValue === 'string' && currentValue.length > 0) {
                // åœ¨ArkTSä¸­å®‰å…¨åœ°è®¾ç½®å±æ€?                const keyToSet = currentKey;
                const valueToSet = currentValue;
                PINYIN_MAP[keyToSet] = valueToSet;
                
                if (isUpdate) {
                  updatedCount++;
                } else {
                  addedCount++;
                }
              }
              
              // é‡ç½®é”®å€¼ç¼“å†²åŒº
              currentKey = '';
              currentValue = '';
            }
          }
        } else if (char === ',' && !inKey && !inValue) {
          // è·³è¿‡é€—å·ï¼Œå‡†å¤‡ä¸‹ä¸€ä¸ªé”®å€¼å¯¹
        } else if (char === '}' && !inKey && !inValue) {
          // è§£æç»“æŸ
          break;
        } else if (inKey) {
          // æ„å»ºé”®å­—ç¬¦ä¸²
          currentKey += char;
        }
        
        i++;
      }
      
      // è®°å½•æ“ä½œç»“æœ
      Logger.debug(TAG, `Pinyin map extended: ${addedCount} entries added, ${updatedCount} entries updated`);
      
    } catch (error) {
      Logger.error(TAG, `Failed to extend pinyin map: ${error instanceof Error ? error.message : String(error)}`);
      // å¯ä»¥è€ƒè™‘æŠ›å‡ºé”™è¯¯æˆ–è¿”å›å¤±è´¥çŠ¶æ€?      throw error instanceof Error ? error : new Error(String(error));
    }
  }

  /**
   * æœç´¢è¿‡æ»¤å‡½æ•° - æ ¹æ®æ‹¼éŸ³é¦–å­—æ¯è¿‡æ»¤æ•°ç»?   * @param items è¦è¿‡æ»¤çš„æ•°ç»„
   * @param keyword æœç´¢å…³é”®è¯?   * @param textExtractor ä»æ•°ç»„é¡¹ä¸­æå–æ–‡æœ¬çš„å‡½æ•°
   * @returns è¿‡æ»¤åçš„æ•°ç»„
   */
  public filterByPinyin<T>(items: T[], keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T instanceof Error ? keyword: string, textExtractor: (item: T : new Error(String(keyword: string, textExtractor: (item: T))))))) => string): T[] {
    // å‚æ•°éªŒè¯
    if (!items || !Array.isArray(items)) {
      Logger.warn(TAG, 'Invalid items array in filterByPinyin');
      return [];
    }
    
    if (!keyword || typeof keyword !== 'string') {
      Logger.debug(TAG, 'Empty or invalid keyword in filterByPinyin');
      return items;
    }
    
    if (!textExtractor || typeof textExtractor !== 'function') {
      Logger.error(TAG, 'Invalid textExtractor function in filterByPinyin');
      return [];
    }
    
    // å»é™¤å…³é”®è¯å‰åç©ºæ ?    const trimmedKeyword = this.trimString(keyword);
    if (trimmedKeyword === '') {
      return items;
    }
    
    const lowerKeyword = this.toLowercase(trimmedKeyword);
    
    // å®ç°è‡ªå®šä¹‰çš„filteré€»è¾‘ï¼Œé¿å…ä½¿ç”¨æ•°ç»„çš„filteræ–¹æ³•
    const filteredItems: T[] = [];
    
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      try {
        const text = textExtractor(item);
        if (typeof text === 'string') {
          // æ–‡æœ¬ç›´æ¥åŒ¹é…
          const lowerText = this.toLowercase(text);
          if (this.stringContains(lowerText, lowerKeyword instanceof Error ? lowerKeyword : new Error(String(lowerKeyword instanceof Error ? lowerKeyword instanceof Error ? lowerKeyword : new Error(String(lowerKeyword : new Error(String(lowerKeyword instanceof Error ? lowerKeyword : new Error(String(lowerKeyword instanceof Error ? lowerKeyword instanceof Error ? lowerKeyword : new Error(String(lowerKeyword instanceof Error ? lowerKeyword instanceof Error ? lowerKeyword : new Error(String(lowerKeyword : new Error(String(lowerKeyword instanceof Error ? lowerKeyword : new Error(String(lowerKeyword : new Error(String(lowerKeyword instanceof Error ? lowerKeyword : new Error(String(lowerKeyword instanceof Error ? lowerKeyword instanceof Error ? lowerKeyword : new Error(String(lowerKeyword : new Error(String(lowerKeyword instanceof Error ? lowerKeyword : new Error(String(lowerKeyword)))))))) {
            filteredItems.push(item);
            continue;
          }
          
          // æ‹¼éŸ³é¦–å­—æ¯åŒ¹é…?          if (this.containsPinyin(text, lowerKeyword)) {
            filteredItems.push(item);
          }
        }
      } catch (error) {
        // å¤„ç†å•ä¸ªé¡¹å¤„ç†å¤±è´¥çš„æƒ…å†µ
        Logger.warn(TAG, `Error processing item in filterByPinyin: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    
    Logger.debug(TAG, `Filtered array from ${items.length} to ${filteredItems.length} items`);
    return filteredItems;
  }
  
  /**
   * å»é™¤å­—ç¬¦ä¸²å‰åç©ºæ ?   * å…¼å®¹ArkTSè¯­æ³•çš„å®ç?   */
  private trimString(str: string): string {
    if (!str || typeof str !== 'string') {
      return str || '';
    }
    
    let start = 0;
    let end = str.length;
    
    // æŸ¥æ‰¾èµ·å§‹éç©ºæ ¼ä½ç½?    while (start < end && this.isWhitespace(str.charAt(start))) {
      start++;
    }
    
    // æŸ¥æ‰¾ç»“æŸéç©ºæ ¼ä½ç½?    while (end > start && this.isWhitespace(str.charAt(end - 1))) {
      end--;
    }
    
    return str.substring(start, end);
  }
  
  /**
   * æ£€æŸ¥å­—ç¬¦æ˜¯å¦ä¸ºç©ºç™½å­—ç¬¦
   */
  private isWhitespace(char: string): boolean {
    const charCode = char.charCodeAt(0);
    // ç©ºæ ¼ã€åˆ¶è¡¨ç¬¦ã€æ¢è¡Œç¬¦ã€å›è½¦ç¬¦ç­?    return charCode === 32 || charCode === 9 || charCode === 10 || charCode === 13;
  }
}

// å¯¼å‡ºå•ä¾‹
export const pinyinUtil = PinyinUtil.getInstance();
export default pinyinUtil;


