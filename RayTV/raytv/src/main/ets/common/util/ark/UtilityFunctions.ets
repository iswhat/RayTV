// UtilityFunctions.ets - ArkTSå…¼å®¹çš„TypeScript Utility Typesè¿è¡Œæ—¶å®ç?
/**
 * ArkTSå…¼å®¹çš„TypeScript Utility Typesè¿è¡Œæ—¶å®ç? * æä¾›ä¸TypeScriptæ ‡å‡†åº“ä¸­ç±»ä¼¼åŠŸèƒ½çš„è¿è¡Œæ—¶å‡½æ•°
 */
import { SafeAny, SafeObject } from './types/ArkTSBaseTypes';
import TypeUtils from './TypeUtils';
import ObjectUtils from './ObjectUtils';
import ArrayUtils from './ArrayUtils';

/**
 * Utility Typesè¿è¡Œæ—¶å®ç°å‡½æ•°é›†å? */
export const UtilityFunctions: Record<string, string | number | boolean | null> = { ... };
    }
    
    const result: Partial<T> = {};
    
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key in obj) {
        // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?        const propertyValue = UtilityFunctions.getPropertyValue(obj, key);
        result[key] = propertyValue as T[Extract<keyof T, string>];
      }
    }
    
    return result;
  },

  /**
   * åˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œç¡®ä¿æ‰€æœ‰æŒ‡å®šçš„é”®éƒ½å­˜åœ¨
   * è¿è¡Œæ—¶å®ç°Required<T>çš„éƒ¨åˆ†åŠŸèƒ?   */
  ensureRequired<T extends Record<string, SafeAny>>(obj: T, keys: string[]): T {
    if (!TypeUtils.isObject(obj)) {
      throw new Error('Object is required');
    }
    
    const missingKeys: string[] = [];
    
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?      const propertyValue = UtilityFunctions.getPropertyValue(obj, key);
      if (!(key in obj) || propertyValue === undefined) {
        missingKeys.push(key);
      }
    }
    
    if (missingKeys.length > 0) {
      throw new Error(`Missing required properties: ${missingKeys.join(', ')}`);
    }
    
    return obj;
  },

  /**
   * ä»å¯¹è±¡ä¸­é€‰å–æŒ‡å®šçš„å±æ€?   * è¿è¡Œæ—¶å®ç°Pick<T, K>çš„åŠŸèƒ?   */
  pick<T extends Record<string, SafeAny>, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
    if (!TypeUtils.isObject(obj)) {
      return {} as Pick<T, K>;
    }
    
    const result: Partial<T> = {};
    
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key in obj) {
        // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?        const propertyValue = UtilityFunctions.getPropertyValue(obj, key as string);
        result[key] = propertyValue as T[K];
      }
    }
    
    return result as Pick<T, K>;
  },

  /**
   * ä»å¯¹è±¡ä¸­æ’é™¤æŒ‡å®šçš„å±æ€?   * è¿è¡Œæ—¶å®ç°Omit<T, K>çš„åŠŸèƒ?   */
  omit<T extends Record<string, SafeAny>, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {
    if (!TypeUtils.isObject(obj)) {
      return {} as Omit<T, K>;
    }
    
    const result: Partial<T> = {};
    const objKeys = Object.keys(obj);
    
    for (let i = 0; i < objKeys.length; i++) {
      const key = objKeys[i];
      if (!keys.includes(key as K)) {
        // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?        const propertyValue = UtilityFunctions.getPropertyValue(obj, key);
        result[key] = propertyValue as T[Extract<keyof T, string>];
      }
    }
    
    return result as Omit<T, K>;
  },

  /**
   * åˆ›å»ºä¸€ä¸ªè®°å½•å¯¹è±?   * è¿è¡Œæ—¶å®ç°Record<K, T>çš„åŠŸèƒ?   */
  createRecord<K extends string | number | symbol, V>(keys: K[], valueGenerator: (key: K) => V): Record<K, V> {
    const result: Record<string | number | symbol, V> = {};
    
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      result[key] = valueGenerator(key);
    }
    
    return result as Record<K, V>;
  },

  /**
   * åˆ›å»ºä¸€ä¸ªåªè¯»å¯¹è±?   * è¿è¡Œæ—¶è¿‘ä¼¼å®ç°Readonly<T>çš„åŠŸèƒ?   */
  makeReadonly<T extends Record<string, SafeAny>>(obj: T): Readonly<T> {
    if (!TypeUtils.isObject(obj)) {
      return obj as Readonly<T>;
    }
    
    // åœ¨JavaScriptä¸­ï¼ŒObject.freezeåªæ˜¯æµ…å†»ç»?    return Object.freeze({ ...obj }) as Readonly<T>;
  },

  /**
   * åˆ›å»ºä¸€ä¸ªæ·±åº¦åªè¯»å¯¹è±?   * è¿è¡Œæ—¶å®ç°DeepReadonly<T>çš„åŠŸèƒ?   */
  makeDeepReadonly<T extends Record<string, SafeAny>>(obj: T): Readonly<T> {
    if (!TypeUtils.isObject(obj)) {
      return obj as Readonly<T>;
    }
    
    const result: Record<string, SafeAny> = {};
    
    for (const key in obj) {
      if (Object.keys(obj).includes(key)) {
        const value = obj[key];
        
        if (TypeUtils.isObject(value) && !Array.isArray(value)) {
          // é€’å½’å¤„ç†åµŒå¥—å¯¹è±¡
          result[key] = UtilityFunctions.makeDeepReadonly(value as Record<string, SafeAny>);
        } else if (Array.isArray(value)) {
          // å¤„ç†æ•°ç»„
          const frozenArray = value.map((item) => {
            if (TypeUtils.isObject(item)) {
              return UtilityFunctions.makeDeepReadonly(item as Record<string, SafeAny>);
            }
            return item;
          });
          result[key] = Object.freeze(frozenArray);
        } else {
          // åŸå§‹å€?          result[key] = value;
        }
      }
    }
    
    return Object.freeze(result) as Readonly<T>;
  },

  /**
   * æ·±åº¦å¤åˆ¶å¯¹è±¡
   * ç”¨äºå¤„ç†DeepPartialç­‰æ·±åº¦ç±»å‹çš„è¾…åŠ©å‡½æ•°
   */
  deepClone<T>(obj: T): T {
    if (obj === null || obj === undefined) {
      return obj;
    }
    
    if (typeof obj !== 'object') {
      return obj;
    }
    
    if (obj instanceof Date) {
      return new Date(obj.getTime()) as unknown as T;
    }
    
    if (Array.isArray(obj)) {
      return obj.map(UtilityFunctions.deepClone) as unknown as T;
    }
    
    const result: Record<string, SafeAny> = {};
    
    for (const key in obj) {
      if (Object.keys(obj).includes(key)) {
        result[key] = UtilityFunctions.deepClone(obj[key]);
      }
    }
    
    return result as T;
  },

  /**
   * å®‰å…¨åœ°è·å–å¯¹è±¡å±æ€§å€?   * @param obj - è¦è·å–å±æ€§çš„å¯¹è±¡
   * @param key - å±æ€§é”®å?   * @returns å±æ€§å€¼ï¼Œå¦‚æœå±æ€§ä¸å­˜åœ¨åˆ™è¿”å›undefined
   */
  getPropertyValue(obj: Record<string, SafeAny>, key: string): Record<string, string | number | boolean | null> {
    if (!TypeUtils.isObject(obj)) {
      return undefined;
    }
    
    if (!(key in obj)) {
      return undefined;
    }
    
    // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?    return obj[key];
  },

  /**
   * åˆ›å»ºä¸€ä¸ªæ·±åº¦éƒ¨åˆ†å¯¹è±?   * è¿è¡Œæ—¶å®ç°DeepPartial<T>çš„åŠŸèƒ?   */
  createDeepPartial<T extends Record<string, SafeAny>>(obj: T, paths: string[]): Partial<T> {
    const result: Partial<T> = {};
    
    if (!TypeUtils.isObject(obj)) {
      return result;
    }
    
    for (let i = 0; i < paths.length; i++) {
      const path = paths[i];
      const pathParts = path.split('.');
      let currentObj: Record<string, SafeAny> = result;
      let sourceObj: Record<string, SafeAny> = obj;
      
      for (let j = 0; j < pathParts.length - 1; j++) {
        const part = pathParts[j];
        
        if (!(part in currentObj)) {
          currentObj[part] = {};
        }
        
        if (!(part in sourceObj) || !TypeUtils.isObject(sourceObj[part])) {
          break;
        }
        
        currentObj = currentObj[part] as Record<string, SafeAny>;
        sourceObj = sourceObj[part] as Record<string, SafeAny>;
      }
      
      const lastPart = pathParts[pathParts.length - 1];
      if (lastPart in sourceObj) {
        currentObj[lastPart] = sourceObj[lastPart];
      }
    }
    
    return result;
  },

  /**
   * åˆå¹¶ä¸¤ä¸ªå¯¹è±¡
   * è¿è¡Œæ—¶å®ç°Merge<T, U>çš„åŠŸèƒ?   */
  merge<T extends Record<string, SafeAny>, U extends Record<string, SafeAny>>(target: T, source: U): T & U {
    if (!TypeUtils.isObject(target)) {
      return source as T & U;
    }
    
    if (!TypeUtils.isObject(source)) {
      return target as T & U;
    }
    
    const result: Record<string, string | number | boolean | null> = { ... };
    
    for (const key in source) {
      if (Object.keys(source).includes(key)) {
        (result as Record<string, SafeAny>)[key] = source[key];
      }
    }
    
    return result as T & U;
  },

  /**
   * æ·±åº¦åˆå¹¶ä¸¤ä¸ªå¯¹è±¡
   * è¿è¡Œæ—¶å®ç°æ·±åº¦Merge<T, U>çš„åŠŸèƒ?   */
  deepMerge<T extends Record<string, SafeAny>, U extends Record<string, SafeAny>>(target: T, source: U): T & U {
    if (!TypeUtils.isObject(target)) {
      return source as T & U;
    }
    
    if (!TypeUtils.isObject(source)) {
      return target as T & U;
    }
    
    const result: Record<string, string | number | boolean | null> = { ... };
    
    for (const key in source) {
      if (Object.keys(source).includes(key)) {
        const targetValue = target[key];
        const sourceValue = source[key];
        
        if (TypeUtils.isObject(targetValue) && TypeUtils.isObject(sourceValue) && !Array.isArray(targetValue) && !Array.isArray(sourceValue)) {
          // é€’å½’åˆå¹¶åµŒå¥—å¯¹è±¡
          (result as Record<string, SafeAny>)[key] = UtilityFunctions.deepMerge(targetValue as Record<string, SafeAny>, sourceValue as Record<string, SafeAny>);
        } else if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
          // åˆå¹¶æ•°ç»„
          (result as Record<string, SafeAny>)[key] = [...targetValue, ...sourceValue];
        } else {
          // ä½¿ç”¨sourceçš„å€¼è¦†ç›–targetçš„å€?          (result as Record<string, SafeAny>)[key] = sourceValue;
        }
      }
    }
    
    return result as T & U;
  },

  /**
   * æ£€æŸ¥å€¼æ˜¯å¦ä¸ºæŒ‡å®šç±»å‹
   * è¿è¡Œæ—¶å®ç°ç±»å‹å®ˆå«åŠŸèƒ?   */
  isType<T>(value: Record<string, string | number | boolean | null>, typeGuard: (value: Record<string, string | number | boolean | null>) => boolean): value is T {
    return typeGuard(value);
  },

  /**
   * å®‰å…¨åœ°è½¬æ¢ç±»å?   * è¿è¡Œæ—¶å®ç°ç±»å‹è½¬æ¢åŠŸèƒ?   */
  safeCast<T>(value: Record<string, string | number | boolean | null>, typeGuard: (value: Record<string, string | number | boolean | null>) => boolean, defaultValue: T): T {
    return typeGuard(value) ? (value as T) : defaultValue;
  },

  /**
   * è·å–å‡½æ•°çš„è¿”å›ç±»å‹ï¼ˆè¿è¡Œæ—¶æ£€æŸ¥ï¼‰
   */
  getReturnType<T>(fn: (...args: Record<string, string | number | boolean | null>[]) => T, ...args: Record<string, string | number | boolean | null>[]): T | null {
    try {
      if (typeof fn === 'function') {
        return fn(...args);
      }
      return null;
    } catch {
      return null;
    }
  },

  /**
   * åˆ›å»ºç±»å‹ä¿æŠ¤å‡½æ•°
   */
  createTypeGuard<T>(validator: (value: Record<string, string | number | boolean | null>) => boolean): (value: Record<string, string | number | boolean | null>) => value is T {
    return validator as (value: Record<string, string | number | boolean | null>) => value is T;
  },

  /**
   * ä»è”åˆç±»å‹ä¸­æå–ç‰¹å®šç±»å‹çš„å…ƒç´?   * è¿è¡Œæ—¶å®ç°Extract<T, U>çš„åŠŸèƒ?   */
  extract<T>(array: T[], typeGuard: (value: T) => boolean): T[] {
    if (!Array.isArray(array)) {
      return [];
    }
    
    return array.filter(typeGuard);
  },

  /**
   * ä»è”åˆç±»å‹ä¸­æ’é™¤ç‰¹å®šç±»å‹çš„å…ƒç´?   * è¿è¡Œæ—¶å®ç°Exclude<T, U>çš„åŠŸèƒ?   */
  exclude<T>(array: T[], typeGuard: (value: T) => boolean): T[] {
    if (!Array.isArray(array)) {
      return [];
    }
    
    return array.filter((value) => !typeGuard(value));
  },

  /**
   * ç¡®ä¿å€¼ä¸ä¸ºnullæˆ–undefined
   * è¿è¡Œæ—¶å®ç°NonNullable<T>çš„åŠŸèƒ?   */
  ensureNotNull<T>(value: T | null | undefined, errorMessage: string = 'Value cannot be null or undefined'): T {
    if (value === null || value === undefined) {
      throw new Error(errorMessage);
    }
    
    return value;
  },

  /**
   * å¼‚æ­¥ç­‰å¾…Promiseè§£æ
   * è¿è¡Œæ—¶å®ç°Awaited<T>çš„åŠŸèƒ?   */
  async awaitPromise<T>(promise: Promise<T>): Promise<T> {
    if (!(promise instanceof Promise)) {
      throw new Error('Value is not a Promise');
    }
    
    return promise;
  },

  /**
   * æ£€æŸ¥å¯¹è±¡æ˜¯å¦å®Œå…¨åŒ¹é…æŒ‡å®šçš„ç±»å‹å®šä¹‰
   * è¿è¡Œæ—¶å®ç°Exact<T, U>çš„éƒ¨åˆ†åŠŸèƒ?   */
  isExactMatch<T extends Record<string, SafeAny>>(obj: Record<string, SafeAny>, expectedKeys: string[]): boolean {
    if (!TypeUtils.isObject(obj)) {
      return false;
    }
    
    const actualKeys = Object.keys(obj);
    
    if (actualKeys.length !== expectedKeys.length) {
      return false;
    }
    
    for (let i = 0; i < expectedKeys.length; i++) {
      if (!actualKeys.includes(expectedKeys[i])) {
        return false;
      }
    }
    
    return true;
  }
};

export default UtilityFunctions;

