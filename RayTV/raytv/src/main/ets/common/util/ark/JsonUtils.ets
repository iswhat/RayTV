// JsonUtils.ets - ArkTSå…¼å®¹çš„JSONå·¥å…·å‡½æ•°

/**
 * JSONå·¥å…·å‡½æ•°
 * æä¾›ArkTSç¯å¢ƒä¸­å®‰å…¨çš„JSONæ“ä½œåŠŸèƒ½
 */
import { Optional, SafeAny } from './types/ArkTSBaseTypes';
import TypeUtils from './TypeUtils';
import StringUtils from './StringUtils';

/**
 * JSONå·¥å…·å‡½æ•°é›†åˆ
 */
export const JsonUtils = {
  /**
   * æ£€æŸ¥å€¼æ˜¯å¦å¯ä»¥è¢«åºåˆ—åŒ?   */
  isSerializable(value: Record<string, string | number | boolean | null>): boolean {
    try {
      JSON.stringify(value);
      return true;
    } catch {
      return false;
    }
  },

  /**
   * å®‰å…¨çš„JSONåºåˆ—åŒ–å‡½æ•?   * æ›¿ä»£JSON.stringify
   */
  stringify(value: Record<string, string | number | boolean | null>, replacer?: (key: string, value: SafeAny) => SafeAny | Array<number | string>, space?: string | number): string | null {
    try {
      return JSON.stringify(value, replacer, space);
    } catch (e) {
      console.error('JsonUtils.stringify error:', e);
      return null;
    }
  },

  /**
   * å®‰å…¨çš„JSONååºåˆ—åŒ–å‡½æ•°
   * æ›¿ä»£JSON.parse
   */
  parse<T = SafeAny>(jsonString: Optional<string>): T | null {
    if (StringUtils.isEmpty(jsonString)) {
      return null;
    }
    
    try {
      return JSON.parse(jsonString) as T;
    } catch (e) {
      console.error('JsonUtils.parse error:', e);
      return null;
    }
  },

  /**
   * ç¾åŒ–JSONå­—ç¬¦ä¸?   */
  prettify(jsonString: Optional<string>, indent: number = 2): string | null {
    const parsed = JsonUtils.parse(jsonString);
    
    if (parsed === null) {
      return null;
    }
    
    return JsonUtils.stringify(parsed, null, indent);
  },

  /**
   * å‹ç¼©JSONå­—ç¬¦ä¸²ï¼ˆç§»é™¤å¤šä½™çš„ç©ºç™½å­—ç¬¦ï¼‰
   */
  compress(jsonString: Optional<string>): string | null {
    if (StringUtils.isEmpty(jsonString)) {
      return null;
    }
    
    try {
      // å…ˆè§£æå†åºåˆ—åŒ–ï¼Œç§»é™¤æ‰€æœ‰ç©ºç™½å­—ç¬?      const parsed = JSON.parse(jsonString);
      return JSON.stringify(parsed);
    } catch (e) {
      console.error('JsonUtils.compress error:', e);
      return null;
    }
  },

  /**
   * æ·±æ‹·è´å¯¹è±¡ï¼ˆä½¿ç”¨JSONåºåˆ—åŒ?ååºåˆ—åŒ–ï¼?   */
  deepClone<T>(obj: T): T | null {
    if (obj === null || typeof obj !== 'object') {
      // å¯¹äºåŸå§‹ç±»å‹ï¼Œç›´æ¥è¿”å›?      return obj;
    }
    
    try {
      return JSON.parse(JSON.stringify(obj)) as T;
    } catch (e) {
      console.error('JsonUtils.deepClone error:', e);
      return null;
    }
  },

  /**
   * åˆå¹¶ä¸¤ä¸ªå¯¹è±¡ï¼ˆæµ…åˆå¹¶ï¼?   */
  merge<T extends Record<string, SafeAny>, U extends Record<string, SafeAny>>(target: T, source: U): T & U {
    if (!TypeUtils.isObject(target) || !TypeUtils.isObject(source)) {
      return target as T & U;
    }
    
    const result: Record<string, string | number | boolean | null> = { ... };
    
    for (const key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?        const propertyValue = JsonUtils.getPropertyValue(source, key);
        (result as Record<string, SafeAny>)[key] = propertyValue;
      }
    }
    
    return result as T & U;
  },

  /**
   * åˆå¹¶ä¸¤ä¸ªå¯¹è±¡ï¼ˆæ·±åˆå¹¶ï¼?   */
  deepMerge<T extends Record<string, SafeAny>, U extends Record<string, SafeAny>>(target: T, source: U): T & U {
    if (!TypeUtils.isObject(target) || !TypeUtils.isObject(source)) {
      return source !== undefined && source !== null ? source as T & U : target as T & U;
    }
    
    const result: Record<string, string | number | boolean | null> = { ... };
    
    for (const key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?        const targetValue = JsonUtils.getPropertyValue(target, key);
        const sourceValue = JsonUtils.getPropertyValue(source, key);
        
        if (TypeUtils.isObject(targetValue) && TypeUtils.isObject(sourceValue) && !Array.isArray(targetValue) && !Array.isArray(sourceValue)) {
          // é€’å½’åˆå¹¶åµŒå¥—å¯¹è±¡
          (result as Record<string, SafeAny>)[key] = JsonUtils.deepMerge(targetValue as Record<string, SafeAny>, sourceValue as Record<string, SafeAny>);
        } else {
          (result as Record<string, SafeAny>)[key] = sourceValue;
        }
      }
    }
    
    return result as T & U;
  },

  /**
   * æ¯”è¾ƒä¸¤ä¸ªå¯¹è±¡æ˜¯å¦ç›¸ç­‰ï¼ˆä½¿ç”¨JSONåºåˆ—åŒ–ï¼‰
   */
  equals(obj1: Record<string, string | number | boolean | null>, obj2: Record<string, string | number | boolean | null>): boolean {
    try {
      return JsonUtils.stringify(obj1) === JsonUtils.stringify(obj2);
    } catch (e) {
      console.error('JsonUtils.equals error:', e);
      return false;
    }
  },

  /**
   * æå–JSONå¯¹è±¡çš„ç‰¹å®šè·¯å¾„å€?   */
  getValueByPath<T = SafeAny>(obj: Record<string, SafeAny>, path: string, defaultValue?: T): T | null {
    if (!TypeUtils.isObject(obj) || StringUtils.isEmpty(path)) {
      return defaultValue !== undefined ? defaultValue : null;
    }
    
    // å¤„ç†ç‚¹å·åˆ†éš”çš„è·¯å¾?    const pathParts = path.split('.');
    let current: SafeAny = obj;
    
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      
      if (TypeUtils.isObject(current) && part in current) {
        current = current[part];
      } else {
        return defaultValue !== undefined ? defaultValue : null;
      }
    }
    
    return current as T;
  },

  /**
   * è®¾ç½®JSONå¯¹è±¡çš„ç‰¹å®šè·¯å¾„å€?   */
  setValueByPath(obj: Record<string, SafeAny>, path: string, value: SafeAny): boolean {
    if (!TypeUtils.isObject(obj) || StringUtils.isEmpty(path)) {
      return false;
    }
    
    // å¤„ç†ç‚¹å·åˆ†éš”çš„è·¯å¾?    const pathParts = path.split('.');
    let current: Record<string, SafeAny> = obj;
    
    // éå†è·¯å¾„éƒ¨åˆ†ï¼Œé™¤äº†æœ€åä¸€ä¸?    for (let i = 0; i < pathParts.length - 1; i++) {
      const part = pathParts[i];
      
      if (!(part in current) || !TypeUtils.isObject(current[part])) {
        current[part] = {};
      }
      
      current = current[part] as Record<string, SafeAny>;
    }
    
    // è®¾ç½®æœ€åä¸€ä¸ªè·¯å¾„éƒ¨åˆ†çš„å€?    const lastPart = pathParts[pathParts.length - 1];
    current[lastPart] = value;
    
    return true;
  },

  /**
   * ç§»é™¤JSONå¯¹è±¡çš„ç‰¹å®šè·¯å¾„å€?   */
  removeValueByPath(obj: Record<string, SafeAny>, path: string): boolean {
    if (!TypeUtils.isObject(obj) || StringUtils.isEmpty(path)) {
      return false;
    }
    
    // å¤„ç†ç‚¹å·åˆ†éš”çš„è·¯å¾?    const pathParts = path.split('.');
    let current: Record<string, SafeAny> = obj;
    let parent: Record<string, SafeAny> | null = null;
    let lastKey: string = '';
    
    // éå†è·¯å¾„éƒ¨åˆ†ï¼Œé™¤äº†æœ€åä¸€ä¸?    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      
      if (!(part in current)) {
        return false; // è·¯å¾„ä¸å­˜åœ?      }
      
      if (i === pathParts.length - 1) {
        // æœ€åä¸€ä¸ªéƒ¨åˆ†ï¼Œä»çˆ¶å¯¹è±¡ä¸­åˆ é™?        lastKey = part;
      } else {
        parent = current;
        current = current[part] as Record<string, SafeAny>;
        
        if (!TypeUtils.isObject(current)) {
          return false;
        }
      }
    }
    
    if (parent && lastKey in parent) {
      delete parent[lastKey];
      return true;
    }
    
    return false;
  },

  /**
   * å®‰å…¨åœ°è·å–å¯¹è±¡å±æ€§å€?   * @param obj - è¦è·å–å±æ€§çš„å¯¹è±¡
   * @param key - å±æ€§é”®å?   * @returns å±æ€§å€¼ï¼Œå¦‚æœå±æ€§ä¸å­˜åœ¨åˆ™è¿”å›undefined
   */
  getPropertyValue(obj: Record<string, SafeAny>, key: string): Record<string, string | number | boolean | null> {
    if (!TypeUtils.isObject(obj)) {
      return undefined;
    }
    
    if (!(key in obj)) {
      return undefined;
    }
    
    // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?    return obj[key];
  },

  /**
   * æ£€æŸ¥JSONå¯¹è±¡æ˜¯å¦åŒ…å«ç‰¹å®šè·¯å¾„
   */
  hasPath(obj: Record<string, SafeAny>, path: string): boolean {
    if (!TypeUtils.isObject(obj) || StringUtils.isEmpty(path)) {
      return false;
    }
    
    // å¤„ç†ç‚¹å·åˆ†éš”çš„è·¯å¾?    const pathParts = path.split('.');
    let current: SafeAny = obj;
    
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      
      if (TypeUtils.isObject(current) && part in current) {
        current = current[part];
      } else {
        return false;
      }
    }
    
    return true;
  },

  /**
   * è¿‡æ»¤JSONå¯¹è±¡ï¼Œåªä¿ç•™æŒ‡å®šçš„å±æ€?   */
  pick<T extends Record<string, SafeAny>>(obj: T, keys: string[]): Partial<T> {
    if (!TypeUtils.isObject(obj) || !Array.isArray(keys)) {
      return {};
    }
    
    const result: Partial<T> = {};
    
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key in obj) {
        result[key] = obj[key];
      }
    }
    
    return result;
  },

  /**
   * è¿‡æ»¤JSONå¯¹è±¡ï¼Œæ’é™¤æŒ‡å®šçš„å±æ€?   */
  omit<T extends Record<string, SafeAny>>(obj: T, keys: string[]): Partial<T> {
    if (!TypeUtils.isObject(obj) || !Array.isArray(keys)) {
      return { ...obj };
    }
    
    const result: Partial<T> = {};
    const keySet = new Set(keys);
    
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && !keySet.has(key)) {
        result[key] = obj[key];
      }
    }
    
    return result;
  },

  /**
   * æ¸…ç†JSONå¯¹è±¡ï¼Œç§»é™¤undefinedå’Œnullå€?   */
  clean(obj: Record<string, SafeAny>, removeEmpty: boolean = false): Record<string, SafeAny> {
    if (!TypeUtils.isObject(obj)) {
      return {};
    }
    
    const result: Record<string, SafeAny> = {};
    
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        const value = obj[key];
        
        if (value !== undefined && value !== null) {
          if (TypeUtils.isObject(value) && !Array.isArray(value)) {
            // é€’å½’æ¸…ç†åµŒå¥—å¯¹è±¡
            const cleanedValue = JsonUtils.clean(value as Record<string, SafeAny>, removeEmpty);
            
            // å¦‚æœéœ€è¦ç§»é™¤ç©ºå¯¹è±¡ï¼Œå¹¶ä¸”æ¸…ç†åçš„å¯¹è±¡ä¸ºç©ºï¼Œåˆ™è·³è¿?            if (!removeEmpty || Object.keys(cleanedValue).length > 0) {
              result[key] = cleanedValue;
            }
          } else if (!removeEmpty || (Array.isArray(value) && value.length > 0) || (!Array.isArray(value))) {
            result[key] = value;
          }
        }
      }
    }
    
    return result;
  },

  /**
   * å°†å¯¹è±¡è½¬æ¢ä¸ºæŸ¥è¯¢å­—ç¬¦ä¸?   */
  toQueryString(obj: Record<string, SafeAny>): string {
    if (!TypeUtils.isObject(obj)) {
      return '';
    }
    
    const parts: string[] = [];
    
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        const value = obj[key];
        
        if (value !== undefined && value !== null) {
          const encodedKey = encodeURIComponent(key);
          const encodedValue = encodeURIComponent(String(value));
          parts.push(`${encodedKey}=${encodedValue}`);
        }
      }
    }
    
    return parts.join('&');
  },

  /**
   * å°†æŸ¥è¯¢å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¯¹è±?   */
  fromQueryString(queryString: Optional<string>): Record<string, string> {
    if (StringUtils.isEmpty(queryString)) {
      return {};
    }
    
    // ç§»é™¤å¯èƒ½çš„é—®å·å‰ç¼€
    const cleanQuery = queryString.startsWith('?') ? queryString.slice(1) : queryString;
    
    const result: Record<string, string> = {};
    const pairs = cleanQuery.split('&');
    
    for (let i = 0; i < pairs.length; i++) {
      const pair = pairs[i];
      const [key, value] = pair.split('=');
      
      if (key) {
        try {
          result[decodeURIComponent(key)] = value ? decodeURIComponent(value) : '';
        } catch (e) {
          console.error('JsonUtils.fromQueryString error decoding pair:', pair, e);
        }
      }
    }
    
    return result;
  }
};

export default JsonUtils;

