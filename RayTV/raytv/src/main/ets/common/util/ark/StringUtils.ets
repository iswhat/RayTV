// StringUtils.ets - ArkTSå…¼å®¹çš„å­—ç¬¦ä¸²å·¥å…·å‡½æ•°

/**
 * å­—ç¬¦ä¸²å·¥å…·å‡½æ•? * æä¾›ArkTSç¯å¢ƒä¸­å®‰å…¨çš„å­—ç¬¦ä¸²æ“ä½œåŠŸèƒ? */
import { Optional } from './types/ArkTSBaseTypes';
import TypeUtils from './TypeUtils';
import ArrayUtils from './ArrayUtils';

/**
 * å­—ç¬¦ä¸²å·¥å…·å‡½æ•°é›†å? */
export const StringUtils = {
  /**
   * æ£€æŸ¥å€¼æ˜¯å¦ä¸ºå­—ç¬¦ä¸?   */
  isString(value: Record<string, string | number | boolean | null>): boolean {
    return TypeUtils.isString(value);
  },

  /**
   * è·å–å­—ç¬¦ä¸²é•¿åº?   */
  length(str: Optional<string>): number {
    if (str === null || str === undefined) {
      return 0;
    }
    
    return str.length;
  },

  /**
   * æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºç©º
   */
  isEmpty(str: Optional<string>): boolean {
    return str === null || str === undefined || str.trim().length === 0;
  },

  /**
   * æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦éç©º
   */
  isNotEmpty(str: Optional<string>): boolean {
    return !StringUtils.isEmpty(str);
  },

  /**
   * å­—ç¬¦ä¸²æˆªå–å‡½æ•?   * æ›¿ä»£String.prototype.substring
   */
  substring(str: Optional<string>, start: number, end?: number): string {
    if (str === null || str === undefined) {
      return '';
    }
    
    const startIndex = Math.max(0, Math.min(start, str.length));
    const endIndex = end !== undefined ? Math.max(0, Math.min(end, str.length)) : str.length;
    
    return str.substring(startIndex, endIndex);
  },

  /**
   * å­—ç¬¦ä¸²æˆªæ–­å‡½æ•?   */
  truncate(str: Optional<string>, maxLength: number, suffix: string = '...'): string {
    if (StringUtils.isEmpty(str)) {
      return str || '';
    }
    
    if (str.length <= maxLength) {
      return str;
    }
    
    const suffixLength = suffix.length;
    const availableLength = maxLength - suffixLength;
    
    if (availableLength <= 0) {
      return StringUtils.substring(suffix, 0, maxLength);
    }
    
    return StringUtils.substring(str, 0, availableLength) + suffix;
  },

  /**
   * å­—ç¬¦ä¸²è½¬å°å†™å‡½æ•°
   * æ›¿ä»£String.prototype.toLowerCase
   */
  toLowerCase(str: Optional<string>): string {
    if (str === null || str === undefined) {
      return '';
    }
    
    return str.toLowerCase();
  },

  /**
   * å­—ç¬¦ä¸²è½¬å¤§å†™å‡½æ•°
   * æ›¿ä»£String.prototype.toUpperCase
   */
  toUpperCase(str: Optional<string>): string {
    if (str === null || str === undefined) {
      return '';
    }
    
    return str.toUpperCase();
  },

  /**
   * å­—ç¬¦ä¸²å»é™¤é¦–å°¾ç©ºæ ¼å‡½æ•?   * æ›¿ä»£String.prototype.trim
   */
  trim(str: Optional<string>): string {
    if (str === null || str === undefined) {
      return '';
    }
    
    return str.trim();
  },

  /**
   * å­—ç¬¦ä¸²åˆ†å‰²å‡½æ•?   * æ›¿ä»£String.prototype.split
   */
  split(str: Optional<string>, separator: string | RegExp, limit?: number): string[] {
    if (str === null || str === undefined) {
      return [];
    }
    
    const parts = str.split(separator);
    
    if (limit !== undefined && limit > 0) {
      return ArrayUtils.slice(parts, 0, limit);
    }
    
    return parts;
  },

  /**
   * å­—ç¬¦ä¸²è¿æ¥å‡½æ•?   * æ›¿ä»£String.prototype.join
   */
  join(separator: string, ...parts: Optional<string>[]): string {
    const nonEmptyParts: string[] = [];
    
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      if (part !== null && part !== undefined) {
        nonEmptyParts.push(part);
      }
    }
    
    return nonEmptyParts.join(separator);
  },

  /**
   * å­—ç¬¦ä¸²åŒ…å«æ£€æŸ¥å‡½æ•?   * æ›¿ä»£String.prototype.includes
   */
  includes(str: Optional<string>, searchString: string, position?: number): boolean {
    if (str === null || str === undefined) {
      return false;
    }
    
    return str.includes(searchString, position);
  },

  /**
   * å­—ç¬¦ä¸²åŒ…å«æ£€æŸ¥å‡½æ•°ï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰
   */
  containsIgnoreCase(str: Optional<string>, searchStr: string): boolean {
    if (StringUtils.isEmpty(str) || StringUtils.isEmpty(searchStr)) {
      return false;
    }
    
    const lowerStr = StringUtils.toLowerCase(str);
    const lowerSearchStr = StringUtils.toLowerCase(searchStr);
    
    return StringUtils.includes(lowerStr, lowerSearchStr);
  },

  /**
   * å­—ç¬¦ä¸²å¼€å¤´æ£€æŸ¥å‡½æ•?   * æ›¿ä»£String.prototype.startsWith
   */
  startsWith(str: Optional<string>, searchString: string, position?: number): boolean {
    if (str === null || str === undefined) {
      return false;
    }
    
    return str.startsWith(searchString, position);
  },

  /**
   * å­—ç¬¦ä¸²ç»“å°¾æ£€æŸ¥å‡½æ•?   * æ›¿ä»£String.prototype.endsWith
   */
  endsWith(str: Optional<string>, searchString: string, length?: number): boolean {
    if (str === null || str === undefined) {
      return false;
    }
    
    return str.endsWith(searchString, length);
  },

  /**
   * å­—ç¬¦ä¸²æŸ¥æ‰¾å‡½æ•?   * æ›¿ä»£String.prototype.indexOf
   */
  indexOf(str: Optional<string>, searchValue: string, fromIndex?: number): number {
    if (str === null || str === undefined) {
      return -1;
    }
    
    return str.indexOf(searchValue, fromIndex);
  },

  /**
   * å­—ç¬¦ä¸²æœ€åæŸ¥æ‰¾å‡½æ•?   * æ›¿ä»£String.prototype.lastIndexOf
   */
  lastIndexOf(str: Optional<string>, searchValue: string, fromIndex?: number): number {
    if (str === null || str === undefined) {
      return -1;
    }
    
    return str.lastIndexOf(searchValue, fromIndex);
  },

  /**
   * å­—ç¬¦ä¸²æ›¿æ¢å‡½æ•?   * æ›¿ä»£String.prototype.replace
   */
  replace(str: Optional<string>, searchValue: string | RegExp, replaceValue: string): string {
    if (str === null || str === undefined) {
      return '';
    }
    
    return str.replace(searchValue, replaceValue);
  },

  /**
   * å­—ç¬¦ä¸²å…¨éƒ¨æ›¿æ¢å‡½æ•?   * æ›¿ä»£String.prototype.replaceAll
   */
  replaceAll(str: Optional<string>, searchValue: string, replaceValue: string): string {
    if (str === null || str === undefined) {
      return '';
    }
    
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å®ç°å…¨éƒ¨æ›¿æ?    const regex = new RegExp(searchValue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
    return str.replace(regex, replaceValue);
  },

  /**
   * å­—ç¬¦ä¸²å¡«å……å‡½æ•?   * æ›¿ä»£String.prototype.padStart
   */
  padStart(str: Optional<string>, targetLength: number, padString: string = ' '): string {
    if (str === null || str === undefined) {
      return '';
    }
    
    return str.padStart(targetLength, padString);
  },

  /**
   * å­—ç¬¦ä¸²å¡«å……å‡½æ•?   * æ›¿ä»£String.prototype.padEnd
   */
  padEnd(str: Optional<string>, targetLength: number, padString: string = ' '): string {
    if (str === null || str === undefined) {
      return '';
    }
    
    return str.padEnd(targetLength, padString);
  },

  /**
   * å­—ç¬¦ä¸²è½¬æ•°ç»„å‡½æ•°
   * æ›¿ä»£String.prototype.split('')
   */
  toCharArray(str: Optional<string>): string[] {
    if (str === null || str === undefined) {
      return [];
    }
    
    const result: string[] = [];
    
    for (let i = 0; i < str.length; i++) {
      result.push(str.charAt(i));
    }
    
    return result;
  },

  /**
   * é¦–å­—æ¯å¤§å†™å‡½æ•?   */
  capitalize(str: Optional<string>): string {
    if (StringUtils.isEmpty(str)) {
      return str || '';
    }
    
    return StringUtils.toUpperCase(StringUtils.substring(str, 0, 1)) + StringUtils.substring(str, 1);
  },

  /**
   * é©¼å³°å‘½åè½¬ä¸‹åˆ’çº¿å‘½åå‡½æ•°
   */
  camelToSnake(str: Optional<string>): string {
    if (StringUtils.isEmpty(str)) {
      return str || '';
    }
    
    return StringUtils.toLowerCase(
      StringUtils.replace(str, /([a-z0-9])([A-Z])/g, '$1_$2')
    );
  },

  /**
   * ä¸‹åˆ’çº¿å‘½åè½¬é©¼å³°å‘½åå‡½æ•°
   */
  snakeToCamel(str: Optional<string>): string {
    if (StringUtils.isEmpty(str)) {
      return str || '';
    }
    
    return StringUtils.replace(str, /_([a-z])/g, (_, group1) => StringUtils.toUpperCase(group1));
  },

  /**
   * ç”Ÿæˆéšæœºå­—ç¬¦ä¸²å‡½æ•?   */
  generateRandomString(length: number = 16): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    
    for (let i = 0; i < length; i++) {
      const randomIndex = Math.floor(Math.random() * chars.length);
      result += chars.charAt(randomIndex);
    }
    
    return result;
  },

  /**
   * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°å‡½æ•?   */
  formatFileSize(bytes: number, decimals: number = 2): string {
    if (bytes === 0) {
      return '0 B';
    }
    
    const k = 1024;
    const sizes: string[] = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
  }
};

export default StringUtils;

