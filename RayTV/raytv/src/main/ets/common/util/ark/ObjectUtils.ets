// ObjectUtils.ets - ArkTSå…¼å®¹çš„å¯¹è±¡å·¥å…·å‡½æ•?

/**
 * å¯¹è±¡å·¥å…·å‡½æ•°
 * æä¾›ArkTSç¯å¢ƒä¸­å®‰å…¨çš„å¯¹è±¡æ“ä½œåŠŸèƒ½
 */
import { SafeAny, SafeObject, Optional } from './types/ArkTSBaseTypes';
import TypeUtils from './TypeUtils';

/**
 * å¯¹è±¡å·¥å…·å‡½æ•°é›†åˆ
 */
export const ObjectUtils = {
  /**
   * å®‰å…¨åœ°æ£€æŸ¥å¯¹è±¡æ˜¯å¦åŒ…å«æŒ‡å®šå±æ€?
   * æ›¿ä»£Object.prototype.hasOwnProperty.call
   */
  hasProperty(obj: SafeAny, key: string | number): boolean {
    if (!TypeUtils.isObject(obj)) {
      return false;
    }
    
    const keyStr = String(key);
    // ä½¿ç”¨Object.getOwnPropertyNamesè·å–æ‰€æœ‰è‡ªæœ‰å±æ€§å¹¶æ£€æŸ¥ï¼Œé¿å…ä½¿ç”¨inæ“ä½œç¬¦å’ŒhasOwnProperty
    return Object.getOwnPropertyNames(obj).includes(keyStr);
  },

  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰é”®
   * æ›¿ä»£Object.keys
   */
  getKeys(obj: SafeAny): string[] {
    if (!TypeUtils.isObject(obj)) {
      return [];
    }
    
    return Object.getOwnPropertyNames(obj);
  },

  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰å€?
   * æ›¿ä»£Object.values
   */
  getValues<T>(obj: SafeAny): T[] {
    if (!TypeUtils.isObject(obj)) {
      return [];
    }
    
    const values: T[] = [];
    const keys = ObjectUtils.getKeys(obj);
    
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?
      const propertyValue = ObjectUtils.getPropertyValue(obj, key);
      values.push(propertyValue as T);
    }
    
    return values;
  },

  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰é”®å€¼å¯¹
   * æ›¿ä»£Object.entries
   */
  getEntries<T>(obj: SafeAny): [string, T][] {
    if (!TypeUtils.isObject(obj)) {
      return [];
    }
    
    const entries: [string, T][] = [];
    const keys = ObjectUtils.getKeys(obj);
    
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?
      const propertyValue = ObjectUtils.getPropertyValue(obj, key);
      entries.push([key, propertyValue as T]);
    }
    
    return entries;
  },

  /**
   * ä»å¯¹è±¡ä¸­è·å–å±æ€§å€¼ï¼Œå¦‚æœå±æ€§ä¸å­˜åœ¨åˆ™è¿”å›é»˜è®¤å€?
   */
  getProperty<T>(obj: SafeAny, key: string | number, defaultValue: T): T {
    if (!TypeUtils.isObject(obj) || !ObjectUtils.hasProperty(obj, key)) {
      return defaultValue;
    }
    
    const keyStr = String(key);
    // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?
    const propertyValue = ObjectUtils.getPropertyValue(obj, keyStr);
    return propertyValue as T;
  },

  /**
   * å®‰å…¨åœ°è®¾ç½®å¯¹è±¡å±æ€?
   */
  setProperty(obj: SafeAny, key: string | number, value: SafeAny): boolean {
    if (!TypeUtils.isObject(obj)) {
      return false;
    }
    
    try {
      const keyStr = String(key);
      (obj as Record<string, SafeAny>)[keyStr] = value;
      return true;
    } catch {
      return false;
    }
  },

  /**
   * å®‰å…¨åœ°åˆ é™¤å¯¹è±¡å±æ€?
   */
  deleteProperty(obj: SafeAny, key: string | number): boolean {
    if (!TypeUtils.isObject(obj) || !ObjectUtils.hasProperty(obj, key)) {
      return false;
    }
    
    try {
      const keyStr = String(key);
      delete (obj as Record<string, SafeAny>)[keyStr];
      return true;
    } catch {
      return false;
    }
  },

  /**
   * å®‰å…¨åœ°è·å–å¯¹è±¡å±æ€§å€?
   * @param obj - è¦è·å–å±æ€§çš„å¯¹è±¡
   * @param key - å±æ€§é”®å?
   * @returns å±æ€§å€¼ï¼Œå¦‚æœå±æ€§ä¸å­˜åœ¨åˆ™è¿”å›undefined
   */
  getPropertyValue(obj: SafeAny, key: string | number): Record<string, string | number | boolean | null> {
    if (!TypeUtils.isObject(obj)) {
      return undefined;
    }
    
    const keyStr = String(key);
    if (!ObjectUtils.hasProperty(obj, keyStr)) {
      return undefined;
    }
    
    // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?
    const safeObj = obj as Record<string, unknown>;
    return safeObj[keyStr];
  },

  /**
   * åˆå¹¶å¤šä¸ªå¯¹è±¡
   */
  merge<T extends SafeObject>(...objects: Optional<T>[]): T {
    const result: T = {} as T;
    
    for (let i = 0; i < objects.length; i++) {
      const obj = objects[i];
      if (TypeUtils.isObject(obj)) {
        const entries = ObjectUtils.getEntries(obj);
        
        for (let j = 0; j < entries.length; j++) {
          const [key, value] = entries[j];
          ObjectUtils.setProperty(result, key, value);
        }
      }
    }
    
    return result;
  },

  /**
   * æ·±æ‹·è´å¯¹è±?
   */
  deepClone<T>(value: T): T {
    // å¤„ç†nullå’Œundefined
    if (value === null || value === undefined) {
      return value;
    }
    
    // å¤„ç†åŸºæœ¬ç±»å‹
    if (typeof value !== 'object') {
      return value;
    }
    
    // å¤„ç†æ—¥æœŸ
    if (value instanceof Date) {
      return new Date(value.getTime()) as T;
    }
    
    // å¤„ç†æ•°ç»„
    if (Array.isArray(value)) {
      const clonedArray: Record<string, string | number | boolean | null>[] = [];
      for (let i = 0; i < value.length; i++) {
        clonedArray.push(ObjectUtils.deepClone(value[i]));
      }
      return clonedArray as T;
    }
    
    // å¤„ç†æ™®é€šå¯¹è±?
    const cloned: Record<string, unknown> = {};
    const entries = ObjectUtils.getEntries(value as Record<string, unknown>);
    
    for (let i = 0; i < entries.length; i++) {
      const [key, val] = entries[i];
      cloned[key] = ObjectUtils.deepClone(val);
    }
    
    return cloned as T;
  },

  /**
   * åˆ›å»ºå¯¹è±¡çš„æµ…æ‹·è´
   */
  shallowClone<T extends SafeObject>(obj: Optional<T>): T {
    if (!TypeUtils.isObject(obj)) {
      return {} as T;
    }
    
    const cloned: T = {} as T;
    const entries = ObjectUtils.getEntries(obj);
    
    for (let i = 0; i < entries.length; i++) {
      const [key, value] = entries[i];
      ObjectUtils.setProperty(cloned, key, value);
    }
    
    return cloned;
  },

  /**
   * è¿‡æ»¤å¯¹è±¡çš„å±æ€?
   */
  filter<T extends SafeObject>(
    obj: Optional<T>, 
    predicate: (key: string, value: SafeAny) => boolean
  ): Partial<T> {
    if (!TypeUtils.isObject(obj)) {
      return {};
    }
    
    const filtered: Partial<T> = {};
    const entries = ObjectUtils.getEntries(obj);
    
    for (let i = 0; i < entries.length; i++) {
      const [key, value] = entries[i];
      if (predicate(key, value)) {
        ObjectUtils.setProperty(filtered, key, value);
      }
    }
    
    return filtered;
  },

  /**
   * è½¬æ¢å¯¹è±¡çš„å±æ€?
   */
  map<T extends SafeObject, R extends SafeObject>(
    obj: Optional<T>, 
    transform: (key: string, value: SafeAny) => [string, SafeAny]
  ): R {
    if (!TypeUtils.isObject(obj)) {
      return {} as R;
    }
    
    const result: R = {} as R;
    const entries = ObjectUtils.getEntries(obj);
    
    for (let i = 0; i < entries.length; i++) {
      const [key, value] = entries[i];
      const [newKey, newValue] = transform(key, value);
      ObjectUtils.setProperty(result, newKey, newValue);
    }
    
    return result;
  }
};

export default ObjectUtils;

