// ArrayUtils.ets - ArkTSå…¼å®¹çš„æ•°ç»„å·¥å…·å‡½æ•?
/**
 * æ•°ç»„å·¥å…·å‡½æ•°
 * æä¾›ArkTSç¯å¢ƒä¸­å®‰å…¨çš„æ•°ç»„æ“ä½œåŠŸèƒ½
 */
import { SafeAny, Optional } from './types/ArkTSBaseTypes';
import TypeUtils from './TypeUtils';

/**
 * æ•°ç»„å·¥å…·å‡½æ•°é›†åˆ
 */
export const ArrayUtils = {
  /**
   * æ£€æŸ¥å€¼æ˜¯å¦ä¸ºæ•°ç»„
   */
  isArray(value: SafeAny): boolean {
    return Array.isArray(value);
  },

  /**
   * è·å–æ•°ç»„é•¿åº¦
   */
  length(array: Optional<ArrayLike<SafeAny>>): number {
    if (array === null || array === undefined) {
      return 0;
    }
    
    return array.length;
  },

  /**
   * æ£€æŸ¥æ•°ç»„æ˜¯å¦ä¸ºç©?   */
  isEmpty(array: Optional<ArrayLike<SafeAny>>): boolean {
    return ArrayUtils.length(array) === 0;
  },

  /**
   * å®‰å…¨åœ°è®¿é—®æ•°ç»„å…ƒç´?   */
  get<T>(array: Optional<T[]>, index: number, defaultValue: T): T {
    if (!Array.isArray(array) || index < 0 || index >= array.length) {
      return defaultValue;
    }
    
    return array[index];
  },

  /**
   * å®‰å…¨åœ°è®¾ç½®æ•°ç»„å…ƒç´?   */
  set<T>(array: Optional<T[]>, index: number, value: T): boolean {
    if (!Array.isArray(array) || index < 0 || index >= array.length) {
      return false;
    }
    
    array[index] = value;
    return true;
  },

  /**
   * å®‰å…¨åœ°åœ¨æ•°ç»„æœ«å°¾æ·»åŠ å…ƒç´ 
   */
  push<T>(array: Optional<T[]>, ...elements: T[]): number {
    if (!Array.isArray(array)) {
      return 0;
    }
    
    return array.push(...elements);
  },

  /**
   * å®‰å…¨åœ°ä»æ•°ç»„æœ«å°¾ç§»é™¤å…ƒç´ 
   */
  pop<T>(array: Optional<T[]>): T | undefined {
    if (!Array.isArray(array) || array.length === 0) {
      return undefined;
    }
    
    return array.pop();
  },

  /**
   * å®‰å…¨åœ°åœ¨æ•°ç»„å¼€å¤´æ·»åŠ å…ƒç´?   */
  unshift<T>(array: Optional<T[]>, ...elements: T[]): number {
    if (!Array.isArray(array)) {
      return 0;
    }
    
    return array.unshift(...elements);
  },

  /**
   * å®‰å…¨åœ°ä»æ•°ç»„å¼€å¤´ç§»é™¤å…ƒç´?   */
  shift<T>(array: Optional<T[]>): T | undefined {
    if (!Array.isArray(array) || array.length === 0) {
      return undefined;
    }
    
    return array.shift();
  },

  /**
   * æ•°ç»„è¿‡æ»¤å‡½æ•°
   * æ›¿ä»£Array.prototype.filter
   */
  filter<T>(array: Optional<T[]>, predicate: (element: T, index: number) => boolean): T[] {
    if (!Array.isArray(array)) {
      return [];
    }
    
    const result: T[] = [];
    
    for (let i = 0; i < array.length; i++) {
      if (predicate(array[i], i)) {
        result.push(array[i]);
      }
    }
    
    return result;
  },

  /**
   * æ•°ç»„æ˜ å°„å‡½æ•°
   * æ›¿ä»£Array.prototype.map
   */
  map<T, R>(array: Optional<T[]>, transform: (element: T, index: number) => R): R[] {
    if (!Array.isArray(array)) {
      return [];
    }
    
    const result: R[] = [];
    
    for (let i = 0; i < array.length; i++) {
      result.push(transform(array[i], i));
    }
    
    return result;
  },

  /**
   * æ•°ç»„å½’çº¦å‡½æ•°
   * æ›¿ä»£Array.prototype.reduce
   */
  reduce<T, R>(
    array: Optional<T[]>, 
    reducer: (accumulator: R, element: T, index: number) => R, 
    initialValue: R
  ): R {
    if (!Array.isArray(array)) {
      return initialValue;
    }
    
    let accumulator = initialValue;
    
    for (let i = 0; i < array.length; i++) {
      accumulator = reducer(accumulator, array[i], i);
    }
    
    return accumulator;
  },

  /**
   * æ•°ç»„æŸ¥æ‰¾å‡½æ•°
   * æ›¿ä»£Array.prototype.find
   */
  find<T>(array: Optional<T[]>, predicate: (element: T, index: number) => boolean): T | undefined {
    if (!Array.isArray(array)) {
      return undefined;
    }
    
    for (let i = 0; i < array.length; i++) {
      if (predicate(array[i], i)) {
        return array[i];
      }
    }
    
    return undefined;
  },

  /**
   * æ•°ç»„æŸ¥æ‰¾ç´¢å¼•å‡½æ•°
   * æ›¿ä»£Array.prototype.findIndex
   */
  findIndex<T>(array: Optional<T[]>, predicate: (element: T, index: number) => boolean): number {
    if (!Array.isArray(array)) {
      return -1;
    }
    
    for (let i = 0; i < array.length; i++) {
      if (predicate(array[i], i)) {
        return i;
      }
    }
    
    return -1;
  },

  /**
   * æ•°ç»„åŒ…å«æ£€æŸ¥å‡½æ•?   * æ›¿ä»£Array.prototype.includes
   */
  includes<T>(array: Optional<T[]>, searchElement: T): boolean {
    if (!Array.isArray(array)) {
      return false;
    }
    
    for (let i = 0; i < array.length; i++) {
      if (array[i] === searchElement) {
        return true;
      }
    }
    
    return false;
  },

  /**
   * æ•°ç»„ç´¢å¼•æ£€æŸ¥å‡½æ•?   * æ›¿ä»£Array.prototype.indexOf
   */
  indexOf<T>(array: Optional<T[]>, searchElement: T): number {
    if (!Array.isArray(array)) {
      return -1;
    }
    
    for (let i = 0; i < array.length; i++) {
      if (array[i] === searchElement) {
        return i;
      }
    }
    
    return -1;
  },

  /**
   * æ•°ç»„æœ€åç´¢å¼•æ£€æŸ¥å‡½æ•?   * æ›¿ä»£Array.prototype.lastIndexOf
   */
  lastIndexOf<T>(array: Optional<T[]>, searchElement: T): number {
    if (!Array.isArray(array)) {
      return -1;
    }
    
    for (let i = array.length - 1; i >= 0; i--) {
      if (array[i] === searchElement) {
        return i;
      }
    }
    
    return -1;
  },

  /**
   * æ•°ç»„è¿æ¥å‡½æ•°
   * æ›¿ä»£Array.prototype.concat
   */
  concat<T>(array: Optional<T[]>, ...values: (Optional<T | T[]>)[]): T[] {
    const result: T[] = Array.isArray(array) ? [...array] : [];
    
    for (let i = 0; i < values.length; i++) {
      const value = values[i];
      if (Array.isArray(value)) {
        // å®‰å…¨åœ°éå†æ•°ç»„å¹¶æ·»åŠ æ¯ä¸ªå…ƒç´ 
        for (let j = 0; j < value.length; j++) {
          result.push(value[j]);
        }
      } else if (value !== null && value !== undefined) {
        result.push(value as T);
      }
    }
    
    return result;
  },

  /**
   * æ•°ç»„åˆ‡ç‰‡å‡½æ•°
   * æ›¿ä»£Array.prototype.slice
   */
  slice<T>(array: Optional<T[]>, start?: number, end?: number): T[] {
    if (!Array.isArray(array)) {
      return [];
    }
    
    const startIndex = start !== undefined ? Math.max(0, Math.min(start, array.length)) : 0;
    const endIndex = end !== undefined ? Math.max(0, Math.min(end, array.length)) : array.length;
    
    const result: T[] = [];
    
    for (let i = startIndex; i < endIndex; i++) {
      result.push(array[i]);
    }
    
    return result;
  },

  /**
   * æ•°ç»„æ’åºå‡½æ•°
   * æ›¿ä»£Array.prototype.sort
   */
  sort<T>(array: Optional<T[]>, compareFn?: (a: T, b: T) => number): T[] {
    if (!Array.isArray(array)) {
      return [];
    }
    
    // åˆ›å»ºå‰¯æœ¬ä»¥é¿å…ä¿®æ”¹åŸå§‹æ•°ç»?    const result = [...array];
    
    if (compareFn) {
      // ä½¿ç”¨å†’æ³¡æ’åºå®ç°è‡ªå®šä¹‰æ’åº?      for (let i = 0; i < result.length - 1; i++) {
        for (let j = 0; j < result.length - 1 - i; j++) {
          if (compareFn(result[j], result[j + 1]) > 0) {
            // äº¤æ¢å…ƒç´ 
            const temp = result[j];
            result[j] = result[j + 1];
            result[j + 1] = temp;
          }
        }
      }
    } else {
      // é»˜è®¤æ’åºï¼ˆè½¬æ¢ä¸ºå­—ç¬¦ä¸²åæŒ‰å­—æ¯é¡ºåºæ’åºï¼‰
      for (let i = 0; i < result.length - 1; i++) {
        for (let j = 0; j < result.length - 1 - i; j++) {
          if (String(result[j]) > String(result[j + 1])) {
            // äº¤æ¢å…ƒç´ 
            const temp = result[j];
            result[j] = result[j + 1];
            result[j + 1] = temp;
          }
        }
      }
    }
    
    return result;
  },

  /**
   * æ•°ç»„å»é‡å‡½æ•°
   */
  unique<T>(array: Optional<T[]>): T[] {
    if (!Array.isArray(array)) {
      return [];
    }
    
    const result: T[] = [];
    const seen = new Set<T>();
    
    for (let i = 0; i < array.length; i++) {
      const item = array[i];
      if (!seen.has(item)) {
        seen.add(item);
        result.push(item);
      }
    }
    
    return result;
  },

  /**
   * æ•°ç»„æ‰å¹³åŒ–å‡½æ•?   */
  flatten<T>(array: Optional<(T | T[])[]>): T[] {
    if (!Array.isArray(array)) {
      return [];
    }
    
    const result: T[] = [];
    
    function flattenHelper(arr: (T | T[])[]): void {
      for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        if (Array.isArray(item)) {
          flattenHelper(item);
        } else {
          result.push(item);
        }
      }
    }
    
    flattenHelper(array);
    return result;
  }
};

export default ArrayUtils;
