// Logger - æ—¥å¿—å·¥å…·ç±?// æä¾›ç»Ÿä¸€çš„æ—¥å¿—è®°å½•åŠŸèƒ½ï¼Œæ”¯æŒä¸åŒçº§åˆ«ã€æ ¼å¼åŒ–è¾“å‡ºå’ŒæŒä¹…åŒ–å­˜å‚¨

/**
 * æ—¥å¿—çº§åˆ«æšä¸¾
 */
export enum LogLevel {
  /**
   * è°ƒè¯•çº§åˆ«
   */
  DEBUG = 'debug',
  
  /**
   * ä¿¡æ¯çº§åˆ«
   */
  INFO = 'info',
  
  /**
   * è­¦å‘Šçº§åˆ«
   */
  WARN = 'warn',
  
  /**
   * é”™è¯¯çº§åˆ«
   */
  ERROR = 'error',
  
  /**
   * è‡´å‘½é”™è¯¯çº§åˆ«
   */
  FATAL = 'fatal',
  
  /**
   * å…³é—­æ—¥å¿—
   */
  OFF = 'off'
}

/**
 * æ—¥å¿—é…ç½®æ¥å£
 */
export interface LoggerConfig {
  /**
   * æ—¥å¿—çº§åˆ«
   */
  level: LogLevel;
  
  /**
   * æ˜¯å¦å¯ç”¨æ§åˆ¶å°æ—¥å¿?   */
  consoleEnabled: boolean;
  
  /**
   * æ˜¯å¦å¯ç”¨æ–‡ä»¶æ—¥å¿—
   */
  fileEnabled: boolean;
  
  /**
   * æ—¥å¿—æ–‡ä»¶è·¯å¾„
   */
  logFilePath?: string;
  
  /**
   * æ—¥å¿—æ–‡ä»¶æœ€å¤§å¤§å°ï¼ˆå­—èŠ‚ï¼?   */
  maxFileSize?: number;
  
  /**
   * æ—¥å¿—æ–‡ä»¶æœ€å¤§æ•°é‡?   */
  maxFileCount?: number;
  
  /**
   * æ˜¯å¦å¯ç”¨æ ¼å¼åŒ?   */
  formatEnabled: boolean;
  
  /**
   * æ˜¯å¦æ˜¾ç¤ºæ—¶é—´æˆ?   */
  showTimestamp: boolean;
  
  /**
   * æ˜¯å¦æ˜¾ç¤ºæ—¥å¿—çº§åˆ«
   */
  showLevel: boolean;
  
  /**
   * æ˜¯å¦æ˜¾ç¤ºè°ƒç”¨è€…ä¿¡æ?   */
  showCaller: boolean;
  
  /**
   * æ˜¯å¦æ˜¾ç¤ºè¿›ç¨‹ID
   */
  showProcessId: boolean;
  
  /**
   * æ˜¯å¦æ˜¾ç¤ºçº¿ç¨‹ID
   */
  showThreadId: boolean;
  
  /**
   * æ˜¯å¦è®°å½•å †æ ˆè·Ÿè¸ª
   */
  enableStackTrace: boolean;
}

/**
 * æ—¥å¿—è¯¦ç»†æ•°æ®æ¥å£
 */
export interface LogDetailData {
  // ä½¿ç”¨Recordæ›¿ä»£ç´¢å¼•ç­¾åï¼Œé¿å…ä½¿ç”¨anyç±»å‹
  data?: Record<string, string | number | boolean | null>;
}

/**
 * æ—¥å¿—é¢å¤–æ•°æ®æ¥å£
 */
export interface LoggerExtraData {
  /**
   * é¢å¤–æ¶ˆæ¯
   */
  message?: string;
  /**
   * é”™è¯¯ä»£ç 
   */
  code?: number;
  /**
   * è¯¦ç»†æ•°æ®
   */
  detail?: LogDetailData;
  /**
   * æ ‡ç­¾
   */
  tag?: string;
  /**
   * é”™è¯¯
   */
  error?: Error;
}

/**
 * æ—¥å¿—æ¡ç›®æ¥å£
 */
export interface LogEntry {
  /**
   * æ—¥å¿—çº§åˆ«
   */
  level: LogLevel;
  
  /**
   * æ¶ˆæ¯å†…å®¹
   */
  message: string;
  
  /**
   * æ—¶é—´æˆ?   */
  timestamp: number;
  
  /**
   * è°ƒç”¨è€…ä¿¡æ?   */
  caller?: string;
  
  /**
   * è¿›ç¨‹ID
   */
  processId?: string;
  
  /**
   * çº¿ç¨‹ID
   */
  threadId?: string;
  
  /**
   * å †æ ˆè·Ÿè¸ª
   */
  stackTrace?: string;
  
  /**
   * é¢å¤–æ•°æ®
   */
  extra?: LoggerExtraData;
}

/**
 * æ—¥å¿—å·¥å…·ç±? */
class Logger {
  // ä½¿ç”¨å±€éƒ¨å˜é‡å­˜å‚¨å•ä¾‹å®ä¾‹ï¼Œé¿å…ä½¿ç”¨ç±»ä½œä¸ºå¯¹è±?  private static _instance: Logger | null = null;
  private config: LoggerConfig;
  private logs: LogEntry[] = [];
  private logFile?: string;
  private logFileHandle?: File; // ä½¿ç”¨å…·ä½“çš„Fileç±»å‹æ›¿ä»£object
  private logQueue: LogEntry[] = [];
  private isWriting: boolean = false;

  /**
   * ç§æœ‰æ„é€ å‡½æ•?   */
  private constructor() {
    this.config = {
      level: LogLevel.INFO,
      consoleEnabled: true,
      fileEnabled: false,
      formatEnabled: true,
      showTimestamp: true,
      showLevel: true,
      showCaller: false,
      showProcessId: false,
      showThreadId: false,
      enableStackTrace: true,
    } as LoggerConfig;
  }

  /**
   * è·å–Loggerå•ä¾‹å®ä¾‹
   */
  public static getInstance(): Logger {
    if (!Logger._instance) {
      const instance = new Logger(); // ä½¿ç”¨å±€éƒ¨å˜é‡?      Logger._instance = instance;
    }
    return Logger._instance!
  }

  /**
   * åˆå§‹åŒ–Logger
   * @param config æ—¥å¿—é…ç½®
   */
  public initialize(config: LoggerConfig): void {
    // æ‰‹åŠ¨åˆå¹¶å¯¹è±¡å±æ€§ï¼Œé¿å…ä½¿ç”¨Object.assignï¼ˆArkTSé™åˆ¶ï¼?    this.config = this.mergeConfig(this.config, config);
    
    if (this.config.fileEnabled && this.config.logFilePath) {
      this.logFile = this.config.logFilePath;
      this.ensureLogFileExists();
    }
    
    this.log(LogLevel.INFO, 'Logger initialized with level: ' + this.config.level);
  }

  /**
   * è®¾ç½®æ—¥å¿—çº§åˆ«
   * @param level æ—¥å¿—çº§åˆ«
   */
  public setLevel(level: LogLevel): void {
    this.config.level = level;
    this.log(LogLevel.INFO, 'Log level changed to: ' + level);
  }

  /**
   * è·å–å½“å‰æ—¥å¿—çº§åˆ«
   */
  public getLevel(): LogLevel {
    return this.config.level;
  }

  /**
   * è°ƒè¯•æ—¥å¿— - å…¼å®¹é™æ€è°ƒç”¨æ–¹å¼?   * @param tag æ—¥å¿—æ ‡ç­¾
   * @param message æ—¥å¿—æ¶ˆæ¯
   * @param extra é¢å¤–æ•°æ®
   */
  public static debug(tag: string, message: string, extra?: LoggerExtraData): void {
    const instance = Logger.getInstance();
    const formattedMessage = `[${tag}] ${message}`;
    instance.debug(formattedMessage, extra);
  }

  /**
   * ä¿¡æ¯æ—¥å¿— - å…¼å®¹é™æ€è°ƒç”¨æ–¹å¼?   * @param tag æ—¥å¿—æ ‡ç­¾
   * @param message æ—¥å¿—æ¶ˆæ¯
   * @param extra é¢å¤–æ•°æ®
   */
  public static info(tag: string, message: string, extra?: LoggerExtraData): void {
    const instance = Logger.getInstance();
    const formattedMessage = `[${tag}] ${message}`;
    instance.info(formattedMessage, extra);
  }

  /**
   * è­¦å‘Šæ—¥å¿— - å…¼å®¹é™æ€è°ƒç”¨æ–¹å¼?   * @param tag æ—¥å¿—æ ‡ç­¾
   * @param message æ—¥å¿—æ¶ˆæ¯
   * @param extra é¢å¤–æ•°æ®
   */
  public static warn(tag: string, message: string, extra?: LoggerExtraData): void {
    const instance = Logger.getInstance();
    const formattedMessage = `[${tag}] ${message}`;
    instance.warn(formattedMessage, extra);
  }

  /**
   * é”™è¯¯æ—¥å¿— - å…¼å®¹é™æ€è°ƒç”¨æ–¹å¼?   * @param tag æ—¥å¿—æ ‡ç­¾
   * @param message æ—¥å¿—æ¶ˆæ¯
   * @param error é”™è¯¯å¯¹è±¡
   * @param extra é¢å¤–æ•°æ®
   */
  public static error(tag: string, message: string, error?: Error, extra?: LoggerExtraData): void {
    const instance = Logger.getInstance();
    const formattedMessage = `[${tag}] ${message}`;
    instance.error(formattedMessage, error, extra);
  }

  /**
   * è¾“å‡ºå¼‚å¸¸ä¿¡æ¯ - å…¼å®¹é™æ€è°ƒç”¨æ–¹å¼?   * @param tag æ—¥å¿—æ ‡ç­¾
   * @param error é”™è¯¯å¯¹è±¡æˆ–é”™è¯¯æ¶ˆæ?   * @param extra é¢å¤–æ•°æ®
   */
  public static exception(tag: string, error: string | Error, extra?: LoggerExtraData): void {
    const instance = Logger.getInstance();
    const formattedMessage = `[${tag}] ${error instanceof Error ? error.message : error}`;
    instance.error(formattedMessage, error instanceof Error ? error : undefined, extra);
  }

  /**
   * è¾“å‡ºå¸¦æ ¼å¼åŒ–å‚æ•°çš„æ—¥å¿?- å…¼å®¹é™æ€è°ƒç”¨æ–¹å¼?   * @param tag æ—¥å¿—æ ‡ç­¾
   * @param format æ ¼å¼åŒ–å­—ç¬¦ä¸²
   * @param args æ ¼å¼åŒ–å‚æ•?   */
  public static format(tag: string, format: string, ...args: Array<string | number | boolean | object | undefined | null>): void {
    // ä½¿ç”¨formatMessageæ–¹æ³•è¿›è¡Œå­—ç¬¦ä¸²æ ¼å¼åŒ–
    const formattedMessage = Logger.formatMessage(format, args);
    
    // ä¸ä½¿ç”¨logInternalï¼Œç›´æ¥è°ƒç”¨logæ–¹æ³•
    const instance = Logger.getInstance();
    if (instance.shouldLog(LogLevel.INFO)) {
      instance.log(LogLevel.INFO, `[${tag}] ${formattedMessage}`);
    }
  }

  /**
   * æ ¼å¼åŒ–æ—¥å¿—æ¶ˆæ¯ï¼ˆæ‰‹åŠ¨å®ç°å­—ç¬¦ä¸²æ›¿æ¢ï¼Œé¿å…ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼‰
   * @param message åŸå§‹æ¶ˆæ¯
   * @param args æ›¿æ¢å‚æ•°
   * @returns æ ¼å¼åŒ–åçš„æ¶ˆæ?   */
  private static formatMessage(message: string, args: Array<string | number | boolean | object | undefined | null>): string {
    if (!args || args.length === 0) {
      return message;
    }
    
    let result = message;
    for (let i = 0; i < args.length; i++) {
      const placeholder = `{${i}}`;
      const value = String(args[i]);
      
      // æ‰‹åŠ¨æ›¿æ¢å ä½ç¬¦ï¼Œé¿å…ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼?      let startIndex = 0;
      while (true) {
        const index = result.indexOf(placeholder, startIndex);
        if (index === -1) {
          break;
        }
        
        result = result.substring(0, index) + value + result.substring(index + placeholder.length);
        startIndex = index + value.length;
      }
    }
    
    return result;
  }

  /**
   * è°ƒè¯•æ—¥å¿— - å®ä¾‹æ–¹æ³•
   * @param message æ—¥å¿—æ¶ˆæ¯
   * @param extra é¢å¤–æ•°æ®
   */
  public debug(message: string, extra?: LoggerExtraData): void {
    if (this.shouldLog(LogLevel.DEBUG)) {
      this.log(LogLevel.DEBUG, message, extra);
    }
  }

  /**
   * ä¿¡æ¯æ—¥å¿— - å®ä¾‹æ–¹æ³•
   * @param message æ—¥å¿—æ¶ˆæ¯
   * @param extra é¢å¤–æ•°æ®
   */
  public info(message: string, extra?: LoggerExtraData): void {
    if (this.shouldLog(LogLevel.INFO)) {
      this.log(LogLevel.INFO, message, extra);
    }
  }

  /**
   * è­¦å‘Šæ—¥å¿— - å®ä¾‹æ–¹æ³•
   * @param message æ—¥å¿—æ¶ˆæ¯
   * @param extra é¢å¤–æ•°æ®
   */
  public warn(message: string, extra?: LoggerExtraData): void {
    if (this.shouldLog(LogLevel.WARN)) {
      this.log(LogLevel.WARN, message, extra);
    }
  }

  /**
   * é”™è¯¯æ—¥å¿— - å®ä¾‹æ–¹æ³•
   * @param message æ—¥å¿—æ¶ˆæ¯
   * @param error é”™è¯¯å¯¹è±¡
   * @param extra é¢å¤–æ•°æ®
   */
  public error(message: string, error?: Error, extra?: LoggerExtraData): void {
    if (this.shouldLog(LogLevel.ERROR)) {
      let stackTrace = '';
      if (error && error.stack) {
        stackTrace = error.stack;
      } else {
        stackTrace = this.getStackTrace();
      }
      this.log(LogLevel.ERROR, message, extra, stackTrace);
    }
  }

  /**
   * è‡´å‘½é”™è¯¯æ—¥å¿— - å®ä¾‹æ–¹æ³•
   * @param message æ—¥å¿—æ¶ˆæ¯
   * @param error é”™è¯¯å¯¹è±¡
   * @param extra é¢å¤–æ•°æ®
   */
  public fatal(message: string, error?: Error, extra?: LoggerExtraData): void {
    if (this.shouldLog(LogLevel.FATAL)) {
      // ç®€åŒ–å®ç°ï¼Œåªä¼ é€’å¿…è¦çš„å‚æ•°
      this.log(LogLevel.FATAL, message, extra);
    }
  }

  /**
   * è®°å½•å¯¹è±¡
   * @param obj è¦è®°å½•çš„å¯¹è±¡
   * @param message æ—¥å¿—æ¶ˆæ¯
   */
  public logObject(obj: object, message?: string): void {
    const objString = this.serializeObject(obj);
    const finalMessage = message ? `${message}: ${objString}` : objString;
    this.debug(finalMessage);
  }

  /**
   * è®°å½•å¼‚å¸¸
   * @param error é”™è¯¯å¯¹è±¡
   * @param message æ—¥å¿—æ¶ˆæ¯
   */
  public logException(error: Error, message?: string): void {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    const finalMessage = message ? `${message}: ${errorMessage}` : errorMessage;
    this.error(finalMessage);
  }

  /**
   * æ¸…ç©ºæ—¥å¿—
   */
  public clearLogs(): void {
    this.logs = [];
    this.log(LogLevel.INFO, 'Logs cleared');
  }

  /**
   * è·å–æ—¥å¿—åˆ—è¡¨
   * @param level æ—¥å¿—çº§åˆ«è¿‡æ»¤
   * @param limit é™åˆ¶æ•°é‡
   */
  public getLogs(level?: LogLevel, limit?: number): LogEntry[] {
    let filteredLogs = this.logs;
    
    if (level) {
      filteredLogs = filteredLogs.filter(log => log.level === level);
    }
    
    if (limit) {
      filteredLogs = filteredLogs.slice(-limit);
    }
    
    return filteredLogs;
  }

  /**
   * å¯¼å‡ºæ—¥å¿—åˆ°æ–‡ä»?   * @param filePath å¯¼å‡ºæ–‡ä»¶è·¯å¾„
   */
  public async exportLogs(filePath: string): Promise<boolean> {
    try {
      // è¿™é‡Œéœ€è¦å®ç°æ–‡ä»¶å†™å…¥åŠŸèƒ?      this.info(`Logs exported to: ${filePath}`);
      return true;
    } catch (error) {
      this.error('Failed to export logs', error as Error);
      return false;
    }
  }

  /**
   * åˆ·æ–°æ—¥å¿—åˆ°æ–‡ä»?   */
  public async flushLogs(): Promise<void> {
    if (this.config.fileEnabled && this.logQueue.length > 0) {
      await this.writeLogsToFile();
    }
  }

  /**
   * å…³é—­Logger
   */
  public async shutdown(): Promise<void> {
    await this.flushLogs();
    if (this.logFileHandle) {
      // å…³é—­æ–‡ä»¶å¥æŸ„
      this.logFileHandle = undefined;
    }
    this.log(LogLevel.INFO, 'Logger shutdown');
  }

  /**
   * å†…éƒ¨æ—¥å¿—è®°å½•æ–¹æ³• - ç”¨äºå…¼å®¹é™æ€è°ƒç”?   * æ³¨æ„ï¼šæ­¤æ–¹æ³•å½“å‰æœªè¢«ä½¿ç”¨ï¼Œä¿ç•™æ˜¯ä¸ºäº†å‘åå…¼å®¹
   */
  private logInternal(level: LogLevel, message: string): void {
    if (this.shouldLog(level)) {
      this.log(level, message, undefined, undefined);
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦åº”è¯¥è®°å½•æŒ‡å®šçº§åˆ«çš„æ—¥å¿—
   * @param level æ—¥å¿—çº§åˆ«
   */
  private shouldLog(level: LogLevel): boolean {
    if (this.config.level === LogLevel.OFF) {
      return false;
    }
    
    const levelOrder = [LogLevel.DEBUG, LogLevel.INFO, LogLevel.WARN, LogLevel.ERROR, LogLevel.FATAL];
    const currentLevelIndex = levelOrder.indexOf(this.config.level);
    const targetLevelIndex = levelOrder.indexOf(level);
    
    return targetLevelIndex >= currentLevelIndex;
  }

  /**
   * è®°å½•æ—¥å¿—
   * @param level æ—¥å¿—çº§åˆ«
   * @param message æ—¥å¿—æ¶ˆæ¯
   * @param extra é¢å¤–æ•°æ®
   * @param stackTrace å †æ ˆè·Ÿè¸ª
   */
  private log(level: LogLevel, message: string, extra?: LoggerExtraData, stackTrace?: string): void {
    const entry: LogEntry = {
      level,
      message,
      timestamp: Date.now(),
      extra,
      stackTrace
    };
    
    if (this.config.showCaller) {
      entry.caller = this.getCallerInfo();
    }
    
    if (this.config.showProcessId) {
      entry.processId = this.getProcessId();
    }
    
    if (this.config.showThreadId) {
      entry.threadId = this.getThreadId();
    }
    
    this.logs.push(entry);
    
    // é™åˆ¶æ—¥å¿—æ•°é‡
    if (this.logs.length > 10000) {
      this.logs = this.logs.slice(-10000);
    }
    
    // è¾“å‡ºåˆ°æ§åˆ¶å°
    if (this.config.consoleEnabled) {
      this.outputToConsole(entry);
    }
    
    // æ·»åŠ åˆ°æ–‡ä»¶å†™å…¥é˜Ÿåˆ?    if (this.config.fileEnabled) {
      this.logQueue.push(entry);
      // å¼‚æ­¥åˆ·æ–°æ—¥å¿—åˆ°æ–‡ä»?      this.flushLogs().catch((err: Error) => {
        console.error('Failed to flush logs:', err);
      });
    }
  }

  /**
   * è¾“å‡ºæ—¥å¿—åˆ°æ§åˆ¶å°
   * @param entry æ—¥å¿—æ¡ç›®
   */
  private outputToConsole(entry: LogEntry): void {
    const formattedMessage = this.formatLogEntry(entry);
    
    switch (entry.level) {
      case LogLevel.DEBUG:
        console.debug(formattedMessage);
        break;
      case LogLevel.INFO:
        console.info(formattedMessage);
        break;
      case LogLevel.WARN:
        console.warn(formattedMessage);
        break;
      case LogLevel.ERROR:
      case LogLevel.FATAL:
        console.error(formattedMessage);
        if (entry.stackTrace) {
          console.error(entry.stackTrace);
        }
        break;
    }
  }

  /**
   * æ ¼å¼åŒ–æ—¥å¿—æ¡ç›?   * @param entry æ—¥å¿—æ¡ç›®
   */
  private formatLogEntry(entry: LogEntry): string {
    if (!this.config.formatEnabled) {
      return entry.message;
    }
    
    let parts: string[] = [];
    
    if (this.config.showTimestamp) {
      parts.push(this.formatTimestamp(entry.timestamp));
    }
    
    if (this.config.showLevel) {
      parts.push(`[${entry.level.toUpperCase()}]`);
    }
    
    if (entry.caller) {
      parts.push(`[${entry.caller}]`);
    }
    
    if (this.config.showProcessId && entry.processId) {
      parts.push(`[PID:${entry.processId}]`);
    }
    
    if (this.config.showThreadId && entry.threadId) {
      parts.push(`[TID:${entry.threadId}]`);
    }
    
    parts.push(entry.message);
    
    if (entry.extra) {
      parts.push(JSON.stringify(entry.extra));
    }
    
    return parts.join(' ');
  }

  /**
   * æ ¼å¼åŒ–æ—¶é—´æˆ³
   */
  private formatTimestamp(timestamp: number): string {
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    const milliseconds = String(date.getMilliseconds()).padStart(3, '0');
    
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}.${milliseconds}`;
  }

  /**
   * è·å–è°ƒç”¨è€…ä¿¡æ?   */
  private getCallerInfo(): string {
    try {
      const stack = new Error().stack?.split('\n') || [];
      // æŸ¥æ‰¾è°ƒç”¨Loggeræ–¹æ³•çš„ä½ç½?      for (let i = 3; i < stack.length; i++) {
        const line = stack[i];
        if (line && !line.includes('Logger.ets')) {
          // ä½¿ç”¨å­—ç¬¦ä¸²æ“ä½œæ›¿ä»£æ­£åˆ™è¡¨è¾¾å¼
          const atIndex = line.indexOf('at ');
          if (atIndex !== -1) {
            const start = atIndex + 3;
            // æŸ¥æ‰¾ç©ºæ ¼æˆ–æ¢è¡?            let end = line.indexOf(' ', start);
            if (end === -1) {
              end = line.length;
            }
            return line.substring(start, end) || 'unknown';
          }
          return 'unknown';
        }
      }
    } catch (error) {
      // å¿½ç•¥é”™è¯¯
    }
    return 'unknown';
  }

  /**
   * è·å–å †æ ˆè·Ÿè¸ª
   */
  private getStackTrace(): string {
    try {
      return new Error().stack || '';
    } catch (error) {
      return '';
    }
  }

  /**
   * è·å–è¿›ç¨‹ID
   */
  private getProcessId(): string {
    // åœ¨ä¸åŒç¯å¢ƒä¸­è·å–è¿›ç¨‹IDçš„æ–¹å¼å¯èƒ½ä¸å?    return 'process-' + Math.random().toString(36).substr(2, 9);
  }

  /**
   * è·å–çº¿ç¨‹ID
   */
  private getThreadId(): string {
    // åœ¨å‰ç«¯ç¯å¢ƒä¸­æ¨¡æ‹Ÿçº¿ç¨‹ID
    return 'thread-' + Math.random().toString(36).substr(2, 9);
  }

  /**
   * åºåˆ—åŒ–å¯¹è±?   * @param obj è¦åºåˆ—åŒ–çš„å¯¹è±?   */
  private serializeObject(obj: object): string {
    try {
      return JSON.stringify(obj, null, 2);
    } catch (error) {
      return String(obj);
    }
  }

  /**
   * ç¡®ä¿æ—¥å¿—æ–‡ä»¶å­˜åœ¨
   */
  private ensureLogFileExists(): void {
    // è¿™é‡Œéœ€è¦å®ç°æ–‡ä»¶ç³»ç»Ÿæ“ä½?    this.info(`Log file configured: ${this.logFile}`);
  }

  /**
   * å†™å…¥æ—¥å¿—åˆ°æ–‡ä»?   */
  private async writeLogsToFile(): Promise<void> {
    if (this.isWriting || this.logQueue.length === 0) {
      return;
    }
    
    this.isWriting = true;
    // ä½¿ç”¨sliceæ›¿ä»£spreadæ“ä½œç¬¦è·å–è¦å†™å…¥çš„æ¡ç›?    const entriesToWrite = this.logQueue.slice(0);
    this.logQueue = [];
    
    try {
      // è¿™é‡Œéœ€è¦å®ç°å¼‚æ­¥æ–‡ä»¶å†™å…?      for (const entry of entriesToWrite) {
        const formattedLine = this.formatLogEntry(entry) + '\n';
        // å†™å…¥åˆ°æ–‡ä»?- å®é™…å®ç°éœ€è¦ä½¿ç”¨æ–‡ä»¶ç³»ç»ŸAPI
        console.log('Log would be written:', formattedLine);
      }
      
      // æ£€æŸ¥æ—¥å¿—æ–‡ä»¶å¤§å°?      this.checkLogFileSize();
    } catch (error) {
      console.error('Failed to write logs to file:', error);
      // ä¸ä½¿ç”¨å±•å¼€è¿ç®—ç¬¦ï¼Œè€Œæ˜¯ä½¿ç”¨å¾ªç¯æ·»åŠ å…ƒç´ 
      for (const entry of entriesToWrite) {
        this.logQueue.push(entry);
      }
    } finally {
      this.isWriting = false;
    }
  }

  /**
   * æ£€æŸ¥æ—¥å¿—æ–‡ä»¶å¤§å°?   */
  private checkLogFileSize(): void {
    // è¿™é‡Œéœ€è¦å®ç°æ–‡ä»¶å¤§å°æ£€æŸ¥å’Œæ—¥å¿—è½®è½¬
  }

  /**
   * æ‰‹åŠ¨åˆå¹¶é…ç½®å¯¹è±¡ï¼Œé¿å…ä½¿ç”¨Object.assign
   * @param target ç›®æ ‡é…ç½®
   * @param source æºé…ç½?   */
  private mergeConfig(target: LoggerConfig, source: LoggerConfig): LoggerConfig {
    const result: LoggerConfig = {
      level: source.level !== undefined ? source.level : target.level,
      consoleEnabled: source.consoleEnabled !== undefined ? source.consoleEnabled : target.consoleEnabled,
      fileEnabled: source.fileEnabled !== undefined ? source.fileEnabled : target.fileEnabled,
      formatEnabled: source.formatEnabled !== undefined ? source.formatEnabled : target.formatEnabled,
      showTimestamp: source.showTimestamp !== undefined ? source.showTimestamp : target.showTimestamp,
      showLevel: source.showLevel !== undefined ? source.showLevel : target.showLevel,
      showCaller: source.showCaller !== undefined ? source.showCaller : target.showCaller,
      showProcessId: source.showProcessId !== undefined ? source.showProcessId : target.showProcessId,
      showThreadId: source.showThreadId !== undefined ? source.showThreadId : target.showThreadId,
      enableStackTrace: source.enableStackTrace !== undefined ? source.enableStackTrace : target.enableStackTrace,
    };

    // å¤„ç†å¯é€‰å±æ€?    if (source.logFilePath !== undefined) {
      result.logFilePath = source.logFilePath;
    } else if (target.logFilePath !== undefined) {
      result.logFilePath = target.logFilePath;
    }

    if (source.maxFileSize !== undefined) {
      result.maxFileSize = source.maxFileSize;
    } else if (target.maxFileSize !== undefined) {
      result.maxFileSize = target.maxFileSize;
    }

    if (source.maxFileCount !== undefined) {
      result.maxFileCount = source.maxFileCount;
    } else if (target.maxFileCount !== undefined) {
      result.maxFileCount = target.maxFileCount;
    }

    return result;
  }
}

// å¯¼å‡ºé»˜è®¤å®ä¾‹
export default Logger.getInstance();
// å¯¼å‡ºLoggerç±»ï¼Œä¾›éœ€è¦åˆ›å»ºè‡ªå®šä¹‰å®ä¾‹çš„åœºæ™¯ä½¿ç”?export { Logger };
