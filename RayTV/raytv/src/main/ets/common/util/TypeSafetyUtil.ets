// TypeSafetyUtil - ç±»å‹å®‰å…¨å·¥å…·ç±?
// æä¾›å®‰å…¨çš„ç±»å‹è½¬æ¢å’ŒéªŒè¯åŠŸèƒ½

// å®šä¹‰åŸºç¡€ç±»å‹æ¥å£ï¼Œé¿å…ä½¿ç”¨any/unknown
export interface TypeWrapper<T> {
  value: T;
}

// å®šä¹‰å…·ä½“çš„å‚æ•°ç±»å‹ï¼Œé¿å…ä½¿ç”¨è¿‡äºå®½æ³›çš„è”åˆç±»å?
export interface BasicValue {
  value: string | number | boolean | null;
}

// ç§»é™¤å‡½æ•°è°ƒç”¨ç­¾åæ¥å£ï¼Œä½¿ç”¨æ™®é€šå‡½æ•°ç±»å‹æ›¿ä»?
export type EnhancedFunction<T, A> = (...args: A) => T;

/**
 * ç±»å‹å®‰å…¨å·¥å…·ç±?
 * æä¾›å®‰å…¨çš„ç±»å‹è½¬æ¢å’ŒéªŒè¯æ–¹æ³•
 */
export class TypeSafetyUtil {
  /**
   * å®‰å…¨å¤„ç†é”™è¯¯å¯¹è±¡ï¼Œç¡®ä¿è¿”å›æœ‰æ•ˆçš„Errorå®ä¾‹
   * @param error é”™è¯¯å¯¹è±¡æˆ–å€?
   * @param message å¯é€‰çš„è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯å‰ç¼€
   * @returns è§„èŒƒåŒ–çš„Errorå®ä¾‹
   */
  public static safeError(error: string | number | boolean | null, message?: string): Error {
    if (error instanceof Error) {
      if (message) {
        // å¦‚æœæä¾›äº†è‡ªå®šä¹‰æ¶ˆæ¯ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„Errorå®ä¾‹
        return new Error(`${message}: ${error.message}`, { cause: error });
      }
      return error;
    }
    // å¯¹äºéErrorç±»å‹çš„å€¼ï¼Œè½¬æ¢ä¸ºå­—ç¬¦ä¸²å¹¶åˆ›å»ºæ–°çš„Errorå®ä¾‹
    const errorStr = String(error);
    return message ? new Error(`${message}: ${errorStr}`) : new Error(errorStr);
  }

  /**
   * å®‰å…¨åœ°è®¿é—®åµŒå¥—å±æ€?
   * @param obj ç›®æ ‡å¯¹è±¡
   * @param path å±æ€§è·¯å¾„ï¼Œå¯ä»¥æ˜¯å­—ç¬¦ä¸²æˆ–å­—ç¬¦ä¸²æ•°ç»„
   * @param defaultValue é»˜è®¤å€?
   * @returns è®¿é—®ç»“æœæˆ–é»˜è®¤å€?
   */
  public static safeAccess<T = string | number | boolean | null>(obj: Record<string, string | number | boolean | null>, path: string | string[], defaultValue?: T): T | undefined {
    if (!obj || typeof obj !== 'object') {
      return defaultValue;
    }

    const keys: string[] = Array.isArray(path) ? path : path.split('.');
    let current: Record<string, string | number | boolean | null> = obj;

    for (const key of keys) {
      // è·³è¿‡æ— æ•ˆé”?
      if (!key || typeof key !== 'string') {
        return defaultValue;
      }
      
      // å®‰å…¨åœ°è¿›è¡Œç´¢å¼•è®¿é—?
      const objRef = current;
      // ä½¿ç”¨Object.keysæ£€æŸ¥å±æ€§å­˜åœ¨æ€?
      if (Object.keys(objRef).includes(key)) {
        const nextValue = objRef[key];
        // æ£€æŸ¥nextValueæ˜¯å¦æ˜¯æœ‰æ•ˆå¯¹è±?
        if (nextValue !== null && typeof nextValue === 'object') {
          current = nextValue as Record<string, string | number | boolean | null>;
        } else if (nextValue === null || 
                   typeof nextValue === 'string' || 
                   typeof nextValue === 'number' || 
                   typeof nextValue === 'boolean') {
          // å¯¹äºåŸºæœ¬ç±»å‹ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯æœ€åä¸€ä¸ªé”®
          if (keys.indexOf(key) === keys.length - 1) {
            return nextValue as T ?? defaultValue;
          }
          return defaultValue; // éå¯¹è±¡ç±»å‹ä¸èƒ½ç»§ç»­è®¿é—®åµŒå¥—å±æ€?
        } else {
          return defaultValue;
        }
      } else {
        return defaultValue;
      }
    }
    
    // å¦‚æœå¾ªç¯ç»“æŸä¸”currentä»æ˜¯å¯¹è±¡ï¼Œè¿”å›é»˜è®¤å€?
    return defaultValue;
  }

  /**
   * å®‰å…¨åœ°è·å–å¯¹è±¡å±æ€§å€?
   * @param obj - è¦è·å–å±æ€§çš„å¯¹è±¡
   * @param key - å±æ€§é”®å?
   * @returns å±æ€§å€¼ï¼Œå¦‚æœå±æ€§ä¸å­˜åœ¨åˆ™è¿”å›undefined
   */
  public static getPropertyValue(obj: Record<string, string | number | boolean | null>, key: string): string | number | boolean | null | undefined {
    if (!obj || typeof obj !== 'object') {
      return undefined;
    }
    
    // ä½¿ç”¨Object.keysæ£€æŸ¥å±æ€§å­˜åœ¨æ€§ï¼Œé¿å…ä½¿ç”¨Object.hasOwnProperty.call
    if (!Object.keys(obj).includes(key)) {
      return undefined;
    }
    
    // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?
    return obj[key];
  }

  /**
   * å®‰å…¨åœ°è®¾ç½®å¯¹è±¡å±æ€§å€?
   * @param obj - è¦è®¾ç½®å±æ€§çš„å¯¹è±¡
   * @param key - å±æ€§é”®å?
   * @param value - å±æ€§å€?
   * @returns æ˜¯å¦è®¾ç½®æˆåŠŸ
   */
  public static safeSet(obj: Record<string, string | number | boolean | null>, key: string, value: string | number | boolean | null): boolean {
    if (obj === null || obj === undefined || typeof obj !== 'object') {
      return false;
    }
    
    try {
      // ä¿®å¤ï¼šä½¿ç”¨æ›´ç²¾ç¡®çš„ç±»å‹æ–­è¨€å’Œç±»å‹å®‰å…¨çš„å±æ€§è®¿é—?
      const safeObj = obj as Record<string | number, string | number | boolean | object | null>;
      // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹æ³?
      const propertyValue = TypeSafetyUtil.getPropertyValue(safeObj, key);
      if (propertyValue !== undefined) {
        safeObj[key] = value;
        return true;
      }
      return false;
    } catch {
      return false;
    }
  }
  
  /**
   * å®‰å…¨åœ°å¤„ç†å±æ€§åï¼Œç¡®ä¿å®ƒæ˜¯æœ‰æ•ˆçš„æ ‡è¯†ç¬?
   * @param propertyName åŸå§‹å±æ€§å
   * @returns å®‰å…¨çš„å±æ€§å
   */
  public static safePropertyName(propertyName: string): string {
    // å¦‚æœå·²ç»æ˜¯æœ‰æ•ˆçš„æ ‡è¯†ç¬¦ï¼Œç›´æ¥è¿”å›
    if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(propertyName)) {
      return propertyName;
    }
    
    // å¯¹äºéæ ‡è¯†ç¬¦å±æ€§åï¼Œè¿›è¡Œå®‰å…¨å¤„ç?
    // 1. æ›¿æ¢ç‰¹æ®Šå­—ç¬¦ä¸ºä¸‹åˆ’çº¿
    let safeName = propertyName.replace(/[^a-zA-Z0-9_$]/g, '_');
    
    // 2. ç¡®ä¿ä¸ä»¥æ•°å­—å¼€å¤?
    if (/^[0-9]/.test(safeName)) {
      safeName = '_' + safeName;
    }
    
    return safeName;
  }
  
  /**
   * ç§»é™¤ç´¢å¼•ç­¾åæ¥å£ï¼Œä½¿ç”¨Recordç±»å‹æ›¿ä»£
   */
  
  /**
   * åˆ›å»ºå¸¦æœ‰å®‰å…¨å±æ€§åçš„å¯¹è±?
   * @param obj åŸå§‹å¯¹è±¡
   * @returns å¸¦æœ‰å®‰å…¨å±æ€§åçš„æ–°å¯¹è±¡
   */
  public static createSafeObject(obj: Record<string, string | number | boolean | object | null>): Record<string, string | number | boolean | object | null> {
    const safeObj: Record<string, string | number | boolean | object | null> = {};
    
    const entries = Object.entries(obj);
    for (let i = 0; i < entries.length; i++) {
      const key = entries[i][0];
      const value = entries[i][1];
      const safeKey = TypeSafetyUtil.safePropertyName(key);
      safeObj[safeKey] = value;
    }
    
    return safeObj;
  }
  
  /**
   * æ³›å‹ç±»å‹æ¨æ–­è¾…åŠ©å‡½æ•°ï¼Œå¸®åŠ©TypeScriptæ›´å¥½åœ°æ¨æ–­æ³›å‹ç±»å?
   * @param value è¦åŒ…è£…çš„å€?
   * @returns åŒ…è£…åçš„å¯¹è±¡ï¼Œä¿ç•™åŸå§‹ç±»å‹ä¿¡æ?
   */
  public static withType<T>(value: T): TypeWrapper<T> {
    // ä½¿ç”¨å®Œæ•´çš„å¯¹è±¡å±æ€§èµ‹å€¼è¯­æ³•å¹¶æ·»åŠ æ˜ç¡®ç±»å‹
    const wrapper: TypeWrapper<T> = { value: value };
    return wrapper;
  }
  
  /**
   * å¢å¼ºçš„ç±»å‹å®ˆå«å‡½æ•°ï¼Œæä¾›æ›´ç²¾ç¡®çš„ç±»å‹æ¨æ–­
   * @param value è¦æ£€æŸ¥çš„å€?
   * @param guard ç±»å‹å®ˆå«å‡½æ•°
   * @returns ç»è¿‡ç±»å‹å®ˆå«åçš„å€?
   */
  public static narrowType<T extends string | number | boolean | null>(value: string | number | boolean | object | null, guard: (v: string | number | boolean | object | null) => boolean): T | null {
    // åœ¨ArkTSä¸­ï¼Œä½¿ç”¨è¿”å›å¸ƒå°”å€¼çš„å‡½æ•°æ›¿ä»£ç±»å‹å®ˆå«
    if (guard(value)) {
      // é¢å¤–çš„è¿è¡Œæ—¶æ£€æŸ¥ç¡®ä¿ç±»å‹å®‰å…?
      const result = value as T;
      if (result === null || 
          typeof result === 'string' || 
          typeof result === 'number' || 
          typeof result === 'boolean') {
        return result;
      }
    }
    return null;
  }
  
  /**
   * å®‰å…¨åœ°è¿›è¡Œç±»å‹è½¬æ¢ï¼Œæä¾›è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥å’Œç¼–è¯‘æ—¶ç±»å‹æ¨æ–?
   * @param value è¦è½¬æ¢çš„å€?
   * @param transformer è½¬æ¢å‡½æ•°
   * @param guard å¯é€‰çš„ç±»å‹å®ˆå«å‡½æ•°ï¼Œç”¨äºéªŒè¯è½¬æ¢ç»“æ?
   * @returns è½¬æ¢åçš„å€¼æˆ–é»˜è®¤å€?
   */
  public static safeCast<T, U>(
    value: T,
    transformer: (v: T) => U,
    guard?: (v: string | number | boolean | object | null) => boolean,
    defaultValue?: U
  ): U | null {
    try {
      const result = transformer(value);
      if (guard && !guard(result)) {
        return defaultValue ?? null;
      }
      return result;
    } catch {
      return defaultValue ?? null;
    }
  }
  
  /**
   * æ³›å‹å·¥å‚å‡½æ•°ï¼Œåˆ›å»ºå…·æœ‰ç‰¹å®šç±»å‹çš„å¯¹è±¡
   * @param factory å·¥å‚å‡½æ•°
   * @param args å·¥å‚å‡½æ•°å‚æ•°
   * @returns åˆ›å»ºçš„å¯¹è±?
   */
  public static createWithType<T, A extends Array<string | number | boolean | object | null>>(factory: (...args: A) => T, ...args: A): T {
    return factory(...args);
  }
  
  /**
   * å®‰å…¨æ‰§è¡Œå‡½æ•°ï¼Œæ•è·å¼‚å¸¸å¹¶è¿”å›é»˜è®¤å€?
   * @param fn è¦æ‰§è¡Œçš„å‡½æ•°
   * @param defaultValue é»˜è®¤å€?
   * @returns å‡½æ•°æ‰§è¡Œç»“æœæˆ–é»˜è®¤å€?
   */
  public static safeExecute<T>(fn: () => T, defaultValue: T): T {
    try {
      return fn();
    } catch {
      return defaultValue;
    }
  }
  
  /**
   * ç±»å‹æ–­è¨€å‡½æ•°ï¼Œæä¾›ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ?
   * @param value è¦æ–­è¨€çš„å€?
   * @returns æ–­è¨€åçš„å€?
   */
  public static asType<T>(value: string | number | boolean | object | null): T {
    return value as T;
  }
  
  /**
   * åˆ›å»ºå¢å¼ºçš„æ³›å‹å‡½æ•°ï¼Œæä¾›æ›´å¥½çš„ç±»å‹æ¨æ–?
   * @param fn åŸå§‹å‡½æ•°
   * @returns å¢å¼ºåçš„å‡½æ•°
   */
  public static createEnhancedGenericFunction<T, R>(fn: (arg: T) => R): EnhancedFunction<R, [T]> {
    const enhancedFn: EnhancedFunction<R, [T]> = (arg: T): R => {
      return fn(arg);
    };
    return enhancedFn;
  }
  
  /**
   * å®‰å…¨åœ°å°†å€¼è½¬æ¢ä¸ºå¯¹è±¡
   * @param value è¦è½¬æ¢çš„å€?
   * @returns è½¬æ¢åçš„å®‰å…¨å¯¹è±¡
   */
  public static asObject(value: string | number | boolean | object | null): Record<string, string | number | boolean | null> {
    if (value === null || value === undefined) {
      return {};
    }
    if (typeof value === 'object' && !Array.isArray(value)) {
      // è½¬æ¢å¯¹è±¡ï¼Œåªä¿ç•™åŸºæœ¬ç±»å‹å€¼å’ŒåµŒå¥—å¯¹è±¡
      const result: Record<string, string | number | boolean | null> = {};
      const obj = value as Record<string, string | number | boolean | null>;
      
      // ä½¿ç”¨Object.keyså’ŒforEachæ›¿ä»£for..inå¾ªç¯
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== undefined) {
          const propValue = obj[key];
          if (typeof propValue === 'string' || 
              typeof propValue === 'number' || 
              typeof propValue === 'boolean' || 
              propValue === null) {
            result[key] = propValue;
          }
        }
      }
      
      return result;
    }
    try {
      // å¯¹äºéå¯¹è±¡ç±»å‹ï¼Œå°è¯•JSONåºåˆ—åŒ?ååºåˆ—åŒ–æ¥åˆ›å»ºå®‰å…¨å¯¹è±?
      const serialized = JSON.stringify(value);
      const parsed = JSON.parse(serialized) as Record<string, string | number | boolean | null>;
      return typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)
          ? parsed
          : {};
    } catch {
      return {};
    }
  }

  /**
   * å°†å€¼å®‰å…¨åœ°è½¬æ¢ä¸ºæ•°ç»?
   * @param value - è¦è½¬æ¢çš„å€?
   * @returns è½¬æ¢åçš„æ•°ç»„ï¼Œå¦‚æœè½¬æ¢å¤±è´¥åˆ™è¿”å›ç©ºæ•°ç»?
   */
  public static asArray<T = string | number | boolean | null>(value: string | number | boolean | null | Array<string | number | boolean | null>): T[] {
    if (Array.isArray(value)) {
      return value as T[];
    }
    return [] as T[];
  }

  /**
   * å°†å€¼å®‰å…¨åœ°è½¬æ¢ä¸ºå­—ç¬¦ä¸²
   * @param value - è¦è½¬æ¢çš„å€?
   * @param defaultValue - é»˜è®¤å€?
   * @returns è½¬æ¢åçš„å­—ç¬¦ä¸²ï¼Œå¦‚æœè½¬æ¢å¤±è´¥åˆ™è¿”å›é»˜è®¤å€?
   */
  public static asString(value: string | number | boolean | null, defaultValue: string = ""): string {
    if (value === null || value === undefined) {
      return defaultValue;
    }
    return String(value);
  }

  /**
   * å°†å€¼å®‰å…¨åœ°è½¬æ¢ä¸ºæ•°å­?
   * @param value - è¦è½¬æ¢çš„å€?
   * @param defaultValue - é»˜è®¤å€?
   * @returns è½¬æ¢åçš„æ•°å­—ï¼Œå¦‚æœè½¬æ¢å¤±è´¥åˆ™è¿”å›é»˜è®¤å€?
   */
  public static asNumber(value: string | number | boolean | null, defaultValue: number = 0): number {
    if (value === null || value === undefined) {
      return defaultValue;
    }
    
    // ä½¿ç”¨ç±»å‹å®ˆå«ç¡®ä¿å®‰å…¨è½¬æ¢
    if (typeof value === 'number') {
      return isFinite(value) ? value : defaultValue;
    }
    
    const num = Number(value);
    return isNaN(num) ? defaultValue : num;
  }

  /**
   * å®‰å…¨åœ°å°†å€¼è½¬æ¢ä¸ºå¸ƒå°”å€?
   * @param value è¦è½¬æ¢çš„å€?
   * @returns è½¬æ¢åçš„å¸ƒå°”å€¼ï¼Œå¦‚æœè½¬æ¢å¤±è´¥åˆ™è¿”å›false
   */
  public static asBoolean(value: string | number | boolean | null): boolean {
    if (value === null || value === undefined) {
      return false;
    }
    return Boolean(value);
  }

  /**
   * å®‰å…¨åœ°ä»å¯¹è±¡ä¸­è·å–å±æ€§ï¼Œæä¾›ç±»å‹æ£€æŸ?
   * @param obj å¯¹è±¡
   * @param key å±æ€§å
   * @param defaultValue é»˜è®¤å€?
   * @returns å±æ€§å€¼æˆ–é»˜è®¤å€?
   */
  public static getProperty<T extends string | number | boolean | null>(
    obj: Record<string, string | number | boolean | null>,
    key: string,
    defaultValue: T
  ): T {
    const safeObj = TypeSafetyUtil.asObject(obj);
    
    // ä½¿ç”¨Object.keyså’Œincludesæ£€æŸ¥å±æ€§å­˜åœ¨æ€§ï¼Œé¿å…ä½¿ç”¨inæ“ä½œç¬?
    if (key !== undefined && Object.keys(safeObj).includes(key)) {
      const value = safeObj[key];
      // ç¡®ä¿è¿”å›å€¼æ˜¯åŸºæœ¬ç±»å‹ä¸”ç¬¦åˆé¢„æœŸç±»å?
      if ((value === null || 
           typeof value === 'string' || 
           typeof value === 'number' || 
           typeof value === 'boolean') && 
          value !== undefined) {
        return value as T;
      }
    }
    
    return defaultValue;
  }

  /**
   * å®‰å…¨åœ°ä»å¯¹è±¡ä¸­è·å–åµŒå¥—å±æ€?
   * @param obj å¯¹è±¡
   * @param path å±æ€§è·¯å¾„ï¼Œå¦?'user.profile.name'
   * @param defaultValue é»˜è®¤å€?
   * @returns å±æ€§å€¼æˆ–é»˜è®¤å€?
   */
  public static getNestedProperty<T>(
    obj: Record<string, string | number | boolean | object | null>,
    path: string,
    defaultValue: T
  ): T {
    if (!obj || typeof obj !== 'object' || !path || typeof path !== 'string') {
      return defaultValue;
    }
    
    const keys = path.split('.');
    let current: Record<string, string | number | boolean | object | null> = obj;
    
    for (const key of keys) {
      // è·³è¿‡æ— æ•ˆé”?
      if (!key || typeof key !== 'string') {
        return defaultValue;
      }
      
      // ä½¿ç”¨Object.keysæ£€æŸ¥å±æ€§å­˜åœ¨æ€?
      if (Object.keys(current).includes(key)) {
        const nextValue = current[key];
        // æ£€æŸ¥nextValueæ˜¯å¦æ˜¯æœ‰æ•ˆå¯¹è±?
        if (nextValue !== null && typeof nextValue === 'object' && !Array.isArray(nextValue)) {
          current = nextValue as Record<string, string | number | boolean | object | null>;
        } else if (nextValue === null || 
                   typeof nextValue === 'string' || 
                   typeof nextValue === 'number' || 
                   typeof nextValue === 'boolean') {
          // å¯¹äºåŸºæœ¬ç±»å‹ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯æœ€åä¸€ä¸ªé”®
          if (keys.indexOf(key) === keys.length - 1) {
            return nextValue as T;
          }
          return defaultValue; // éå¯¹è±¡ç±»å‹ä¸èƒ½ç»§ç»­è®¿é—®åµŒå¥—å±æ€?
        } else {
          return defaultValue;
        }
      } else {
        return defaultValue;
      }
    }
    
    // å¦‚æœå¾ªç¯ç»“æŸä¸”currentä»æ˜¯å¯¹è±¡ï¼Œå°è¯•è¿›è¡Œç±»å‹è½¬æ?
    return current as T;
  }

  /**
   * å®‰å…¨åœ°è®¾ç½®å¯¹è±¡çš„å±æ€?
   * @param obj å¯¹è±¡
   * @param key å±æ€§å
   * @param value å€?
   * @returns æ˜¯å¦è®¾ç½®æˆåŠŸ
   */
  public static setProperty<T extends string | number | boolean | null>(
    obj: Record<string, string | number | boolean | object | null>,
    key: string,
    value: T
  ): boolean {
    if (obj && typeof obj === 'object' && key && !Array.isArray(obj)) {
      // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹æ³?
      const propertyValue = TypeSafetyUtil.getPropertyValue(obj, key);
      if (propertyValue !== undefined) {
        obj[key] = value;
        return true;
      }
    }
    return false;
  }

  /**
   * å®‰å…¨åœ°è®¾ç½®å¯¹è±¡çš„åµŒå¥—å±æ€?
   * @param obj å¯¹è±¡
   * @param path å±æ€§è·¯å¾?
   * @param value å€?
   * @returns æ˜¯å¦è®¾ç½®æˆåŠŸ
   */
  public static setNestedProperty<T extends string | number | boolean | null>(
    obj: Record<string, string | number | boolean | object | null>,
    path: string,
    value: T
  ): boolean {
    if (!obj || typeof obj !== 'object' || !path || typeof path !== 'string') {
      return false;
    }
    
    const keys = path.split('.');
    let current: Record<string, string | number | boolean | object | null> = obj;
    
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      if (!current[key] || typeof current[key] !== 'object' || Array.isArray(current[key])) {
        // ä½¿ç”¨æ˜ç¡®çš„ç±»å‹å£°æ˜ï¼Œé¿å…ä½¿ç”¨ç©ºå¯¹è±¡å­—é¢é‡
        current[key] = {} as Record<string, string | number | boolean | object | null>;
      }
      current = current[key] as Record<string, string | number | boolean | object | null>;
    }
    
    return TypeSafetyUtil.setProperty(current, keys[keys.length - 1], value);
  }

  /**
   * å®‰å…¨åœ°è®¿é—®åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å±æ€?
   * @param obj è¦è®¿é—®çš„å¯¹è±¡
   * @param propertyName å±æ€§åï¼ˆå¯èƒ½åŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼‰
   * @param defaultValue é»˜è®¤å€?
   * @returns å±æ€§å€¼æˆ–é»˜è®¤å€?
   */
  public static getPropertyWithSpecialChars<T extends string | number | boolean | null>(obj: Record<string, string | number | boolean | object | null>, propertyName: string, defaultValue: T): T {
    if (!obj || typeof obj !== 'object' || Array.isArray(obj)) {
      return defaultValue;
    }
    
    try {
      if (propertyName !== undefined && Object.keys(obj).includes(propertyName)) {
        const value = obj[propertyName];
        // ç¡®ä¿è¿”å›å€¼æ˜¯åŸºæœ¬ç±»å‹ä¸”ç¬¦åˆé¢„æœŸç±»å?
        if ((value === null || 
             typeof value === 'string' || 
             typeof value === 'number' || 
             typeof value === 'boolean') && 
            value !== undefined) {
          return value as T;
        }
      }
      return defaultValue;
    } catch {
      return defaultValue;
    }
  }
  
  /**
   * å®‰å…¨åœ°è®¾ç½®åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å±æ€?
   * @param obj è¦è®¾ç½®å±æ€§çš„å¯¹è±¡
   * @param propertyName å±æ€§åï¼ˆå¯èƒ½åŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼‰
   * @param value å±æ€§å€?
   * @returns æ˜¯å¦è®¾ç½®æˆåŠŸ
   */
  public static setPropertyWithSpecialChars<T extends string | number | boolean | null>(
    obj: Record<string, string | number | boolean | object | null>,
    propertyName: string,
    value: T
  ): boolean {
    if (!obj || typeof obj !== 'object' || Array.isArray(obj)) {
      return false;
    }
    
    try {
      // ä½¿ç”¨ç´¢å¼•è®¿é—®å™¨å®‰å…¨åœ°è®¾ç½®å±æ€?
      obj[propertyName] = value;
      return true;
    } catch {
      return false;
    }
  }
  
  /**
   * åˆ›å»ºå®‰å…¨çš„æ•°æ®åº“è®°å½•å¯¹è±¡
   * @param data åŸå§‹æ•°æ®å¯¹è±¡
   * @returns å®‰å…¨çš„æ•°æ®åº“è®°å½•å¯¹è±¡
   */
  public static createSafeDatabaseRecord(data: Record<string, string | number | boolean | object | null>): Record<string, string | number | boolean | null> {
    const result: Record<string, string | number | boolean | null> = {};
    
    if (!data || typeof data !== 'object' || Array.isArray(data)) {
      return result;
    }
    
    // å®‰å…¨åœ°å¤åˆ¶æ‰€æœ‰å±æ€§ï¼ŒåŒ…æ‹¬é‚£äº›åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å±æ€?
    const keys = Object.keys(data);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      // å®‰å…¨åœ°æ£€æŸ¥å±æ€§æ˜¯å¦å±äºå¯¹è±¡è‡ªèº?
      if (key !== undefined && Object.keys(data).includes(key)) {
        // åªä¿ç•™åŸºæœ¬ç±»å‹å€?
        const value = data[key];
        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) {
          result[key] = value;
        } else {
          // å¯¹äºå¤æ‚ç±»å‹ï¼Œè½¬æ¢ä¸ºå­—ç¬¦ä¸²æˆ–å¿½ç•¥
          result[key] = value === undefined ? null : String(value);
        }
      }
    }
    
    return result;
  }

  /**
   * å®‰å…¨åœ°è·å–å¯¹è±¡çš„é”®åˆ—è¡?
   * @param obj å¯¹è±¡
   * @returns é”®åˆ—è¡?
   */
  public static getObjectKeys(obj: Record<string, string | number | boolean | null>): string[] {
    return Object.keys(obj);
  }

  /**
   * å®‰å…¨åœ°è·å–å¯¹è±¡çš„å€¼åˆ—è¡?
   * @param obj å¯¹è±¡
   * @returns å€¼åˆ—è¡?
   */
  public static getObjectValues<T extends string | number | boolean | null>(obj: Record<string, string | number | boolean | null>): T[] {
    const values = Object.values(obj);
    // è¿‡æ»¤å¹¶è½¬æ¢å€¼ï¼Œç¡®ä¿è¿”å›çš„æ˜¯æŒ‡å®šç±»å‹
    return values.filter(value => 
      typeof value === 'string' || 
      typeof value === 'number' || 
      typeof value === 'boolean' || 
      value === null
    ) as T[];
  }

  /**
   * å®‰å…¨åœ°è·å–å¯¹è±¡çš„é”®å€¼å¯¹åˆ—è¡¨
   * @param obj å¯¹è±¡
   * @returns é”®å€¼å¯¹åˆ—è¡¨
   */
  public static getObjectEntries<T extends string | number | boolean | null>(obj: Record<string, string | number | boolean | null>): [string, T][] {
    const entries = Object.entries(obj);
    // è¿‡æ»¤å¹¶è½¬æ¢é”®å€¼å¯¹ï¼Œç¡®ä¿è¿”å›çš„æ˜¯æŒ‡å®šç±»å?
    return entries.filter((entry) => {
      const value = entry[1];
      return typeof value === 'string' || 
             typeof value === 'number' || 
             typeof value === 'boolean' || 
             value === null;
    }) as [string, T][];
  }

  /**
   * åˆå¹¶å¯¹è±¡ï¼Œå¤„ç†ç±»å‹å®‰å…?
   * @param target ç›®æ ‡å¯¹è±¡
   * @param sources æºå¯¹è±?
   * @returns åˆå¹¶åçš„å¯¹è±¡
   */
  public static mergeObjects(
    target: Record<string, string | number | boolean | null>,
    ...sources: Record<string, string | number | boolean | null>[]
  ): Record<string, string | number | boolean | null> {
    // åˆ›å»ºç›®æ ‡å¯¹è±¡çš„å‰¯æœ¬ï¼Œé¿å…ç›´æ¥ä¿®æ”¹åŸå¯¹è±?
    const result: Record<string, string | number | boolean | null> = {};
    
    // å¤åˆ¶ç›®æ ‡å¯¹è±¡çš„å±æ€?
    const targetEntries = TypeSafetyUtil.getObjectEntries<string | number | boolean | null>(target);
    for (let i = 0; i < targetEntries.length; i++) {
      const entry = targetEntries[i];
      const key = entry[0];
      const value = entry[1];
      result[key] = value;
    }
    
    for (const source of sources) {
      const entries = TypeSafetyUtil.getObjectEntries<string | number | boolean | null>(source);
      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        const key = entry[0];
        const value = entry[1];
        if (value === null || value === undefined) {
          continue;
        }
        
        if (TypeSafetyUtil.isValidObject(value)) {
          const targetValue = result[key];
          if (TypeSafetyUtil.isValidObject(targetValue)) {
            result[key] = TypeSafetyUtil.mergeObjects(
              targetValue as Record<string, string | number | boolean | null>, 
              value as Record<string, string | number | boolean | null>
            );
          } else {
            // é¿å…ä½¿ç”¨å¯¹è±¡å±•å¼€æ“ä½œï¼Œæ”¹ç”¨æ˜ç¡®çš„å¯¹è±¡åˆ›å»º
            result[key] = TypeSafetyUtil.asObject(value);
          }
        } else if (TypeSafetyUtil.isValidArray(value)) {
          // é¿å…ä½¿ç”¨æ•°ç»„å±•å¼€æ“ä½œï¼Œæ”¹ç”¨Array.fromåˆ›å»ºæ–°æ•°ç»?
          result[key] = Array.from(value as string[]);
        } else {
          result[key] = value;
        }
      }
    }
    
    return result;
  }

  /**
   * åˆ›å»ºç±»å‹æ£€æŸ¥å‡½æ•?
   * @param schema å±æ€§éªŒè¯å‡½æ•°çš„æ˜ å°„
   * @returns ç±»å‹æ£€æŸ¥å‡½æ•°ï¼Œè¿”å›å¸ƒå°”å€?
   */
  public static createTypeGuard(
    schema: Record<string, (value: string | number | boolean | object | null) => boolean>
  ): (obj: Record<string, string | number | boolean | object | null>) => boolean {
    return (obj: Record<string, string | number | boolean | object | null>): boolean => {
      if (!TypeSafetyUtil.isValidObject(obj)) {
        return false;
      }
      
      // éªŒè¯æ‰€æœ‰å¿…éœ€çš„å±æ€§éƒ½å­˜åœ¨ä¸”ç¬¦åˆç±»å?      const entries = TypeSafetyUtil.getObjectEntries<(value: string | number | boolean | object | null) => boolean>(schema);
      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        const key = entry[0];
        const validator = entry[1];
        // å®‰å…¨åœ°è·å–å¯¹è±¡å±æ€§å¹¶éªŒè¯
        let value = TypeSafetyUtil.safeAccess(obj, key.toString(), null);
        // ç¡®ä¿valueä¸æ˜¯undefinedï¼Œä½¿ç”¨nullä½œä¸ºé»˜è®¤å€?        if (value === undefined) {
          value = null;
        }
        if (!validator(value)) {
          return false;
        }
      }
      
      return true;
    };
  }

  /**
   * å®‰å…¨åœ°è§£æJSONå­—ç¬¦ä¸?
   * @param jsonStr JSONå­—ç¬¦ä¸?
   * @param defaultValue é»˜è®¤å€?
   * @returns è§£æåçš„å¯¹è±¡æˆ–é»˜è®¤å€?
   */
  public static safeJsonParse<T>(jsonStr: string | number | boolean | object | null, defaultValue: T): T {
    try {
      // ç¡®ä¿jsonStræ˜¯å­—ç¬¦ä¸²ç±»å‹
      if (typeof jsonStr !== 'string') {
        return defaultValue;
      }
      const parsed = JSON.parse(jsonStr) as T;
      return parsed !== null ? parsed : defaultValue;
    } catch {
      return defaultValue;
    }
  }

  /**
   * å®‰å…¨åœ°åºåˆ—åŒ–å¯¹è±¡ä¸ºJSONå­—ç¬¦ä¸?
   * @param obj è¦åºåˆ—åŒ–çš„å¯¹è±?
   * @param defaultValue é»˜è®¤å€?
   * @returns åºåˆ—åŒ–åçš„å­—ç¬¦ä¸²æˆ–é»˜è®¤å€?
   */
  public static safeJsonStringify(obj: string | number | boolean | object | null, defaultValue: string): string {
    try {
      return JSON.stringify(obj);
    } catch {
      return defaultValue;
    }
  }

  /**
   * æ£€æŸ¥å€¼æ˜¯å¦ä¸ºæœ‰æ•ˆçš„éç©ºå­—ç¬¦ä¸²
   * @param value è¦æ£€æŸ¥çš„å€?
   * @returns æ˜¯å¦ä¸ºæœ‰æ•ˆå­—ç¬¦ä¸²
   */
  public static isValidString(value: string | number | boolean | object | null): boolean {
    return typeof value === 'string' && value.trim().length > 0;
  }

  /**
   * æ£€æŸ¥å€¼æ˜¯å¦ä¸ºæœ‰æ•ˆçš„éé›¶æ•°å­?
   * @param value è¦æ£€æŸ¥çš„å€?
   * @returns æ˜¯å¦ä¸ºæœ‰æ•ˆæ•°å­?
   */
  public static isValidNumber(value: string | number | boolean | object | null): boolean {
    return typeof value === 'number' && !isNaN(value) && isFinite(value);
  }

  /**
   * æ£€æŸ¥å€¼æ˜¯å¦ä¸ºæœ‰æ•ˆçš„å¸ƒå°”å€?
   * @param value è¦æ£€æŸ¥çš„å€?
   * @returns æ˜¯å¦ä¸ºæœ‰æ•ˆå¸ƒå°”å€?
   */
  public static isValidBoolean(value: string | number | boolean | object | null): boolean {
    return typeof value === 'boolean';
  }

  /**
   * æ£€æŸ¥å€¼æ˜¯å¦ä¸ºæœ‰æ•ˆçš„å¯¹è±?
   * @param value è¦æ£€æŸ¥çš„å€?
   * @returns æ˜¯å¦ä¸ºæœ‰æ•ˆå¯¹è±?
   */
  public static isValidObject(value: string | number | boolean | object | null): boolean {
    return value !== null && typeof value === 'object' && !Array.isArray(value);
  }

  /**
   * æ£€æŸ¥å€¼æ˜¯å¦ä¸ºæœ‰æ•ˆçš„æ•°ç»?
   * @param value è¦æ£€æŸ¥çš„å€?
   * @returns æ˜¯å¦ä¸ºæœ‰æ•ˆæ•°ç»?
   */
  public static isValidArray(value: string | number | boolean | object | null): boolean {
    return Array.isArray(value);
  }

  /**
   * åˆ›å»ºç±»å‹å®‰å…¨çš„æ˜ å°„å¯¹è±?
   * @param entries é”®å€¼å¯¹æ•°ç»„
   * @returns ç±»å‹å®‰å…¨çš„æ˜ å°„å¯¹è±?
   */
  public static createSafeMap<K extends string, V extends string | number | boolean | null>(
    entries: [K, V][]
  ): Record<K, V> {
    const result = {} as Record<K, V>;
    
    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];
      const key = entry[0];
      const value = entry[1];
      if (key !== undefined && value !== undefined) {
        // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹æ³?
        const propertyValue = TypeSafetyUtil.getPropertyValue(result, key);
        if (propertyValue !== undefined) {
          result[key] = value;
        }
      }
    }
    
    return result;
  }

  /**
   * ä»å¯¹è±¡ä¸­é€‰æ‹©æŒ‡å®šçš„å±æ€?
   * @param obj æºå¯¹è±?
   * @param keys è¦é€‰æ‹©çš„å±æ€§åæ•°ç»„
   * @returns åŒ…å«é€‰å®šå±æ€§çš„æ–°å¯¹è±?
   */
  public static pickProperties<T extends Record<string, string | number | boolean | object | null>, K extends keyof T>(
    obj: T,
    keys: K[]
  ): Record<string, string | number | boolean | object | null> {
    const result: Record<string, string | number | boolean | object | null> = {};
    
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key !== undefined && obj[key] !== undefined) {
        // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹æ³?
        const propertyValue = TypeSafetyUtil.getPropertyValue(obj, key);
        if (propertyValue !== undefined) {
          result[key as string] = propertyValue;
        }
      }
    }
    
    return result;
  }

  /**
   * ä»å¯¹è±¡ä¸­æ’é™¤æŒ‡å®šçš„å±æ€?
   * @param obj æºå¯¹è±?
   * @param keys è¦æ’é™¤çš„å±æ€§åæ•°ç»„
   * @returns æ’é™¤æŒ‡å®šå±æ€§åçš„æ–°å¯¹è±¡
   */
  public static omitProperties<T extends Record<string, string | number | boolean | object | null>, K extends keyof T>(
    obj: T,
    keys: K[]
  ): Record<string, string | number | boolean | object | null> {
    const result: Record<string, string | number | boolean | object | null> = {};
    const objKeys = Object.keys(obj) as (keyof T)[];
    
    for (let i = 0; i < objKeys.length; i++) {
      const key = objKeys[i];
      // æ£€æŸ¥keyæ˜¯å¦åœ¨è¦æ’é™¤çš„é”®åˆ—è¡¨ä¸?
      let shouldExclude = false;
      for (let j = 0; j < keys.length; j++) {
        if (key === keys[j]) {
          shouldExclude = true;
          break;
        }
      }
      
      if (!shouldExclude && key !== undefined) {
        // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹æ³?
        const propertyValue = TypeSafetyUtil.getPropertyValue(obj, key);
        if (propertyValue !== undefined) {
          result[key as string] = propertyValue;
        }
      }
    }
    
    return result;
  }
}

// ç±»å‹å®šä¹‰ï¼Œé¿å…ä½¿ç”¨å¯¹è±¡å­—é¢é‡ä½œä¸ºç±»å‹
// æ¥å£å·²åœ¨æ–‡ä»¶é¡¶éƒ¨å®šä¹‰ï¼Œæ­¤å¤„ä¸å†é‡å¤
