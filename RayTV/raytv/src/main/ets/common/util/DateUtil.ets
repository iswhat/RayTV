// DateUtil - æ—¥æœŸå’Œæ—¶é—´å¤„ç†å·¥å…·ç±»
import Logger from './Logger';

const TAG = 'DateUtil';

/**
 * æ—¥æœŸæ ¼å¼ç±»å‹æšä¸¾
 */
export enum DateFormatType {
  FULL,        // å®Œæ•´æ ¼å¼ï¼šYYYY-MM-DD HH:mm:ss
  DATE,        // æ—¥æœŸæ ¼å¼ï¼šYYYY-MM-DD
  TIME,        // æ—¶é—´æ ¼å¼ï¼šHH:mm:ss
  TIME_SHORT,  // çŸ­æ—¶é—´æ ¼å¼ï¼šHH:mm
  DATE_CHINESE,// ä¸­æ–‡æ—¥æœŸæ ¼å¼ï¼šYYYYå¹´MMæœˆDDæ—?  FULL_CHINESE // å®Œæ•´ä¸­æ–‡æ ¼å¼ï¼šYYYYå¹´MMæœˆDDæ—?HH:mm:ss
}

/**
 * æ—¥æœŸå·¥å…·ç±? * æä¾›æ—¥æœŸæ ¼å¼åŒ–ã€è§£æã€æ¯”è¾ƒç­‰åŠŸèƒ½
 */
export default class DateUtil {
  /**
   * æ ¼å¼åŒ–æ—¥æœ?   * @param date æ—¥æœŸå¯¹è±¡æˆ–æ—¶é—´æˆ³
   * @param format æ ¼å¼åŒ–ç±»å‹æˆ–è‡ªå®šä¹‰æ ¼å¼å­—ç¬¦ä¸²
   * @returns æ ¼å¼åŒ–åçš„æ—¥æœŸå­—ç¬¦ä¸²
   */
  public static format(date: Date | number | string, format: DateFormatType | string = DateFormatType.FULL): string {
    try {
      const dateObj = DateUtil.parseDate(date);
      if (!dateObj) {
        throw new Error('Invalid date');
      }

      // æ ¹æ®æ ¼å¼ç±»å‹è·å–å¯¹åº”çš„æ ¼å¼å­—ç¬¦ä¸²
      let formatStr = format;
      if (typeof format !== 'string') {
        switch (format) {
          case DateFormatType.FULL:
            formatStr = 'YYYY-MM-DD HH:mm:ss';
            break;
          case DateFormatType.DATE:
            formatStr = 'YYYY-MM-DD';
            break;
          case DateFormatType.TIME:
            formatStr = 'HH:mm:ss';
            break;
          case DateFormatType.TIME_SHORT:
            formatStr = 'HH:mm';
            break;
          case DateFormatType.DATE_CHINESE:
            formatStr = 'YYYYå¹´MMæœˆDDæ—?;
            break;
          case DateFormatType.FULL_CHINESE:
            formatStr = 'YYYYå¹´MMæœˆDDæ—?HH:mm:ss';
            break;
          default:
            formatStr = 'YYYY-MM-DD HH:mm:ss';
        }
      }

      // æ ¼å¼åŒ–æ›¿æ?      return formatStr
        .replace('YYYY', dateObj.getFullYear().toString())
        .replace('MM', DateUtil.padZero(dateObj.getMonth() + 1))
        .replace('DD', DateUtil.padZero(dateObj.getDate()))
        .replace('HH', DateUtil.padZero(dateObj.getHours()))
        .replace('mm', DateUtil.padZero(dateObj.getMinutes()))
        .replace('ss', DateUtil.padZero(dateObj.getSeconds()));
    } catch (error) {
      Logger.error(TAG, `Failed to format date: ${error}`);
      return '';
    }
  }

  /**
   * è§£ææ—¥æœŸå­—ç¬¦ä¸?   * @param dateStr æ—¥æœŸå­—ç¬¦ä¸?   * @param format æ ¼å¼å­—ç¬¦ä¸²ï¼ˆå¯é€‰ï¼‰
   * @returns è§£æåçš„æ—¥æœŸå¯¹è±¡
   */
  public static parse(dateStr: string, format?: string instanceof Error ? format?: string : new Error(String(format?: string instanceof Error ? format?: string instanceof Error ? format?: string : new Error(String(format?: string : new Error(String(format?: string instanceof Error ? format?: string : new Error(String(format?: string instanceof Error ? format?: string instanceof Error ? format?: string : new Error(String(format?: string instanceof Error ? format?: string instanceof Error ? format?: string : new Error(String(format?: string : new Error(String(format?: string instanceof Error ? format?: string : new Error(String(format?: string : new Error(String(format?: string instanceof Error ? format?: string : new Error(String(format?: string instanceof Error ? format?: string instanceof Error ? format?: string : new Error(String(format?: string : new Error(String(format?: string instanceof Error ? format?: string : new Error(String(format?: string))))))): Date | null {
    try {
      if (!dateStr) return null;

      // å¦‚æœæä¾›äº†æ ¼å¼ï¼Œä½¿ç”¨æ›´ç²¾ç¡®çš„è§£æ
      if (format) {
        return DateUtil.parseWithFormat(dateStr, format);
      }

      // é»˜è®¤è§£æ
      const date = new Date(dateStr);
      return isNaN(date.getTime()) ? null : date;
    } catch (error) {
      Logger.error(TAG, `Failed to parse date string: ${error}`);
      return null;
    }
  }

  /**
   * æ ¹æ®æ ¼å¼è§£ææ—¥æœŸå­—ç¬¦ä¸?   * @param dateStr æ—¥æœŸå­—ç¬¦ä¸?   * @param format æ ¼å¼å­—ç¬¦ä¸?   * @returns è§£æåçš„æ—¥æœŸå¯¹è±¡
   */
  private static parseWithFormat(dateStr: string, format: string instanceof Error ? format: string : new Error(String(format: string instanceof Error ? format: string instanceof Error ? format: string : new Error(String(format: string : new Error(String(format: string instanceof Error ? format: string : new Error(String(format: string instanceof Error ? format: string instanceof Error ? format: string : new Error(String(format: string instanceof Error ? format: string instanceof Error ? format: string : new Error(String(format: string : new Error(String(format: string instanceof Error ? format: string : new Error(String(format: string : new Error(String(format: string instanceof Error ? format: string : new Error(String(format: string instanceof Error ? format: string instanceof Error ? format: string : new Error(String(format: string : new Error(String(format: string instanceof Error ? format: string : new Error(String(format: string))))))): Date | null {
    try {
      // æå–æ ¼å¼ä¸­çš„å¹´æœˆæ—¥æ—¶åˆ†ç§’ä½ç½®
      const yearMatch = format.match(/YYYY/g);
      const monthMatch = format.match(/MM/g);
      const dayMatch = format.match(/DD/g);
      const hourMatch = format.match(/HH/g);
      const minuteMatch = format.match(/mm/g);
      const secondMatch = format.match(/ss/g);

      let year = 1970;
      let month = 0;
      let day = 1;
      let hour = 0;
      let minute = 0;
      let second = 0;

      // æå–å¹´æœˆæ—?      if (yearMatch && yearMatch.index !== undefined) {
        year = parseInt(dateStr.substr(yearMatch.index, 4));
      }
      if (monthMatch && monthMatch.index !== undefined) {
        month = parseInt(dateStr.substr(monthMatch.index, 2)) - 1; // æœˆä»½ä»?å¼€å§?      }
      if (dayMatch && dayMatch.index !== undefined) {
        day = parseInt(dateStr.substr(dayMatch.index, 2));
      }

      // æå–æ—¶åˆ†ç§?      if (hourMatch && hourMatch.index !== undefined) {
        hour = parseInt(dateStr.substr(hourMatch.index, 2));
      }
      if (minuteMatch && minuteMatch.index !== undefined) {
        minute = parseInt(dateStr.substr(minuteMatch.index, 2));
      }
      if (secondMatch && secondMatch.index !== undefined) {
        second = parseInt(dateStr.substr(secondMatch.index, 2));
      }

      const date = new Date(year, month, day, hour, minute, second);
      return isNaN(date.getTime()) ? null : date;
    } catch (error) {
      Logger.error(TAG, `Failed to parse date with format: ${error}`);
      return null;
    }
  }

  /**
   * è·å–ç›¸å¯¹æ—¶é—´æè¿°
   * @param date æ—¥æœŸå¯¹è±¡æˆ–æ—¶é—´æˆ³
   * @returns ç›¸å¯¹æ—¶é—´æè¿°
   */
  public static getRelativeTime(date: Date | number | string): string {
    try {
      const dateObj = DateUtil.parseDate(date);
      if (!dateObj) return '';

      const now = new Date();
      const diffMs = now.getTime() - dateObj.getTime();
      const diffSecs = Math.floor(diffMs / 1000);
      const diffMins = Math.floor(diffSecs / 60);
      const diffHours = Math.floor(diffMins / 60);
      const diffDays = Math.floor(diffHours / 24);

      if (diffSecs < 60) {
        return 'åˆšåˆš';
      } else if (diffMins < 60) {
        return `${diffMins}åˆ†é’Ÿå‰`;
      } else if (diffHours < 24) {
        return `${diffHours}å°æ—¶å‰`;
      } else if (diffDays < 7) {
        return `${diffDays}å¤©å‰`;
      } else if (diffDays < 30) {
        const weeks = Math.floor(diffDays / 7);
        return `${weeks}å‘¨å‰`;
      } else if (diffDays < 365) {
        const months = Math.floor(diffDays / 30);
        return `${months}ä¸ªæœˆå‰`;
      } else {
        const years = Math.floor(diffDays / 365);
        return `${years}å¹´å‰`;
      }
    } catch (error) {
      Logger.error(TAG, `Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}` instanceof Error ? `Failed to get relative time: ${error}` : new Error(String(`Failed to get relative time: ${error}`)))))));
      return '';
    }
  }

  /**
   * æ·»åŠ æ—¶é—´é—´éš”
   * @param date æ—¥æœŸå¯¹è±¡æˆ–æ—¶é—´æˆ³
   * @param amount æ—¶é—´æ•°é‡
   * @param unit æ—¶é—´å•ä½
   * @returns æ–°çš„æ—¥æœŸå¯¹è±¡
   */
  public static add(date: Date | number | string, amount: number, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second'): Date {
    try {
      const dateObj = DateUtil.parseDate(date);
      if (!dateObj) throw new Error('Invalid date');

      const result = new Date(dateObj.getTime());

      switch (unit) {
        case 'year':
          result.setFullYear(result.getFullYear() + amount);
          break;
        case 'month':
          result.setMonth(result.getMonth() + amount);
          break;
        case 'day':
          result.setDate(result.getDate() + amount);
          break;
        case 'hour':
          result.setHours(result.getHours() + amount);
          break;
        case 'minute':
          result.setMinutes(result.getMinutes() + amount);
          break;
        case 'second':
          result.setSeconds(result.getSeconds() + amount);
          break;
      }

      return result;
    } catch (error) {
      Logger.error(TAG, `Failed to add time: ${error}`);
      throw new Error(error instanceof Error ? error.message : String(error));
    }
  }

  /**
   * æ¯”è¾ƒä¸¤ä¸ªæ—¥æœŸ
   * @param date1 ç¬¬ä¸€ä¸ªæ—¥æœ?   * @param date2 ç¬¬äºŒä¸ªæ—¥æœ?   * @returns 1:date1>date2, -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string instanceof Error ? -1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string : new Error(String(-1:date1<date2, 0:ç›¸ç­‰
   */
  public static compare(date1: Date | number | string, date2: Date | number | string))))))): number {
    try {
      const d1 = DateUtil.parseDate(date1);
      const d2 = DateUtil.parseDate(date2);

      if (!d1 || !d2) throw new Error('Invalid date');

      const time1 = d1.getTime();
      const time2 = d2.getTime();

      if (time1 > time2) return 1;
      if (time1 < time2) return -1;
      return 0;
    } catch (error) {
      Logger.error(TAG, `Failed to compare dates: ${error}`);
      throw new Error(String(error));
    }
  }

  /**
   * è·å–ä¸¤ä¸ªæ—¥æœŸä¹‹é—´çš„å·®å€?   * @param date1 ç¬¬ä¸€ä¸ªæ—¥æœ?   * @param date2 ç¬¬äºŒä¸ªæ—¥æœ?   * @param unit æ—¶é—´å•ä½
   * @returns å·®å€?   */
  public static diff(date1: Date | number | string, date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' instanceof Error ? date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' : new Error(String(date2: Date | number | string, unit: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second'))))))): number {
    try {
      const d1 = DateUtil.parseDate(date1);
      const d2 = DateUtil.parseDate(date2);

      if (!d1 || !d2) throw new Error('Invalid date');

      const diffMs = Math.abs(d1.getTime() - d2.getTime());

      switch (unit) {
        case 'year':
          return Math.floor(diffMs / (1000 * 60 * 60 * 24 * 365));
        case 'month':
          return Math.floor(diffMs / (1000 * 60 * 60 * 24 * 30));
        case 'day':
          return Math.floor(diffMs / (1000 * 60 * 60 * 24));
        case 'hour':
          return Math.floor(diffMs / (1000 * 60 * 60));
        case 'minute':
          return Math.floor(diffMs / (1000 * 60));
        case 'second':
          return Math.floor(diffMs / 1000);
        default:
          return 0;
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error(TAG, `Failed to calculate date difference: ${errorMessage}`);
      throw new Error(errorMessage);
    }
  }

  /**
   * åˆ¤æ–­æ—¥æœŸæ˜¯å¦ä¸ºä»Šå¤?   * @param date æ—¥æœŸå¯¹è±¡æˆ–æ—¶é—´æˆ³
   * @returns æ˜¯å¦ä¸ºä»Šå¤?   */
  public static isToday(date: Date | number | string): boolean {
    try {
      const dateObj = DateUtil.parseDate(date);
      if (!dateObj) return false;

      const today = new Date();
      return dateObj.toDateString() === today.toDateString();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error(TAG, `Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}` instanceof Error ? `Failed to check if date is today: ${errorMessage}` : new Error(String(`Failed to check if date is today: ${errorMessage}`)))))));
      return false;
    }
  }

  /**
   * åˆ¤æ–­æ—¥æœŸæ˜¯å¦ä¸ºæ˜¨å¤?   * @param date æ—¥æœŸå¯¹è±¡æˆ–æ—¶é—´æˆ³
   * @returns æ˜¯å¦ä¸ºæ˜¨å¤?   */
  public static isYesterday(date: Date | number | string): boolean {
    try {
      const dateObj = DateUtil.parseDate(date);
      if (!dateObj) return false;

      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      return dateObj.toDateString() === yesterday.toDateString();
    } catch (error) {
      Logger.error(TAG, `Failed to check if date is yesterday: ${error}`);
      return false;
    }
  }

  /**
   * åˆ¤æ–­æ—¥æœŸæ˜¯å¦åœ¨æŒ‡å®šèŒƒå›´å†…
   * @param date è¦æ£€æŸ¥çš„æ—¥æœŸ
   * @param start å¼€å§‹æ—¥æœ?   * @param end ç»“æŸæ—¥æœŸ
   * @returns æ˜¯å¦åœ¨èŒƒå›´å†…
   */
  public static isBetween(date: Date | number | string, start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string instanceof Error ? start: Date | number | string, end: Date | number | string : new Error(String(start: Date | number | string, end: Date | number | string))))))): boolean {
    try {
      const dateObj = DateUtil.parseDate(date);
      const startObj = DateUtil.parseDate(start);
      const endObj = DateUtil.parseDate(end);

      if (!dateObj || !startObj || !endObj) return false;

      return DateUtil.compare(dateObj, startObj) >= 0 && DateUtil.compare(dateObj, endObj) <= 0;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error(TAG, `Failed to check if date is between range: ${errorMessage}`);
      return false;
    }
  }

  /**
   * è·å–æŒ‡å®šæœˆä»½çš„å¤©æ•?   * @param year å¹´ä»½
   * @param month æœˆä»½ï¼?-12ï¼?   * @returns å¤©æ•°
   */
  public static getDaysInMonth(year: number, month: number instanceof Error ? month: number : new Error(String(month: number instanceof Error ? month: number instanceof Error ? month: number : new Error(String(month: number : new Error(String(month: number instanceof Error ? month: number : new Error(String(month: number instanceof Error ? month: number instanceof Error ? month: number : new Error(String(month: number instanceof Error ? month: number instanceof Error ? month: number : new Error(String(month: number : new Error(String(month: number instanceof Error ? month: number : new Error(String(month: number : new Error(String(month: number instanceof Error ? month: number : new Error(String(month: number instanceof Error ? month: number instanceof Error ? month: number : new Error(String(month: number : new Error(String(month: number instanceof Error ? month: number : new Error(String(month: number))))))): number {
    try {
      return new Date(year, month, 0).getDate();
    } catch (error) {
      Logger.error(TAG, `Failed to get days in month: ${error}`);
      return 0;
    }
  }

  /**
   * è·å–æ—¶é—´æˆ³ï¼ˆç§’ï¼‰
   * @param date æ—¥æœŸå¯¹è±¡ï¼ˆå¯é€‰ï¼‰
   * @returns æ—¶é—´æˆ³ï¼ˆç§’ï¼‰
   */
  public static getTimestamp(date?: Date): number {
    return Math.floor((date ? date.getTime() : Date.now()) / 1000);
  }

  /**
   * è·å–æ¯«ç§’æ—¶é—´æˆ?   * @param date æ—¥æœŸå¯¹è±¡ï¼ˆå¯é€‰ï¼‰
   * @returns æ¯«ç§’æ—¶é—´æˆ?   */
  public static getMillisecondTimestamp(date?: Date): number {
    return date ? date.getTime() : Date.now();
  }

  /**
   * æ ¼å¼åŒ–æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
   * @param seconds ç§’æ•°
   * @returns æ ¼å¼åŒ–çš„æŒç»­æ—¶é—´
   */
  public static formatDuration(seconds: number): string {
    try {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);

      if (hours > 0) {
        return `${hours}:${DateUtil.padZero(minutes)}:${DateUtil.padZero(secs)}`;
      } else {
        return `${minutes}:${DateUtil.padZero(secs)}`;
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error(TAG, `Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}` instanceof Error ? `Failed to format duration: ${errorMessage}` : new Error(String(`Failed to format duration: ${errorMessage}`)))))));
      return '0:00';
    }
  }

  /**
   * è§£ææŒç»­æ—¶é—´å­—ç¬¦ä¸?   * @param durationStr æŒç»­æ—¶é—´å­—ç¬¦ä¸²ï¼ˆå¦?"1:30:45" æˆ?"45:30"ï¼?   * @returns æ€»ç§’æ•?   */
  public static parseDuration(durationStr: string): number {
    try {
      const parts = durationStr.split(':').map(p => parseInt(p));
      
      if (parts.length === 3) {
        return parts[0] * 3600 + parts[1] * 60 + parts[2];
      } else if (parts.length === 2) {
        return parts[0] * 60 + parts[1];
      } else {
        throw new Error('Invalid duration format');
      }
    } catch (error) {
      Logger.error(TAG, `Failed to parse duration: ${error}`);
      return 0;
    }
  }

  // å·¥å…·æ–¹æ³•ï¼šæ•°å­—è¡¥é›?  private static padZero(num: number): string {
    return num < 10 ? `0${num}` : num.toString();
  }

  // å·¥å…·æ–¹æ³•ï¼šè§£ææ—¥æœ?  private static parseDate(date: Date | number | string): Date | null {
    if (date instanceof Date) {
      return isNaN(date.getTime()) ? null : date;
    } else if (typeof date === 'number') {
      const d = new Date(date);
      return isNaN(d.getTime()) ? null : d;
    } else if (typeof date === 'string') {
      return DateUtil.parse(date);
    }
    return null;
  }
}


