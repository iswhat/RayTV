// TypeSafeUtil - ç±»å‹å®‰å…¨å·¥å…·ç±?
// æä¾›ç»Ÿä¸€çš„ç±»å‹æ£€æŸ¥ã€è½¬æ¢å’Œé”™è¯¯å¤„ç†æ–¹æ³•

/**
 * ç±»å‹å®‰å…¨å·¥å…·ç±?
 */
export default class TypeSafeUtil {
  /**
   * å®‰å…¨åœ°å°†å€¼è½¬æ¢ä¸ºå¯¹è±¡
   * @param value è¦è½¬æ¢çš„å€?
   * @returns è½¬æ¢åçš„å¯¹è±¡ï¼Œå¤±è´¥æ—¶è¿”å›ç©ºå¯¹è±?
   */
  public static asObject(value: Record<string, string | number | boolean | null>): Record<string, unknown> {
    if (value === null || value === undefined) {
      return {};
    }
    if (typeof value === 'object') {
      return value as Record<string, unknown>;
    }
    try {
      return JSON.parse(JSON.stringify(value)) as Record<string, unknown>;
    } catch {
      return {};
    }
  }

  /**
   * å®‰å…¨åœ°å°†å€¼è½¬æ¢ä¸ºæ•°ç»„
   * @param value è¦è½¬æ¢çš„å€?
   * @returns è½¬æ¢åçš„æ•°ç»„ï¼Œå¤±è´¥æ—¶è¿”å›ç©ºæ•°ç»?
   */
  public static asArray<T>(value: Record<string, string | number | boolean | null>): T[] {
    if (Array.isArray(value)) {
      return value as T[];
    }
    if (value === null || value === undefined) {
      return [];
    }
    return [value as T];
  }

  /**
   * å®‰å…¨åœ°å°†å€¼è½¬æ¢ä¸ºå­—ç¬¦ä¸?
   * @param value è¦è½¬æ¢çš„å€?
   * @param defaultValue é»˜è®¤å€?
   * @returns è½¬æ¢åçš„å­—ç¬¦ä¸?
   */
  public static asString(value: Record<string, string | number | boolean | null>, defaultValue: string = ''): string {
    if (value === null || value === undefined) {
      return defaultValue;
    }
    return String(value);
  }

  /**
   * å®‰å…¨åœ°å°†å€¼è½¬æ¢ä¸ºæ•°å­—
   * @param value è¦è½¬æ¢çš„å€?
   * @param defaultValue é»˜è®¤å€?
   * @returns è½¬æ¢åçš„æ•°å­—
   */
  public static asNumber(value: Record<string, string | number | boolean | null>, defaultValue: number = 0): number {
    if (value === null || value === undefined) {
      return defaultValue;
    }
    const num = Number(value);
    return isNaN(num) ? defaultValue : num;
  }

  /**
   * å®‰å…¨åœ°å°†å€¼è½¬æ¢ä¸ºå¸ƒå°”å€?
   * @param value è¦è½¬æ¢çš„å€?
   * @returns è½¬æ¢åçš„å¸ƒå°”å€?
   */
  public static asBoolean(value: Record<string, string | number | boolean | null>): boolean {
    if (value === null || value === undefined) {
      return false;
    }
    if (typeof value === 'boolean') {
      return value;
    }
    if (typeof value === 'string') {
      return value.toLowerCase() === 'true' || value === '1';
    }
    return Boolean(value);
  }

  /**
   * å®‰å…¨åœ°è®¿é—®å¯¹è±¡å±æ€?
   * @param obj å¯¹è±¡
   * @param key å±æ€§å
   * @param defaultValue é»˜è®¤å€?
   * @returns å±æ€§å€¼æˆ–é»˜è®¤å€?
   */
  public static safeGet<T>(
    obj: Record<string, string | number | boolean | null>,
    key: string | number,
    defaultValue: T
  ): T {
    const safeObj = TypeSafeUtil.asObject(obj);
    const value = safeObj[key];
    return value !== undefined ? (value as T) : defaultValue;
  }

  /**
   * å®‰å…¨åœ°è®¾ç½®å¯¹è±¡å±æ€?
   * @param obj å¯¹è±¡
   * @param key å±æ€§å
   * @param value å±æ€§å€?
   * @returns æ›´æ–°åçš„å¯¹è±¡
   */
  public static safeSet<T>(
    obj: T,
    key: string | number,
    value: Record<string, string | number | boolean | null>
  ): T {
    const safeObj = TypeSafeUtil.asObject(obj);
    safeObj[key] = value;
    return safeObj as T;
  }

  /**
   * åˆ›å»ºå®‰å…¨çš„é”™è¯¯å¯¹è±?
   * @param message é”™è¯¯æ¶ˆæ¯
   * @param cause é”™è¯¯åŸå› 
   * @returns Errorå¯¹è±¡
   */
  public static safeError(message: string, cause?: Record<string, string | number | boolean | null>): Error {
    const error = new Error(message);
    if (cause) {
      // ä½¿ç”¨å¯¹è±¡å±•å¼€æ“ä½œç¬¦å®‰å…¨åœ°è®¾ç½®causeå±æ€§ï¼Œé¿å…ä½¿ç”¨anyç±»å‹
      Object.assign(error, { cause });
    }
    return error;
  }

  /**
   * å®‰å…¨åœ°æ£€æŸ¥å¯¹è±¡æ˜¯å¦æœ‰æŒ‡å®šå±æ€?
   * @param obj å¯¹è±¡
   * @param key å±æ€§å
   * @returns æ˜¯å¦æœ‰è¯¥å±æ€?
   */
  public static hasProperty(obj: Record<string, string | number | boolean | null>, key: string | number): boolean {
    if (obj === null || obj === undefined) {
      return false;
    }
    if (typeof obj !== 'object') {
      return false;
    }
    return Object.hasOwnProperty.call(obj, key);
  }

  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰é”®
   * @param obj å¯¹è±¡
   * @returns é”®æ•°ç»?
   */
  public static getObjectKeys(obj: Record<string, string | number | boolean | null>): string[] {
    if (obj === null || obj === undefined || typeof obj !== 'object') {
      return [];
    }
    return Object.keys(obj);
  }

  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰å€?
   * @param obj å¯¹è±¡
   * @returns å€¼æ•°ç»?
   */
  public static getObjectValues<T>(obj: Record<string, string | number | boolean | null>): T[] {
    if (obj === null || obj === undefined || typeof obj !== 'object') {
      return [];
    }
    return Object.values(obj) as T[];
  }

  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰é”®å€¼å¯¹
   * @param obj å¯¹è±¡
   * @returns é”®å€¼å¯¹æ•°ç»„
   */
  public static getObjectEntries<T>(
    obj: Record<string, string | number | boolean | null>
  ): [string, T][] {
    if (obj === null || obj === undefined || typeof obj !== 'object') {
      return [];
    }
    return Object.entries(obj) as [string, T][];
  }

  /**
   * å®‰å…¨åœ°åˆå¹¶å¤šä¸ªå¯¹è±?
   * @param target ç›®æ ‡å¯¹è±¡
   * @param sources æºå¯¹è±?
   * @returns åˆå¹¶åçš„å¯¹è±¡
   */
  public static mergeObjects<T extends Record<string, unknown>>(
    target: T,
    ...sources: Record<string, unknown>[]
  ): T {
    const result: Record<string, string | number | boolean | null> = { ... };
    
    sources.forEach(source => {
      const safeSource = TypeSafeUtil.asObject(source);
      Object.keys(safeSource).forEach(key => {
        const sourceValue = safeSource[key];
        const targetValue = result[key];
        
        // å¦‚æœä¸¤è¾¹éƒ½æ˜¯å¯¹è±¡ï¼Œé€’å½’åˆå¹¶
        if (typeof sourceValue === 'object' && 
            sourceValue !== null && 
            !Array.isArray(sourceValue) &&
            typeof targetValue === 'object' &&
            targetValue !== null &&
            !Array.isArray(targetValue)) {
          result[key] = TypeSafeUtil.mergeObjects(
            targetValue as Record<string, unknown>,
            sourceValue as Record<string, unknown>
          );
        } else {
          result[key] = sourceValue;
        }
      });
    });
    
    return result as T;
  }

  /**
   * å®‰å…¨åœ°æ·±æ‹·è´å¯¹è±¡
   * @param value è¦æ‹·è´çš„å€?
   * @returns æ‹·è´åçš„æ–°å€?
   */
  public static deepClone<T>(value: T): T {
    if (value === null || value === undefined) {
      return value;
    }
    
    // å¤„ç†åŸºæœ¬ç±»å‹
    if (typeof value !== 'object') {
      return value;
    }
    
    // å¤„ç†æ—¥æœŸ
    if (value instanceof Date) {
      return new Date(value.getTime()) as T;
    }
    
    // å¤„ç†æ•°ç»„
    if (Array.isArray(value)) {
      return value.map(item => TypeSafeUtil.deepClone(item)) as T;
    }
    
    // å¤„ç†å¯¹è±¡
    const cloned: Record<string, unknown> = {};
    Object.keys(value as Record<string, unknown>).forEach(key => {
      cloned[key] = TypeSafeUtil.deepClone(
        (value as Record<string, unknown>)[key]
      );
    });
    
    return cloned as T;
  }

  /**
   * ç±»å‹å®ˆå«ï¼šæ£€æŸ¥å€¼æ˜¯å¦ä¸ºå¯¹è±¡
   * @param value è¦æ£€æŸ¥çš„å€?
   * @returns æ˜¯å¦ä¸ºå¯¹è±?
   */
  public static isObject(value: Record<string, string | number | boolean | null>): value is Record<string, unknown> {
    return value !== null && typeof value === 'object' && !Array.isArray(value);
  }

  /**
   * ç±»å‹å®ˆå«ï¼šæ£€æŸ¥å€¼æ˜¯å¦ä¸ºæ•°ç»„
   * @param value è¦æ£€æŸ¥çš„å€?
   * @returns æ˜¯å¦ä¸ºæ•°ç»?
   */
  public static isArray<T>(value: Record<string, string | number | boolean | null>): value is T[] {
    return Array.isArray(value);
  }

  /**
   * ç±»å‹å®ˆå«ï¼šæ£€æŸ¥å€¼æ˜¯å¦ä¸ºå‡½æ•°
   * @param value è¦æ£€æŸ¥çš„å€?
   * @returns æ˜¯å¦ä¸ºå‡½æ•?
   */
  public static isFunction(value: Record<string, string | number | boolean | null>): value is Function {
    return typeof value === 'function';
  }

  /**
   * å®‰å…¨åœ°è¿›è¡Œç±»å‹æ–­è¨€
   * @param value è¦æ–­è¨€çš„å€?
   * @param typeGuard ç±»å‹å®ˆå«å‡½æ•°
   * @param defaultValue é»˜è®¤å€?
   * @returns æ–­è¨€åçš„å€¼æˆ–é»˜è®¤å€?
   */
  public static safeAssert<T>(
    value: Record<string, string | number | boolean | null>,
    typeGuard: (v: Record<string, string | number | boolean | null>) => v is T,
    defaultValue: T
  ): T {
    return typeGuard(value) ? value : defaultValue;
  }

  /**
   * å®‰å…¨åœ°æ‰§è¡Œå‡½æ•?
   * @param fn è¦æ‰§è¡Œçš„å‡½æ•°
   * @param defaultValue é»˜è®¤å€?
   * @param args å‡½æ•°å‚æ•°
   * @returns å‡½æ•°æ‰§è¡Œç»“æœæˆ–é»˜è®¤å€?
   */
  public static safeExecute<T>(
    fn: (...args: Array<string | number | boolean | object | null>) => T,
    defaultValue: T,
    ...args: Array<string | number | boolean | object | null>
  ): T {
    try {
      return TypeSafeUtil.isFunction(fn) ? fn(...args) : defaultValue;
    } catch {
      return defaultValue;
    }
  }
}

