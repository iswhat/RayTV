// é€šç”¨å·¥å…·ç±?// æä¾›å„ç§è¾…åŠ©å‡½æ•°

/**
 * é€šç”¨å·¥å…·ç±? */
export class CommonUtil {
  private static instance: CommonUtil;
  
  private constructor() {
    // åˆå§‹åŒ?  }
  
  /**
   * è·å–CommonUtilå•ä¾‹å®ä¾‹
   */
  public static getInstance(): CommonUtil {
    if (!CommonUtil.instance) {
      CommonUtil.instance = new CommonUtil();
    }
    return CommonUtil.instance;
  }
  
  /**
   * æ£€æŸ¥å¯¹è±¡æ˜¯å¦åŒ…å«æŒ‡å®šå±æ€?   * æ›¿ä»£Object.prototype.hasOwnProperty.call
   */
  private hasOwnProperty<T extends object>(obj: T, key: string): boolean {
    return Object.getOwnPropertyNames(obj).includes(key);
  }

  /**
   * è·å–å¯¹è±¡çš„æ‰€æœ‰é”®
   * æ›¿ä»£Object.keysï¼Œå…¼å®¹ArkTSè¯­æ³•
   */
  private getObjectKeys<T extends object>(obj: T): string[] {
    const keys: string[] = [];
    for (const key in obj) {
      if (typeof obj === 'object' && obj !== null && this.hasOwnProperty(obj, key)) {
        keys.push(key);
      }
    }
    return keys;
  }

  /**
   * å®‰å…¨åœ°è·å–å¯¹è±¡å±æ€§å€?   * @param obj - è¦è·å–å±æ€§çš„å¯¹è±¡
   * @param key - å±æ€§é”®å?   * @returns å±æ€§å€¼ï¼Œå¦‚æœå±æ€§ä¸å­˜åœ¨åˆ™è¿”å›undefined
   */
  private getPropertyValue<T extends object>(obj: T, key: string): Record<string, string | number | boolean | null> {
    if (!obj || typeof obj !== 'object') {
      return undefined;
    }
    
    // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼?    if (this.hasOwnProperty(obj, key)) {
      const safeObj = obj as Record<string, unknown>;
      return safeObj[key];
    }
    
    return undefined;
  }
  
  /**
   * ç”Ÿæˆå”¯ä¸€ID
   * @param prefix IDå‰ç¼€
   * @returns å”¯ä¸€IDå­—ç¬¦ä¸?   */
  public generateUniqueId(prefix: string = 'id'): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `${prefix}_${timestamp}_${random}`;
  }
  
  /**
   * æ·±æ‹·è´å¯¹è±?   * @param obj è¦æ‹·è´çš„å¯¹è±¡
   * @returns æ‹·è´åçš„æ–°å¯¹è±?   */
  public deepClone<T>(obj: T): T {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }
    
    if (obj instanceof Date) {
      return new Date(obj.getTime()) as T;
    }
    
    if (obj instanceof Array) {
      const clonedArray = [];
      for (const item of obj) {
        clonedArray.push(this.deepClone(item));
      }
      return clonedArray as T;
    }
    
    if (obj instanceof Object) {
      const clonedObj: Record<string, unknown> = {};
      // ä½¿ç”¨getObjectKeysæ›¿ä»£Object.keys
      const keys = this.getObjectKeys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (this.hasOwnProperty(obj, key)) {
          // ä½¿ç”¨ç±»å‹å®‰å…¨çš„å±æ€§è®¿é—®æ–¹å¼ï¼Œé¿å…å­—æ®µç´¢å¼•è®¿é—®
          const propertyValue = this.getPropertyValue(obj, key);
          clonedObj[key] = this.deepClone(propertyValue);
        }
      }
      return clonedObj as T;
    }
    
    return obj;
  }
  
  /**
   * é˜²æŠ–å‡½æ•°
   * @param func è¦é˜²æŠ–çš„å‡½æ•°
   * @param delay å»¶è¿Ÿæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
   * @returns é˜²æŠ–åçš„å‡½æ•°
   */
  public debounce<T extends (...args: Array<string | number | boolean | object | null>) => string | number | boolean | object | null>(func: T, delay: number): (...args: Parameters<T>) => void {
    let timeoutId: number | undefined;
    
    return (...args: Parameters<T>) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        // ArkTSå…¼å®¹ï¼šä½¿ç”¨ç›´æ¥è°ƒç”¨æ›¿ä»£apply
        func(...args);
      }, delay);
    };
  }
  
  /**
   * èŠ‚æµå‡½æ•°
   * @param func è¦èŠ‚æµçš„å‡½æ•°
   * @param limit æ—¶é—´é™åˆ¶ï¼ˆæ¯«ç§’ï¼‰
   * @returns èŠ‚æµåçš„å‡½æ•°
   */
  public throttle<T extends (...args: Array<string | number | boolean | object | null>) => string | number | boolean | object | null>(func: T, limit: number): (...args: Parameters<T>) => void {
    let inThrottle: boolean = false;
    
    return (...args: Parameters<T>) => {
      if (!inThrottle) {
        // ArkTSå…¼å®¹ï¼šä½¿ç”¨ç›´æ¥è°ƒç”¨æ›¿ä»£apply
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  
  /**
   * æ ¼å¼åŒ–æ—¶é—?   * @param date æ—¥æœŸå¯¹è±¡æˆ–æ—¶é—´æˆ³
   * @param format æ ¼å¼åŒ–å­—ç¬¦ä¸²
   * @returns æ ¼å¼åŒ–åçš„æ—¶é—´å­—ç¬¦ä¸²
   */
  public formatDate(date: Date | number | string, format: string = 'YYYY-MM-DD HH:mm:ss'): string {
    const d = new Date(date);
    
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    const hours = String(d.getHours()).padStart(2, '0');
    const minutes = String(d.getMinutes()).padStart(2, '0');
    const seconds = String(d.getSeconds()).padStart(2, '0');
    
    return format
      .replace('YYYY', String(year))
      .replace('MM', month)
      .replace('DD', day)
      .replace('HH', hours)
      .replace('mm', minutes)
      .replace('ss', seconds);
  }
  
  /**
   * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°?   * @param bytes å­—èŠ‚æ•?   * @returns æ ¼å¼åŒ–åçš„å¤§å°å­—ç¬¦ä¸²
   */
  public formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 B';
    
    const sizes: string[] = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    
    return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;
  }
  
  /**
   * æ ¼å¼åŒ–æ’­æ”¾æ—¶é•?   * @param seconds ç§’æ•°
   * @returns æ ¼å¼åŒ–åçš„æ—¶é•¿å­—ç¬¦ä¸²
   */
  public formatDuration(seconds: number): string {
    if (isNaN(seconds) || seconds < 0) {
      return '00:00';
    }
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    
    if (hours > 0) {
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    } else {
      return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }
  }
  
  /**
   * æˆªæ–­æ–‡æœ¬
   * @param text æ–‡æœ¬å†…å®¹
   * @param maxLength æœ€å¤§é•¿åº?   * @param suffix åç¼€
   * @returns æˆªæ–­åçš„æ–‡æœ¬
   */
  public truncateText(text: string, maxLength: number, suffix: string = '...'): string {
    if (!text || text.length <= maxLength) {
      return text;
    }
    
    return text.substring(0, maxLength - suffix.length) + suffix;
  }
  
  /**
   * éªŒè¯é‚®ç®±æ ¼å¼
   * @param email é‚®ç®±åœ°å€
   * @returns æ˜¯å¦ä¸ºæœ‰æ•ˆé‚®ç®?   */
  public isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
  
  /**
   * éªŒè¯æ‰‹æœºå·æ ¼å¼?   * @param phone æ‰‹æœºå·ç 
   * @returns æ˜¯å¦ä¸ºæœ‰æ•ˆæ‰‹æœºå·
   */
  public isValidPhone(phone: string): boolean {
    // ç®€å•çš„ä¸­å›½æ‰‹æœºå·éªŒè¯?    const phoneRegex = /^1[3-9]\d{9}$/;
    return phoneRegex.test(phone);
  }
  
  /**
   * éªŒè¯å¯†ç å¼ºåº¦
   * @param password å¯†ç 
   * @returns å¯†ç å¼ºåº¦ï¼?-å¼±ï¼Œ1-ä¸­ï¼Œ2-å¼?   */
  public checkPasswordStrength(password: string): 0 | 1 | 2 {
    let strength = 0;
    
    // é•¿åº¦æ£€æŸ?    if (password.length >= 8) strength++;
    
    // åŒ…å«æ•°å­—
    if (/\d/.test(password)) strength++;
    
    // åŒ…å«å°å†™å­—æ¯
    if (/[a-z]/.test(password)) strength++;
    
    // åŒ…å«å¤§å†™å­—æ¯
    if (/[A-Z]/.test(password)) strength++;
    
    // åŒ…å«ç‰¹æ®Šå­—ç¬¦
    if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) strength++;
    
    if (strength < 3) return 0;
    if (strength < 5) return 1;
    return 2;
  }
  
  /**
   * éšæœºæ‰“ä¹±æ•°ç»„
   * @param array è¦æ‰“ä¹±çš„æ•°ç»„
   * @returns æ‰“ä¹±åçš„æ–°æ•°ç»?   */
  public shuffleArray<T>(array: T[]): T[] {
    // ä½¿ç”¨sliceæ›¿ä»£spreadæ“ä½œç¬?    const shuffled = array.slice();
    
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    
    return shuffled;
  }
  
  /**
   * æ•°ç»„å»é‡
   * @param array è¦å»é‡çš„æ•°ç»„
   * @param key ç”¨äºæ¯”è¾ƒçš„é”®ï¼ˆå¯¹è±¡æ•°ç»„ï¼‰
   * @returns å»é‡åçš„æ–°æ•°ç»?   */
  public uniqueArray<T>(array: T[], key?: keyof T): T[] {
    if (!array || array.length === 0) {
      return [];
    }
    
    if (key) {
      // å¯¹è±¡æ•°ç»„å»é‡
      const seen = new Set();
      return array.filter(item => {
        const value = item[key];
        const isDuplicate = seen.has(value);
        seen.add(value);
        return !isDuplicate;
      });
    } else {
      // åŸå§‹ç±»å‹æ•°ç»„å»é‡
      return Array.from(new Set(array));
    }
  }
  
  /**
   * å»¶è¿Ÿæ‰§è¡Œ
   * @param ms å»¶è¿Ÿæ¯«ç§’æ•?   * @returns Promise
   */
  public delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  /**
   * é‡è¯•å‡½æ•°
   * @param fn è¦é‡è¯•çš„å‡½æ•°
   * @param retries é‡è¯•æ¬¡æ•°
   * @param delay é‡è¯•é—´éš”ï¼ˆæ¯«ç§’ï¼‰
   * @returns å‡½æ•°æ‰§è¡Œç»“æœ
   */
  public async retry<T>(fn: () => Promise<T>, retries: number = 3, delay: number = 1000): Promise<T> {
    try {
      return await fn();
    } catch (error) {
      if (retries <= 0) {
        throw error;
      }
      
      await this.delay(delay);
      return this.retry(fn, retries - 1, delay * 2);
    }
  }
  
  /**
   * è·å–å¯¹è±¡å·®å¼‚
   * @param obj1 å¯¹è±¡1
   * @param obj2 å¯¹è±¡2
   * @returns å·®å¼‚å¯¹è±¡
   */
  public getObjectDiff(obj1: Record<string, unknown>, obj2: Record<string, unknown>): Record<string, unknown> {
    const diff: Record<string, unknown> = {};
    
    // ä½¿ç”¨getObjectKeysæ›¿ä»£Object.keys
    const keys1 = this.getObjectKeys(obj1);
    for (let i = 0; i < keys1.length; i++) {
      const key = keys1[i];
      // å®‰å…¨æ£€æŸ¥å±æ€§æ˜¯å¦å­˜åœ¨ï¼Œé¿å…ä½¿ç”¨Object.prototype.hasOwnProperty.call
      if (typeof obj1 === 'object' && obj1 !== null && Object.keys(obj1).includes(key)) {
        // å®‰å…¨æ£€æŸ¥å±æ€§æ˜¯å¦å­˜åœ¨ï¼Œé¿å…ä½¿ç”¨Object.prototype.hasOwnProperty.call
            if (typeof obj2 === 'object' && obj2 !== null && Object.keys(obj2).includes(key)) {
          if (obj1[key] !== obj2[key]) {
            if (typeof obj1[key] === 'object' && typeof obj2[key] === 'object') {
              const nestedDiff = this.getObjectDiff(obj1[key], obj2[key]);
              if (this.getObjectKeys(nestedDiff).length > 0) {
                diff[key] = nestedDiff;
              }
            } else {
              diff[key] = obj2[key];
            }
          }
        } else {
          diff[key] = undefined;
        }
      }
    }
    
    // ä½¿ç”¨getObjectKeysæ›¿ä»£Object.keys
    const keys2 = this.getObjectKeys(obj2);
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      // å®‰å…¨æ£€æŸ¥å±æ€§æ˜¯å¦å­˜åœ¨ï¼Œé¿å…ä½¿ç”¨Object.prototype.hasOwnProperty.call
      if (typeof obj1 === 'object' && obj1 !== null && typeof obj2 === 'object' && obj2 !== null && 
          Object.keys(obj2).includes(key) && !Object.keys(obj1).includes(key)) {
        diff[key] = obj2[key];
      }
    }
    
    return diff;
  }
  
  /**
   * åˆå¹¶å¯¹è±¡
   * @param target ç›®æ ‡å¯¹è±¡
   * @param sources æºå¯¹è±?   * @returns åˆå¹¶åçš„å¯¹è±¡
   */
  public mergeObjects<T extends Record<string, unknown>>(target: T, ...sources: Record<string, unknown>[]): T {
    if (!sources.length) return target;
    
    const source = sources.shift();
    
    if (target && source && (typeof target === 'object' && typeof source === 'object')) {
      // ä½¿ç”¨getObjectKeysæ›¿ä»£Object.keys
      const keys = this.getObjectKeys(source);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        // å®‰å…¨æ£€æŸ¥å±æ€§æ˜¯å¦å­˜åœ?        if (typeof source === 'object' && source !== null && this.hasOwnProperty(source, key)) {
          if (source[key] && typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key])) {
            if (!target[key]) {
              target[key] = {};
            } else if (typeof target[key] !== 'object' || target[key] === null || Array.isArray(target[key])) {
              target[key] = {};
            }
            this.mergeObjects(target[key] as Record<string, unknown>, source[key] as Record<string, unknown>);
          } else {
            target[key] = source[key];
          }
        }
      }
    }
    
    // é€’å½’åˆå¹¶åç»­æºå¯¹è±?    if (sources.length > 0) {
      return this.mergeObjects(target, ...sources);
    }
    
    return target;
  }
  
  /**
   * ç”Ÿæˆéšæœºé¢œè‰²
   * @param alpha é€æ˜åº?   * @returns é¢œè‰²å­—ç¬¦ä¸?   */
  public generateRandomColor(alpha: number = 1): string {
    const r = Math.floor(Math.random() * 256);
    const g = Math.floor(Math.random() * 256);
    const b = Math.floor(Math.random() * 256);
    
    if (alpha === 1) {
      return `rgb(${r}, ${g}, ${b})`;
    } else {
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
  }
  
  /**
   * åå…­è¿›åˆ¶é¢œè‰²è½¬RGB
   * @param hex åå…­è¿›åˆ¶é¢œè‰²
   * @returns RGBå¯¹è±¡
   */
  public hexToRgb(hex: string): { r: number; g: number; b: number } | null {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }
  
  /**
   * RGBé¢œè‰²è½¬åå…­è¿›åˆ?   * @param r çº¢è‰²é€šé“
   * @param g ç»¿è‰²é€šé“
   * @param b è“è‰²é€šé“
   * @returns åå…­è¿›åˆ¶é¢œè‰²å­—ç¬¦ä¸?   */
  public rgbToHex(r: number, g: number, b: number): string {
    return `#${[r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }).join('')}`;
  }
  
  /**
   * è®¡ç®—æ–‡æœ¬ç›¸ä¼¼åº¦ï¼ˆLevenshteinè·ç¦»ï¼?   * @param str1 æ–‡æœ¬1
   * @param str2 æ–‡æœ¬2
   * @returns ç›¸ä¼¼åº¦ï¼ˆ0-1ï¼?   */
  public calculateSimilarity(str1: string, str2: string): number {
    if (str1 === str2) return 1;
    
    const len1 = str1.length;
    const len2 = str2.length;
    
    if (len1 === 0 || len2 === 0) return 0;
    
    const matrix: number[][] = [];
    
    // åˆå§‹åŒ–çŸ©é˜?    for (let i = 0; i <= len2; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= len1; j++) {
      matrix[0][j] = j;
    }
    
    // å¡«å……çŸ©é˜µ
    for (let i = 1; i <= len2; i++) {
      for (let j = 1; j <= len1; j++) {
        const cost = str1[j - 1] === str2[i - 1] ? 0 : 1;
        matrix[i][j] = Math.min(
          matrix[i - 1][j] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j - 1] + cost
        );
      }
    }
    
    // è®¡ç®—ç›¸ä¼¼åº?    const distance = matrix[len2][len1];
    const maxLen = Math.max(len1, len2);
    return 1 - distance / maxLen;
  }
  
  /**
   * è§£æURLå‚æ•°
   * @param url URLå­—ç¬¦ä¸?   * @returns å‚æ•°å¯¹è±¡
   */
  public parseUrlParams(url: string): Record<string, string> {
    const params: Record<string, string> = {};
    try {
      // ä½¿ç”¨è‡ªå®šä¹‰URLè§£æé€»è¾‘æ›¿ä»£new URL
      const queryIndex = url.indexOf('?');
      if (queryIndex !== -1) {
        const queryString = url.slice(queryIndex + 1);
        queryString.split('&').forEach(param => {
          const [key, value] = param.split('=').map(decodeURIComponent);
          if (key) {
            params[key] = value || '';
          }
        });
      }
    } catch (error) {
      console.error('Failed to parse URL parameters:', error);
    }
    
    return params;
  }
  
  /**
   * æ„å»ºURL
   * @param baseUrl åŸºç¡€URL
   * @param params æŸ¥è¯¢å‚æ•°
   * @returns æ„å»ºåçš„URL
   */
  public buildUrl(baseUrl: string, params?: Record<string, unknown>): string {
    if (!params || this.getObjectKeys(params).length === 0) {
      return baseUrl;
    }
    
    const queryString = Object.entries(params)
      .filter(([_, value]) => value !== undefined && value !== null)
      .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`)
      .join('&');
    
    const hasQuery = baseUrl.includes('?');
    return `${baseUrl}${hasQuery ? '&' : '?'}${queryString}`;
  }
  
  /**
   * æ£€æŸ¥å€¼æ˜¯å¦ä¸ºç©?   * @param value è¦æ£€æŸ¥çš„å€?   * @returns æ˜¯å¦ä¸ºç©º
   */
  public isEmpty(value: Record<string, string | number | boolean | null>): boolean {
    if (value === null || value === undefined) return true;
    if (typeof value === 'string') return value.trim() === '';
    if (Array.isArray(value)) return value.length === 0;
    if (typeof value === 'object') return this.getObjectKeys(value).length === 0;
    return false;
  }
  
  /**
   * å®‰å…¨åœ°è·å–åµŒå¥—å±æ€?   * @param obj å¯¹è±¡
   * @param path å±æ€§è·¯å¾?   * @param defaultValue é»˜è®¤å€?   * @returns å±æ€§å€¼æˆ–é»˜è®¤å€?   */
  public getNestedProperty<T>(obj: Record<string, string | number | boolean | null>, path: string, defaultValue: T): T {
    const keys = path.split('.');
    let result = obj;
    
    for (const key of keys) {
      if (result === null || result === undefined || (typeof result !== 'object' && !Array.isArray(result))) {
        return defaultValue;
      }
      result = (result as Record<string, unknown>)[key];
    }
    
    return result !== undefined && result !== null ? result as T : defaultValue;
  }
  
  /**
   * å®‰å…¨åœ°è®¾ç½®åµŒå¥—å±æ€?   * @param obj å¯¹è±¡
   * @param path å±æ€§è·¯å¾?   * @param value å±æ€§å€?   * @returns æ˜¯å¦è®¾ç½®æˆåŠŸ
   */
  public setNestedProperty(obj: Record<string, unknown>, path: string, value: Record<string, string | number | boolean | null>): boolean {
    if (!obj || typeof obj !== 'object') return false;
    
    const keys = path.split('.');
    let current: Record<string, unknown> = obj;
    
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      
      if (current[key] === undefined) {
        current[key] = {};
      } else if (typeof current[key] !== 'object') {
        return false;
      }
      
      current = current[key];
    }
    
    current[keys[keys.length - 1]] = value;
    return true;
  }
  
  /**
   * è®¡ç®—æ•°ç»„ä¸­å…ƒç´ å‡ºç°æ¬¡æ•?   * @param array æ•°ç»„
   * @returns å…ƒç´ å‡ºç°æ¬¡æ•°æ˜ å°„
   */
  public countOccurrences<T>(array: T[]): Record<string, number> {
    const counts: Record<string, number> = {};
    
    array.forEach(item => {
      const key = String(item);
      counts[key] = (counts[key] || 0) + 1;
    });
    
    return counts;
  }
  
  /**
   * æŒ‰å±æ€§å¯¹å¯¹è±¡æ•°ç»„è¿›è¡Œæ’åº
   * @param array æ•°ç»„
   * @param key æ’åºé”?   * @param order æ’åºé¡ºåº
   * @returns æ’åºåçš„æ•°ç»„
   */
  public sortByProperty<T>(array: T[], key: keyof T, order: 'asc' | 'desc' = 'asc'): T[] {
    return [...array].sort((a, b) => {
      const valueA = a[key];
      const valueB = b[key];
      
      if (valueA < valueB) return order === 'asc' ? -1 : 1;
      if (valueA > valueB) return order === 'asc' ? 1 : -1;
      return 0;
    });
  }
  
  /**
   * åˆ†ç»„å¯¹è±¡æ•°ç»„
   * @param array æ•°ç»„
   * @param key åˆ†ç»„é”®æˆ–åˆ†ç»„å‡½æ•°
   * @returns åˆ†ç»„åçš„æ˜ å°„
   */
  public groupBy<T>(array: T[], key: keyof T | ((item: T) => string)): Record<string, T[]> {
    const groups: Record<string, T[]> = {};
    
    array.forEach(item => {
      const groupKey = typeof key === 'function' ? key(item) : String(item[key]);
      
      if (!groups[groupKey]) {
        groups[groupKey] = [];
      }
      
      groups[groupKey].push(item);
    });
    
    return groups;
  }
  
  /**
   * ä»æ•°ç»„ä¸­æå–å”¯ä¸€çš„å€¼åˆ—è¡?   * @param array å¯¹è±¡æ•°ç»„
   * @param key å±æ€§é”®
   * @returns å”¯ä¸€å€¼æ•°ç»?   */
  public extractUniqueValues<T, K extends keyof T>(array: T[], key: K): T[K][] {
    const values = array.map(item => item[key]);
    return this.uniqueArray(values);
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºæ•°å­—
   * @param value è¦æ£€æŸ¥çš„å€?   * @returns æ˜¯å¦ä¸ºæ•°å­?   */
  public isNumber(value: Record<string, string | number | boolean | null>): boolean {
    return typeof value === 'number' && !isNaN(value);
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºæ•´æ•°
   * @param value è¦æ£€æŸ¥çš„å€?   * @returns æ˜¯å¦ä¸ºæ•´æ•?   */
  public isInteger(value: Record<string, string | number | boolean | null>): boolean {
    return Number.isInteger(value);
  }
  
  /**
   * é™åˆ¶æ•°å­—åœ¨æŒ‡å®šèŒƒå›´å†…
   * @param value è¦é™åˆ¶çš„æ•°å­—
   * @param min æœ€å°å€?   * @param max æœ€å¤§å€?   * @returns é™åˆ¶åçš„æ•°å­—
   */
  public clamp(value: number, min: number, max: number): number {
    return Math.min(Math.max(value, min), max);
  }
  
  /**
   * çº¿æ€§æ’å€?   * @param start èµ·å§‹å€?   * @param end ç»“æŸå€?   * @param t æ’å€¼å› å­ï¼ˆ0-1ï¼?   * @returns æ’å€¼ç»“æ?   */
  public lerp(start: number, end: number, t: number): number {
    const clampedT = this.clamp(t, 0, 1);
    return start + (end - start) * clampedT;
  }
}

// å¯¼å‡ºé€šç”¨å·¥å…·å•ä¾‹
export const commonUtil = CommonUtil.getInstance();
