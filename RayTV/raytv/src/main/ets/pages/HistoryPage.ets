import { ScrollView, Text, Button, List, ListItem, Image, LoadingProgress, Empty, Flex, Tag, Checkbox, Switch, Stack, ProgressBar, Blank, BarState } from '@kit.ArkUI';
import { AppNavigator, PageRoute } from '../navigation/AppNavigator';
import Logger from '../common/util/Logger';
import { historyService, HistoryItem } from '../service/media/HistoryService';
import { mediaService, MediaItem, MediaType } from '../service/media/MediaService';

/**
 * å†å²è®°å½•é¡µé¢ç»„ä»¶
 * å®ç°æ’­æ”¾å†å²çš„å±•ç¤ºã€ç®¡ç†ã€ç¼–è¾‘å’Œæ¸…ç©ºç­‰åŠŸèƒ½
 */
@Component
struct HistoryPage {
  private readonly TAG: string = 'HistoryPage';
  
  // çŠ¶æ€ç®¡ç†
  @State histories: HistoryItem[] = [];
  @State mediaItems: Map<string, MediaItem> = new Map();
  @State isLoading: boolean = false;
  @State errorMessage: string = '';
  @State isEditMode: boolean = false;
  @State selectedItems: Set<string> = new Set();
  @State isRefreshing: boolean = false;
  @State autoPlayLast: boolean = true;
  
  // åˆå§‹åŒ–
  /**
   * é¡µé¢åŠ è½½æ—¶è°ƒç”¨
   */
  aboutToAppear(): void {
    Logger.info(this.TAG, 'HistoryPage appeared');
    this.loadHistories();
  }

  /**
   * é¡µé¢å¸è½½æ—¶è°ƒç”¨
   */
  aboutToDisappear(): void {
    Logger.info(this.TAG, 'HistoryPage disappeared');
  }
  
  /**
   * åŠ è½½å†å²è®°å½•
   */
  private loadHistories(): void {
    this.isLoading = true;
    this.errorMessage = '';
    
    try {
      // ä»å†å²æœåŠ¡è·å–å†å²è®°å½•åˆ—è¡¨ï¼ˆæŒ‰æ’­æ”¾æ—¶é—´å€’åºï¼‰
      historyService.getHistories(100).then((histories) => {
        this.histories = histories;
        
        // åŠ è½½åª’ä½“è¯¦æƒ…
        this.loadMediaDetails(histories);
        
        Logger.info(this.TAG, `Loaded ${this.histories.length} history records`);
        this.isLoading = false;
        this.isRefreshing = false;
      }).catch((error) => {
        Logger.error(this.TAG, `Failed to load histories: ${error}`);
        this.errorMessage = 'åŠ è½½å†å²è®°å½•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
        this.isLoading = false;
        this.isRefreshing = false;
      });
    } catch (error) {
      Logger.error(this.TAG, `Failed to load histories: ${error}`);
      this.errorMessage = 'åŠ è½½å†å²è®°å½•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
      this.isLoading = false;
      this.isRefreshing = false;
    }
  }
  
  /**
   * åŠ è½½åª’ä½“è¯¦æƒ…
   */
  private loadMediaDetails(histories: HistoryItem[]): void {
    try {
      // å¹¶è¡ŒåŠ è½½åª’ä½“è¯¦æƒ…
      const detailPromises = histories.map((history) => {
        return mediaService.getMediaDetail(history.mediaId, history.siteKey)
          .then((media) => {
            if (media) {
              this.mediaItems.set(history.mediaId, media);
            }
          })
          .catch((error) => {
            Logger.warn(this.TAG, `Failed to load detail for ${history.mediaId}: ${error}`);
            // å¦‚æœåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å†å²è®°å½•ä¸­çš„åŸºç¡€ä¿¡æ¯
            const placeholderMedia: MediaItem = {
              id: history.mediaId,
              siteKey: history.siteKey,
              title: history.title,
              coverUrl: history.cover || '',
              type: history.type,
              year: '',
              description: '',
              score: '',
              directors: [],
              actors: [],
              tags: [],
              category: '',
              region: '',
              language: '',
              updateTime: '',
              status: ''
            };
            this.mediaItems.set(history.mediaId, placeholderMedia);
          });
      });
      
      Promise.all(detailPromises).catch((error) => {
        Logger.error(this.TAG, `Failed in Promise.all: ${error}`);
      });
    } catch (error) {
      Logger.error(this.TAG, `Failed to load media details: ${error}`);
    }
  }
  
  /**
   * å¤„ç†è¿”å›
   */
  private handleBack(): void {
      AppNavigator.getInstance().back();
    }
  
  /**
   * å¤„ç†ç¼–è¾‘æ¨¡å¼åˆ‡æ¢
   */
  private toggleEditMode(): void {
    this.isEditMode = !this.isEditMode;
    this.selectedItems.clear();
  }
  
  /**
   * å¤„ç†é¡¹ç›®é€‰æ‹©
   */
  private handleItemSelect(historyId: string): void {
    if (this.selectedItems.has(historyId)) {
      this.selectedItems.delete(historyId);
    } else {
      this.selectedItems.add(historyId);
    }
  }
  
  /**
   * å¤„ç†å…¨é€‰/å–æ¶ˆå…¨é€‰
   */
  private handleSelectAll(): void {
    if (this.selectedItems.size === this.histories.length) {
      this.selectedItems.clear();
    } else {
      this.selectedItems = new Set(this.histories.map(item => item.id));
    }
  }
  
  /**
   * å¤„ç†åˆ é™¤é€‰ä¸­é¡¹
   */
  private handleDeleteSelected(): void {
    if (this.selectedItems.size === 0) return;
    
    try {
      const idsToDelete = Array.from(this.selectedItems);
      
      // åˆ é™¤é€‰ä¸­çš„å†å²è®°å½•
      historyService.removeHistories(idsToDelete)
        .then(() => {
          // æ›´æ–°æœ¬åœ°çŠ¶æ€
          this.histories = this.histories.filter(history => !idsToDelete.includes(history.id));
          
          // æ¸…é™¤å·²åˆ é™¤é¡¹çš„åª’ä½“è¯¦æƒ…ç¼“å­˜
          idsToDelete.forEach(id => {
            const history = this.histories.find(h => h.id === id);
            if (history) {
              this.mediaItems.delete(history.mediaId);
            }
            this.selectedItems.delete(id);
          });
          
          Logger.info(this.TAG, `Deleted ${idsToDelete.length} history records`);
          
          // å¦‚æœæ²¡æœ‰å†å²è®°å½•äº†ï¼Œé€€å‡ºç¼–è¾‘æ¨¡å¼
          if (this.histories.length === 0) {
            this.isEditMode = false;
          }
        })
        .catch(error => {
          Logger.error(this.TAG, `Failed to delete histories: ${error}`);
          this.errorMessage = 'åˆ é™¤å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
        });
    } catch (error) {
      Logger.error(this.TAG, `Failed to delete histories: ${error}`);
      this.errorMessage = 'åˆ é™¤å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
    }
  }
  
  /**
   * å¤„ç†æ¸…ç©ºæ‰€æœ‰å†å²
   */
  private handleClearAll(): void {
    try {
      // æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•
      historyService.clearAllHistories()
        .then(() => {
          // æ›´æ–°æœ¬åœ°çŠ¶æ€
          this.histories = [];
          this.mediaItems.clear();
          this.selectedItems.clear();
          this.isEditMode = false;
          
          Logger.info(this.TAG, 'Cleared all history records');
        })
        .catch(error => {
          Logger.error(this.TAG, `Failed to clear all histories: ${error}`);
          this.errorMessage = 'æ¸…ç©ºå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
        });
    } catch (error) {
      Logger.error(this.TAG, `Failed to clear all histories: ${error}`);
      this.errorMessage = 'æ¸…ç©ºå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
    }
  }
  
  /**
   * å¤„ç†å†å²é¡¹ç‚¹å‡»
   */
  private handleHistoryClick(history: HistoryItem): void {
    if (this.isEditMode) {
      this.handleItemSelect(history.id);
      return;
    }
    
    Logger.info(this.TAG, `History clicked: ${history.title}, episode: ${history.episodeIndex}`);
    
    try {
      // æ›´æ–°æ’­æ”¾å†å²æ—¶é—´
      historyService.updateHistoryTime(history.id)
        .then(() => {
          // è·³è½¬åˆ°æ’­æ”¾é¡µé¢ï¼Œå¸¦ä¸Šä¸Šæ¬¡æ’­æ”¾çš„è¿›åº¦
          AppNavigator.getInstance().navigateToVideoPlay({
            mediaId: history.mediaId,
            siteKey: history.siteKey,
            episodeId: history.episodeId,
            playbackPosition: history.progress * 1000,
            title: history.title,
            coverUrl: history.cover || ''
          });
        })
        .catch(error => {
          Logger.error(this.TAG, `Failed to update history time: ${error}`);
          // å³ä½¿æ›´æ–°å¤±è´¥ï¼Œä¹Ÿè·³è½¬åˆ°æ’­æ”¾é¡µé¢
          Router.push({
            uri: 'pages/PlaybackPage',
            params: {
              mediaId: history.mediaId,
              siteKey: history.siteKey,
              episodeId: history.episodeId,
              playbackPosition: history.progress * 1000,
              title: history.title,
              coverUrl: history.cover || ''
            }
          });
        });
    } catch (error) {
      Logger.error(this.TAG, `Failed to handle history click: ${error}`);
      // é”™è¯¯å¤„ç†ï¼šè·³è½¬åˆ°æ’­æ”¾é¡µé¢
      AppNavigator.getInstance().navigateToVideoPlay({
        mediaId: history.mediaId,
        siteKey: history.siteKey,
        episodeId: history.episodeId,
        playbackPosition: history.progress * 1000,
        title: history.title,
        coverUrl: history.cover || ''
      });
    }
  }
  
  /**
   * å¤„ç†ç»§ç»­æ’­æ”¾
   */
  private handleContinuePlay(history: HistoryItem): void {
    Logger.info(this.TAG, `Continue playing: ${history.title} from ${history.playbackPosition}ms`);
    
    // è·³è½¬åˆ°æ’­æ”¾é¡µé¢ï¼Œå¸¦ä¸Šä¸Šæ¬¡æ’­æ”¾çš„è¿›åº¦
    AppNavigator.getInstance().navigateToVideoPlay({
        mediaId: history.mediaId,
        siteKey: history.siteKey,
        episodeId: history.episodeId,
        playbackPosition: history.progress * 1000,
        title: history.title,
        coverUrl: history.cover || ''
      });
  }
  
  /**
   * å¤„ç†åˆ·æ–°
   */
  private handleRefresh(): void {
    this.isRefreshing = true;
    this.mediaItems.clear();
    this.loadHistories();
  }
  
  /**
   * æ ¼å¼åŒ–æ’­æ”¾è¿›åº¦
   */
  private formatPlaybackProgress(position: number, duration: number): string {
    if (duration === 0) return '00:00';
    
    const positionSec = Math.floor(position / 1000);
    const durationSec = Math.floor(duration / 1000);
    
    const posMin = Math.floor(positionSec / 60);
    const posSec = positionSec % 60;
    const durMin = Math.floor(durationSec / 60);
    const durSec = durationSec % 60;
    
    return `${posMin.toString().padStart(2, '0')}:${posSec.toString().padStart(2, '0')} / ${durMin.toString().padStart(2, '0')}:${durSec.toString().padStart(2, '0')}`;
  }
  
  /**
   * è®¡ç®—æ’­æ”¾è¿›åº¦ç™¾åˆ†æ¯”
   */
  private getProgressPercentage(position: number, duration: number): number {
    if (duration === 0) return 0;
    return Math.min(100, Math.max(0, (position / duration) * 100));
  }
  
  /**
   * æ¸²æŸ“å¤´éƒ¨
   */
  @Builder
  private renderHeader() {
    Stack.create({ className: "header" });
    Button.create({ className: "back-button", onClick: this.handleBack });
    Button.text("â†");
    Button.pop();
    Text.create({ className: "page-title" });
    Text.text("æ’­æ”¾å†å²");
    Text.pop();
    Button.create({ className: "action-button", onClick: this.toggleEditMode });
    Button.text(this.isEditMode ? 'å–æ¶ˆ' : 'ç¼–è¾‘');
    Button.pop();
    Stack.pop();
  }

  /**
   * æ¸²æŸ“ç¼–è¾‘å·¥å…·æ 
   */
  @Builder
  private renderEditToolbar() {
    if (!this.isEditMode || this.histories.length === 0) return;
    
    Flex.create({ className: "edit-toolbar" });
    Flex.create({ className: "select-all" });
    Checkbox.create();
    Checkbox.checked(this.selectedItems.size === this.histories.length && this.histories.length > 0);
    Checkbox.onCheckChange(this.handleSelectAll);
    Checkbox.pop();
    Text.create();
    Text.text("å…¨é€‰");
    Text.pop();
    Flex.pop();
    Text.create({ className: "selected-count" });
    Text.text(`å·²é€‰æ‹© ${this.selectedItems.size} é¡¹`);
    Text.pop();
    Button.create({ 
      className: "delete-button", 
      onClick: this.handleDeleteSelected,
      disabled: this.selectedItems.size === 0 
    });
    Button.text("åˆ é™¤");
    Button.pop();
    Button.create({ className: "clear-all-button", onClick: this.handleClearAll });
    Button.text("æ¸…ç©º");
    Button.pop();
    Flex.pop();
  }

  /**
   * æ¸²æŸ“è®¾ç½®é€‰é¡¹
   */
  @Builder
  private renderSettings() {
    if (this.isEditMode || this.histories.length === 0) return;
    
    Flex.create({ className: "settings-container" });
    Text.create({ className: "setting-label" });
    Text.text("è‡ªåŠ¨ç»­æ’­ä¸Šæ¬¡å†…å®¹");
    Text.pop();
    Switch.create();
    Switch.checked(this.autoPlayLast);
    Switch.onValueChange((value) => {
      this.autoPlayLast = value;
      // è¿™é‡Œå¯ä»¥ä¿å­˜è®¾ç½®åˆ°é…ç½®æœåŠ¡
      Logger.info(this.TAG, `Auto play last content: ${value}`);
    });
    Switch.pop();
    Flex.pop();
  }

  /**
   * æ¸²æŸ“å†å²è®°å½•é¡¹
   */
  @Builder
  private renderHistoryItem(history: HistoryItem) {
    const media = this.mediaItems.get(history.mediaId);
    const progressText = this.formatPlaybackProgress(history.progress * 1000, (history.duration || 0) * 1000);
    const progressPercentage = this.getProgressPercentage(history.progress * 1000, (history.duration || 0) * 1000);
    
    ListItem.create({ onClick: () => this.handleHistoryClick(history) });
    Flex.create({ className: "history-item" });
    
    if (this.isEditMode) {
      Checkbox.create();
      Checkbox.checked(this.selectedItems.has(history.id));
      Checkbox.onCheckChange(() => this.handleItemSelect(history.id));
      Checkbox.pop();
    }
    
    Image.create({ 
      src: media?.coverUrl || history.cover || "https://via.placeholder.com/120x160?text=No+Image",
      className: "media-cover",
      objectFit: ImageFit.Cover
    });
    Image.pop();
    
    Flex.create({ className: "media-info", direction: FlexDirection.Column });
    Text.create({ className: "media-title", numberOfLines: 2 });
    Text.text(media?.title || history.title);
    Text.pop();
    
    if (history.episodeTitle) {
      Text.create({ className: "episode-title", numberOfLines: 1 });
      Text.text(history.episodeTitle);
      Text.pop();
    }
    
    Text.create({ className: "play-time" });
    Text.text(`æ’­æ”¾æ—¶é—´: ${new Date(history.lastPlayTime).toLocaleString()}`);
    Text.pop();
    
    Stack.create({ className: "progress-container" });
    ProgressBar.create();
    ProgressBar.percent(progressPercentage);
    ProgressBar.strokeWidth(4);
    ProgressBar.color("#FF4500");
    ProgressBar.pop();
    Text.create({ className: "progress-text" });
    Text.text(progressText);
    Text.pop();
    Stack.pop();
    
    if (!this.isEditMode) {
      Button.create({ className: "continue-button", onClick: () => this.handleContinuePlay(history) });
      Button.text("ç»§ç»­è§‚çœ‹");
      Button.pop();
    }
    
    Flex.pop();
    ListItem.pop();
  }

  /**
   * æ¸²æŸ“å†å²è®°å½•åˆ—è¡¨
   */
  @Builder
  private renderHistoryList() {
    if (this.isLoading && !this.isRefreshing) {
      Stack.create({ className: "loading-container" });
      LoadingProgress.create({ className: "loading-progress", color: "#FF4500" });
      LoadingProgress.pop();
      Text.create();
      Text.text("åŠ è½½ä¸­...");
      Text.pop();
      Stack.pop();
      return;
    }
    
    if (this.errorMessage) {
      Stack.create({ className: "error-container" });
      Text.create({ className: "error-icon" });
      Text.text("âš ï¸");
      Text.pop();
      Text.create({ className: "error-message" });
      Text.text(this.errorMessage);
      Text.pop();
      Button.create({ className: "retry-button", onClick: this.loadHistories });
      Button.text("é‡è¯•");
      Button.pop();
      Stack.pop();
      return;
    }
    
    if (this.histories.length === 0) {
      Empty.create({ className: "empty-container" });
      Text.create({ className: "empty-icon" });
      Text.text("ğŸ“º");
      Text.pop();
      Text.create();
      Text.text("æš‚æ— æ’­æ”¾å†å²");
      Text.pop();
      Button.create({ className: "explore-button", onClick: () => AppNavigator.getInstance().navigateToHome() });
      Button.text("å»æ¢ç´¢");
      Button.pop();
      Empty.pop();
      return;
    }
    
    List.create({ 
      className: "history-list",
      itemTemplate: this.renderHistoryItem,
      data: this.histories,
      onRefresh: () => this.handleRefresh(),
      refreshing: this.isRefreshing
    });
    List.pop();
  }

  /**
   * ç»„ä»¶æ¸²æŸ“
   */
  build() {
    Stack.create({ className: "history-page" });
    
    // é¡µé¢å¤´éƒ¨
    this.renderHeader();
    
    // ç¼–è¾‘å·¥å…·æ 
    this.renderEditToolbar();
    
    // è®¾ç½®é€‰é¡¹
    this.renderSettings();
    
    // å†å²è®°å½•åˆ—è¡¨
    ScrollView.create({ className: "content-scroll", scrollBar: BarState.Auto });
    this.renderHistoryList();
    Blank.create({ className: "bottom-space" });
    Blank.pop();
    ScrollView.pop();
    
    Stack.pop();
  }
}

export default HistoryPage;