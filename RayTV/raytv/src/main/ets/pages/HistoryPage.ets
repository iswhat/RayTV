import { useState, useEffect, onMounted, onUnmounted } from '@ohos/base';
import { ScrollView, Text, Button, List, ListItem, Image, LoadingProgress, Empty, Flex, Tag, Checkbox, Switch } from '@ohos/base/ui';
import { Router } from '@ohos/router';
import { historyService } from '../service/media/HistoryService';
import { mediaService } from '../service/media/MediaService';
import Logger from '@ohos/base/Logger';

/**
 * å†å²è®°å½•é¡µé¢ç»„ä»¶
 * å®ç°æ’­æ”¾å†å²çš„å±•ç¤ºã€ç®¡ç†ã€ç¼–è¾‘å’Œæ¸…ç©ºç­‰åŠŸèƒ½
 */
@Component
struct HistoryPage {
  private readonly TAG: string = 'HistoryPage';
  
  // çŠ¶æ€ç®¡ç†
  @State histories: HistoryItem[] = [];
  @State mediaItems: Map<string, MediaItem> = new Map();
  @State isLoading: boolean = false;
  @State errorMessage: string = '';
  @State isEditMode: boolean = false;
  @State selectedItems: Set<string> = new Set();
  @State isRefreshing: boolean = false;
  @State autoPlayLast: boolean = true;
  
  // åˆå§‹åŒ–
  onMounted(() => {
    Logger.info(this.TAG, 'HistoryPage mounted');
    this.loadHistories();
  });
  
  // æ¸…ç†èµ„æº
  onUnmounted(() => {
    Logger.info(this.TAG, 'HistoryPage unmounted');
  });
  
  /**
   * åŠ è½½å†å²è®°å½•
   */
  private async loadHistories(): Promise<void> {
    this.isLoading = true;
    this.errorMessage = '';
    
    try {
      // ä»å†å²æœåŠ¡è·å–å†å²è®°å½•åˆ—è¡¨ï¼ˆæŒ‰æ’­æ”¾æ—¶é—´å€’åºï¼‰
      const histories = await historyService.getHistories(100); // è·å–æœ€è¿‘100æ¡è®°å½•
      this.histories = histories;
      
      // åŠ è½½åª’ä½“è¯¦æƒ…
      await this.loadMediaDetails(histories);
      
      Logger.info(this.TAG, `Loaded ${this.histories.length} history records`);
    } catch (error) {
      Logger.error(this.TAG, `Failed to load histories: ${error}`);
      this.errorMessage = 'åŠ è½½å†å²è®°å½•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
    } finally {
      this.isLoading = false;
      this.isRefreshing = false;
    }
  }
  
  /**
   * åŠ è½½åª’ä½“è¯¦æƒ…
   */
  private async loadMediaDetails(histories: HistoryItem[]): Promise<void> {
    try {
      // å¹¶è¡ŒåŠ è½½åª’ä½“è¯¦æƒ…
      const detailPromises = histories.map(async (history) => {
        try {
          const media = await mediaService.getMediaDetail(history.mediaId, history.siteKey);
          if (media) {
            this.mediaItems.set(history.mediaId, media);
          }
        } catch (error) {
          Logger.warn(this.TAG, `Failed to load detail for ${history.mediaId}: ${error}`);
          // å¦‚æœåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å†å²è®°å½•ä¸­çš„åŸºç¡€ä¿¡æ¯
          const placeholderMedia: MediaItem = {
            id: history.mediaId,
            siteKey: history.siteKey,
            title: history.title,
            coverUrl: history.coverUrl,
            type: history.type,
            year: history.year,
            description: '',
            score: '',
            directors: [],
            actors: [],
            tags: [],
            category: '',
            region: '',
            language: '',
            updateTime: '',
            status: ''
          };
          this.mediaItems.set(history.mediaId, placeholderMedia);
        }
      });
      
      await Promise.all(detailPromises);
    } catch (error) {
      Logger.error(this.TAG, `Failed to load media details: ${error}`);
    }
  }
  
  /**
   * å¤„ç†è¿”å›
   */
  private handleBack(): void {
    Router.back();
  }
  
  /**
   * å¤„ç†ç¼–è¾‘æ¨¡å¼åˆ‡æ¢
   */
  private toggleEditMode(): void {
    this.isEditMode = !this.isEditMode;
    this.selectedItems.clear();
  }
  
  /**
   * å¤„ç†é¡¹ç›®é€‰æ‹©
   */
  private handleItemSelect(historyId: string): void {
    if (this.selectedItems.has(historyId)) {
      this.selectedItems.delete(historyId);
    } else {
      this.selectedItems.add(historyId);
    }
  }
  
  /**
   * å¤„ç†å…¨é€‰/å–æ¶ˆå…¨é€‰
   */
  private handleSelectAll(): void {
    if (this.selectedItems.size === this.histories.length) {
      this.selectedItems.clear();
    } else {
      this.selectedItems = new Set(this.histories.map(item => item.id));
    }
  }
  
  /**
   * å¤„ç†åˆ é™¤é€‰ä¸­é¡¹
   */
  private async handleDeleteSelected(): Promise<void> {
    if (this.selectedItems.size === 0) return;
    
    try {
      const idsToDelete = Array.from(this.selectedItems);
      
      // åˆ é™¤é€‰ä¸­çš„å†å²è®°å½•
      await historyService.removeHistories(idsToDelete);
      
      // æ›´æ–°æœ¬åœ°çŠ¶æ€
      this.histories = this.histories.filter(history => !idsToDelete.includes(history.id));
      
      // æ¸…é™¤å·²åˆ é™¤é¡¹çš„åª’ä½“è¯¦æƒ…ç¼“å­˜
      idsToDelete.forEach(id => {
        const history = this.histories.find(h => h.id === id);
        if (history) {
          this.mediaItems.delete(history.mediaId);
        }
        this.selectedItems.delete(id);
      });
      
      Logger.info(this.TAG, `Deleted ${idsToDelete.length} history records`);
      
      // å¦‚æœæ²¡æœ‰å†å²è®°å½•äº†ï¼Œé€€å‡ºç¼–è¾‘æ¨¡å¼
      if (this.histories.length === 0) {
        this.isEditMode = false;
      }
    } catch (error) {
      Logger.error(this.TAG, `Failed to delete histories: ${error}`);
      this.errorMessage = 'åˆ é™¤å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
    }
  }
  
  /**
   * å¤„ç†æ¸…ç©ºæ‰€æœ‰å†å²
   */
  private async handleClearAll(): Promise<void> {
    try {
      // æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•
      await historyService.clearAllHistories();
      
      // æ›´æ–°æœ¬åœ°çŠ¶æ€
      this.histories = [];
      this.mediaItems.clear();
      this.selectedItems.clear();
      this.isEditMode = false;
      
      Logger.info(this.TAG, 'Cleared all history records');
    } catch (error) {
      Logger.error(this.TAG, `Failed to clear all histories: ${error}`);
      this.errorMessage = 'æ¸…ç©ºå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
    }
  }
  
  /**
   * å¤„ç†å†å²é¡¹ç‚¹å‡»
   */
  private handleHistoryClick(history: HistoryItem): void {
    if (this.isEditMode) {
      this.handleItemSelect(history.id);
      return;
    }
    
    Logger.info(this.TAG, `History clicked: ${history.title}, episode: ${history.episodeIndex}`);
    
    // è·³è½¬åˆ°æ’­æ”¾é¡µé¢ï¼Œå¸¦ä¸Šä¸Šæ¬¡æ’­æ”¾çš„è¿›åº¦
    Router.push({
      url: 'pages/PlaybackPage',
      params: {
        mediaId: history.mediaId,
        siteKey: history.siteKey,
        episodeIndex: history.episodeIndex,
        playSourceIndex: history.playSourceIndex,
        playbackPosition: history.playbackPosition,
        title: history.title,
        coverUrl: history.coverUrl
      }
    });
  }
  
  /**
   * å¤„ç†ç»§ç»­æ’­æ”¾
   */
  private handleContinuePlay(history: HistoryItem): void {
    Logger.info(this.TAG, `Continue playing: ${history.title} from ${history.playbackPosition}ms`);
    
    // è·³è½¬åˆ°æ’­æ”¾é¡µé¢ï¼Œå¸¦ä¸Šä¸Šæ¬¡æ’­æ”¾çš„è¿›åº¦
    Router.push({
      url: 'pages/PlaybackPage',
      params: {
        mediaId: history.mediaId,
        siteKey: history.siteKey,
        episodeIndex: history.episodeIndex,
        playSourceIndex: history.playSourceIndex,
        playbackPosition: history.playbackPosition,
        title: history.title,
        coverUrl: history.coverUrl
      }
    });
  }
  
  /**
   * å¤„ç†åˆ·æ–°
   */
  private handleRefresh(): void {
    this.isRefreshing = true;
    this.mediaItems.clear();
    this.loadHistories();
  }
  
  /**
   * æ ¼å¼åŒ–æ’­æ”¾è¿›åº¦
   */
  private formatPlaybackProgress(position: number, duration: number): string {
    if (duration === 0) return '00:00';
    
    const positionSec = Math.floor(position / 1000);
    const durationSec = Math.floor(duration / 1000);
    
    const posMin = Math.floor(positionSec / 60);
    const posSec = positionSec % 60;
    const durMin = Math.floor(durationSec / 60);
    const durSec = durationSec % 60;
    
    return `${posMin.toString().padStart(2, '0')}:${posSec.toString().padStart(2, '0')} / ${durMin.toString().padStart(2, '0')}:${durSec.toString().padStart(2, '0')}`;
  }
  
  /**
   * è®¡ç®—æ’­æ”¾è¿›åº¦ç™¾åˆ†æ¯”
   */
  private getProgressPercentage(position: number, duration: number): number {
    if (duration === 0) return 0;
    return Math.min(100, Math.max(0, (position / duration) * 100));
  }
  
  /**
   * æ¸²æŸ“å¤´éƒ¨
   */
  @Builder
  private renderHeader(): void {
    <Stack className="header">
      <Button className="back-button" onClick={this.handleBack}>
        â†
      </Button>
      <Text className="page-title">æ’­æ”¾å†å²</Text>
      <Button className="action-button" onClick={this.toggleEditMode}>
        {this.isEditMode ? 'å–æ¶ˆ' : 'ç¼–è¾‘'}
      </Button>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“ç¼–è¾‘å·¥å…·æ 
   */
  @Builder
  private renderEditToolbar(): void {
    if (!this.isEditMode || this.histories.length === 0) return;
    
    <Flex className="edit-toolbar">
      <Flex className="select-all">
        <Checkbox
          checked={this.selectedItems.size === this.histories.length && this.histories.length > 0}
          onCheckChange={this.handleSelectAll}
        />
        <Text>å…¨é€‰</Text>
      </Flex>
      <Text className="selected-count">
        å·²é€‰æ‹© {this.selectedItems.size} é¡¹
      </Text>
      <Button
        className="delete-button"
        onClick={this.handleDeleteSelected}
        disabled={this.selectedItems.size === 0}
      >
        åˆ é™¤
      </Button>
      <Button
        className="clear-all-button"
        onClick={this.handleClearAll}
      >
        æ¸…ç©º
      </Button>
    </Flex>
  }
  
  /**
   * æ¸²æŸ“è®¾ç½®é€‰é¡¹
   */
  @Builder
  private renderSettings(): void {
    if (this.isEditMode || this.histories.length === 0) return;
    
    <Flex className="settings-container">
      <Text className="setting-label">è‡ªåŠ¨ç»­æ’­ä¸Šæ¬¡å†…å®¹</Text>
      <Switch
        checked={this.autoPlayLast}
        onValueChange={(value) => {
          this.autoPlayLast = value;
          // è¿™é‡Œå¯ä»¥ä¿å­˜è®¾ç½®åˆ°é…ç½®æœåŠ¡
          Logger.info(this.TAG, `Auto play last content: ${value}`);
        }}
      />
    </Flex>
  }
  
  /**
   * æ¸²æŸ“å†å²è®°å½•é¡¹
   */
  @Builder
  private renderHistoryItem(history: HistoryItem): void {
    const media = this.mediaItems.get(history.mediaId);
    const progressText = this.formatPlaybackProgress(history.playbackPosition, history.duration);
    const progressPercentage = this.getProgressPercentage(history.playbackPosition, history.duration);
    
    <ListItem onClick={() => this.handleHistoryClick(history)}>
      <Flex className="history-item">
        {this.isEditMode && (
          <Checkbox
            checked={this.selectedItems.has(history.id)}
            onCheckChange={() => this.handleItemSelect(history.id)}
          />
        )}
        <Image
          src={media?.coverUrl || history.coverUrl || 'https://via.placeholder.com/120x160?text=No+Image'}
          className="media-cover"
          objectFit="cover"
        />
        <Flex className="media-info" direction="column">
          <Text className="media-title" numberOfLines={2}>
            {media?.title || history.title}
          </Text>
          {history.episodeTitle && (
            <Text className="episode-title" numberOfLines={1}>
              ç¬¬{history.episodeIndex + 1}é›†: {history.episodeTitle}
            </Text>
          )}
          <Text className="play-time">
            æ’­æ”¾æ—¶é—´: {new Date(history.playTime).toLocaleString()}
          </Text>
          <Stack className="progress-container">
            <ProgressBar
              percent={progressPercentage}
              style={{ strokeWidth: 4, color: '#FF4500' }}
            />
            <Text className="progress-text">{progressText}</Text>
          </Stack>
          {!this.isEditMode && (
            <Button className="continue-button" onClick={() => this.handleContinuePlay(history)}>
              ç»§ç»­è§‚çœ‹
            </Button>
          )}
        </Flex>
      </Flex>
    </ListItem>
  }
  
  /**
   * æ¸²æŸ“å†å²è®°å½•åˆ—è¡¨
   */
  @Builder
  private renderHistoryList(): void {
    if (this.isLoading && !this.isRefreshing) {
      <Stack className="loading-container">
        <LoadingProgress className="loading-progress" color="#FF4500" />
        <Text>åŠ è½½ä¸­...</Text>
      </Stack>
      return;
    }
    
    if (this.errorMessage) {
      <Stack className="error-container">
        <Text className="error-icon">âš ï¸</Text>
        <Text className="error-message">{this.errorMessage}</Text>
        <Button className="retry-button" onClick={this.loadHistories}>
          é‡è¯•
        </Button>
      </Stack>
      return;
    }
    
    if (this.histories.length === 0) {
      <Empty className="empty-container">
        <Text className="empty-icon">ğŸ“º</Text>
        <Text>æš‚æ— æ’­æ”¾å†å²</Text>
        <Button className="explore-button" onClick={() => Router.push({ url: 'pages/HomePage' })}>
          å»æ¢ç´¢
        </Button>
      </Empty>
      return;
    }
    
    <List
      className="history-list"
      itemTemplate={this.renderHistoryItem}
      data={this.histories}
      onRefresh={() => this.handleRefresh()}
      refreshing={this.isRefreshing}
    />
  }
  
  /**
   * ç»„ä»¶æ¸²æŸ“
   */
  build() {
    <Stack className="history-page">
      {/* é¡µé¢å¤´éƒ¨ */}
      {this.renderHeader()}
      
      {/* ç¼–è¾‘å·¥å…·æ  */}
      {this.renderEditToolbar()}
      
      {/* è®¾ç½®é€‰é¡¹ */}
      {this.renderSettings()}
      
      {/* å†å²è®°å½•åˆ—è¡¨ */}
      <ScrollView className="content-scroll" scrollBar="auto">
        {this.renderHistoryList()}
        <Blank className="bottom-space" />
      </ScrollView>
    </Stack>
  }
}

export default HistoryPage;