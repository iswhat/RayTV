import { useState, useEffect, onMounted, onUnmounted } from '@ohos/base';
import { ScrollView, TextInput, Button, List, ListItem, Image, Text, LoadingProgress, Empty, Flex, Tag } from '@ohos/base/ui';
import { Router } from '@ohos/router';
import { mediaService } from '../service/media/MediaService';
import Logger from '@ohos/base/Logger';

/**
 * æœç´¢é¡µé¢ç»„ä»¶
 * å®ç°åª’ä½“æœç´¢åŠŸèƒ½ï¼ŒåŒ…æ‹¬æœç´¢è¾“å…¥ã€ç»“æœå±•ç¤ºã€å†å²æœç´¢ç­‰
 */
@Component
struct SearchPage {
  private readonly TAG: string = 'SearchPage';
  
  // çŠ¶æ€ç®¡ç†
  @State searchQuery: string = '';
  @State searchResults: MediaItem[] = [];
  @State hotKeywords: string[] = [];
  @State searchHistory: string[] = [];
  @State isLoading: boolean = false;
  @State isSearching: boolean = false;
  @State errorMessage: string = '';
  @State currentPage: number = 1;
  @State hasMoreResults: boolean = true;
  @State showHistory: boolean = true;
  
  // åˆ†é¡µé…ç½®
  private pageSize: number = 20;
  private searchDebounceTimer: NodeJS.Timeout | null = null;
  
  // åˆå§‹åŒ–
  onMounted(() => {
    Logger.info(this.TAG, 'SearchPage mounted');
    
    // è·å–è·¯ç”±å‚æ•°ä¸­çš„æœç´¢è¯
    const params = Router.getParams();
    if (params?.['query']) {
      this.searchQuery = params['query'];
      this.performSearch();
    } else {
      // åŠ è½½çƒ­é—¨æœç´¢è¯
      this.loadHotKeywords();
    }
    
    // åŠ è½½æœç´¢å†å²
    this.loadSearchHistory();
  });
  
  // æ¸…ç†èµ„æº
  onUnmounted(() => {
    Logger.info(this.TAG, 'SearchPage unmounted');
    
    // æ¸…ç†å®šæ—¶å™¨
    if (this.searchDebounceTimer) {
      clearTimeout(this.searchDebounceTimer);
    }
  });
  
  /**
   * åŠ è½½çƒ­é—¨æœç´¢è¯
   */
  private async loadHotKeywords(): Promise<void> {
    try {
      this.hotKeywords = await mediaService.getHotSearchKeywords(10);
      Logger.info(this.TAG, `Loaded ${this.hotKeywords.length} hot keywords`);
    } catch (error) {
      Logger.error(this.TAG, `Failed to load hot keywords: ${error}`);
      // ä½¿ç”¨é»˜è®¤çƒ­é—¨å…³é”®è¯
      this.hotKeywords = ['çƒ­é—¨ç”µå½±', 'æœ€æ–°å‰§é›†', 'ç»å…¸åŠ¨æ¼«', 'ç§‘å¹»å¤§ç‰‡', 'çˆ±æƒ…å–œå‰§'];
    }
  }
  
  /**
   * åŠ è½½æœç´¢å†å²
   */
  private loadSearchHistory(): Promise<void> {
    return new Promise((resolve) => {
      try {
        // è¿™é‡Œåº”è¯¥ä»æœ¬åœ°å­˜å‚¨ä¸­è¯»å–æœç´¢å†å²
        // æš‚æ—¶ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
        const history = ['å¤ä»‡è€…è”ç›Ÿ', 'æµ·è´¼ç‹', 'æ˜Ÿé™…ç©¿è¶Š'];
        this.searchHistory = history;
        Logger.info(this.TAG, `Loaded ${this.searchHistory.length} search history items`);
      } catch (error) {
        Logger.error(this.TAG, `Failed to load search history: ${error}`);
        this.searchHistory = [];
      }
      resolve();
    });
  }
  
  /**
   * ä¿å­˜æœç´¢å†å²
   */
  private saveSearchHistory(keyword: string): Promise<void> {
    return new Promise((resolve) => {
      try {
        // å»é‡å¹¶é™åˆ¶æ•°é‡
        let history = this.searchHistory.filter(item => item !== keyword);
        history.unshift(keyword);
        history = history.slice(0, 10); // æœ€å¤šä¿å­˜10æ¡
        
        this.searchHistory = history;
        
        // è¿™é‡Œåº”è¯¥ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        Logger.info(this.TAG, `Search history saved: ${keyword}`);
      } catch (error) {
        Logger.error(this.TAG, `Failed to save search history: ${error}`);
      }
      resolve();
    });
  }
  
  /**
   * æ¸…é™¤æœç´¢å†å²
   */
  private clearSearchHistory(): Promise<void> {
    return new Promise((resolve) => {
      try {
        this.searchHistory = [];
        // è¿™é‡Œåº”è¯¥æ¸…é™¤æœ¬åœ°å­˜å‚¨ä¸­çš„æœç´¢å†å²
        Logger.info(this.TAG, 'Search history cleared');
      } catch (error) {
        Logger.error(this.TAG, `Failed to clear search history: ${error}`);
      }
      resolve();
    });
  }
  
  /**
   * å¤„ç†æœç´¢è¾“å…¥å˜åŒ–
   */
  private handleSearchInputChange(value: string): void {
    this.searchQuery = value;
    
    // é˜²æŠ–å¤„ç†
    if (this.searchDebounceTimer) {
      clearTimeout(this.searchDebounceTimer);
    }
    
    // è¾“å…¥åœæ­¢300msåæ‰§è¡Œæœç´¢
    this.searchDebounceTimer = setTimeout(() => {
      if (value.trim().length >= 2) {
        this.performSearch();
      } else if (value.trim().length === 0) {
        this.resetSearchState();
      }
    }, 300);
  }
  
  /**
   * æ‰§è¡Œæœç´¢
   */
  private async performSearch(): Promise<void> {
    const query = this.searchQuery.trim();
    if (!query) return;
    
    this.isSearching = true;
    this.isLoading = true;
    this.errorMessage = '';
    this.showHistory = false;
    this.currentPage = 1;
    
    try {
      // ä¿å­˜æœç´¢å†å²
      await this.saveSearchHistory(query);
      
      // æ‰§è¡Œæœç´¢
      Logger.info(this.TAG, `Searching for: ${query}`);
      this.searchResults = await mediaService.searchMedia(query, this.currentPage, this.pageSize);
      
      // æ£€æŸ¥æ˜¯å¦æœ‰æ›´å¤šç»“æœ
      this.hasMoreResults = this.searchResults.length >= this.pageSize;
      
      Logger.info(this.TAG, `Search completed, found ${this.searchResults.length} results`);
    } catch (error) {
      Logger.error(this.TAG, `Search failed: ${error}`);
      this.errorMessage = 'æœç´¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
      this.searchResults = [];
      this.hasMoreResults = false;
    } finally {
      this.isLoading = false;
      this.isSearching = false;
    }
  }
  
  /**
   * åŠ è½½æ›´å¤šæœç´¢ç»“æœ
   */
  private async loadMoreResults(): Promise<void> {
    if (!this.hasMoreResults || this.isLoading || !this.searchQuery.trim()) return;
    
    this.isLoading = true;
    this.currentPage++;
    
    try {
      const query = this.searchQuery.trim();
      Logger.info(this.TAG, `Loading more results for: ${query}, page ${this.currentPage}`);
      
      const moreResults = await mediaService.searchMedia(query, this.currentPage, this.pageSize);
      
      if (moreResults && moreResults.length > 0) {
        this.searchResults = [...this.searchResults, ...moreResults];
        this.hasMoreResults = moreResults.length === this.pageSize;
      } else {
        this.hasMoreResults = false;
      }
    } catch (error) {
      Logger.error(this.TAG, `Failed to load more results: ${error}`);
      this.errorMessage = 'åŠ è½½æ›´å¤šç»“æœå¤±è´¥';
    } finally {
      this.isLoading = false;
    }
  }
  
  /**
   * é‡ç½®æœç´¢çŠ¶æ€
   */
  private resetSearchState(): void {
    this.searchResults = [];
    this.showHistory = true;
    this.errorMessage = '';
    this.currentPage = 1;
    this.hasMoreResults = true;
  }
  
  /**
   * å¤„ç†å…³é”®è¯ç‚¹å‡»
   */
  private handleKeywordClick(keyword: string): void {
    this.searchQuery = keyword;
    this.performSearch();
  }
  
  /**
   * å¤„ç†æœç´¢ç»“æœé¡¹ç‚¹å‡»
   */
  private handleSearchResultClick(media: MediaItem): void {
    Logger.info(this.TAG, `Search result clicked: ${media.title}`);
    // è·³è½¬åˆ°è¯¦æƒ…é¡µ
    Router.push({
      url: 'pages/MediaDetailPage',
      params: {
        mediaId: media.id,
        siteKey: media.siteKey
      }
    });
  }
  
  /**
   * å¤„ç†æ¸…é™¤æŒ‰é’®ç‚¹å‡»
   */
  private handleClearInput(): void {
    this.searchQuery = '';
    this.resetSearchState();
  }
  
  /**
   * å¤„ç†è¿”å›
   */
  private handleBack(): void {
    Router.back();
  }
  
  /**
   * æ¸²æŸ“æœç´¢è¾“å…¥æ¡†
   */
  @Builder
  private renderSearchInput(): void {
    <Stack className="search-input-container">
      <Button className="back-button" onClick={this.handleBack}>
        â†
      </Button>
      <Flex className="search-input-wrapper">
        <Text className="search-icon">ğŸ”</Text>
        <TextInput
          className="search-input"
          value={this.searchQuery}
          onChange={this.handleSearchInputChange}
          onSubmit={this.performSearch}
          placeholder="æœç´¢ç”µå½±ã€ç”µè§†å‰§ã€åŠ¨æ¼«..."
          enterKeyType="search"
          autoFocus={true}
        />
        {this.searchQuery && (
          <Button className="clear-button" onClick={this.handleClearInput}>
            âœ•
          </Button>
        )}
      </Flex>
      <Button className="search-button" onClick={this.performSearch}>
        æœç´¢
      </Button>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“çƒ­é—¨æœç´¢
   */
  @Builder
  private renderHotKeywords(): void {
    <Stack className="hot-keywords-section">
      <Flex className="section-header">
        <Text className="section-title">çƒ­é—¨æœç´¢</Text>
      </Flex>
      <Flex className="keywords-container" wrap="wrap">
        {this.hotKeywords.map((keyword, index) => (
          <Tag
            key={`hot-${index}`}
            className="keyword-tag hot"
            onClick={() => this.handleKeywordClick(keyword)}
          >
            <Text className="keyword-rank">{index + 1}</Text>
            <Text>{keyword}</Text>
          </Tag>
        ))}
      </Flex>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“æœç´¢å†å²
   */
  @Builder
  private renderSearchHistory(): void {
    if (this.searchHistory.length === 0) return;
    
    <Stack className="search-history-section">
      <Flex className="section-header">
        <Text className="section-title">æœç´¢å†å²</Text>
        <Button className="clear-history-button" onClick={this.clearSearchHistory}>
          æ¸…é™¤
        </Button>
      </Flex>
      <Flex className="keywords-container" wrap="wrap">
        {this.searchHistory.map((keyword, index) => (
          <Tag
            key={`history-${index}`}
            className="keyword-tag history"
            onClick={() => this.handleKeywordClick(keyword)}
          >
            <Text className="history-icon">ğŸ•</Text>
            <Text>{keyword}</Text>
          </Tag>
        ))}
      </Flex>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“æœç´¢ç»“æœé¡¹
   */
  @Builder
  private renderSearchResultItem(media: MediaItem): void {
    <ListItem onClick={() => this.handleSearchResultClick(media)}>
      <Flex className="search-result-item">
        <Image
          src={media.coverUrl || 'https://via.placeholder.com/100x150?text=No+Image'}
          className="result-cover"
          objectFit="cover"
        />
        <Flex className="result-info" direction="column">
          <Text className="result-title" numberOfLines={2}>{media.title}</Text>
          <Flex className="result-meta">
            {media.year && <Tag className="meta-tag">{media.year}</Tag>}
            {media.type && <Tag className="meta-tag">{media.type}</Tag>}
            {media.score && <Tag className="meta-tag score">{media.score}</Tag>}
          </Flex>
          {media.description && (
            <Text className="result-description" numberOfLines={2}>
              {media.description}
            </Text>
          )}
          {media.directors && media.directors.length > 0 && (
            <Text className="result-directors" numberOfLines={1}>
              å¯¼æ¼”: {media.directors.slice(0, 3).join(', ')}
            </Text>
          )}
          {media.actors && media.actors.length > 0 && (
            <Text className="result-actors" numberOfLines={1}>
              ä¸»æ¼”: {media.actors.slice(0, 3).join(', ')}
            </Text>
          )}
        </Flex>
      </Flex>
    </ListItem>
  }
  
  /**
   * æ¸²æŸ“æœç´¢ç»“æœ
   */
  @Builder
  private renderSearchResults(): void {
    <Stack className="search-results-section">
      <Text className="results-count">
        æ‰¾åˆ° {this.searchResults.length} ä¸ªç»“æœ
      </Text>
      
      {this.searchResults.length > 0 ? (
        <List
          className="search-results-list"
          itemTemplate={this.renderSearchResultItem}
          data={this.searchResults}
          onScrollBottom={() => this.loadMoreResults()}
        />
      ) : (
        <Empty className="empty-results">
          <Text>æš‚æ— æœç´¢ç»“æœ</Text>
        </Empty>
      )}
      
      {this.isLoading && this.currentPage > 1 && (
        <Stack className="loading-more">
          <LoadingProgress className="loading-progress" color="#FF4500" />
          <Text>åŠ è½½æ›´å¤š...</Text>
        </Stack>
      )}
    </Stack>
  }
  
  /**
   * æ¸²æŸ“åŠ è½½çŠ¶æ€
   */
  @Builder
  private renderLoading(): void {
    <Stack className="loading-container">
      <LoadingProgress className="loading-progress" color="#FF4500" />
      <Text>æœç´¢ä¸­...</Text>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“é”™è¯¯çŠ¶æ€
   */
  @Builder
  private renderError(): void {
    <Stack className="error-container">
      <Text className="error-icon">âš ï¸</Text>
      <Text className="error-message">{this.errorMessage}</Text>
      <Button className="retry-button" onClick={this.performSearch}>
        é‡è¯•
      </Button>
    </Stack>
  }
  
  /**
   * ç»„ä»¶æ¸²æŸ“
   */
  build() {
    <Stack className="search-page">
      {/* æœç´¢è¾“å…¥åŒºåŸŸ */}
      {this.renderSearchInput()}
      
      {/* ä¸»å†…å®¹åŒºåŸŸ */}
      <ScrollView className="content-scroll" scrollBar="auto">
        {this.isSearching && this.isLoading && this.currentPage === 1 ? (
          this.renderLoading()
        ) : this.errorMessage ? (
          this.renderError()
        ) : this.showHistory ? (
          <Stack>
            {this.renderHotKeywords()}
            {this.renderSearchHistory()}
          </Stack>
        ) : (
          this.renderSearchResults()
        )}
        
        <Blank className="bottom-space" />
      </ScrollView>
    </Stack>
  }
}

export default SearchPage;