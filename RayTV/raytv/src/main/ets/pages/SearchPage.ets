import { useState, useEffect, onMounted, onUnmounted } from '@kit.ArkUI';
import { ScrollView, TextInput, Button, List, ListItem, Image, Text, LoadingProgress, Empty, Flex, Tag } from '@kit.ArkUI';
import { Router } from '@kit.AbilityKit';
import Logger from '../common/util/Logger.ets';
import { MediaItem } from '../data/bean/MediaItem';
import { SearchHistoryItem } from '../data/repository/SearchHistoryRepository';
import { mediaService } from '../service/media/MediaService';
import { SearchType, SearchFilter, SearchSort } from '../data/dto/SearchDto';
import Logger from '@ohos/base/Logger';

/**
 * æœç´¢é¡µé¢ç»„ä»¶
 * å®ç°åª’ä½“æœç´¢åŠŸèƒ½ï¼ŒåŒ…æ‹¬æœç´¢è¾“å…¥ã€ç»“æœå±•ç¤ºã€å†å²æœç´¢ç­‰
 */
@Component
struct SearchPage {
  private readonly TAG: string = 'SearchPage';
  
  // çŠ¶æ€ç®¡ç†
  @State searchQuery: string = '';
  @State searchResults: MediaItem[] = [];
  @State hotKeywords: string[] = [];
  @State searchHistory: SearchHistoryItem[] = [];
  @State isLoading: boolean = false;
  @State isSearching: boolean = false;
  @State errorMessage: string = '';
  @State currentPage: number = 1;
  @State hasMoreResults: boolean = true;
  @State showHistory: boolean = true;
  @State displayMode: 'list' | 'grid' = 'list'; // æ˜¾ç¤ºæ¨¡å¼ï¼šåˆ—è¡¨æˆ–ç½‘æ ¼
  @State showFilterPanel: boolean = false; // æ˜¯å¦æ˜¾ç¤ºç­›é€‰é¢æ¿
  @State filters: SearchFilter = {}; // å½“å‰ç­›é€‰æ¡ä»¶
  
  // åˆ†é¡µé…ç½®
  private pageSize: number = 20;
  private searchDebounceTimer: NodeJS.Timeout | null = null;
  
  // åˆå§‹åŒ–
  onMounted(() => {
    Logger.info(this.TAG, 'SearchPage mounted');
    
    // è·å–è·¯ç”±å‚æ•°ä¸­çš„æœç´¢è¯
    const params = Router.getParams();
    if (params?.['query']) {
      this.searchQuery = params['query'];
      this.performSearch();
    } else {
      // åŠ è½½çƒ­é—¨æœç´¢è¯
      this.loadHotKeywords();
    }
    
    // åŠ è½½æœç´¢å†å²
    this.loadSearchHistory();
  });
  
  // æ¸…ç†èµ„æº
  onUnmounted(() => {
    Logger.info(this.TAG, 'SearchPage unmounted');
    
    // æ¸…ç†å®šæ—¶å™¨
    if (this.searchDebounceTimer) {
      clearTimeout(this.searchDebounceTimer);
    }
  });
  
  /**
   * åŠ è½½çƒ­é—¨æœç´¢è¯
   */
  private async loadHotKeywords(): Promise<void> {
    try {
      this.hotKeywords = await mediaService.getHotSearchKeywords(10);
      Logger.info(this.TAG, `Loaded ${this.hotKeywords.length} hot keywords`);
    } catch (error) {
      Logger.error(this.TAG, `Failed to load hot keywords: ${error}`);
      // ä½¿ç”¨é»˜è®¤çƒ­é—¨å…³é”®è¯
      this.hotKeywords = ['çƒ­é—¨ç”µå½±', 'æœ€æ–°å‰§é›†', 'ç»å…¸åŠ¨æ¼«', 'ç§‘å¹»å¤§ç‰‡', 'çˆ±æƒ…å–œå‰§'];
    }
  }
  
  /**
   * åŠ è½½æœç´¢å†å²
   */
  private loadSearchHistory(): Promise<void> {
    return new Promise((resolve) => {
      try {
        // è¿™é‡Œåº”è¯¥ä»æœ¬åœ°å­˜å‚¨ä¸­è¯»å–æœç´¢å†å²
        // æš‚æ—¶ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
        const history = ['å¤ä»‡è€…è”ç›Ÿ', 'æµ·è´¼ç‹', 'æ˜Ÿé™…ç©¿è¶Š'];
        this.searchHistory = history;
        Logger.info(this.TAG, `Loaded ${this.searchHistory.length} search history items`);
      } catch (error) {
        Logger.error(this.TAG, `Failed to load search history: ${error}`);
        this.searchHistory = [];
      }
      resolve();
    });
  }
  
  /**
   * ä¿å­˜æœç´¢å†å²
   */
  private saveSearchHistory(keyword: string): Promise<void> {
    return new Promise((resolve) => {
      try {
        // å»é‡å¹¶é™åˆ¶æ•°é‡
        let history = this.searchHistory.filter(item => item !== keyword);
        history.unshift(keyword);
        history = history.slice(0, 10); // æœ€å¤šä¿å­˜10æ¡
        
        this.searchHistory = history;
        
        // è¿™é‡Œåº”è¯¥ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        Logger.info(this.TAG, `Search history saved: ${keyword}`);
      } catch (error) {
        Logger.error(this.TAG, `Failed to save search history: ${error}`);
      }
      resolve();
    });
  }
  
  /**
   * æ¸…é™¤æœç´¢å†å²
   */
  private clearSearchHistory(): Promise<void> {
    return new Promise((resolve) => {
      try {
        this.searchHistory = [];
        // è¿™é‡Œåº”è¯¥æ¸…é™¤æœ¬åœ°å­˜å‚¨ä¸­çš„æœç´¢å†å²
        Logger.info(this.TAG, 'Search history cleared');
      } catch (error) {
        Logger.error(this.TAG, `Failed to clear search history: ${error}`);
      }
      resolve();
    });
  }
  
  /**
   * å¤„ç†æœç´¢è¾“å…¥å˜åŒ–
   */
  private handleSearchInputChange(value: string): void {
    this.searchQuery = value;
    
    // é˜²æŠ–å¤„ç†
    if (this.searchDebounceTimer) {
      clearTimeout(this.searchDebounceTimer);
    }
    
    // è¾“å…¥åœæ­¢300msåæ‰§è¡Œæœç´¢
    this.searchDebounceTimer = setTimeout(() => {
      if (value.trim().length >= 2) {
        this.performSearch();
      } else if (value.trim().length === 0) {
        this.resetSearchState();
      }
    }, 300);
  }
  
  /**
   * æ‰§è¡Œæœç´¢
   */
  private async performSearch(): Promise<void> {
    const query = this.searchQuery.trim();
    if (!query) return;
    
    this.isSearching = true;
    this.isLoading = true;
    this.errorMessage = '';
    this.showHistory = false;
    this.currentPage = 1;
    
    try {
      // ä¿å­˜æœç´¢å†å²
      await this.saveSearchHistory(query);
      
      // æ‰§è¡Œæœç´¢ï¼Œä¼ é€’ç­›é€‰æ¡ä»¶
      Logger.info(this.TAG, `Searching for: ${query} with filters:`, JSON.stringify(this.filters));
      
      // æ„å»ºæœç´¢å‚æ•°ï¼ŒåŒ…å«ç­›é€‰æ¡ä»¶
      const searchParams = {
        keyword: query,
        type: SearchType.All,
        page: this.currentPage,
        pageSize: this.pageSize,
        ...this.filters // åˆå¹¶ç­›é€‰æ¡ä»¶
      };
      
      const result = await mediaService.searchMedia(searchParams);
      
      // å¤„ç†æœç´¢ç»“æœ
      this.searchResults = result.items || [];
      this.hasMoreResults = result.hasMore || false;
      
      Logger.info(this.TAG, `Search completed, found ${this.searchResults.length} results`);
    } catch (error) {
      Logger.error(this.TAG, `Search failed: ${error}`);
      this.errorMessage = 'æœç´¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
      this.searchResults = [];
      this.hasMoreResults = false;
    } finally {
      this.isLoading = false;
      this.isSearching = false;
    }
  }
  
  /**
   * åŠ è½½æ›´å¤šæœç´¢ç»“æœ
   */
  private async loadMoreResults(): Promise<void> {
    if (!this.hasMoreResults || this.isLoading || !this.searchQuery.trim()) return;
    
    this.isLoading = true;
    this.currentPage++;
    
    try {
      const query = this.searchQuery.trim();
      Logger.info(this.TAG, `Loading more results for: ${query}, page ${this.currentPage}`);
      
      // æ„å»ºæœç´¢å‚æ•°ï¼ŒåŒ…å«ç­›é€‰æ¡ä»¶
      const searchParams = {
        keyword: query,
        type: SearchType.All,
        page: this.currentPage,
        pageSize: this.pageSize,
        ...this.filters // åˆå¹¶ç­›é€‰æ¡ä»¶
      };
      
      const result = await mediaService.searchMedia(searchParams);
      
      if (result && result.items && result.items.length > 0) {
        this.searchResults = [...this.searchResults, ...result.items];
        this.hasMoreResults = result.hasMore || false;
      } else {
        this.hasMoreResults = false;
      }
    } catch (error) {
      Logger.error(this.TAG, `Failed to load more results: ${error}`);
      this.errorMessage = 'åŠ è½½æ›´å¤šç»“æœå¤±è´¥';
    } finally {
      this.isLoading = false;
    }
  }
  
  /**
   * é‡ç½®æœç´¢çŠ¶æ€
   */
  private resetSearchState(): void {
    this.searchResults = [];
    this.showHistory = true;
    this.errorMessage = '';
    this.currentPage = 1;
    this.hasMoreResults = true;
  }
  
  /**
   * å¤„ç†å…³é”®è¯ç‚¹å‡»
   */
  private handleKeywordClick(keyword: string): void {
    this.searchQuery = keyword;
    this.performSearch();
  }
  
  /**
   * å¤„ç†æœç´¢ç»“æœé¡¹ç‚¹å‡»
   */
  private handleSearchResultClick(media: MediaItem): void {
    Logger.info(this.TAG, `Search result clicked: ${media.title}`);
    // è·³è½¬åˆ°è¯¦æƒ…é¡µ
    Router.push({
      url: 'pages/MediaDetailPage',
      params: {
        mediaId: media.id,
        siteKey: media.siteKey
      }
    });
  }
  
  /**
   * å¤„ç†æ¸…é™¤æŒ‰é’®ç‚¹å‡»
   */
  private handleClearInput(): void {
    this.searchQuery = '';
    this.resetSearchState();
  }
  
  /**
   * å¤„ç†è¿”å›
   */
  private handleBack(): void {
    Router.back();
  }
  
  /**
   * æ¸²æŸ“æœç´¢è¾“å…¥æ¡†
   */
  @Builder
  private renderSearchInput(): void {
    <Stack className="search-input-container">
      <Button className="back-button" onClick={this.handleBack}>
        â†
      </Button>
      <Flex className="search-input-wrapper">
        <Text className="search-icon">ğŸ”</Text>
        <TextInput
          className="search-input"
          value={this.searchQuery}
          onChange={this.handleSearchInputChange}
          onSubmit={this.performSearch}
          placeholder="æœç´¢ç”µå½±ã€ç”µè§†å‰§ã€åŠ¨æ¼«..."
          enterKeyType="search"
          autoFocus={true}
        />
        {this.searchQuery && (
          <Button className="clear-button" onClick={this.handleClearInput}>
            âœ•
          </Button>
        )}
      </Flex>
      <Button className="search-button" onClick={this.performSearch}>
        æœç´¢
      </Button>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“çƒ­é—¨æœç´¢
   */
  @Builder
  private renderHotKeywords(): void {
    <Stack className="hot-keywords-section">
      <Flex className="section-header">
        <Text className="section-title">çƒ­é—¨æœç´¢</Text>
      </Flex>
      <Flex className="keywords-container" wrap="wrap">
        {this.hotKeywords.map((keyword, index) => (
          <Tag
            key={`hot-${index}`}
            className="keyword-tag hot"
            onClick={() => this.handleKeywordClick(keyword)}
          >
            <Text className="keyword-rank">{index + 1}</Text>
            <Text>{keyword}</Text>
          </Tag>
        ))}
      </Flex>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“æœç´¢å†å²
   */
  @Builder
  private renderSearchHistory(): void {
    if (this.searchHistory.length === 0) return;
    
    <Stack className="search-history-section">
      <Flex className="section-header">
        <Text className="section-title">æœç´¢å†å²</Text>
        <Button className="clear-history-button" onClick={this.clearSearchHistory}>
          æ¸…é™¤
        </Button>
      </Flex>
      <Flex className="keywords-container" wrap="wrap">
        {this.searchHistory.map((keyword, index) => (
          <Tag
            key={`history-${index}`}
            className="keyword-tag history"
            onClick={() => this.handleKeywordClick(keyword)}
          >
            <Text className="history-icon">ğŸ•</Text>
            <Text>{keyword}</Text>
          </Tag>
        ))}
      </Flex>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“æœç´¢ç»“æœé¡¹
   */
  @Builder
  private renderSearchResultItem(media: MediaItem): void {
    <ListItem onClick={() => this.handleSearchResultClick(media)}>
      <Flex className="search-result-item">
        <Image
          src={media.coverUrl || 'https://via.placeholder.com/100x150?text=No+Image'}
          className="result-cover"
          objectFit="cover"
        />
        <Flex className="result-info" direction="column">
          <Text className="result-title" numberOfLines={2}>{media.title}</Text>
          <Flex className="result-meta">
            {media.year && <Tag className="meta-tag">{media.year}</Tag>}
            {media.type && <Tag className="meta-tag">{media.type}</Tag>}
            {media.score && <Tag className="meta-tag score">{media.score}</Tag>}
          </Flex>
          {media.description && (
            <Text className="result-description" numberOfLines={2}>
              {media.description}
            </Text>
          )}
          {media.directors && media.directors.length > 0 && (
            <Text className="result-directors" numberOfLines={1}>
              å¯¼æ¼”: {media.directors.slice(0, 3).join(', ')}
            </Text>
          )}
          {media.actors && media.actors.length > 0 && (
            <Text className="result-actors" numberOfLines={1}>
              ä¸»æ¼”: {media.actors.slice(0, 3).join(', ')}
            </Text>
          )}
        </Flex>
      </Flex>
    </ListItem>
  }
  
  /**
   * åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼
   */
  private toggleDisplayMode(): void {
    this.displayMode = this.displayMode === 'list' ? 'grid' : 'list';
    // å¯ä»¥ä¿å­˜ç”¨æˆ·çš„æ˜¾ç¤ºæ¨¡å¼åå¥½åˆ°é…ç½®æœåŠ¡
    // ConfigService.getInstance().setDisplayMode(this.displayMode);
  }

  /**
   * æ¸²æŸ“æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢æŒ‰é’®
   */
  @Builder
  private renderDisplayModeToggle(): void {
    <Button
      className="display-mode-toggle"
      icon={this.displayMode === 'list' ? 'grid' : 'list'}
      onClick={this.toggleDisplayMode}
      type="circle"
      size="small"
    >
      {this.displayMode === 'list' ? 'ç½‘æ ¼' : 'åˆ—è¡¨'}
    </Button>
  }

  /**
   * åˆ‡æ¢ç­›é€‰é¢æ¿æ˜¾ç¤º
   */
  private toggleFilterPanel(): void {
    this.showFilterPanel = !this.showFilterPanel;
  }

  /**
   * æ¸²æŸ“ç­›é€‰æŒ‰é’®
   */
  @Builder
  private renderFilterButton(): void {
    <Button
      className="filter-button"
      icon="filter"
      onClick={this.toggleFilterPanel}
      type="text"
      size="small"
    >
      ç­›é€‰
    </Button>
  }

  /**
   * åº”ç”¨ç­›é€‰æ¡ä»¶
   */
  private applyFilters(): void {
    this.currentPage = 1;
    this.performSearch();
    this.showFilterPanel = false;
  }

  /**
   * é‡ç½®ç­›é€‰æ¡ä»¶
   */
  private resetFilters(): void {
    this.filters = {};
  }

  /**
   * æ¸²æŸ“ç­›é€‰é¢æ¿
   */
  @Builder
  private renderFilterPanel(): void {
    if (!this.showFilterPanel) return;
    
    <Stack className="filter-panel-overlay" onClick={this.toggleFilterPanel}>
      <Stack className="filter-panel" onClick={(e) => e.stopPropagation()}>
        <Stack className="filter-header">
          <Text className="filter-title">ç­›é€‰æ¡ä»¶</Text>
          <Button
            icon="close"
            onClick={this.toggleFilterPanel}
            type="text"
            size="small"
          />
        </Stack>
        
        <ScrollView className="filter-content">
          {/* åª’ä½“ç±»å‹ç­›é€‰ */}
          <Stack className="filter-section">
            <Text className="filter-section-title">åª’ä½“ç±»å‹</Text>
            <Flex className="filter-options">
              <CheckboxGroup>
                <Checkbox value="movie" onChange={(value) => this.updateMediaTypeFilter('movie', value)}>ç”µå½±</Checkbox>
                <Checkbox value="tv" onChange={(value) => this.updateMediaTypeFilter('tv', value)}>ç”µè§†å‰§</Checkbox>
                <Checkbox value="anime" onChange={(value) => this.updateMediaTypeFilter('anime', value)}>åŠ¨æ¼«</Checkbox>
                <Checkbox value="variety" onChange={(value) => this.updateMediaTypeFilter('variety', value)}>ç»¼è‰º</Checkbox>
              </CheckboxGroup>
            </Flex>
          </Stack>
          
          {/* æ’åºæ–¹å¼ */}
          <Stack className="filter-section">
            <Text className="filter-section-title">æ’åºæ–¹å¼</Text>
            <RadioGroup onChange={(value) => {
              this.filters.sortBy = value;
            }}>
              <Radio value="time">æœ€æ–°</Radio>
              <Radio value="score">è¯„åˆ†</Radio>
              <Radio value="hot">çƒ­åº¦</Radio>
            </RadioGroup>
          </Stack>
        </ScrollView>
        
        <Stack className="filter-actions">
          <Button onClick={this.resetFilters} type="text">é‡ç½®</Button>
          <Button onClick={this.applyFilters} type="capsule">åº”ç”¨ç­›é€‰</Button>
        </Stack>
      </Stack>
    </Stack>
  }

  /**
   * æ›´æ–°åª’ä½“ç±»å‹ç­›é€‰
   */
  private updateMediaTypeFilter(type: string, checked: boolean): void {
    if (!this.filters.types) {
      this.filters.types = [];
    }
    
    if (checked) {
      if (!this.filters.types.includes(type)) {
        this.filters.types.push(type);
      }
    } else {
      const index = this.filters.types.indexOf(type);
      if (index > -1) {
        this.filters.types.splice(index, 1);
      }
    }
  }

  /**
   * æ¸²æŸ“ç½‘æ ¼æ¨¡å¼çš„æœç´¢ç»“æœé¡¹
   */
  @Builder
  private renderGridItem(item: MediaItem): void {
    <GridItem className="grid-item">
      <Stack className="grid-item-content">
        <Image
          className="grid-item-image"
          src={item.coverUrl || item.posterUrl || 'https://via.placeholder.com/100x150?text=No+Image'}
          objectFit="cover"
        />
        <Stack className="grid-item-overlay">
          <Text className="grid-item-title" numberOfLines={2}>
            {item.title}
          </Text>
          {item.year && (
            <Text className="grid-item-year">{item.year}</Text>
          )}
        </Stack>
      </Stack>
    </GridItem>
  }

  /**
   * æ¸²æŸ“æœç´¢ç»“æœ
   */
  @Builder
  private renderSearchResults(): void {
    <Stack className="search-results-section">
      <Flex className="results-header">
        <Text className="results-count">
          æ‰¾åˆ° {this.searchResults.length} ä¸ªç»“æœ
        </Text>
        <Flex className="header-actions">
          {this.searchResults.length > 0 && this.renderFilterButton()}
          {this.searchResults.length > 0 && this.renderDisplayModeToggle()}
        </Flex>
      </Flex>
      
      {/* ç­›é€‰é¢æ¿ */}
      {this.renderFilterPanel()}
      
      {this.searchResults.length > 0 ? (
        this.displayMode === 'list' ? (
          // åˆ—è¡¨æ¨¡å¼
          <List
            className="search-results-list"
            itemTemplate={this.renderSearchResultItem}
            data={this.searchResults}
            onScrollBottom={() => this.loadMoreResults()}
          />
        ) : (
          // ç½‘æ ¼æ¨¡å¼
          <Grid
            className="search-results-grid"
            columnsTemplate="1fr 1fr"
            rowsTemplate="auto"
            rowsGap={10}
            columnsGap={10}
            onScrollBottom={() => this.loadMoreResults()}
          >
            {this.searchResults.map((item) => this.renderGridItem(item))}
          </Grid>
        )
      ) : (
        <Empty className="empty-results">
          <Text>æš‚æ— æœç´¢ç»“æœ</Text>
        </Empty>
      )}
      
      {this.isLoading && this.currentPage > 1 && (
        <Stack className="loading-more">
          <LoadingProgress className="loading-progress" color="#FF4500" />
          <Text>åŠ è½½æ›´å¤š...</Text>
        </Stack>
      )}
    </Stack>
  }
  
  /**
   * æ¸²æŸ“åŠ è½½çŠ¶æ€
   */
  @Builder
  private renderLoading(): void {
    <Stack className="loading-container">
      <LoadingProgress className="loading-progress" color="#FF4500" />
      <Text>æœç´¢ä¸­...</Text>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“é”™è¯¯çŠ¶æ€
   */
  @Builder
  private renderError(): void {
    <Stack className="error-container">
      <Text className="error-icon">âš ï¸</Text>
      <Text className="error-message">{this.errorMessage}</Text>
      <Button className="retry-button" onClick={this.performSearch}>
        é‡è¯•
      </Button>
    </Stack>
  }
  
  /**
   * ç»„ä»¶æ¸²æŸ“
   */
  build() {
    <Stack className="search-page">
      {/* æœç´¢è¾“å…¥åŒºåŸŸ */}
      {this.renderSearchInput()}
      
      {/* ä¸»å†…å®¹åŒºåŸŸ */}
      <ScrollView className="content-scroll" scrollBar="auto">
        {this.isSearching && this.isLoading && this.currentPage === 1 ? (
          this.renderLoading()
        ) : this.errorMessage ? (
          this.renderError()
        ) : this.showHistory ? (
          <Stack>
            {this.renderHotKeywords()}
            {this.renderSearchHistory()}
          </Stack>
        ) : (
          this.renderSearchResults()
        )}
        
        <Blank className="bottom-space" />
      </ScrollView>
    </Stack>
  }
}

export default SearchPage;