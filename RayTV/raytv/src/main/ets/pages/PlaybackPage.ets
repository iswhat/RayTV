import { useState, useEffect, onMounted, onUnmounted } from '@kit.ArkUI';
import { Stack, Video, Image, Text, Button, Slider, List, ListItem, LoadingProgress, Toast } from '@kit.ArkUI';
import { Router } from '@kit.AbilityKit';
import Logger from '../common/util/Logger.ets';playbackService } from '../service/media/PlaybackService';
import { historyService } from '../service/media/HistoryService';
import { mediaService } from '../service/media/MediaService';
import { configService } from '../service/config/ConfigService';
import { PlaybackState, PlaybackSpeed } from '../service/media/PlaybackService';
import Logger from '@ohos/base/Logger';

/**
 * æ’­æ”¾é¡µé¢ç»„ä»¶
 * å®ç°è§†é¢‘æ’­æ”¾æ§åˆ¶ç•Œé¢ï¼ŒåŒ…å«æ’­æ”¾/æš‚åœã€è¿›åº¦æ§åˆ¶ã€éŸ³é‡æ§åˆ¶ã€é€Ÿåº¦è°ƒæ•´ç­‰åŠŸèƒ½
 */
@Component
struct PlaybackPage {
  private readonly TAG: string = 'PlaybackPage';
  
  // è·¯ç”±å‚æ•°
  private mediaId: string = '';
  private siteKey: string = '';
  private episodeId?: string;
  private initialPosition: number = 0;
  private mediaTitle: string = '';
  private episodeName: string = '';
  private playSource?: PlaySource;
  private playSourceIndex: number = 0;
  
  // çŠ¶æ€ç®¡ç†
  @State playbackState: PlaybackState = PlaybackState.IDLE;
  @State currentTime: number = 0;
  @State duration: number = 0;
  @State isPlaying: boolean = false;
  @State volume: number = 1.0;
  @State isMuted: boolean = false;
  @State playbackSpeed: PlaybackSpeed = PlaybackSpeed.NORMAL;
  @State isBuffering: boolean = false;
  @State bufferPercentage: number = 0;
  @State showControls: boolean = true;
  @State showSpeedMenu: boolean = false;
  @State showSourceMenu: boolean = false;
  @State showSubtitleMenu: boolean = false;
  @State playSources: PlaySource[] = [];
  @State subtitles: Subtitle[] = [];
  @State selectedSubtitle: Subtitle | null = null;
  @State isFullscreen: boolean = false;
  @State errorMessage: string = '';
  @State isLoading: boolean = true;
  @State controlsTimeout: NodeJS.Timeout | null = null;
  @State lastProgressSaveTime: number = 0;
  @State saveProgressInterval: number = 30000; // 30ç§’ä¿å­˜ä¸€æ¬¡è¿›åº¦
  private autoSwitchSourceOnError: boolean = true; // æ˜¯å¦è‡ªåŠ¨åˆ‡æ¢ç‰‡æº
  private lastSaveTime: number = 0; // ä¸Šæ¬¡ä¿å­˜è¿›åº¦çš„æ—¶é—´(æ¯«ç§’)
  private currentPosition: number = 0; // å½“å‰æ’­æ”¾ä½ç½®
  private totalTime: number = 0;
  
  // åˆå§‹åŒ–
  onMounted(() => {
    Logger.info(this.TAG, 'PlaybackPage mounted');
    
    // è·å–è·¯ç”±å‚æ•°
    const params = Router.getParams();
    this.mediaId = params?.['mediaId'] || '';
    this.siteKey = params?.['siteKey'] || '';
    this.episodeId = params?.['episodeId'];
    this.initialPosition = params?.['currentTime'] || params?.['startPosition'] || 0;
    this.mediaTitle = params?.['mediaTitle'] || 'æ­£åœ¨æ’­æ”¾';
    this.episodeName = params?.['episodeName'] || '';
    this.playSource = params?.['playSource'];
    this.playSourceIndex = params?.['playSourceIndex'] || 0;
    this.autoSwitchSourceOnError = params?.['autoSwitchSourceOnError'] !== false; // é»˜è®¤å¼€å¯
    
    Logger.info(this.TAG, `Starting playback for: ${this.siteKey}:${this.mediaId}${this.episodeId ? ` episode: ${this.episodeId}` : ''}, startPosition=${this.initialPosition}`);
    
    // åˆå§‹åŒ–æ’­æ”¾å™¨
    this.initializePlayback();
    
    // è®¾ç½®æ§åˆ¶æ è‡ªåŠ¨éšè—
    this.startControlsTimeout();
  });
  
  // æ¸…ç†èµ„æº
  aboutToDisappear() {
    Logger.info(this.TAG, 'PlaybackPage unmounted');
    
    // ç§»é™¤æ’­æ”¾ç›‘å¬å™¨
    this.removePlaybackListeners();
    
    // ä¿å­˜æœ€ç»ˆæ’­æ”¾è¿›åº¦
    this.savePlayProgress(this.currentPosition).catch(error => {
      Logger.error(this.TAG, `Failed to save final progress: ${error}`);
    });
    
    // åœæ­¢æ§åˆ¶æ è¶…æ—¶
    this.stopControlsTimeout();
    
    // é‡Šæ”¾æ’­æ”¾å™¨èµ„æº
    this.releasePlayer();
    playbackService.stop();
    playbackService.destroy();
  }
  
  /**
   * åˆå§‹åŒ–æ’­æ”¾
   */
  private async initializePlayback(): Promise<void> {
    if (!this.mediaId || !this.siteKey) {
      this.errorMessage = 'ç¼ºå°‘å¿…è¦å‚æ•°';
      this.isLoading = false;
      this.playbackState = PlaybackState.ERROR;
      return;
    }
    
    try {
      // åŠ è½½æ’­æ”¾æº
      await this.loadPlaySources();
      
      // è®¾ç½®æ’­æ”¾æºå¹¶å¼€å§‹æ’­æ”¾
      if (this.playSource) {
        await this.setupPlayback(this.playSource);
      } else if (this.playSources.length > 0 && this.playSourceIndex < this.playSources.length) {
        await this.setupPlayback(this.playSources[this.playSourceIndex]);
      } else {
        this.errorMessage = 'æ— å¯ç”¨æ’­æ”¾æº';
        this.isLoading = false;
        this.playbackState = PlaybackState.ERROR;
      }
    } catch (error) {
      Logger.error(this.TAG, `Failed to initialize playback: ${error}`);
      this.errorMessage = 'æ’­æ”¾åˆå§‹åŒ–å¤±è´¥';
      this.isLoading = false;
      this.playbackState = PlaybackState.ERROR;
    }
  }
  
  /**
   * åŠ è½½æ’­æ”¾æº
   */
  private async loadPlaySources(): Promise<void> {
    try {
      // å¦‚æœæ²¡æœ‰ä¼ å…¥æ’­æ”¾æºï¼Œåˆ™ä»æœåŠ¡è·å–
      if (!this.playSource || this.playSources.length === 0) {
        this.playSources = await mediaService.getPlaySources(
          this.mediaId,
          this.siteKey,
          this.episodeId
        );
        Logger.info(this.TAG, `Loaded ${this.playSources.length} play sources`);
      }
      
      // å¦‚æœåªæœ‰ä¸€ä¸ªæ’­æ”¾æºï¼Œåˆ™ä½¿ç”¨å®ƒ
      if (this.playSources.length === 1 && !this.playSource) {
        this.playSource = this.playSources[0];
      }
    } catch (error) {
      Logger.error(this.TAG, `Failed to load play sources: ${error}`);
      throw error;
    }
  }
  
  /**
   * è®¾ç½®æ’­æ”¾
   */
  private async setupPlayback(source: PlaySource): Promise<void> {
    try {
      // æ·»åŠ æ’­æ”¾ç›‘å¬å™¨
      this.addPlaybackListeners();
      
      // è®¾ç½®æ’­æ”¾æº
      await playbackService.setSource(source, {
        autoPlay: true,
        startPosition: this.initialPosition,
        volume: this.volume,
        isMuted: this.isMuted,
        playbackSpeed: this.playbackSpeed
      });
      
      this.playSource = source;
      this.isLoading = false;
    } catch (error) {
      Logger.error(this.TAG, `Failed to setup playback: ${error}`);
      
      // å°è¯•è‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç‰‡æº
      if (this.autoSwitchSourceOnError) {
        await this.handlePlaybackError(error);
      } else {
        throw error;
      }
    }
  }
  
  /**
   * æ·»åŠ æ’­æ”¾ç›‘å¬å™¨
   */
  private addPlaybackListeners(): void {
    playbackService.addListener({
      onStateChanged: (state) => {
        this.playbackState = state;
        this.isPlaying = state === PlaybackState.PLAYING;
        
        if (state === PlaybackState.COMPLETED) {
          this.handlePlaybackCompleted();
        } else if (state === PlaybackState.ERROR) {
          this.errorMessage = 'æ’­æ”¾å‡ºé”™';
        }
        
        this.showControls = true;
        this.restartControlsTimeout();
      },
      
      onError: async (error: Error) => {
        Logger.error(this.TAG, `Playback error: ${error}`);
        
        // å°è¯•è‡ªåŠ¨åˆ‡æ¢ç‰‡æº
        if (this.autoSwitchSourceOnError) {
          await this.handlePlaybackError(error);
        } else {
          this.errorMessage = `æ’­æ”¾é”™è¯¯: ${error.message || 'æœªçŸ¥é”™è¯¯'}`;
        }
      },
      
      // å®šæœŸä¿å­˜æ’­æ”¾è¿›åº¦
      onTimeUpdate: async (currentTime, duration) => {
        this.currentTime = currentTime;
        this.currentPosition = currentTime;
        this.duration = duration;
        this.totalTime = duration || this.totalTime;
        
        // æ¯10ç§’ä¿å­˜ä¸€æ¬¡æ’­æ”¾è¿›åº¦
        if (this.lastSaveTime === 0 || currentTime - this.lastSaveTime > 10000) {
          await this.savePlayProgress(currentTime);
          this.lastSaveTime = currentTime;
        }
      },
      
      onError: (error) => {
        Logger.error(this.TAG, `Playback error: ${error.message}`);
        this.errorMessage = error.message || 'æ’­æ”¾å‡ºé”™';
        this.isLoading = false;
      },
      
      onCompleted: () => {
        Logger.info(this.TAG, 'Playback completed');
      },
      
      onBufferUpdate: (bufferPercentage) => {
        this.bufferPercentage = bufferPercentage;
      },
      
      onSeekCompleted: (seekTime) => {
        Logger.info(this.TAG, `Seek completed to ${seekTime}s`);
      }
    });
  }
  
  /**
   * å¤„ç†æ’­æ”¾å®Œæˆ
   */
  private async handlePlaybackCompleted(): Promise<void> {
    try {
      // ä¿å­˜å®Œæˆçš„æ’­æ”¾çŠ¶æ€
      await historyService.updateProgress(
        this.mediaId,
        this.siteKey,
        this.duration, // æ ‡è®°ä¸ºå·²å®Œæˆ
        this.episodeId,
        true // æ ‡è®°ä¸ºå·²å®Œæˆ
      );
      
      // å¯ä»¥åœ¨è¿™é‡Œå¤„ç†ä¸‹ä¸€é›†é€»è¾‘
      Toast.show('æ’­æ”¾å®Œæˆ');
    } catch (error) {
      Logger.error(this.TAG, `Failed to handle playback completed: ${error}`);
    }
  }
  
  /**
   * ä¿å­˜æ’­æ”¾è¿›åº¦
   */
  private async savePlaybackProgress(): Promise<void> {
    try {
      await playbackService.savePlaybackPosition(
        this.mediaId,
        this.siteKey,
        this.episodeId
      );
    } catch (error) {
      Logger.error(this.TAG, `Failed to save playback progress: ${error}`);
    }
  }
  
  /**
   * åˆ‡æ¢æ’­æ”¾/æš‚åœ
   */
  private async togglePlayPause(): Promise<void> {
    try {
      if (this.isPlaying) {
        await playbackService.pause();
      } else {
        await playbackService.play();
      }
      
      this.showControls = true;
      this.restartControlsTimeout();
    } catch (error) {
      Logger.error(this.TAG, `Failed to toggle play/pause: ${error}`);
    }
  }
  
  /**
   * å¤„ç†è¿›åº¦æ¡å˜åŒ–
   */
  private async handleProgressChange(value: number): Promise<void> {
    try {
      const seekTime = (value / 100) * this.duration;
      await playbackService.seekTo(seekTime);
      
      this.showControls = true;
      this.restartControlsTimeout();
    } catch (error) {
      Logger.error(this.TAG, `Failed to seek: ${error}`);
    }
  }
  
  /**
   * å¤„ç†éŸ³é‡å˜åŒ–
   */
  private async handleVolumeChange(value: number): Promise<void> {
    try {
      this.volume = value;
      if (this.isMuted && value > 0) {
        this.isMuted = false;
      }
      await playbackService.setVolume(value);
    } catch (error) {
      Logger.error(this.TAG, `Failed to set volume: ${error}`);
    }
  }
  
  /**
   * åˆ‡æ¢é™éŸ³
   */
  private async toggleMute(): Promise<void> {
    try {
      this.isMuted = !this.isMuted;
      await playbackService.setMuted(this.isMuted);
    } catch (error) {
      Logger.error(this.TAG, `Failed to toggle mute: ${error}`);
    }
  }
  
  /**
   * è®¾ç½®æ’­æ”¾é€Ÿåº¦
   */
  private async setPlaybackSpeed(speed: PlaybackSpeed): Promise<void> {
    try {
      this.playbackSpeed = speed;
      await playbackService.setPlaybackSpeed(speed);
      this.showSpeedMenu = false;
    } catch (error) {
      Logger.error(this.TAG, `Failed to set playback speed: ${error}`);
    }
  }
  
  /**
   * ä¿å­˜æ’­æ”¾è¿›åº¦
   */
  private async savePlayProgress(position: number): Promise<void> {
    if (!this.mediaId || !this.siteKey || !this.episodeId) return;
    
    try {
      const duration = this.totalTime || this.duration;
      
      // ä¿å­˜æ’­æ”¾è¿›åº¦åˆ°å†å²è®°å½•
      await historyService.saveWatchProgress(
        this.mediaId,
        this.siteKey,
        this.episodeId,
        position,
        duration
      );
      
      Logger.info(this.TAG, `Saved playback progress: ${position}ms of ${duration}ms`);
    } catch (error) {
      Logger.error(this.TAG, `Failed to save play progress: ${error}`);
    }
  }
  
  /**
   * å¤„ç†æ’­æ”¾é”™è¯¯ï¼Œå°è¯•åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå¯ç”¨ç‰‡æº
   */
  private async handlePlaybackError(error: Error): Promise<void> {
    if (!this.playSources || this.playSources.length <= 1) {
      this.errorMessage = 'æ’­æ”¾å¤±è´¥ï¼Œæš‚æ— å¯ç”¨å¤‡ç”¨ç‰‡æº';
      this.isLoading = false;
      return;
    }
    
    // æŸ¥æ‰¾å½“å‰ç‰‡æºçš„ç´¢å¼•
    const currentIndex = this.playSources.findIndex(s => 
      s.id === this.playSource?.id || 
      (s.name === this.playSource?.name && s.url === this.playSource?.url)
    );
    
    // é€‰æ‹©ä¸‹ä¸€ä¸ªå¯ç”¨çš„ç‰‡æº
    let nextIndex = (currentIndex + 1) % this.playSources.length;
    
    if (currentIndex !== -1) {
      Logger.info(this.TAG, `å°è¯•åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç‰‡æº: ${nextIndex}ï¼ŒåŸç‰‡æº: ${currentIndex}`);
      
      // æ˜¾ç¤ºåˆ‡æ¢æç¤º
      this.errorMessage = `å½“å‰ç‰‡æºæ’­æ”¾å¤±è´¥ï¼Œæ­£åœ¨å°è¯•åˆ‡æ¢åˆ°å¤‡ç”¨ç‰‡æº(${nextIndex + 1}/${this.playSources.length})...`;
      
      // ç­‰å¾…ä¸€å°æ®µæ—¶é—´å†åˆ‡æ¢
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      try {
        // ä¿å­˜å½“å‰æ’­æ”¾ä½ç½®
        const currentPosition = this.currentPosition;
        
        // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªç‰‡æº
        this.initialPosition = currentPosition; // ä¿æŒç›¸åŒçš„æ’­æ”¾ä½ç½®
        await this.setupPlayback(this.playSources[nextIndex]);
        this.errorMessage = '';
      } catch (nextError) {
        // å¦‚æœä¸‹ä¸€ä¸ªç‰‡æºä¹Ÿå¤±è´¥ï¼Œç»§ç»­å°è¯•ä¸‹ä¸€ä¸ª
        if (nextIndex !== currentIndex) {
          await this.handlePlaybackError(nextError);
        } else {
          this.errorMessage = 'æ‰€æœ‰ç‰‡æºæ’­æ”¾å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
          this.isLoading = false;
        }
      }
    } else {
      this.errorMessage = 'æ’­æ”¾å¤±è´¥ï¼Œæ— æ³•è¯†åˆ«å½“å‰ç‰‡æº';
      this.isLoading = false;
    }
  }
  
  /**
   * åˆ‡æ¢æ’­æ”¾æº
   */
  private async switchPlaySource(source: PlaySource): Promise<void> {
    try {
      this.isLoading = true;
      
      // ä¿å­˜å½“å‰æ’­æ”¾ä½ç½®
      const currentPosition = this.currentPosition;
      
      // åˆ‡æ¢åˆ°æ–°ç‰‡æºå¹¶æ¢å¤æ’­æ”¾ä½ç½®
      this.initialPosition = currentPosition;
      await this.setupPlayback(source);
      
      this.showSourceMenu = false;
    } catch (error) {
      Logger.error(this.TAG, `Failed to switch play source: ${error}`);
      this.errorMessage = 'åˆ‡æ¢æ’­æ”¾æºå¤±è´¥';
      this.isLoading = false;
    }
  }
  
  /**
   * åˆ‡æ¢å…¨å±
   */
  private toggleFullscreen(): void {
    this.isFullscreen = !this.isFullscreen;
    // è¿™é‡Œéœ€è¦å¤„ç†å®é™…çš„å…¨å±é€»è¾‘ï¼Œå¯èƒ½éœ€è¦è°ƒç”¨ç³»ç»ŸAPI
    Logger.info(this.TAG, `Fullscreen mode: ${this.isFullscreen}`);
  }
  
  /**
   * å¤„ç†è¿”å›
   */
  private handleBack(): void {
    // å…ˆä¿å­˜è¿›åº¦
    this.savePlaybackProgress().finally(() => {
      Router.back();
    });
  }
  
  /**
   * å¤„ç†å±å¹•ç‚¹å‡»
   */
  private handleScreenTap(): void {
    this.showControls = !this.showControls;
    if (this.showControls) {
      this.restartControlsTimeout();
    } else {
      this.stopControlsTimeout();
    }
  }
  
  /**
   * å¼€å§‹æ§åˆ¶æ è¶…æ—¶éšè—
   */
  private startControlsTimeout(): void {
    this.stopControlsTimeout();
    this.controlsTimeout = setTimeout(() => {
      if (this.isPlaying && this.playbackState !== PlaybackState.ERROR) {
        this.showControls = false;
      }
    }, 3000); // 3ç§’åéšè—
  }
  
  /**
   * é‡æ–°å¼€å§‹æ§åˆ¶æ è¶…æ—¶
   */
  private restartControlsTimeout(): void {
    this.startControlsTimeout();
  }
  
  /**
   * åœæ­¢æ§åˆ¶æ è¶…æ—¶
   */
  private stopControlsTimeout(): void {
    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
      this.controlsTimeout = null;
    }
  }
  
  /**
   * é‡Šæ”¾æ’­æ”¾å™¨èµ„æº
   */
  private async releasePlayer(): Promise<void> {
    try {
      await playbackService.release();
    } catch (error) {
      Logger.error(this.TAG, `Failed to release player: ${error}`);
    }
  }
  
  /**
   * æ ¼å¼åŒ–æ—¶é—´
   */
  private formatTime(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    
    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  }
  
  /**
   * æ¸²æŸ“åŠ è½½çŠ¶æ€
   */
  @Builder
  private renderLoading(): void {
    <Stack className="loading-overlay">
      <LoadingProgress className="loading-progress" color="#FF4500" />
      <Text className="loading-text">æ­£åœ¨åŠ è½½...</Text>
      {this.bufferPercentage > 0 && (
        <Text className="buffer-text">å·²ç¼“å†² {this.bufferPercentage}%</Text>
      )}
    </Stack>
  }
  
  /**
   * æ¸²æŸ“é”™è¯¯çŠ¶æ€
   */
  @Builder
  private renderError(): void {
    <Stack className="error-overlay">
      <Text className="error-icon">âš ï¸</Text>
      <Text className="error-message">{this.errorMessage}</Text>
      <Button className="retry-button" onClick={() => this.initializePlayback()}>
        é‡è¯•
      </Button>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“é¡¶éƒ¨æ§åˆ¶æ 
   */
  @Builder
  private renderTopControls(): void {
    <Stack className="top-controls">
      <Button className="back-button" onClick={this.handleBack}>
        â† è¿”å›
      </Button>
      <Stack className="title-container">
        <Text className="media-title" numberOfLines={1}>{this.mediaTitle}</Text>
        {this.episodeName && (
          <Text className="episode-name" numberOfLines={1}>{this.episodeName}</Text>
        )}
      </Stack>
      <Button className="settings-button" onClick={() => this.showSpeedMenu = !this.showSpeedMenu}>
        {this.playbackSpeed}x
      </Button>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“åº•éƒ¨æ§åˆ¶æ 
   */
  @Builder
  private renderBottomControls(): void {
    <Stack className="bottom-controls">
      <Button className="play-pause-button" onClick={this.togglePlayPause}>
        {this.isPlaying ? 'â¸' : 'â–¶'}
      </Button>
      
      <Stack className="progress-container">
        <Slider
          className="progress-slider"
          value={(this.currentTime / this.duration) * 100 || 0}
          min={0}
          max={100}
          onChange={this.handleProgressChange}
        />
        <Flex className="time-display">
          <Text className="current-time">{this.formatTime(this.currentTime)}</Text>
          <Text className="duration">{this.formatTime(this.duration)}</Text>
        </Flex>
      </Stack>
      
      <Button className="mute-button" onClick={this.toggleMute}>
        {this.isMuted ? 'ğŸ”‡' : 'ğŸ”Š'}
      </Button>
      
      <Stack className="volume-container">
        <Slider
          className="volume-slider"
          value={this.volume * 100}
          min={0}
          max={100}
          onChange={this.handleVolumeChange}
        />
      </Stack>
      
      <Button className="source-button" onClick={() => this.showSourceMenu = !this.showSourceMenu}>
        æº
      </Button>
      
      <Button className="fullscreen-button" onClick={this.toggleFullscreen}>
        {this.isFullscreen ? 'â¤¢' : 'â¤¡'}
      </Button>
    </Stack>
  }
  
  /**
   * æ¸²æŸ“æ’­æ”¾é€Ÿåº¦èœå•
   */
  @Builder
  private renderSpeedMenu(): void {
    if (!this.showSpeedMenu) return;
    
    <Stack className="speed-menu">
      {playbackService.getSupportedPlaybackSpeeds().map((speed) => (
        <Button
          key={speed}
          className={`speed-option ${this.playbackSpeed === speed ? 'selected' : ''}`}
          onClick={() => this.setPlaybackSpeed(speed)}
        >
          {playbackService.getPlaybackSpeedText(speed)}
        </Button>
      ))}
    </Stack>
  }
  
  /**
   * æ¸²æŸ“æ’­æ”¾æºèœå•
   */
  @Builder
  private renderSourceMenu(): void {
    if (!this.showSourceMenu || this.playSources.length === 0) return;
    
    <List className="source-menu">
      {this.playSources.map((source, index) => (
        <ListItem 
          key={index} 
          onClick={() => this.switchPlaySource(source)}
          className={this.playSource?.url === source.url ? 'selected' : ''}
        >
          <Text className="source-name">{source.name || `æ’­æ”¾æº${index + 1}`}</Text>
          {source.quality && <Text className="source-quality">{source.quality}</Text>}
        </ListItem>
      ))}
    </List>
  }
  
  /**
   * ç»„ä»¶æ¸²æŸ“
   */
  build() {
    <Stack className={`playback-page ${this.isFullscreen ? 'fullscreen' : ''}`} onClick={this.handleScreenTap}>
      {/* è§†é¢‘æ’­æ”¾åŒºåŸŸ */}
      <Stack className="video-container">
        {/* è¿™é‡Œåº”è¯¥ä½¿ç”¨å®é™…çš„è§†é¢‘æ’­æ”¾å™¨ç»„ä»¶ */}
        {/* ç”±äºHarmonyOSçš„Videoç»„ä»¶å…·ä½“APIå¯èƒ½ä¸åŒï¼Œè¿™é‡Œç”¨å ä½ç¬¦è¡¨ç¤º */}
        <Image 
          src="https://via.placeholder.com/1920x1080?text=Video+Player" 
          className="video-placeholder"
          objectFit="cover"
        />
        
        {/* åŠ è½½çŠ¶æ€ */}
        {this.isLoading && this.renderLoading()}
        
        {/* é”™è¯¯çŠ¶æ€ */}
        {this.errorMessage && this.renderError()}
        
        {/* æ’­æ”¾æ§åˆ¶ç•Œé¢ */}
        {this.showControls && (
          <Stack className="controls-overlay">
            {this.renderTopControls()}
            {this.renderBottomControls()}
          </Stack>
        )}
        
        {/* æ’­æ”¾é€Ÿåº¦èœå• */}
        {this.renderSpeedMenu()}
        
        {/* æ’­æ”¾æºèœå• */}
        {this.renderSourceMenu()}
      </Stack>
    </Stack>
  }
}

export default PlaybackPage;