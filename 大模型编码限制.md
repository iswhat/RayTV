# ArkTS大模型编码限制与最佳实践

## 1. 类型安全原则

### 1.1 禁止将类型用作值
**错误示例：**
```typescript
// ❌ 错误：'number' only refers to a type, but is being used as a value here
const value = number;

// ❌ 错误：'Record' only refers to a type, but is being used as a value here
const record = Record<string, unknown>;
```

**正确示例：**
```typescript
// ✅ 正确：使用具体数值
const value: number = 10;

// ✅ 正确：使用类型断言
const record: Record<string, unknown> = {};
```

### 1.2 明确变量类型声明
**错误示例：**
```typescript
// ❌ 错误：隐式any类型
let data;
```

**正确示例：**
```typescript
// ✅ 正确：明确类型声明
let data: string;

// ✅ 正确：类型推断
const name = "John";
```

### 1.3 禁止使用any和unknown类型
**错误示例：**
```typescript
// ❌ 错误：使用any类型
function processData(data: any) {
  return data;
}
```

**正确示例：**
```typescript
// ✅ 正确：使用具体类型
function processData(data: string | number) {
  return data;
}

// ✅ 正确：使用类型保护
function isString(value: unknown): value is string {
  return typeof value === 'string';
}
```

## 2. 函数与方法规范

### 2.1 明确函数参数类型和返回值类型
**错误示例：**
```typescript
// ❌ 错误：缺少参数类型和返回值类型
function add(a, b) {
  return a + b;
}
```

**正确示例：**
```typescript
// ✅ 正确：明确参数类型和返回值类型
function add(a: number, b: number): number {
  return a + b;
}
```

### 2.2 函数参数数量匹配
**错误示例：**
```typescript
// ❌ 错误：参数数量不匹配
function greeting(name: string) {
  return `Hello, ${name}!`;
}

greeting("John", "Doe"); //  Expected 1 arguments, but got 2
```

**正确示例：**
```typescript
// ✅ 正确：参数数量匹配
function greeting(name: string, lastName?: string) {
  return `Hello, ${name} ${lastName || ''}!`;
}

greeting("John"); // ✅
greeting("John", "Doe"); // ✅
```

### 2.3 避免过多参数
**错误示例：**
```typescript
// ❌ 错误：参数过多
function createUser(name: string, email: string, age: number, address: string, phone: string) {
  // ...
}
```

**正确示例：**
```typescript
// ✅ 正确：使用参数对象
interface UserParams {
  name: string;
  email: string;
  age: number;
  address: string;
  phone: string;
}

function createUser(params: UserParams) {
  // ...
}
```

## 3. 变量与作用域规范

### 3.1 变量必须先定义后使用
**错误示例：**
```typescript
// ❌ 错误：变量未定义
console.log(offset); // Cannot find name 'offset'
```

**正确示例：**
```typescript
// ✅ 正确：先定义后使用
const offset = 0;
console.log(offset);
```

### 3.2 避免未初始化的变量
**错误示例：**
```typescript
// ❌ 错误：变量未初始化
let offset: number;
console.log(offset); // Object is possibly 'undefined'
```

**正确示例：**
```typescript
// ✅ 正确：初始化变量
let offset: number = 0;
console.log(offset);

// ✅ 正确：使用可选链
let user: User | null = null;
console.log(user?.name);
```

## 4. 类与对象规范

### 4.1 正确使用访问修饰符
**错误示例：**
```typescript
// ❌ 错误：public关键字使用错误
class User {
  public name: string;
  private age: number;
}

// ❌ 错误：在类外部访问私有成员
const user = new User();
user.age = 20; // Property 'age' is private and only accessible within class 'User'
```

**正确示例：**
```typescript
// ✅ 正确：使用访问修饰符
class User {
  constructor(public name: string, private age: number) {
    // ...
  }

  public getAge(): number {
    return this.age;
  }
}
```

### 4.2 避免对象可能未定义的情况
**错误示例：**
```typescript
// ❌ 错误：对象可能未定义
let user: User | undefined;
console.log(user.name); // Object is possibly 'undefined'
```

**正确示例：**
```typescript
// ✅ 正确：使用可选链
let user: User | undefined;
console.log(user?.name);

// ✅ 正确：使用类型守卫
if (user) {
  console.log(user.name);
}
```

## 5. instanceof操作符规范

### 5.1 instanceof左侧必须是对象类型
**错误示例：**
```typescript
// ❌ 错误：instanceof左侧不是对象类型
if (5 instanceof Number) {
  // ...
}
```

**正确示例：**
```typescript
// ✅ 正确：instanceof左侧是对象类型
const num = new Number(5);
if (num instanceof Number) {
  // ...
}

// ✅ 正确：使用typeof检查基本类型
if (typeof 5 === 'number') {
  // ...
}
```

## 6. 异步编程规范

### 6.1 正确使用async/await
**错误示例：**
```typescript
// ❌ 错误：async关键字使用错误
function fetchData() async {
  // ...
}
```

**正确示例：**
```typescript
// ✅ 正确：async关键字位置正确
async function fetchData() {
  // ...
}

// ✅ 正确：使用try-catch处理异步错误
async function processData() {
  try {
    const data = await fetchData();
    return data;
  } catch (error) {
    console.error('Failed to fetch data:', error);
    return null;
  }
}
```

## 7. 错误处理规范

### 7.1 正确创建和处理Error对象
**错误示例：**
```typescript
// ❌ 错误：字符串无法赋值给Error类型
throw "An error occurred"; // Argument of type 'string' is not assignable to parameter of type 'Error'
```

**正确示例：**
```typescript
// ✅ 正确：使用Error对象
throw new Error("An error occurred");

// ✅ 正确：自定义错误类型
class CustomError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'CustomError';
  }
}

throw new CustomError("A custom error occurred");
```

### 7.2 正确记录错误
**错误示例：**
```typescript
// ❌ 错误：JSON.stringify不能直接处理Error对象
try {
  // ...
} catch (error) {
  console.error(JSON.stringify(error)); // No overload matches this call
}
```

**正确示例：**
```typescript
// ✅ 正确：使用Error对象的message属性
try {
  // ...
} catch (error) {
  if (error instanceof Error) {
    console.error(error.message);
    console.error(error.stack);
  } else {
    console.error(String(error));
  }
}
```

## 8. 命名规范

### 8.1 变量和函数命名
**错误示例：**
```typescript
// ❌ 错误：使用拼音命名
const shujv = { name: "John" };

// ❌ 错误：使用模糊命名
function process(data) {
  // ...
}
```

**正确示例：**
```typescript
// ✅ 正确：使用英文命名
const userData = { name: "John" };

// ✅ 正确：使用描述性命名
function processUserData(data: User) {
  // ...
}
```

### 8.2 类和接口命名
**错误示例：**
```typescript
// ❌ 错误：类名使用驼峰命名
class user {
  // ...
}
```

**正确示例：**
```typescript
// ✅ 正确：类名使用帕斯卡命名
class User {
  // ...
}

// ✅ 正确：接口名使用帕斯卡命名
interface UserInterface {
  // ...
}
```

## 9. 代码结构规范

### 9.1 函数长度控制
**错误示例：**
```typescript
// ❌ 错误：函数过长，超过50行
function complexFunction() {
  // ... 大量代码 ...
}
```

**正确示例：**
```typescript
// ✅ 正确：将复杂函数拆分为多个小函数
function complexFunction() {
  const result1 = step1();
  const result2 = step2(result1);
  return step3(result2);
}

function step1() {
  // ...
}

function step2(data: any) {
  // ...
}

function step3(data: any) {
  // ...
}
```

### 9.2 单一职责原则
**错误示例：**
```typescript
// ❌ 错误：一个函数承担过多职责
function processAndSaveData(data: any) {
  // 处理数据
  // 验证数据
  // 保存数据
  // 发送通知
}
```

**正确示例：**
```typescript
// ✅ 正确：每个函数只负责一个功能
function processData(data: any) {
  // 处理数据
}

function validateData(data: any) {
  // 验证数据
}

function saveData(data: any) {
  // 保存数据
}

function sendNotification(data: any) {
  // 发送通知
}
```

## 10. 其他规范

### 10.1 禁止使用var声明
**错误示例：**
```typescript
// ❌ 错误：使用var声明
var name = "John";
```

**正确示例：**
```typescript
// ✅ 正确：使用const或let声明
const name = "John";
let age = 20;
```

### 10.2 避免循环依赖
**错误示例：**
```typescript
// file1.ts
import { func2 } from './file2';

export function func1() {
  return func2();
}

// file2.ts
import { func1 } from './file1';

export function func2() {
  return func1();
}
```

**正确示例：**
```typescript
// file1.ts
export function func1() {
  // ...
}

// file2.ts
import { func1 } from './file1';

export function func2() {
  return func1();
}
```

## 总结

1. **类型安全优先**：避免使用any和unknown类型，明确变量和函数的类型
2. **函数规范**：明确参数类型和返回值类型，参数数量匹配
3. **变量规范**：变量必须先定义后使用，避免未初始化的变量
4. **类与对象**：正确使用访问修饰符，避免对象可能未定义的情况
5. **错误处理**：正确创建和处理Error对象，避免直接使用字符串作为错误
6. **命名规范**：使用有意义的英文命名，遵循驼峰和帕斯卡命名约定
7. **代码结构**：控制函数长度，遵循单一职责原则

遵循这些规范可以避免大部分ArkTS编译器错误，提高代码质量和可维护性。